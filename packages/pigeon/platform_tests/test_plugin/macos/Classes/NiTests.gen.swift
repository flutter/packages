// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Autogenerated from Pigeon, do not edit directly.
// See also: https://pub.dev/packages/pigeon
// swift-format-ignore-file: AlwaysUseLowerCamelCase

import Foundation

/// Error class for passing custom error details to Dart side.
@objc final class NiTestsError: NSObject, Error {
  @objc var code: String?
  @objc var message: String?
  @objc var details: String?

  @objc override init() {}

  @objc init(code: String?, message: String?, details: String?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "NiTestsError(code: \(code ?? "<nil>"), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

@objc class NumberWrapper: NSObject, NSCopying {
  @objc required init(
    number: NSNumber,
    type: Int,
  ) {
    self.number = number
    self.type = type
  }
  func copy(with zone: NSZone? = nil) -> Any {
    return Self(number: number, type: type)
  }
  @objc var number: NSNumber
  @objc var type: Int
}

private func wrapNumber(number: Any) -> NumberWrapper {
  switch number {
  case _ as Int:
    return NumberWrapper(number: NSNumber(value: number as! Int), type: 1)
  case _ as Int64:
    return NumberWrapper(number: NSNumber(value: number as! Int64), type: 1)
  case _ as Double:
    return NumberWrapper(number: NSNumber(value: number as! Double), type: 2)
  case _ as Float:
    return NumberWrapper(number: NSNumber(value: number as! Float), type: 2)
  case _ as Bool:
    return NumberWrapper(number: NSNumber(value: number as! Bool), type: 3)

  case _ as NIAnEnum:
    return NumberWrapper(number: NSNumber(value: (number as! NIAnEnum).rawValue), type: 4)
  case _ as NIAnotherEnum:
    return NumberWrapper(number: NSNumber(value: (number as! NIAnotherEnum).rawValue), type: 5)
  default:
    return NumberWrapper(number: NSNumber(value: 0), type: 0)
  }
}

private func unwrapNumber(wrappedNumber: NumberWrapper) -> Any {
  switch wrappedNumber.type {
  case 1:
    return wrappedNumber.number.int64Value
  case 2:
    return wrappedNumber.number.doubleValue
  case 3:
    return wrappedNumber.number.boolValue
  case 4:
    return NIAnEnum(rawValue: wrappedNumber.number.intValue)!
  case 5:
    return NIAnotherEnum(rawValue: wrappedNumber.number.intValue)!
  default:
    return wrappedNumber.number.int64Value
  }
}

private func numberCodec(number: Any) -> Int {
  switch number {
  case _ as Int:
    return 1
  case _ as Double:
    return 2
  case _ as Float:
    return 2
  case _ as Bool:
    return 3
  case _ as NIAnEnum:
    return 4
  case _ as NIAnotherEnum:
    return 5
  default:
    return 0
  }
}

private func isNullish(_ value: Any?) -> Bool {
  guard let innerValue = value else {
    return true
  }

  if case Optional<Any>.some(Optional<Any>.none) = value {
    return true
  }

  return innerValue is NSNull || innerValue is PigeonInternalNull
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

@objc enum NIAnEnum: Int {
  case one = 0
  case two = 1
  case three = 2
  case fortyTwo = 3
  case fourHundredTwentyTwo = 4
}

@objc enum NIAnotherEnum: Int {
  case justInCase = 0
}

/// A class containing all supported types.
///
/// Generated class from Pigeon that represents data sent in messages.
struct NIAllTypes {
  var aBool: Bool
  var anInt: Int64
  var anInt64: Int64
  var aDouble: Double
  var anEnum: NIAnEnum
  var anotherEnum: NIAnotherEnum
  var aString: String
  var anObject: Any
  var list: [Any?]
  var stringList: [String]
  var intList: [Int64]
  var doubleList: [Double]
  var boolList: [Bool]
  var map: [AnyHashable?: Any?]
  var stringMap: [String: String]

  static func fromList(_ pigeonVar_list: [Any?]) -> NIAllTypes? {
    let aBool = pigeonVar_list[0] as! Bool
    let anInt = pigeonVar_list[1] as! Int64
    let anInt64 = pigeonVar_list[2] as! Int64
    let aDouble = pigeonVar_list[3] as! Double
    let anEnum = pigeonVar_list[4] as! NIAnEnum
    let anotherEnum = pigeonVar_list[5] as! NIAnotherEnum
    let aString = pigeonVar_list[6] as! String
    let anObject = pigeonVar_list[7]!
    let list = pigeonVar_list[8] as! [Any?]
    let stringList = pigeonVar_list[9] as! [String]
    let intList = pigeonVar_list[10] as! [Int64]
    let doubleList = pigeonVar_list[11] as! [Double]
    let boolList = pigeonVar_list[12] as! [Bool]
    let map = pigeonVar_list[13] as! [AnyHashable?: Any?]
    let stringMap = pigeonVar_list[14] as! [String: String]

    return NIAllTypes(
      aBool: aBool,
      anInt: anInt,
      anInt64: anInt64,
      aDouble: aDouble,
      anEnum: anEnum,
      anotherEnum: anotherEnum,
      aString: aString,
      anObject: anObject,
      list: list,
      stringList: stringList,
      intList: intList,
      doubleList: doubleList,
      boolList: boolList,
      map: map,
      stringMap: stringMap
    )
  }
  func toList() -> [Any?] {
    return [
      aBool,
      anInt,
      anInt64,
      aDouble,
      anEnum,
      anotherEnum,
      aString,
      anObject,
      list,
      stringList,
      intList,
      doubleList,
      boolList,
      map,
      stringMap,
    ]
  }
}

/// A class containing all supported types.
///
/// Generated bridge class from Pigeon that moves data from Swift to Objective-C.
@available(iOS 13, macOS 16.0.0, *)
@objc class NIAllTypesBridge: NSObject {
  @objc init(
    aBool: Bool,
    anInt: Int64,
    anInt64: Int64,
    aDouble: Double,
    anEnum: NIAnEnum,
    anotherEnum: NIAnotherEnum,
    aString: NSString,
    anObject: NSObject,
    list: [NSObject],
    stringList: [NSObject],
    intList: [NSObject],
    doubleList: [NSObject],
    boolList: [NSObject],
    map: [NSObject: NSObject],
    stringMap: [NSObject: NSObject]
  ) {
    self.aBool = aBool
    self.anInt = anInt
    self.anInt64 = anInt64
    self.aDouble = aDouble
    self.anEnum = anEnum
    self.anotherEnum = anotherEnum
    self.aString = aString
    self.anObject = anObject
    self.list = list
    self.stringList = stringList
    self.intList = intList
    self.doubleList = doubleList
    self.boolList = boolList
    self.map = map
    self.stringMap = stringMap
  }
  @objc var aBool: Bool
  @objc var anInt: Int64
  @objc var anInt64: Int64
  @objc var aDouble: Double
  @objc var anEnum: NIAnEnum
  @objc var anotherEnum: NIAnotherEnum
  @objc var aString: NSString
  @objc var anObject: NSObject
  @objc var list: [NSObject]
  @objc var stringList: [NSObject]
  @objc var intList: [NSObject]
  @objc var doubleList: [NSObject]
  @objc var boolList: [NSObject]
  @objc var map: [NSObject: NSObject]
  @objc var stringMap: [NSObject: NSObject]

  static func fromSwift(_ pigeonVar_Class: NIAllTypes?) -> NIAllTypesBridge? {
    if isNullish(pigeonVar_Class) {
      return nil
    }
    return NIAllTypesBridge(
      aBool: pigeonVar_Class!.aBool,
      anInt: pigeonVar_Class!.anInt,
      anInt64: pigeonVar_Class!.anInt64,
      aDouble: pigeonVar_Class!.aDouble,
      anEnum: pigeonVar_Class!.anEnum,
      anotherEnum: pigeonVar_Class!.anotherEnum,
      aString: pigeonVar_Class!.aString as NSString,
      anObject: pigeonVar_Class!.anObject as! NSObject,
      list: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.list) as! [NSObject],
      stringList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.stringList) as! [NSObject],
      intList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.intList) as! [NSObject],
      doubleList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.doubleList) as! [NSObject],
      boolList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.boolList) as! [NSObject],
      map: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.map) as! [NSObject: NSObject],
      stringMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.stringMap)
        as! [NSObject: NSObject],
    )
  }
  func toSwift() -> NIAllTypes {
    return NIAllTypes(
      aBool: aBool,
      anInt: anInt,
      anInt64: anInt64,
      aDouble: aDouble,
      anEnum: anEnum,
      anotherEnum: anotherEnum,
      aString: aString as String,
      anObject: anObject,
      list: _PigeonFfiCodec.readValue(value: list as NSObject) as! [Any?],
      stringList: _PigeonFfiCodec.readValue(value: stringList as NSObject) as! [String],
      intList: _PigeonFfiCodec.readValue(value: intList as NSObject) as! [Int64],
      doubleList: _PigeonFfiCodec.readValue(value: doubleList as NSObject) as! [Double],
      boolList: _PigeonFfiCodec.readValue(value: boolList as NSObject) as! [Bool],
      map: _PigeonFfiCodec.readValue(value: map as NSObject) as! [AnyHashable?: Any?],
      stringMap: _PigeonFfiCodec.readValue(value: stringMap as NSObject) as! [String: String],
    )
  }
}

/// A class containing all supported nullable types.
/// The primary purpose for this class is to ensure coverage of Swift structs
/// with nullable items, as the primary [NIAllNullableTypes] class is being used to
/// test Swift classes.
///
/// Generated class from Pigeon that represents data sent in messages.
struct NIAllNullableTypesWithoutRecursion {
  var aNullableBool: Bool? = nil
  var aNullableInt: Int64? = nil
  var aNullableInt64: Int64? = nil
  var aNullableDouble: Double? = nil
  var aNullableEnum: NIAnEnum? = nil
  var anotherNullableEnum: NIAnotherEnum? = nil
  var aNullableString: String? = nil
  var aNullableObject: Any? = nil
  var list: [Any?]? = nil
  var map: [AnyHashable?: Any?]? = nil

  static func fromList(_ pigeonVar_list: [Any?]) -> NIAllNullableTypesWithoutRecursion? {
    let aNullableBool: Bool? = nilOrValue(pigeonVar_list[0])
    let aNullableInt: Int64? = nilOrValue(pigeonVar_list[1])
    let aNullableInt64: Int64? = nilOrValue(pigeonVar_list[2])
    let aNullableDouble: Double? = nilOrValue(pigeonVar_list[3])
    let aNullableEnum: NIAnEnum? = nilOrValue(pigeonVar_list[4])
    let anotherNullableEnum: NIAnotherEnum? = nilOrValue(pigeonVar_list[5])
    let aNullableString: String? = nilOrValue(pigeonVar_list[6])
    let aNullableObject: Any? = pigeonVar_list[7]
    let list: [Any?]? = nilOrValue(pigeonVar_list[8])
    let map: [AnyHashable?: Any?]? = nilOrValue(pigeonVar_list[9])

    return NIAllNullableTypesWithoutRecursion(
      aNullableBool: aNullableBool,
      aNullableInt: aNullableInt,
      aNullableInt64: aNullableInt64,
      aNullableDouble: aNullableDouble,
      aNullableEnum: aNullableEnum,
      anotherNullableEnum: anotherNullableEnum,
      aNullableString: aNullableString,
      aNullableObject: aNullableObject,
      list: list,
      map: map
    )
  }
  func toList() -> [Any?] {
    return [
      aNullableBool,
      aNullableInt,
      aNullableInt64,
      aNullableDouble,
      aNullableEnum,
      anotherNullableEnum,
      aNullableString,
      aNullableObject,
      list,
      map,
    ]
  }
}

/// A class containing all supported nullable types.
/// The primary purpose for this class is to ensure coverage of Swift structs
/// with nullable items, as the primary [NIAllNullableTypes] class is being used to
/// test Swift classes.
///
/// Generated bridge class from Pigeon that moves data from Swift to Objective-C.
@available(iOS 13, macOS 16.0.0, *)
@objc class NIAllNullableTypesWithoutRecursionBridge: NSObject {
  @objc init(
    aNullableBool: NSNumber? = nil,
    aNullableInt: NSNumber? = nil,
    aNullableInt64: NSNumber? = nil,
    aNullableDouble: NSNumber? = nil,
    aNullableEnum: NSNumber? = nil,
    anotherNullableEnum: NSNumber? = nil,
    aNullableString: NSString? = nil,
    aNullableObject: NSObject? = nil,
    list: [NSObject]? = nil,
    map: [NSObject: NSObject]? = nil
  ) {
    self.aNullableBool = aNullableBool
    self.aNullableInt = aNullableInt
    self.aNullableInt64 = aNullableInt64
    self.aNullableDouble = aNullableDouble
    self.aNullableEnum = aNullableEnum
    self.anotherNullableEnum = anotherNullableEnum
    self.aNullableString = aNullableString
    self.aNullableObject = aNullableObject
    self.list = list
    self.map = map
  }
  @objc var aNullableBool: NSNumber? = nil
  @objc var aNullableInt: NSNumber? = nil
  @objc var aNullableInt64: NSNumber? = nil
  @objc var aNullableDouble: NSNumber? = nil
  @objc var aNullableEnum: NSNumber? = nil
  @objc var anotherNullableEnum: NSNumber? = nil
  @objc var aNullableString: NSString? = nil
  @objc var aNullableObject: NSObject? = nil
  @objc var list: [NSObject]? = nil
  @objc var map: [NSObject: NSObject]? = nil

  static func fromSwift(_ pigeonVar_Class: NIAllNullableTypesWithoutRecursion?)
    -> NIAllNullableTypesWithoutRecursionBridge?
  {
    if isNullish(pigeonVar_Class) {
      return nil
    }
    return NIAllNullableTypesWithoutRecursionBridge(
      aNullableBool: isNullish(pigeonVar_Class!.aNullableBool)
        ? nil : NSNumber(value: pigeonVar_Class!.aNullableBool!),
      aNullableInt: isNullish(pigeonVar_Class!.aNullableInt)
        ? nil : NSNumber(value: pigeonVar_Class!.aNullableInt!),
      aNullableInt64: isNullish(pigeonVar_Class!.aNullableInt64)
        ? nil : NSNumber(value: pigeonVar_Class!.aNullableInt64!),
      aNullableDouble: isNullish(pigeonVar_Class!.aNullableDouble)
        ? nil : NSNumber(value: pigeonVar_Class!.aNullableDouble!),
      aNullableEnum: isNullish(pigeonVar_Class!.aNullableEnum)
        ? nil : NSNumber(value: pigeonVar_Class!.aNullableEnum!.rawValue),
      anotherNullableEnum: isNullish(pigeonVar_Class!.anotherNullableEnum)
        ? nil : NSNumber(value: pigeonVar_Class!.anotherNullableEnum!.rawValue),
      aNullableString: pigeonVar_Class!.aNullableString as NSString?,
      aNullableObject: pigeonVar_Class!.aNullableObject as! NSObject?,
      list: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.list) as? [NSObject],
      map: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.map) as? [NSObject: NSObject],
    )
  }
  func toSwift() -> NIAllNullableTypesWithoutRecursion {
    return NIAllNullableTypesWithoutRecursion(
      aNullableBool: isNullish(aNullableBool) ? nil : aNullableBool!.boolValue,
      aNullableInt: isNullish(aNullableInt) ? nil : aNullableInt!.int64Value,
      aNullableInt64: isNullish(aNullableInt64) ? nil : aNullableInt64!.int64Value,
      aNullableDouble: isNullish(aNullableDouble) ? nil : aNullableDouble!.doubleValue,
      aNullableEnum: isNullish(aNullableEnum)
        ? nil : NIAnEnum.init(rawValue: aNullableEnum!.intValue),
      anotherNullableEnum: isNullish(anotherNullableEnum)
        ? nil : NIAnotherEnum.init(rawValue: anotherNullableEnum!.intValue),
      aNullableString: aNullableString as String?,
      aNullableObject: aNullableObject,
      list: _PigeonFfiCodec.readValue(value: list as NSObject?) as? [Any?],
      map: _PigeonFfiCodec.readValue(value: map as NSObject?) as? [AnyHashable?: Any?],
    )
  }
}

/// A class for testing nested class handling.
///
/// This is needed to test nested nullable and non-nullable classes,
/// `NIAllNullableTypes` is non-nullable here as it is easier to instantiate
/// than `NIAllTypes` when testing doesn't require both (ie. testing null classes).
///
/// Generated class from Pigeon that represents data sent in messages.
struct NIAllClassesWrapper {
  var allNullableTypesWithoutRecursion: NIAllNullableTypesWithoutRecursion? = nil
  var allTypes: NIAllTypes? = nil

  static func fromList(_ pigeonVar_list: [Any?]) -> NIAllClassesWrapper? {
    let allNullableTypesWithoutRecursion: NIAllNullableTypesWithoutRecursion? = nilOrValue(
      pigeonVar_list[0])
    let allTypes: NIAllTypes? = nilOrValue(pigeonVar_list[1])

    return NIAllClassesWrapper(
      allNullableTypesWithoutRecursion: allNullableTypesWithoutRecursion,
      allTypes: allTypes
    )
  }
  func toList() -> [Any?] {
    return [
      allNullableTypesWithoutRecursion,
      allTypes,
    ]
  }
}

/// A class for testing nested class handling.
///
/// This is needed to test nested nullable and non-nullable classes,
/// `NIAllNullableTypes` is non-nullable here as it is easier to instantiate
/// than `NIAllTypes` when testing doesn't require both (ie. testing null classes).
///
/// Generated bridge class from Pigeon that moves data from Swift to Objective-C.
@available(iOS 13, macOS 16.0.0, *)
@objc class NIAllClassesWrapperBridge: NSObject {
  @objc init(
    allNullableTypesWithoutRecursion: NIAllNullableTypesWithoutRecursionBridge? = nil,
    allTypes: NIAllTypesBridge? = nil
  ) {
    self.allNullableTypesWithoutRecursion = allNullableTypesWithoutRecursion
    self.allTypes = allTypes
  }
  @objc var allNullableTypesWithoutRecursion: NIAllNullableTypesWithoutRecursionBridge? = nil
  @objc var allTypes: NIAllTypesBridge? = nil

  static func fromSwift(_ pigeonVar_Class: NIAllClassesWrapper?) -> NIAllClassesWrapperBridge? {
    if isNullish(pigeonVar_Class) {
      return nil
    }
    return NIAllClassesWrapperBridge(
      allNullableTypesWithoutRecursion: NIAllNullableTypesWithoutRecursionBridge.fromSwift(
        pigeonVar_Class!.allNullableTypesWithoutRecursion),
      allTypes: NIAllTypesBridge.fromSwift(pigeonVar_Class!.allTypes),
    )
  }
  func toSwift() -> NIAllClassesWrapper {
    return NIAllClassesWrapper(
      allNullableTypesWithoutRecursion: isNullish(allNullableTypesWithoutRecursion)
        ? nil : allNullableTypesWithoutRecursion!.toSwift(),
      allTypes: isNullish(allTypes) ? nil : allTypes!.toSwift(),
    )
  }
}

@objc class PigeonInternalNull: NSObject {}

@available(iOS 13, macOS 16.0.0, *)
class _PigeonFfiCodec {
  static func readValue(value: NSObject?, type: String? = nil) -> Any? {
    if isNullish(value) {
      return nil
    }
    if value is NSNumber {
      if type == "int" {
        return (value as! NSNumber).int64Value
      } else if type == "double" {
        return (value as! NSNumber).doubleValue
      } else if type == "bool" {
        return (value as! NSNumber).boolValue
      } else if type == "NIAnEnum" {
        return NIAnEnum.init(rawValue: (value as! NSNumber).intValue)
      } else if type == "NIAnotherEnum" {
        return NIAnotherEnum.init(rawValue: (value as! NSNumber).intValue)
      }
    }
    // } else if (value.isA<NSByteArray>(NSByteArray.type)) {
    //   final Uint8List list = Uint8List(value.as(NSByteArray.type).length)
    //   for (int i = 0; i < value.as(NSByteArray.type).length; i++) {
    //     list[i] = value.as(NSByteArray.type)[i]
    //   }
    //   return list
    // } else if (value.isA<NSIntArray>(NSIntArray.type)) {
    //   final Int32List list = Int32List(value.as(NSIntArray.type).length)
    //   for (int i = 0; i < value.as(NSIntArray.type).length; i++) {
    //     list[i] = value.as(NSIntArray.type)[i]
    //   }
    //   return list
    //   // } else if (value.isA<NSLongArray>(NSLongArray.type)) {
    //   final Int64List list = Int64List(value.as(NSLongArray.type).length)
    //   //   for (int i = 0; i < value.as(NSLongArray.type).length; i++) {
    //     list[i] = value.as(NSLongArray.type)[i]
    //   //   }
    //   return list
    //   // } else if (value.isA<NSDoubleArray>(NSDoubleArray.type)) {
    //   final Float64List list = Float64List(value.as(NSDoubleArray.type).length)
    //   //   for (int i = 0; i < value.as(NSDoubleArray.type).length; i++) {
    //     list[i] = value.as(NSDoubleArray.type)[i]
    //   //   }
    //   return list
    if value is NSMutableArray || value is NSArray {
      var res: [Any?] = []
      for item in (value as! NSArray) {
        res.append(readValue(value: item as? NSObject))
      }
      return res
    }
    if value is NSDictionary {
      var res: [AnyHashable?: Any?] = Dictionary()
      for (key, value) in (value as! NSDictionary) {
        res[readValue(value: key as? NSObject) as? AnyHashable] = readValue(
          value: value as? NSObject)
      }
      return res
    }
    if value is NumberWrapper {
      return unwrapNumber(wrappedNumber: value as! NumberWrapper)
    }
    if value is NSString {
      return value as! NSString
    }
    return value
  }

  static func writeValue(value: Any?, isObject: Bool = false) -> Any? {
    if isNullish(value) {
      return PigeonInternalNull()
    }
    if value is Bool || value is Double || value is Int || value is Int64 || value is NIAnEnum
      || value is NIAnotherEnum
    {
      if isObject {
        return wrapNumber(number: value!)
      }
      if value is Bool {
        return (value as! Bool) ? Int(1) : Int(0)
      } else if value is Double {
        return value
      } else if value is Int || value is Int64 {
        return value
      } else if value is NIAnEnum {
        return (value as! NIAnEnum).rawValue
      } else if value is NIAnotherEnum {
        return (value as! NIAnotherEnum).rawValue
      }
    }
    // } else if (isTypeOrNullableType<NSByteArray>(T)) {
    //   value as List<int>
    //   final NSByteArray array = NSByteArray(value.length)
    //   for (int i = 0; i < value.length; i++) {
    //     array[i] = value[i]
    //   }
    //   return array
    // } else if (isTypeOrNullableType<NSIntArray>(T)) {
    //   value as List<int>
    //   final NSIntArray array = NSIntArray(value.length)
    //   for (int i = 0; i < value.length; i++) {
    //     array[i] = value[i]
    //   }
    //   return array
    // } else if (isTypeOrNullableType<NSLongArray>(T)) {
    //   value as List<int>
    //   final NSLongArray array = NSLongArray(value.length)
    //   for (int i = 0; i < value.length; i++) {
    //     array[i] = value[i]
    //   }
    //   return array
    // } else if (isTypeOrNullableType<NSDoubleArray>(T)) {
    //   value as List<double>
    //   final NSDoubleArray array = NSDoubleArray(value.length)
    //   for (int i = 0; i < value.length; i++) {
    //     array[i] = value[i]
    //   }
    //   return array
    if value is [Any] {
      let res: NSMutableArray = NSMutableArray()
      for item in (value as! [Any]) {
        res.add(
          isNullish(item)
            ? PigeonInternalNull() : writeValue(value: item, isObject: true) as! NSObject)
      }
      return res
    }
    if value is [AnyHashable: Any] {
      let res: NSMutableDictionary = NSMutableDictionary()
      for (key, value) in (value as! [AnyHashable: Any]) {
        res.setObject(
          isNullish(key)
            ? PigeonInternalNull() : writeValue(value: value, isObject: true) as! NSObject,
          forKey: writeValue(value: key, isObject: true) as! NSCopying)
      }
      return res
    }
    if value is String {
      return value as! NSString
    }
    return value
  }
}

let defaultInstanceName = "PigeonDefaultClassName32uh4ui3lh445uh4h3l2l455g4y34u"
var instancesOfNIHostIntegrationCoreApi = [String: NIHostIntegrationCoreApiSetup?]()
/// The core interface that each host language plugin must implement in
/// platform_test integration tests.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol NIHostIntegrationCoreApi {
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  func noop() throws
  /// Returns the passed object, to test serialization and deserialization.
  func echoAllTypes(everything: NIAllTypes) throws -> NIAllTypes
  /// Returns passed in int.
  func echoInt(anInt: Int64) throws -> Int64
  /// Returns passed in double.
  func echoDouble(aDouble: Double) throws -> Double
  /// Returns the passed in boolean.
  func echoBool(aBool: Bool) throws -> Bool
  /// Returns the passed in string.
  func echoString(aString: String) throws -> String
  /// Returns the passed in generic Object.
  func echoObject(anObject: Any) throws -> Any
  /// Returns the passed list, to test serialization and deserialization.
  func echoList(list: [Any?]) throws -> [Any?]
  /// Returns the passed list, to test serialization and deserialization.
  func echoStringList(stringList: [String?]) throws -> [String?]
  /// Returns the passed list, to test serialization and deserialization.
  func echoIntList(intList: [Int64?]) throws -> [Int64?]
  /// Returns the passed list, to test serialization and deserialization.
  func echoDoubleList(doubleList: [Double?]) throws -> [Double?]
  /// Returns the passed list, to test serialization and deserialization.
  func echoBoolList(boolList: [Bool?]) throws -> [Bool?]
  /// Returns the passed map, to test serialization and deserialization.
  func echoMap(map: [AnyHashable?: Any?]) throws -> [AnyHashable?: Any?]
  /// Returns the passed map, to test serialization and deserialization.
  func echoStringMap(stringMap: [String?: String?]) throws -> [String?: String?]
  /// Returns the passed map, to test serialization and deserialization.
  /// Returns the passed class to test nested class serialization and deserialization.
  func echoClassWrapper(wrapper: NIAllClassesWrapper) throws -> NIAllClassesWrapper
  /// Returns the passed enum to test serialization and deserialization.
  func echoEnum(anEnum: NIAnEnum) throws -> NIAnEnum
  /// Returns the passed enum to test serialization and deserialization.
  func echoAnotherEnum(anotherEnum: NIAnotherEnum) throws -> NIAnotherEnum
  /// Returns the passed object, to test serialization and deserialization.
  /// Returns the passed object, to test serialization and deserialization.
  func echoAllNullableTypesWithoutRecursion(everything: NIAllNullableTypesWithoutRecursion?) throws
    -> NIAllNullableTypesWithoutRecursion?
  /// Returns the inner `aString` value from the wrapped object, to test
  /// sending of nested objects.
  func extractNestedNullableString(wrapper: NIAllClassesWrapper) throws -> String?
  /// Returns the inner `aString` value from the wrapped object, to test
  /// sending of nested objects.
  func createNestedNullableString(nullableString: String?) throws -> NIAllClassesWrapper
  /// Returns passed in arguments of multiple types.
  func sendMultipleNullableTypesWithoutRecursion(
    aNullableBool: Bool?, aNullableInt: Int64?, aNullableString: String?
  ) throws -> NIAllNullableTypesWithoutRecursion
  /// Returns passed in int.
  func echoNullableInt(aNullableInt: Int64?) throws -> Int64?
  /// Returns passed in double.
  func echoNullableDouble(aNullableDouble: Double?) throws -> Double?
  /// Returns the passed in boolean.
  func echoNullableBool(aNullableBool: Bool?) throws -> Bool?
  /// Returns the passed in string.
  func echoNullableString(aNullableString: String?) throws -> String?
  /// Returns the passed in generic Object.
  func echoNullableObject(aNullableObject: Any?) throws -> Any?
  /// Returns the passed list, to test serialization and deserialization.
  func echoNullableList(aNullableList: [Any?]?) throws -> [Any?]?
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullableMap(map: [AnyHashable?: Any?]?) throws -> [AnyHashable?: Any?]?
  func echoNullableEnum(anEnum: NIAnEnum?) throws -> NIAnEnum?
  func echoAnotherNullableEnum(anotherEnum: NIAnotherEnum?) throws -> NIAnotherEnum?
}

/// Generated setup class from Pigeon to register implemented NIHostIntegrationCoreApi classes.
@objc class NIHostIntegrationCoreApiSetup: NSObject {
  private var api: NIHostIntegrationCoreApi?
  override init() {}
  static func register(api: NIHostIntegrationCoreApi?, name: String = defaultInstanceName) {
    let wrapper = NIHostIntegrationCoreApiSetup()
    wrapper.api = api
    instancesOfNIHostIntegrationCoreApi[name] = wrapper
  }
  @objc static func getInstance(name: String) -> NIHostIntegrationCoreApiSetup? {
    return instancesOfNIHostIntegrationCoreApi[name] ?? nil
  }
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func noop(wrappedError: NiTestsError) {
    do {
      return try api!.noop()
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return
  }
  /// Returns the passed object, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoAllTypes(everything: NIAllTypesBridge, wrappedError: NiTestsError)
    -> NIAllTypesBridge?
  {
    do {
      return try NIAllTypesBridge.fromSwift(api!.echoAllTypes(everything: everything.toSwift()))
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns passed in int.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoInt(anInt: Int64, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try api!.echoInt(anInt: anInt) as NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns passed in double.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoDouble(aDouble: Double, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try api!.echoDouble(aDouble: aDouble) as NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in boolean.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoBool(aBool: Bool, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try api!.echoBool(aBool: aBool) as NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in string.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoString(aString: NSString, wrappedError: NiTestsError) -> NSString? {
    do {
      return try api!.echoString(aString: aString as String) as NSString?
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in generic Object.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoObject(anObject: NSObject, wrappedError: NiTestsError) -> NSObject? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoObject(anObject: anObject), isObject: true) as? NSObject
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoList(list: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoList(list: _PigeonFfiCodec.readValue(value: list as NSObject) as! [Any?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoStringList(stringList: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoStringList(
          stringList: _PigeonFfiCodec.readValue(value: stringList as NSObject) as! [String?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoIntList(intList: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoIntList(
          intList: _PigeonFfiCodec.readValue(value: intList as NSObject) as! [Int64?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoDoubleList(doubleList: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoDoubleList(
          doubleList: _PigeonFfiCodec.readValue(value: doubleList as NSObject) as! [Double?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoBoolList(boolList: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoBoolList(
          boolList: _PigeonFfiCodec.readValue(value: boolList as NSObject) as! [Bool?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoMap(map: [NSObject: NSObject], wrappedError: NiTestsError) -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoMap(
          map: _PigeonFfiCodec.readValue(value: map as NSObject) as! [AnyHashable?: Any?]))
        as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoStringMap(stringMap: [NSObject: NSObject], wrappedError: NiTestsError)
    -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoStringMap(
          stringMap: _PigeonFfiCodec.readValue(value: stringMap as NSObject) as! [String?: String?])
      ) as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  /// Returns the passed class to test nested class serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoClassWrapper(wrapper: NIAllClassesWrapperBridge, wrappedError: NiTestsError)
    -> NIAllClassesWrapperBridge?
  {
    do {
      return try NIAllClassesWrapperBridge.fromSwift(
        api!.echoClassWrapper(wrapper: wrapper.toSwift()))
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed enum to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoEnum(anEnum: NIAnEnum, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try NSNumber(value: api!.echoEnum(anEnum: anEnum).rawValue)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed enum to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoAnotherEnum(anotherEnum: NIAnotherEnum, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try NSNumber(value: api!.echoAnotherEnum(anotherEnum: anotherEnum).rawValue)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed object, to test serialization and deserialization.
  /// Returns the passed object, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoAllNullableTypesWithoutRecursion(
    everything: NIAllNullableTypesWithoutRecursionBridge?, wrappedError: NiTestsError
  ) -> NIAllNullableTypesWithoutRecursionBridge? {
    do {
      return try NIAllNullableTypesWithoutRecursionBridge.fromSwift(
        api!.echoAllNullableTypesWithoutRecursion(
          everything: isNullish(everything) ? nil : everything!.toSwift()))
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the inner `aString` value from the wrapped object, to test
  /// sending of nested objects.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func extractNestedNullableString(
    wrapper: NIAllClassesWrapperBridge, wrappedError: NiTestsError
  ) -> NSString? {
    do {
      return try api!.extractNestedNullableString(wrapper: wrapper.toSwift()) as NSString?
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the inner `aString` value from the wrapped object, to test
  /// sending of nested objects.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func createNestedNullableString(nullableString: NSString?, wrappedError: NiTestsError)
    -> NIAllClassesWrapperBridge?
  {
    do {
      return try NIAllClassesWrapperBridge.fromSwift(
        api!.createNestedNullableString(nullableString: nullableString as String?))
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns passed in arguments of multiple types.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func sendMultipleNullableTypesWithoutRecursion(
    aNullableBool: NSNumber?, aNullableInt: NSNumber?, aNullableString: NSString?,
    wrappedError: NiTestsError
  ) -> NIAllNullableTypesWithoutRecursionBridge? {
    do {
      return try NIAllNullableTypesWithoutRecursionBridge.fromSwift(
        api!.sendMultipleNullableTypesWithoutRecursion(
          aNullableBool: isNullish(aNullableBool) ? nil : aNullableBool!.boolValue,
          aNullableInt: isNullish(aNullableInt) ? nil : aNullableInt!.int64Value,
          aNullableString: aNullableString as String?))
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns passed in int.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableInt(aNullableInt: NSNumber?, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try api!.echoNullableInt(
        aNullableInt: isNullish(aNullableInt) ? nil : aNullableInt!.int64Value) as? NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns passed in double.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableDouble(aNullableDouble: NSNumber?, wrappedError: NiTestsError) -> NSNumber?
  {
    do {
      return try api!.echoNullableDouble(
        aNullableDouble: isNullish(aNullableDouble) ? nil : aNullableDouble!.doubleValue)
        as? NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in boolean.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableBool(aNullableBool: NSNumber?, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try api!.echoNullableBool(
        aNullableBool: isNullish(aNullableBool) ? nil : aNullableBool!.boolValue) as? NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in string.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableString(aNullableString: NSString?, wrappedError: NiTestsError) -> NSString?
  {
    do {
      return try api!.echoNullableString(aNullableString: aNullableString as String?) as NSString?
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in generic Object.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableObject(aNullableObject: NSObject, wrappedError: NiTestsError) -> NSObject?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableObject(aNullableObject: aNullableObject), isObject: true)
        as? NSObject
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableList(aNullableList: [NSObject]?, wrappedError: NiTestsError) -> [NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableList(
          aNullableList: _PigeonFfiCodec.readValue(value: aNullableList as NSObject?) as? [Any?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableMap(map: [NSObject: NSObject]?, wrappedError: NiTestsError) -> [NSObject:
    NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableMap(
          map: _PigeonFfiCodec.readValue(value: map as NSObject?) as? [AnyHashable?: Any?]))
        as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableEnum(anEnum: NSNumber?, wrappedError: NiTestsError) -> NSNumber? {
    do {
      let res = try api!.echoNullableEnum(
        anEnum: isNullish(anEnum) ? nil : NIAnEnum.init(rawValue: anEnum!.intValue))?.rawValue
      return isNullish(res) ? nil : NSNumber(value: res!)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoAnotherNullableEnum(anotherEnum: NSNumber?, wrappedError: NiTestsError)
    -> NSNumber?
  {
    do {
      let res = try api!.echoAnotherNullableEnum(
        anotherEnum: isNullish(anotherEnum)
          ? nil : NIAnotherEnum.init(rawValue: anotherEnum!.intValue))?.rawValue
      return isNullish(res) ? nil : NSNumber(value: res!)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
}
