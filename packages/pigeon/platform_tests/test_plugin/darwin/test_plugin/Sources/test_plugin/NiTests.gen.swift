// Copyright 2013 The Flutter Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Autogenerated from Pigeon, do not edit directly.
// See also: https://pub.dev/packages/pigeon
// swift-format-ignore-file: AlwaysUseLowerCamelCase

import Foundation

/// Error class for passing custom error details to Dart side.
@objc final class NiTestsError: NSObject, Error {
  @objc var code: String?
  @objc var message: String?
  @objc var details: String?

  @objc override init() {}

  @objc init(code: String?, message: String?, details: String?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "NiTestsError(code: \(code ?? "<nil>"), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

@objc class NumberWrapper: NSObject, NSCopying {
  @objc required init(
    number: NSNumber,
    type: Int,
  ) {
    self.number = number
    self.type = type
  }
  func copy(with zone: NSZone? = nil) -> Any {
    return Self(number: number, type: type)
  }
  @objc var number: NSNumber
  @objc var type: Int
  static func == (lhs: NumberWrapper, rhs: NumberWrapper) -> Bool {
    return lhs.number == rhs.number && lhs.type == rhs.type
  }

  override func isEqual(_ object: Any?) -> Bool {
    guard let other = object as? NumberWrapper else {
      return false
    }
    return self == other
  }

  override var hash: Int {
    return number.hashValue ^ type.hashValue
  }

}

private func wrapNumber(number: Any) -> NumberWrapper {
  switch number {
  case _ as Int:
    return NumberWrapper(number: NSNumber(value: number as! Int), type: 1)
  case _ as Int64:
    return NumberWrapper(number: NSNumber(value: number as! Int64), type: 1)
  case _ as Double:
    return NumberWrapper(number: NSNumber(value: number as! Double), type: 2)
  case _ as Float:
    return NumberWrapper(number: NSNumber(value: number as! Float), type: 2)
  case _ as Bool:
    return NumberWrapper(number: NSNumber(value: number as! Bool), type: 3)

  case _ as NIAnEnum:
    return NumberWrapper(number: NSNumber(value: (number as! NIAnEnum).rawValue), type: 4)
  case _ as NIAnotherEnum:
    return NumberWrapper(number: NSNumber(value: (number as! NIAnotherEnum).rawValue), type: 5)
  default:
    return NumberWrapper(number: NSNumber(value: 0), type: 0)
  }
}

private func unwrapNumber(wrappedNumber: NumberWrapper) -> Any {
  switch wrappedNumber.type {
  case 1:
    return wrappedNumber.number.int64Value
  case 2:
    return wrappedNumber.number.doubleValue
  case 3:
    return wrappedNumber.number.boolValue
  case 4:
    return NIAnEnum(rawValue: wrappedNumber.number.intValue)!
  case 5:
    return NIAnotherEnum(rawValue: wrappedNumber.number.intValue)!
  default:
    return wrappedNumber.number.int64Value
  }
}

private func numberCodec(number: Any) -> Int {
  switch number {
  case _ as Int:
    return 1
  case _ as Double:
    return 2
  case _ as Float:
    return 2
  case _ as Bool:
    return 3
  case _ as NIAnEnum:
    return 4
  case _ as NIAnotherEnum:
    return 5
  default:
    return 0
  }
}
// Enum to represent the Dart TypedData types
enum MyDataType: Int {
  case uint8 = 0
  case int32 = 1
  case int64 = 2
  case float32 = 3
  case float64 = 4
}

@available(iOS 13, macOS 16.0.0, *)
@objc public class PigeonTypedData: NSObject {
  @objc public let data: NSData
  @objc public let type: Int

  @objc public init(data: NSData, type: Int) {
    self.data = data
    self.type = type
  }

  public init(_ data: [UInt8]) {
    let swiftData = data.withUnsafeBufferPointer { Data(buffer: $0) }
    self.data = NSData(data: swiftData)
    self.type = MyDataType.uint8.rawValue
  }

  public init(_ data: [Int32]) {
    let swiftData = data.withUnsafeBufferPointer { Data(buffer: $0) }
    self.data = NSData(data: swiftData)
    self.type = MyDataType.int32.rawValue
  }

  public init(_ data: [Int64]) {
    let swiftData = data.withUnsafeBufferPointer { Data(buffer: $0) }
    self.data = NSData(data: swiftData)
    self.type = MyDataType.int64.rawValue
  }

  public init(_ data: [Float32]) {
    let swiftData = data.withUnsafeBufferPointer { Data(buffer: $0) }
    self.data = NSData(data: swiftData)
    self.type = MyDataType.float32.rawValue
  }

  public init(_ data: [Float64]) {
    let swiftData = data.withUnsafeBufferPointer { Data(buffer: $0) }
    self.data = NSData(data: swiftData)
    self.type = MyDataType.float64.rawValue
  }

  /// Returns the data as a [UInt8] array, if the type is .uint8
  public func toUint8Array() -> [UInt8]? {
    guard type == MyDataType.uint8.rawValue else { return nil }
    var array = [UInt8](repeating: 0, count: data.length)
    data.getBytes(&array, length: data.length)
    return array
  }

  /// Returns the data as a [Int32] array, if the type is .int32
  public func toInt32Array() -> [Int32]? {
    guard type == MyDataType.int32.rawValue else { return nil }
    let itemSize = MemoryLayout<Int32>.stride
    guard data.length % itemSize == 0 else { return nil }
    let count = data.length / itemSize
    var array = [Int32](repeating: 0, count: count)
    data.getBytes(&array, length: data.length)
    return array
  }

  /// Returns the data as a [Int64] array, if the type is .int64
  public func toInt64Array() -> [Int64]? {
    guard type == MyDataType.int64.rawValue else { return nil }
    let itemSize = MemoryLayout<Int64>.stride
    guard data.length % itemSize == 0 else { return nil }
    let count = data.length / itemSize
    var array = [Int64](repeating: 0, count: count)
    data.getBytes(&array, length: data.length)
    return array
  }

  /// Returns the data as a [Float32] array, if the type is .float32
  public func toFloat32Array() -> [Float32]? {
    guard type == MyDataType.float32.rawValue else { return nil }
    let itemSize = MemoryLayout<Float32>.stride
    guard data.length % itemSize == 0 else { return nil }
    let count = data.length / itemSize
    var array = [Float32](repeating: 0, count: count)
    data.getBytes(&array, length: data.length)
    return array
  }

  /// Returns the data as a [Float64] array (Array<Double>), if the type is .float64
  public func toFloat64Array() -> [Double]? {
    guard type == MyDataType.float64.rawValue else { return nil }
    let itemSize = MemoryLayout<Double>.stride
    guard data.length % itemSize == 0 else { return nil }
    let count = data.length / itemSize
    var array = [Double](repeating: 0, count: count)
    data.getBytes(&array, length: data.length)
    return array
  }

  @objc public func getUint8Array() -> [NSNumber]? {
    return toUint8Array()?.map { NSNumber(value: $0) }
  }

  @objc public func getInt32Array() -> [NSNumber]? {
    return toInt32Array()?.map { NSNumber(value: $0) }
  }

  @objc public func getInt64Array() -> [NSNumber]? {
    return toInt64Array()?.map { NSNumber(value: $0) }
  }

  @objc public func getFloat32Array() -> [NSNumber]? {
    return toFloat32Array()?.map { NSNumber(value: $0) }
  }

  @objc public func getFloat64Array() -> [NSNumber]? {
    return toFloat64Array()?.map { NSNumber(value: $0) }
  }
}

private func isNullish(_ value: Any?) -> Bool {
  guard let innerValue = value else {
    return true
  }

  if case Optional<Any>.some(Optional<Any>.none) = value {
    return true
  }

  return innerValue is NSNull || innerValue is PigeonInternalNull
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

func deepEqualsNiTests(_ lhs: Any?, _ rhs: Any?) -> Bool {
  let cleanLhs = nilOrValue(lhs) as Any?
  let cleanRhs = nilOrValue(rhs) as Any?
  switch (cleanLhs, cleanRhs) {
  case (nil, nil):
    return true

  case (nil, _), (_, nil):
    return false

  case is (Void, Void):
    return true

  case let (cleanLhsHashable, cleanRhsHashable) as (AnyHashable, AnyHashable):
    return cleanLhsHashable == cleanRhsHashable

  case let (cleanLhsArray, cleanRhsArray) as ([Any?], [Any?]):
    guard cleanLhsArray.count == cleanRhsArray.count else { return false }
    for (index, element) in cleanLhsArray.enumerated() {
      if !deepEqualsNiTests(element, cleanRhsArray[index]) {
        return false
      }
    }
    return true

  case let (cleanLhsDictionary, cleanRhsDictionary) as ([AnyHashable: Any?], [AnyHashable: Any?]):
    guard cleanLhsDictionary.count == cleanRhsDictionary.count else { return false }
    for (key, cleanLhsValue) in cleanLhsDictionary {
      guard cleanRhsDictionary.index(forKey: key) != nil else { return false }
      if !deepEqualsNiTests(cleanLhsValue, cleanRhsDictionary[key]!) {
        return false
      }
    }
    return true

  default:
    // Any other type shouldn't be able to be used with pigeon. File an issue if you find this to be untrue.
    return false
  }
}

func deepHashNiTests(value: Any?, hasher: inout Hasher) {
  if let valueList = value as? [AnyHashable] {
    for item in valueList { deepHashNiTests(value: item, hasher: &hasher) }
    return
  }

  if let valueDict = value as? [AnyHashable: AnyHashable] {
    for key in valueDict.keys {
      hasher.combine(key)
      deepHashNiTests(value: valueDict[key]!, hasher: &hasher)
    }
    return
  }

  if let hashableValue = value as? AnyHashable {
    hasher.combine(hashableValue.hashValue)
  }

  return hasher.combine(String(describing: value))
}

@objc enum NIAnEnum: Int {
  case one = 0
  case two = 1
  case three = 2
  case fortyTwo = 3
  case fourHundredTwentyTwo = 4
}

@objc enum NIAnotherEnum: Int {
  case justInCase = 0
}

/// A class containing all supported types.
///
/// Generated class from Pigeon that represents data sent in messages.
struct NIAllTypes: Hashable {
  var aBool: Bool
  var anInt: Int64
  var anInt64: Int64
  var aDouble: Double
  var aByteArray: [UInt8]
  var a4ByteArray: [Int32]
  var a8ByteArray: [Int64]
  var aFloatArray: [Float64]
  var anEnum: NIAnEnum
  var anotherEnum: NIAnotherEnum
  var aString: String
  var anObject: Any
  var list: [Any?]
  var stringList: [String]
  var intList: [Int64]
  var doubleList: [Double]
  var boolList: [Bool]
  var enumList: [NIAnEnum]
  var objectList: [Any]
  var listList: [[Any?]]
  var mapList: [[AnyHashable?: Any?]]
  var map: [AnyHashable?: Any?]
  var stringMap: [String: String]
  var intMap: [Int64: Int64]
  var enumMap: [NIAnEnum: NIAnEnum]
  var objectMap: [AnyHashable: Any]
  var listMap: [Int64: [Any?]]
  var mapMap: [Int64: [AnyHashable?: Any?]]

  static func fromList(_ pigeonVar_list: [Any?]) -> NIAllTypes? {
    let aBool = pigeonVar_list[0] as! Bool
    let anInt = pigeonVar_list[1] as! Int64
    let anInt64 = pigeonVar_list[2] as! Int64
    let aDouble = pigeonVar_list[3] as! Double
    let aByteArray = pigeonVar_list[4] as! [UInt8]
    let a4ByteArray = pigeonVar_list[5] as! [Int32]
    let a8ByteArray = pigeonVar_list[6] as! [Int64]
    let aFloatArray = pigeonVar_list[7] as! [Float64]
    let anEnum = pigeonVar_list[8] as! NIAnEnum
    let anotherEnum = pigeonVar_list[9] as! NIAnotherEnum
    let aString = pigeonVar_list[10] as! String
    let anObject = pigeonVar_list[11]!
    let list = pigeonVar_list[12] as! [Any?]
    let stringList = pigeonVar_list[13] as! [String]
    let intList = pigeonVar_list[14] as! [Int64]
    let doubleList = pigeonVar_list[15] as! [Double]
    let boolList = pigeonVar_list[16] as! [Bool]
    let enumList = pigeonVar_list[17] as! [NIAnEnum]
    let objectList = pigeonVar_list[18] as! [Any]
    let listList = pigeonVar_list[19] as! [[Any?]]
    let mapList = pigeonVar_list[20] as! [[AnyHashable?: Any?]]
    let map = pigeonVar_list[21] as! [AnyHashable?: Any?]
    let stringMap = pigeonVar_list[22] as! [String: String]
    let intMap = pigeonVar_list[23] as! [Int64: Int64]
    let enumMap = pigeonVar_list[24] as? [NIAnEnum: NIAnEnum]
    let objectMap = pigeonVar_list[25] as! [AnyHashable: Any]
    let listMap = pigeonVar_list[26] as! [Int64: [Any?]]
    let mapMap = pigeonVar_list[27] as! [Int64: [AnyHashable?: Any?]]

    return NIAllTypes(
      aBool: aBool,
      anInt: anInt,
      anInt64: anInt64,
      aDouble: aDouble,
      aByteArray: aByteArray,
      a4ByteArray: a4ByteArray,
      a8ByteArray: a8ByteArray,
      aFloatArray: aFloatArray,
      anEnum: anEnum,
      anotherEnum: anotherEnum,
      aString: aString,
      anObject: anObject,
      list: list,
      stringList: stringList,
      intList: intList,
      doubleList: doubleList,
      boolList: boolList,
      enumList: enumList,
      objectList: objectList,
      listList: listList,
      mapList: mapList,
      map: map,
      stringMap: stringMap,
      intMap: intMap,
      enumMap: enumMap!,
      objectMap: objectMap,
      listMap: listMap,
      mapMap: mapMap
    )
  }
  func toList() -> [Any?] {
    return [
      aBool,
      anInt,
      anInt64,
      aDouble,
      aByteArray,
      a4ByteArray,
      a8ByteArray,
      aFloatArray,
      anEnum,
      anotherEnum,
      aString,
      anObject,
      list,
      stringList,
      intList,
      doubleList,
      boolList,
      enumList,
      objectList,
      listList,
      mapList,
      map,
      stringMap,
      intMap,
      enumMap,
      objectMap,
      listMap,
      mapMap,
    ]
  }
  static func == (lhs: NIAllTypes, rhs: NIAllTypes) -> Bool {
    return deepEqualsNiTests(lhs.toList(), rhs.toList())
  }
  func hash(into hasher: inout Hasher) {
    deepHashNiTests(value: toList(), hasher: &hasher)
  }
}

/// A class containing all supported types.
///
/// Generated bridge class from Pigeon that moves data from Swift to Objective-C.
@available(iOS 13, macOS 16.0.0, *)
@objc class NIAllTypesBridge: NSObject {
  @objc init(
    aBool: Bool,
    anInt: Int64,
    anInt64: Int64,
    aDouble: Double,
    aByteArray: PigeonTypedData,
    a4ByteArray: PigeonTypedData,
    a8ByteArray: PigeonTypedData,
    aFloatArray: PigeonTypedData,
    anEnum: NIAnEnum,
    anotherEnum: NIAnotherEnum,
    aString: NSString,
    anObject: NSObject,
    list: [NSObject],
    stringList: [NSObject],
    intList: [NSObject],
    doubleList: [NSObject],
    boolList: [NSObject],
    enumList: [NSObject],
    objectList: [NSObject],
    listList: [NSObject],
    mapList: [NSObject],
    map: [NSObject: NSObject],
    stringMap: [NSObject: NSObject],
    intMap: [NSObject: NSObject],
    enumMap: [NSObject: NSObject],
    objectMap: [NSObject: NSObject],
    listMap: [NSObject: NSObject],
    mapMap: [NSObject: NSObject]
  ) {
    self.aBool = aBool
    self.anInt = anInt
    self.anInt64 = anInt64
    self.aDouble = aDouble
    self.aByteArray = aByteArray
    self.a4ByteArray = a4ByteArray
    self.a8ByteArray = a8ByteArray
    self.aFloatArray = aFloatArray
    self.anEnum = anEnum
    self.anotherEnum = anotherEnum
    self.aString = aString
    self.anObject = anObject
    self.list = list
    self.stringList = stringList
    self.intList = intList
    self.doubleList = doubleList
    self.boolList = boolList
    self.enumList = enumList
    self.objectList = objectList
    self.listList = listList
    self.mapList = mapList
    self.map = map
    self.stringMap = stringMap
    self.intMap = intMap
    self.enumMap = enumMap
    self.objectMap = objectMap
    self.listMap = listMap
    self.mapMap = mapMap
  }
  @objc var aBool: Bool
  @objc var anInt: Int64
  @objc var anInt64: Int64
  @objc var aDouble: Double
  @objc var aByteArray: PigeonTypedData
  @objc var a4ByteArray: PigeonTypedData
  @objc var a8ByteArray: PigeonTypedData
  @objc var aFloatArray: PigeonTypedData
  @objc var anEnum: NIAnEnum
  @objc var anotherEnum: NIAnotherEnum
  @objc var aString: NSString
  @objc var anObject: NSObject
  @objc var list: [NSObject]
  @objc var stringList: [NSObject]
  @objc var intList: [NSObject]
  @objc var doubleList: [NSObject]
  @objc var boolList: [NSObject]
  @objc var enumList: [NSObject]
  @objc var objectList: [NSObject]
  @objc var listList: [NSObject]
  @objc var mapList: [NSObject]
  @objc var map: [NSObject: NSObject]
  @objc var stringMap: [NSObject: NSObject]
  @objc var intMap: [NSObject: NSObject]
  @objc var enumMap: [NSObject: NSObject]
  @objc var objectMap: [NSObject: NSObject]
  @objc var listMap: [NSObject: NSObject]
  @objc var mapMap: [NSObject: NSObject]

  static func fromSwift(_ pigeonVar_Class: NIAllTypes?) -> NIAllTypesBridge? {
    if isNullish(pigeonVar_Class) {
      return nil
    }
    return NIAllTypesBridge(
      aBool: pigeonVar_Class!.aBool,
      anInt: pigeonVar_Class!.anInt,
      anInt64: pigeonVar_Class!.anInt64,
      aDouble: pigeonVar_Class!.aDouble,
      aByteArray: PigeonTypedData(pigeonVar_Class!.aByteArray),
      a4ByteArray: PigeonTypedData(pigeonVar_Class!.a4ByteArray),
      a8ByteArray: PigeonTypedData(pigeonVar_Class!.a8ByteArray),
      aFloatArray: PigeonTypedData(pigeonVar_Class!.aFloatArray),
      anEnum: pigeonVar_Class!.anEnum,
      anotherEnum: pigeonVar_Class!.anotherEnum,
      aString: pigeonVar_Class!.aString as NSString,
      anObject: pigeonVar_Class!.anObject as! NSObject,
      list: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.list) as! [NSObject],
      stringList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.stringList) as! [NSObject],
      intList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.intList) as! [NSObject],
      doubleList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.doubleList) as! [NSObject],
      boolList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.boolList) as! [NSObject],
      enumList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.enumList) as! [NSObject],
      objectList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.objectList) as! [NSObject],
      listList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.listList) as! [NSObject],
      mapList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.mapList) as! [NSObject],
      map: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.map) as! [NSObject: NSObject],
      stringMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.stringMap)
        as! [NSObject: NSObject],
      intMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.intMap) as! [NSObject: NSObject],
      enumMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.enumMap) as! [NSObject: NSObject],
      objectMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.objectMap)
        as! [NSObject: NSObject],
      listMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.listMap) as! [NSObject: NSObject],
      mapMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.mapMap) as! [NSObject: NSObject],
    )
  }
  func toSwift() -> NIAllTypes {
    return NIAllTypes(
      aBool: aBool,
      anInt: anInt,
      anInt64: anInt64,
      aDouble: aDouble,
      aByteArray: aByteArray.toUint8Array()!,
      a4ByteArray: a4ByteArray.toInt32Array()!,
      a8ByteArray: a8ByteArray.toInt64Array()!,
      aFloatArray: aFloatArray.toFloat64Array()!,
      anEnum: anEnum,
      anotherEnum: anotherEnum,
      aString: aString as String,
      anObject: anObject,
      list: _PigeonFfiCodec.readValue(value: list as NSObject) as! [Any?],
      stringList: _PigeonFfiCodec.readValue(value: stringList as NSObject) as! [String],
      intList: _PigeonFfiCodec.readValue(value: intList as NSObject) as! [Int64],
      doubleList: _PigeonFfiCodec.readValue(value: doubleList as NSObject) as! [Double],
      boolList: _PigeonFfiCodec.readValue(value: boolList as NSObject) as! [Bool],
      enumList: _PigeonFfiCodec.readValue(value: enumList as NSObject) as! [NIAnEnum],
      objectList: _PigeonFfiCodec.readValue(value: objectList as NSObject) as! [Any],
      listList: _PigeonFfiCodec.readValue(value: listList as NSObject) as! [[Any?]],
      mapList: _PigeonFfiCodec.readValue(value: mapList as NSObject) as! [[AnyHashable?: Any?]],
      map: _PigeonFfiCodec.readValue(value: map as NSObject) as! [AnyHashable?: Any?],
      stringMap: _PigeonFfiCodec.readValue(value: stringMap as NSObject) as! [String: String],
      intMap: _PigeonFfiCodec.readValue(value: intMap as NSObject) as! [Int64: Int64],
      enumMap: _PigeonFfiCodec.readValue(value: enumMap as NSObject) as! [NIAnEnum: NIAnEnum],
      objectMap: _PigeonFfiCodec.readValue(value: objectMap as NSObject) as! [AnyHashable: Any],
      listMap: _PigeonFfiCodec.readValue(value: listMap as NSObject) as! [Int64: [Any?]],
      mapMap: _PigeonFfiCodec.readValue(value: mapMap as NSObject)
        as! [Int64: [AnyHashable?: Any?]],
    )
  }
}

/// A class containing all supported nullable types.
/// The primary purpose for this class is to ensure coverage of Swift structs
/// with nullable items, as the primary [NIAllNullableTypes] class is being used to
/// test Swift classes.
///
/// Generated class from Pigeon that represents data sent in messages.
struct NIAllNullableTypesWithoutRecursion: Hashable {
  var aNullableBool: Bool? = nil
  var aNullableInt: Int64? = nil
  var aNullableInt64: Int64? = nil
  var aNullableDouble: Double? = nil
  var aNullableByteArray: [UInt8]? = nil
  var aNullable4ByteArray: [Int32]? = nil
  var aNullable8ByteArray: [Int64]? = nil
  var aNullableFloatArray: [Float64]? = nil
  var aNullableEnum: NIAnEnum? = nil
  var anotherNullableEnum: NIAnotherEnum? = nil
  var aNullableString: String? = nil
  var aNullableObject: Any? = nil
  var list: [Any?]? = nil
  var stringList: [String?]? = nil
  var intList: [Int64?]? = nil
  var doubleList: [Double?]? = nil
  var boolList: [Bool?]? = nil
  var enumList: [NIAnEnum?]? = nil
  var objectList: [Any?]? = nil
  var listList: [[Any?]?]? = nil
  var mapList: [[AnyHashable?: Any?]?]? = nil
  var map: [AnyHashable?: Any?]? = nil
  var stringMap: [String?: String?]? = nil
  var intMap: [Int64?: Int64?]? = nil
  var enumMap: [NIAnEnum?: NIAnEnum?]? = nil
  var objectMap: [AnyHashable?: Any?]? = nil
  var listMap: [Int64?: [Any?]?]? = nil
  var mapMap: [Int64?: [AnyHashable?: Any?]?]? = nil

  static func fromList(_ pigeonVar_list: [Any?]) -> NIAllNullableTypesWithoutRecursion? {
    let aNullableBool: Bool? = nilOrValue(pigeonVar_list[0])
    let aNullableInt: Int64? = nilOrValue(pigeonVar_list[1])
    let aNullableInt64: Int64? = nilOrValue(pigeonVar_list[2])
    let aNullableDouble: Double? = nilOrValue(pigeonVar_list[3])
    let aNullableByteArray: [UInt8]? = nilOrValue(pigeonVar_list[4])
    let aNullable4ByteArray: [Int32]? = nilOrValue(pigeonVar_list[5])
    let aNullable8ByteArray: [Int64]? = nilOrValue(pigeonVar_list[6])
    let aNullableFloatArray: [Float64]? = nilOrValue(pigeonVar_list[7])
    let aNullableEnum: NIAnEnum? = nilOrValue(pigeonVar_list[8])
    let anotherNullableEnum: NIAnotherEnum? = nilOrValue(pigeonVar_list[9])
    let aNullableString: String? = nilOrValue(pigeonVar_list[10])
    let aNullableObject: Any? = pigeonVar_list[11]
    let list: [Any?]? = nilOrValue(pigeonVar_list[12])
    let stringList: [String?]? = nilOrValue(pigeonVar_list[13])
    let intList: [Int64?]? = nilOrValue(pigeonVar_list[14])
    let doubleList: [Double?]? = nilOrValue(pigeonVar_list[15])
    let boolList: [Bool?]? = nilOrValue(pigeonVar_list[16])
    let enumList: [NIAnEnum?]? = nilOrValue(pigeonVar_list[17])
    let objectList: [Any?]? = nilOrValue(pigeonVar_list[18])
    let listList: [[Any?]?]? = nilOrValue(pigeonVar_list[19])
    let mapList: [[AnyHashable?: Any?]?]? = nilOrValue(pigeonVar_list[20])
    let map: [AnyHashable?: Any?]? = nilOrValue(pigeonVar_list[21])
    let stringMap: [String?: String?]? = nilOrValue(pigeonVar_list[22])
    let intMap: [Int64?: Int64?]? = nilOrValue(pigeonVar_list[23])
    let enumMap: [NIAnEnum?: NIAnEnum?]? = pigeonVar_list[24] as? [NIAnEnum?: NIAnEnum?]
    let objectMap: [AnyHashable?: Any?]? = nilOrValue(pigeonVar_list[25])
    let listMap: [Int64?: [Any?]?]? = nilOrValue(pigeonVar_list[26])
    let mapMap: [Int64?: [AnyHashable?: Any?]?]? = nilOrValue(pigeonVar_list[27])

    return NIAllNullableTypesWithoutRecursion(
      aNullableBool: aNullableBool,
      aNullableInt: aNullableInt,
      aNullableInt64: aNullableInt64,
      aNullableDouble: aNullableDouble,
      aNullableByteArray: aNullableByteArray,
      aNullable4ByteArray: aNullable4ByteArray,
      aNullable8ByteArray: aNullable8ByteArray,
      aNullableFloatArray: aNullableFloatArray,
      aNullableEnum: aNullableEnum,
      anotherNullableEnum: anotherNullableEnum,
      aNullableString: aNullableString,
      aNullableObject: aNullableObject,
      list: list,
      stringList: stringList,
      intList: intList,
      doubleList: doubleList,
      boolList: boolList,
      enumList: enumList,
      objectList: objectList,
      listList: listList,
      mapList: mapList,
      map: map,
      stringMap: stringMap,
      intMap: intMap,
      enumMap: enumMap,
      objectMap: objectMap,
      listMap: listMap,
      mapMap: mapMap
    )
  }
  func toList() -> [Any?] {
    return [
      aNullableBool,
      aNullableInt,
      aNullableInt64,
      aNullableDouble,
      aNullableByteArray,
      aNullable4ByteArray,
      aNullable8ByteArray,
      aNullableFloatArray,
      aNullableEnum,
      anotherNullableEnum,
      aNullableString,
      aNullableObject,
      list,
      stringList,
      intList,
      doubleList,
      boolList,
      enumList,
      objectList,
      listList,
      mapList,
      map,
      stringMap,
      intMap,
      enumMap,
      objectMap,
      listMap,
      mapMap,
    ]
  }
  static func == (lhs: NIAllNullableTypesWithoutRecursion, rhs: NIAllNullableTypesWithoutRecursion)
    -> Bool
  {
    return deepEqualsNiTests(lhs.toList(), rhs.toList())
  }
  func hash(into hasher: inout Hasher) {
    deepHashNiTests(value: toList(), hasher: &hasher)
  }
}

/// A class containing all supported nullable types.
/// The primary purpose for this class is to ensure coverage of Swift structs
/// with nullable items, as the primary [NIAllNullableTypes] class is being used to
/// test Swift classes.
///
/// Generated bridge class from Pigeon that moves data from Swift to Objective-C.
@available(iOS 13, macOS 16.0.0, *)
@objc class NIAllNullableTypesWithoutRecursionBridge: NSObject {
  @objc init(
    aNullableBool: NSNumber? = nil,
    aNullableInt: NSNumber? = nil,
    aNullableInt64: NSNumber? = nil,
    aNullableDouble: NSNumber? = nil,
    aNullableByteArray: PigeonTypedData? = nil,
    aNullable4ByteArray: PigeonTypedData? = nil,
    aNullable8ByteArray: PigeonTypedData? = nil,
    aNullableFloatArray: PigeonTypedData? = nil,
    aNullableEnum: NSNumber? = nil,
    anotherNullableEnum: NSNumber? = nil,
    aNullableString: NSString? = nil,
    aNullableObject: NSObject? = nil,
    list: [NSObject]? = nil,
    stringList: [NSObject]? = nil,
    intList: [NSObject]? = nil,
    doubleList: [NSObject]? = nil,
    boolList: [NSObject]? = nil,
    enumList: [NSObject]? = nil,
    objectList: [NSObject]? = nil,
    listList: [NSObject]? = nil,
    mapList: [NSObject]? = nil,
    map: [NSObject: NSObject]? = nil,
    stringMap: [NSObject: NSObject]? = nil,
    intMap: [NSObject: NSObject]? = nil,
    enumMap: [NSObject: NSObject]? = nil,
    objectMap: [NSObject: NSObject]? = nil,
    listMap: [NSObject: NSObject]? = nil,
    mapMap: [NSObject: NSObject]? = nil
  ) {
    self.aNullableBool = aNullableBool
    self.aNullableInt = aNullableInt
    self.aNullableInt64 = aNullableInt64
    self.aNullableDouble = aNullableDouble
    self.aNullableByteArray = aNullableByteArray
    self.aNullable4ByteArray = aNullable4ByteArray
    self.aNullable8ByteArray = aNullable8ByteArray
    self.aNullableFloatArray = aNullableFloatArray
    self.aNullableEnum = aNullableEnum
    self.anotherNullableEnum = anotherNullableEnum
    self.aNullableString = aNullableString
    self.aNullableObject = aNullableObject
    self.list = list
    self.stringList = stringList
    self.intList = intList
    self.doubleList = doubleList
    self.boolList = boolList
    self.enumList = enumList
    self.objectList = objectList
    self.listList = listList
    self.mapList = mapList
    self.map = map
    self.stringMap = stringMap
    self.intMap = intMap
    self.enumMap = enumMap
    self.objectMap = objectMap
    self.listMap = listMap
    self.mapMap = mapMap
  }
  @objc var aNullableBool: NSNumber? = nil
  @objc var aNullableInt: NSNumber? = nil
  @objc var aNullableInt64: NSNumber? = nil
  @objc var aNullableDouble: NSNumber? = nil
  @objc var aNullableByteArray: PigeonTypedData? = nil
  @objc var aNullable4ByteArray: PigeonTypedData? = nil
  @objc var aNullable8ByteArray: PigeonTypedData? = nil
  @objc var aNullableFloatArray: PigeonTypedData? = nil
  @objc var aNullableEnum: NSNumber? = nil
  @objc var anotherNullableEnum: NSNumber? = nil
  @objc var aNullableString: NSString? = nil
  @objc var aNullableObject: NSObject? = nil
  @objc var list: [NSObject]? = nil
  @objc var stringList: [NSObject]? = nil
  @objc var intList: [NSObject]? = nil
  @objc var doubleList: [NSObject]? = nil
  @objc var boolList: [NSObject]? = nil
  @objc var enumList: [NSObject]? = nil
  @objc var objectList: [NSObject]? = nil
  @objc var listList: [NSObject]? = nil
  @objc var mapList: [NSObject]? = nil
  @objc var map: [NSObject: NSObject]? = nil
  @objc var stringMap: [NSObject: NSObject]? = nil
  @objc var intMap: [NSObject: NSObject]? = nil
  @objc var enumMap: [NSObject: NSObject]? = nil
  @objc var objectMap: [NSObject: NSObject]? = nil
  @objc var listMap: [NSObject: NSObject]? = nil
  @objc var mapMap: [NSObject: NSObject]? = nil

  static func fromSwift(_ pigeonVar_Class: NIAllNullableTypesWithoutRecursion?)
    -> NIAllNullableTypesWithoutRecursionBridge?
  {
    if isNullish(pigeonVar_Class) {
      return nil
    }
    return NIAllNullableTypesWithoutRecursionBridge(
      aNullableBool: isNullish(pigeonVar_Class!.aNullableBool)
        ? nil : NSNumber(value: pigeonVar_Class!.aNullableBool!),
      aNullableInt: isNullish(pigeonVar_Class!.aNullableInt)
        ? nil : NSNumber(value: pigeonVar_Class!.aNullableInt!),
      aNullableInt64: isNullish(pigeonVar_Class!.aNullableInt64)
        ? nil : NSNumber(value: pigeonVar_Class!.aNullableInt64!),
      aNullableDouble: isNullish(pigeonVar_Class!.aNullableDouble)
        ? nil : NSNumber(value: pigeonVar_Class!.aNullableDouble!),
      aNullableByteArray: isNullish(pigeonVar_Class!.aNullableByteArray)
        ? nil : PigeonTypedData(pigeonVar_Class!.aNullableByteArray!),
      aNullable4ByteArray: isNullish(pigeonVar_Class!.aNullable4ByteArray)
        ? nil : PigeonTypedData(pigeonVar_Class!.aNullable4ByteArray!),
      aNullable8ByteArray: isNullish(pigeonVar_Class!.aNullable8ByteArray)
        ? nil : PigeonTypedData(pigeonVar_Class!.aNullable8ByteArray!),
      aNullableFloatArray: isNullish(pigeonVar_Class!.aNullableFloatArray)
        ? nil : PigeonTypedData(pigeonVar_Class!.aNullableFloatArray!),
      aNullableEnum: isNullish(pigeonVar_Class!.aNullableEnum)
        ? nil : NSNumber(value: pigeonVar_Class!.aNullableEnum!.rawValue),
      anotherNullableEnum: isNullish(pigeonVar_Class!.anotherNullableEnum)
        ? nil : NSNumber(value: pigeonVar_Class!.anotherNullableEnum!.rawValue),
      aNullableString: pigeonVar_Class!.aNullableString as NSString?,
      aNullableObject: pigeonVar_Class!.aNullableObject as! NSObject?,
      list: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.list) as? [NSObject],
      stringList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.stringList) as? [NSObject],
      intList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.intList) as? [NSObject],
      doubleList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.doubleList) as? [NSObject],
      boolList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.boolList) as? [NSObject],
      enumList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.enumList) as? [NSObject],
      objectList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.objectList) as? [NSObject],
      listList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.listList) as? [NSObject],
      mapList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.mapList) as? [NSObject],
      map: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.map) as? [NSObject: NSObject],
      stringMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.stringMap)
        as? [NSObject: NSObject],
      intMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.intMap) as? [NSObject: NSObject],
      enumMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.enumMap) as? [NSObject: NSObject],
      objectMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.objectMap)
        as? [NSObject: NSObject],
      listMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.listMap) as? [NSObject: NSObject],
      mapMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.mapMap) as? [NSObject: NSObject],
    )
  }
  func toSwift() -> NIAllNullableTypesWithoutRecursion {
    return NIAllNullableTypesWithoutRecursion(
      aNullableBool: isNullish(aNullableBool) ? nil : aNullableBool!.boolValue,
      aNullableInt: isNullish(aNullableInt) ? nil : aNullableInt!.int64Value,
      aNullableInt64: isNullish(aNullableInt64) ? nil : aNullableInt64!.int64Value,
      aNullableDouble: isNullish(aNullableDouble) ? nil : aNullableDouble!.doubleValue,
      aNullableByteArray: isNullish(aNullableByteArray) ? nil : aNullableByteArray!.toUint8Array(),
      aNullable4ByteArray: isNullish(aNullable4ByteArray)
        ? nil : aNullable4ByteArray!.toInt32Array(),
      aNullable8ByteArray: isNullish(aNullable8ByteArray)
        ? nil : aNullable8ByteArray!.toInt64Array(),
      aNullableFloatArray: isNullish(aNullableFloatArray)
        ? nil : aNullableFloatArray!.toFloat64Array(),
      aNullableEnum: isNullish(aNullableEnum)
        ? nil : NIAnEnum.init(rawValue: aNullableEnum!.intValue),
      anotherNullableEnum: isNullish(anotherNullableEnum)
        ? nil : NIAnotherEnum.init(rawValue: anotherNullableEnum!.intValue),
      aNullableString: aNullableString as String?,
      aNullableObject: aNullableObject,
      list: _PigeonFfiCodec.readValue(value: list as NSObject?) as? [Any?],
      stringList: _PigeonFfiCodec.readValue(value: stringList as NSObject?) as? [String?],
      intList: _PigeonFfiCodec.readValue(value: intList as NSObject?) as? [Int64?],
      doubleList: _PigeonFfiCodec.readValue(value: doubleList as NSObject?) as? [Double?],
      boolList: _PigeonFfiCodec.readValue(value: boolList as NSObject?) as? [Bool?],
      enumList: _PigeonFfiCodec.readValue(value: enumList as NSObject?) as? [NIAnEnum?],
      objectList: _PigeonFfiCodec.readValue(value: objectList as NSObject?) as? [Any?],
      listList: _PigeonFfiCodec.readValue(value: listList as NSObject?) as? [[Any?]?],
      mapList: _PigeonFfiCodec.readValue(value: mapList as NSObject?) as? [[AnyHashable?: Any?]?],
      map: _PigeonFfiCodec.readValue(value: map as NSObject?) as? [AnyHashable?: Any?],
      stringMap: _PigeonFfiCodec.readValue(value: stringMap as NSObject?) as? [String?: String?],
      intMap: _PigeonFfiCodec.readValue(value: intMap as NSObject?) as? [Int64?: Int64?],
      enumMap: _PigeonFfiCodec.readValue(value: enumMap as NSObject?) as? [NIAnEnum?: NIAnEnum?],
      objectMap: _PigeonFfiCodec.readValue(value: objectMap as NSObject?) as? [AnyHashable?: Any?],
      listMap: _PigeonFfiCodec.readValue(value: listMap as NSObject?) as? [Int64?: [Any?]?],
      mapMap: _PigeonFfiCodec.readValue(value: mapMap as NSObject?)
        as? [Int64?: [AnyHashable?: Any?]?],
    )
  }
}

/// A class for testing nested class handling.
///
/// This is needed to test nested nullable and non-nullable classes,
/// `NIAllNullableTypes` is non-nullable here as it is easier to instantiate
/// than `NIAllTypes` when testing doesn't require both (ie. testing null classes).
///
/// Generated class from Pigeon that represents data sent in messages.
struct NIAllClassesWrapper: Hashable {
  var allNullableTypesWithoutRecursion: NIAllNullableTypesWithoutRecursion? = nil
  var allTypes: NIAllTypes? = nil
  var classList: [NIAllTypes?]
  var nullableClassList: [NIAllNullableTypesWithoutRecursion?]? = nil
  var classMap: [Int64?: NIAllTypes?]
  var nullableClassMap: [Int64?: NIAllNullableTypesWithoutRecursion?]? = nil

  static func fromList(_ pigeonVar_list: [Any?]) -> NIAllClassesWrapper? {
    let allNullableTypesWithoutRecursion: NIAllNullableTypesWithoutRecursion? = nilOrValue(
      pigeonVar_list[0])
    let allTypes: NIAllTypes? = nilOrValue(pigeonVar_list[1])
    let classList = pigeonVar_list[2] as! [NIAllTypes?]
    let nullableClassList: [NIAllNullableTypesWithoutRecursion?]? = nilOrValue(pigeonVar_list[3])
    let classMap = pigeonVar_list[4] as! [Int64?: NIAllTypes?]
    let nullableClassMap: [Int64?: NIAllNullableTypesWithoutRecursion?]? = nilOrValue(
      pigeonVar_list[5])

    return NIAllClassesWrapper(
      allNullableTypesWithoutRecursion: allNullableTypesWithoutRecursion,
      allTypes: allTypes,
      classList: classList,
      nullableClassList: nullableClassList,
      classMap: classMap,
      nullableClassMap: nullableClassMap
    )
  }
  func toList() -> [Any?] {
    return [
      allNullableTypesWithoutRecursion,
      allTypes,
      classList,
      nullableClassList,
      classMap,
      nullableClassMap,
    ]
  }
  static func == (lhs: NIAllClassesWrapper, rhs: NIAllClassesWrapper) -> Bool {
    return deepEqualsNiTests(lhs.toList(), rhs.toList())
  }
  func hash(into hasher: inout Hasher) {
    deepHashNiTests(value: toList(), hasher: &hasher)
  }
}

/// A class for testing nested class handling.
///
/// This is needed to test nested nullable and non-nullable classes,
/// `NIAllNullableTypes` is non-nullable here as it is easier to instantiate
/// than `NIAllTypes` when testing doesn't require both (ie. testing null classes).
///
/// Generated bridge class from Pigeon that moves data from Swift to Objective-C.
@available(iOS 13, macOS 16.0.0, *)
@objc class NIAllClassesWrapperBridge: NSObject {
  @objc init(
    allNullableTypesWithoutRecursion: NIAllNullableTypesWithoutRecursionBridge? = nil,
    allTypes: NIAllTypesBridge? = nil,
    classList: [NSObject],
    nullableClassList: [NSObject]? = nil,
    classMap: [NSObject: NSObject],
    nullableClassMap: [NSObject: NSObject]? = nil
  ) {
    self.allNullableTypesWithoutRecursion = allNullableTypesWithoutRecursion
    self.allTypes = allTypes
    self.classList = classList
    self.nullableClassList = nullableClassList
    self.classMap = classMap
    self.nullableClassMap = nullableClassMap
  }
  @objc var allNullableTypesWithoutRecursion: NIAllNullableTypesWithoutRecursionBridge? = nil
  @objc var allTypes: NIAllTypesBridge? = nil
  @objc var classList: [NSObject]
  @objc var nullableClassList: [NSObject]? = nil
  @objc var classMap: [NSObject: NSObject]
  @objc var nullableClassMap: [NSObject: NSObject]? = nil

  static func fromSwift(_ pigeonVar_Class: NIAllClassesWrapper?) -> NIAllClassesWrapperBridge? {
    if isNullish(pigeonVar_Class) {
      return nil
    }
    return NIAllClassesWrapperBridge(
      allNullableTypesWithoutRecursion: NIAllNullableTypesWithoutRecursionBridge.fromSwift(
        pigeonVar_Class!.allNullableTypesWithoutRecursion),
      allTypes: NIAllTypesBridge.fromSwift(pigeonVar_Class!.allTypes),
      classList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.classList) as! [NSObject],
      nullableClassList: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.nullableClassList)
        as? [NSObject],
      classMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.classMap)
        as! [NSObject: NSObject],
      nullableClassMap: _PigeonFfiCodec.writeValue(value: pigeonVar_Class!.nullableClassMap)
        as? [NSObject: NSObject],
    )
  }
  func toSwift() -> NIAllClassesWrapper {
    return NIAllClassesWrapper(
      allNullableTypesWithoutRecursion: isNullish(allNullableTypesWithoutRecursion)
        ? nil : allNullableTypesWithoutRecursion!.toSwift(),
      allTypes: isNullish(allTypes) ? nil : allTypes!.toSwift(),
      classList: _PigeonFfiCodec.readValue(value: classList as NSObject) as! [NIAllTypes?],
      nullableClassList: _PigeonFfiCodec.readValue(value: nullableClassList as NSObject?)
        as? [NIAllNullableTypesWithoutRecursion?],
      classMap: _PigeonFfiCodec.readValue(value: classMap as NSObject) as! [Int64?: NIAllTypes?],
      nullableClassMap: _PigeonFfiCodec.readValue(value: nullableClassMap as NSObject?)
        as? [Int64?: NIAllNullableTypesWithoutRecursion?],
    )
  }
}

@objc class PigeonInternalNull: NSObject {}

@available(iOS 13, macOS 16.0.0, *)
class _PigeonFfiCodec {
  static func readValue(value: NSObject?, type: String? = nil) -> Any? {
    if isNullish(value) {
      return nil
    }
    if value is NSNumber {
      if type == "int" || type == "int64" {
        return (value as! NSNumber).int64Value
      } else if type == "double" {
        return (value as! NSNumber).doubleValue
      } else if type == "bool" {
        return (value as! NSNumber).boolValue
      } else if type == "NIAnEnum" {
        return NIAnEnum.init(rawValue: (value as! NSNumber).intValue)
      } else if type == "NIAnotherEnum" {
        return NIAnotherEnum.init(rawValue: (value as! NSNumber).intValue)
      }
    }
    // } else if (value.isA<NSByteArray>(NSByteArray.type)) {
    //   final Uint8List list = Uint8List(value.as(NSByteArray.type).length)
    //   for (int i = 0; i < value.as(NSByteArray.type).length; i++) {
    //     list[i] = value.as(NSByteArray.type)[i]
    //   }
    //   return list
    // } else if (value.isA<NSIntArray>(NSIntArray.type)) {
    //   final Int32List list = Int32List(value.as(NSIntArray.type).length)
    //   for (int i = 0; i < value.as(NSIntArray.type).length; i++) {
    //     list[i] = value.as(NSIntArray.type)[i]
    //   }
    //   return list
    //   // } else if (value.isA<NSLongArray>(NSLongArray.type)) {
    //   final Int64List list = Int64List(value.as(NSLongArray.type).length)
    //   //   for (int i = 0; i < value.as(NSLongArray.type).length; i++) {
    //     list[i] = value.as(NSLongArray.type)[i]
    //   //   }
    //   return list
    //   // } else if (value.isA<NSDoubleArray>(NSDoubleArray.type)) {
    //   final Float64List list = Float64List(value.as(NSDoubleArray.type).length)
    //   //   for (int i = 0; i < value.as(NSDoubleArray.type).length; i++) {
    //     list[i] = value.as(NSDoubleArray.type)[i]
    //   //   }
    //   return list
    if value is NSMutableArray || value is NSArray {
      var res: [Any?] = []
      for item in (value as! NSArray) {
        res.append(readValue(value: item as? NSObject))
      }
      return res
    }
    if value is NSDictionary {
      var res: [AnyHashable?: Any?] = Dictionary()
      for (key, value) in (value as! NSDictionary) {
        res[readValue(value: key as? NSObject) as? AnyHashable] = readValue(
          value: value as? NSObject)
      }
      return res
    }
    if value is NumberWrapper {
      return unwrapNumber(wrappedNumber: value as! NumberWrapper)
    }
    if value is NSString {
      return value as! NSString
    } else if value is NIAllTypesBridge {
      return (value! as! NIAllTypesBridge).toSwift()
    } else if value is NIAllNullableTypesWithoutRecursionBridge {
      return (value! as! NIAllNullableTypesWithoutRecursionBridge).toSwift()
    } else if value is NIAllClassesWrapperBridge {
      return (value! as! NIAllClassesWrapperBridge).toSwift()

    }
    return value
  }

  static func writeValue(value: Any?, isObject: Bool = false) -> Any? {
    if isNullish(value) {
      return PigeonInternalNull()
    }
    if value is Bool || value is Double || value is Int || value is Int64 || value is NIAnEnum
      || value is NIAnotherEnum
    {
      if isObject {
        return wrapNumber(number: value!)
      }
      if value is Bool {
        return (value as! Bool) ? Int(1) : Int(0)
      } else if value is Double {
        return value
      } else if value is Int || value is Int64 {
        return value
      } else if value is NIAnEnum {
        return (value as! NIAnEnum).rawValue
      } else if value is NIAnotherEnum {
        return (value as! NIAnotherEnum).rawValue
      }
    }
    // } else if (isTypeOrNullableType<NSByteArray>(T)) {
    //   value as List<int>
    //   final NSByteArray array = NSByteArray(value.length)
    //   for (int i = 0; i < value.length; i++) {
    //     array[i] = value[i]
    //   }
    //   return array
    // } else if (isTypeOrNullableType<NSIntArray>(T)) {
    //   value as List<int>
    //   final NSIntArray array = NSIntArray(value.length)
    //   for (int i = 0; i < value.length; i++) {
    //     array[i] = value[i]
    //   }
    //   return array
    // } else if (isTypeOrNullableType<NSLongArray>(T)) {
    //   value as List<int>
    //   final NSLongArray array = NSLongArray(value.length)
    //   for (int i = 0; i < value.length; i++) {
    //     array[i] = value[i]
    //   }
    //   return array
    // } else if (isTypeOrNullableType<NSDoubleArray>(T)) {
    //   value as List<double>
    //   final NSDoubleArray array = NSDoubleArray(value.length)
    //   for (int i = 0; i < value.length; i++) {
    //     array[i] = value[i]
    //   }
    //   return array
    if value is [Any] {
      let res: NSMutableArray = NSMutableArray()
      for item in (value as! [Any]) {
        res.add(
          isNullish(item)
            ? PigeonInternalNull() : writeValue(value: item, isObject: true) as! NSObject)
      }
      return res
    }
    if value is [AnyHashable: Any] {
      let res: NSMutableDictionary = NSMutableDictionary()
      for (key, value) in (value as! [AnyHashable: Any]) {
        res.setObject(
          isNullish(key)
            ? PigeonInternalNull() : writeValue(value: value, isObject: true) as! NSObject,
          forKey: writeValue(value: key, isObject: true) as! NSCopying)
      }
      return res
    }
    if value is String {
      return value as! NSString
    } else if value is NIAllTypes {
      return NIAllTypesBridge.fromSwift(value as? NIAllTypes)
    } else if value is NIAllNullableTypesWithoutRecursion {
      return NIAllNullableTypesWithoutRecursionBridge.fromSwift(
        value as? NIAllNullableTypesWithoutRecursion)
    } else if value is NIAllClassesWrapper {
      return NIAllClassesWrapperBridge.fromSwift(value as? NIAllClassesWrapper)

    }
    return value
  }
}

let defaultInstanceName = "PigeonDefaultClassName32uh4ui3lh445uh4h3l2l455g4y34u"
var instancesOfNIHostIntegrationCoreApi = [String: NIHostIntegrationCoreApiSetup?]()
/// The core interface that each host language plugin must implement in
/// platform_test integration tests.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol NIHostIntegrationCoreApi {
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  func noop() throws
  /// Returns the passed object, to test serialization and deserialization.
  func echoAllTypes(everything: NIAllTypes) throws -> NIAllTypes
  /// Returns passed in int.
  func echoInt(anInt: Int64) throws -> Int64
  /// Returns passed in double.
  func echoDouble(aDouble: Double) throws -> Double
  /// Returns the passed in boolean.
  func echoBool(aBool: Bool) throws -> Bool
  /// Returns the passed in string.
  func echoString(aString: String) throws -> String
  /// Returns the passed in Uint8List.
  func echoUint8List(aUint8List: [UInt8]) throws -> [UInt8]
  /// Returns the passed in Int32List.
  func echoInt32List(aInt32List: [Int32]) throws -> [Int32]
  /// Returns the passed in Int64List.
  func echoInt64List(aInt64List: [Int64]) throws -> [Int64]
  /// Returns the passed in Float64List.
  func echoFloat64List(aFloat64List: [Float64]) throws -> [Float64]
  /// Returns the passed in generic Object.
  func echoObject(anObject: Any) throws -> Any
  /// Returns the passed list, to test serialization and deserialization.
  func echoList(list: [Any?]) throws -> [Any?]
  /// Returns the passed list, to test serialization and deserialization.
  func echoStringList(stringList: [String?]) throws -> [String?]
  /// Returns the passed list, to test serialization and deserialization.
  func echoIntList(intList: [Int64?]) throws -> [Int64?]
  /// Returns the passed list, to test serialization and deserialization.
  func echoDoubleList(doubleList: [Double?]) throws -> [Double?]
  /// Returns the passed list, to test serialization and deserialization.
  func echoBoolList(boolList: [Bool?]) throws -> [Bool?]
  /// Returns the passed list, to test serialization and deserialization.
  func echoEnumList(enumList: [NIAnEnum?]) throws -> [NIAnEnum?]
  /// Returns the passed list, to test serialization and deserialization.
  func echoClassList(classList: [NIAllNullableTypesWithoutRecursion?]) throws
    -> [NIAllNullableTypesWithoutRecursion?]
  /// Returns the passed list, to test serialization and deserialization.
  func echoNonNullEnumList(enumList: [NIAnEnum]) throws -> [NIAnEnum]
  /// Returns the passed list, to test serialization and deserialization.
  func echoNonNullClassList(classList: [NIAllNullableTypesWithoutRecursion]) throws
    -> [NIAllNullableTypesWithoutRecursion]
  /// Returns the passed map, to test serialization and deserialization.
  func echoMap(map: [AnyHashable?: Any?]) throws -> [AnyHashable?: Any?]
  /// Returns the passed map, to test serialization and deserialization.
  func echoStringMap(stringMap: [String?: String?]) throws -> [String?: String?]
  /// Returns the passed map, to test serialization and deserialization.
  func echoIntMap(intMap: [Int64?: Int64?]) throws -> [Int64?: Int64?]
  /// Returns the passed map, to test serialization and deserialization.
  func echoEnumMap(enumMap: [NIAnEnum?: NIAnEnum?]) throws -> [NIAnEnum?: NIAnEnum?]
  /// Returns the passed map, to test serialization and deserialization.
  func echoClassMap(classMap: [Int64?: NIAllNullableTypesWithoutRecursion?]) throws -> [Int64?:
    NIAllNullableTypesWithoutRecursion?]
  /// Returns the passed map, to test serialization and deserialization.
  func echoNonNullStringMap(stringMap: [String: String]) throws -> [String: String]
  /// Returns the passed map, to test serialization and deserialization.
  func echoNonNullIntMap(intMap: [Int64: Int64]) throws -> [Int64: Int64]
  /// Returns the passed map, to test serialization and deserialization.
  func echoNonNullEnumMap(enumMap: [NIAnEnum: NIAnEnum]) throws -> [NIAnEnum: NIAnEnum]
  /// Returns the passed map, to test serialization and deserialization.
  func echoNonNullClassMap(classMap: [Int64: NIAllNullableTypesWithoutRecursion]) throws -> [Int64:
    NIAllNullableTypesWithoutRecursion]
  /// Returns the passed class to test nested class serialization and deserialization.
  func echoClassWrapper(wrapper: NIAllClassesWrapper) throws -> NIAllClassesWrapper
  /// Returns the passed enum to test serialization and deserialization.
  func echoEnum(anEnum: NIAnEnum) throws -> NIAnEnum
  /// Returns the passed enum to test serialization and deserialization.
  func echoAnotherEnum(anotherEnum: NIAnotherEnum) throws -> NIAnotherEnum
  /// Returns the passed object, to test serialization and deserialization.
  /// Returns the passed object, to test serialization and deserialization.
  func echoAllNullableTypesWithoutRecursion(everything: NIAllNullableTypesWithoutRecursion?) throws
    -> NIAllNullableTypesWithoutRecursion?
  /// Returns the inner `aString` value from the wrapped object, to test
  /// sending of nested objects.
  func extractNestedNullableString(wrapper: NIAllClassesWrapper) throws -> String?
  /// Returns the inner `aString` value from the wrapped object, to test
  /// sending of nested objects.
  func createNestedNullableString(nullableString: String?) throws -> NIAllClassesWrapper
  func sendMultipleNullableTypes(
    aNullableBool: Bool?, aNullableInt: Int64?, aNullableString: String?
  ) throws -> NIAllNullableTypesWithoutRecursion
  func sendMultipleNullableTypesWithoutRecursion(
    aNullableBool: Bool?, aNullableInt: Int64?, aNullableString: String?
  ) throws -> NIAllNullableTypesWithoutRecursion
  /// Returns passed in int.
  func echoNullableInt(aNullableInt: Int64?) throws -> Int64?
  /// Returns passed in double.
  func echoNullableDouble(aNullableDouble: Double?) throws -> Double?
  /// Returns the passed in boolean.
  func echoNullableBool(aNullableBool: Bool?) throws -> Bool?
  /// Returns the passed in string.
  func echoNullableString(aNullableString: String?) throws -> String?
  /// Returns the passed in Uint8List.
  func echoNullableUint8List(aNullableUint8List: [UInt8]?) throws -> [UInt8]?
  /// Returns the passed in Int32List.
  func echoNullableInt32List(aNullableInt32List: [Int32]?) throws -> [Int32]?
  /// Returns the passed in Int64List.
  func echoNullableInt64List(aNullableInt64List: [Int64]?) throws -> [Int64]?
  /// Returns the passed in Float64List.
  func echoNullableFloat64List(aNullableFloat64List: [Float64]?) throws -> [Float64]?
  /// Returns the passed in generic Object.
  func echoNullableObject(aNullableObject: Any?) throws -> Any?
  /// Returns the passed list, to test serialization and deserialization.
  func echoNullableList(aNullableList: [Any?]?) throws -> [Any?]?
  /// Returns the passed list, to test serialization and deserialization.
  func echoNullableEnumList(enumList: [NIAnEnum?]?) throws -> [NIAnEnum?]?
  /// Returns the passed list, to test serialization and deserialization.
  func echoNullableClassList(classList: [NIAllNullableTypesWithoutRecursion?]?) throws
    -> [NIAllNullableTypesWithoutRecursion?]?
  /// Returns the passed list, to test serialization and deserialization.
  func echoNullableNonNullEnumList(enumList: [NIAnEnum]?) throws -> [NIAnEnum]?
  /// Returns the passed list, to test serialization and deserialization.
  func echoNullableNonNullClassList(classList: [NIAllNullableTypesWithoutRecursion]?) throws
    -> [NIAllNullableTypesWithoutRecursion]?
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullableMap(map: [AnyHashable?: Any?]?) throws -> [AnyHashable?: Any?]?
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullableStringMap(stringMap: [String?: String?]?) throws -> [String?: String?]?
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullableIntMap(intMap: [Int64?: Int64?]?) throws -> [Int64?: Int64?]?
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullableEnumMap(enumMap: [NIAnEnum?: NIAnEnum?]?) throws -> [NIAnEnum?: NIAnEnum?]?
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullableClassMap(classMap: [Int64?: NIAllNullableTypesWithoutRecursion?]?) throws
    -> [Int64?: NIAllNullableTypesWithoutRecursion?]?
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullableNonNullStringMap(stringMap: [String: String]?) throws -> [String: String]?
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullableNonNullIntMap(intMap: [Int64: Int64]?) throws -> [Int64: Int64]?
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullableNonNullEnumMap(enumMap: [NIAnEnum: NIAnEnum]?) throws -> [NIAnEnum: NIAnEnum]?
  /// Returns the passed map, to test serialization and deserialization.
  func echoNullableNonNullClassMap(classMap: [Int64: NIAllNullableTypesWithoutRecursion]?) throws
    -> [Int64: NIAllNullableTypesWithoutRecursion]?
  func echoNullableEnum(anEnum: NIAnEnum?) throws -> NIAnEnum?
  func echoAnotherNullableEnum(anotherEnum: NIAnotherEnum?) throws -> NIAnotherEnum?
}

/// Generated setup class from Pigeon to register implemented NIHostIntegrationCoreApi classes.
@objc class NIHostIntegrationCoreApiSetup: NSObject {
  private var api: NIHostIntegrationCoreApi?
  override init() {}
  static func register(api: NIHostIntegrationCoreApi?, name: String = defaultInstanceName) {
    let wrapper = NIHostIntegrationCoreApiSetup()
    wrapper.api = api
    instancesOfNIHostIntegrationCoreApi[name] = wrapper
  }
  @objc static func getInstance(name: String) -> NIHostIntegrationCoreApiSetup? {
    return instancesOfNIHostIntegrationCoreApi[name] ?? nil
  }
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func noop(wrappedError: NiTestsError) {
    do {
      return try api!.noop()
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return
  }
  /// Returns the passed object, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoAllTypes(everything: NIAllTypesBridge, wrappedError: NiTestsError)
    -> NIAllTypesBridge?
  {
    do {
      return try NIAllTypesBridge.fromSwift(api!.echoAllTypes(everything: everything.toSwift()))
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns passed in int.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoInt(anInt: Int64, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try api!.echoInt(anInt: anInt) as NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns passed in double.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoDouble(aDouble: Double, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try api!.echoDouble(aDouble: aDouble) as NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in boolean.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoBool(aBool: Bool, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try api!.echoBool(aBool: aBool) as NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in string.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoString(aString: NSString, wrappedError: NiTestsError) -> NSString? {
    do {
      return try api!.echoString(aString: aString as String) as NSString?
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in Uint8List.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoUint8List(aUint8List: PigeonTypedData, wrappedError: NiTestsError)
    -> PigeonTypedData?
  {
    do {
      let res = try api!.echoUint8List(aUint8List: aUint8List.toUint8Array()!)
      return isNullish(res) ? nil : PigeonTypedData(res)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in Int32List.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoInt32List(aInt32List: PigeonTypedData, wrappedError: NiTestsError)
    -> PigeonTypedData?
  {
    do {
      let res = try api!.echoInt32List(aInt32List: aInt32List.toInt32Array()!)
      return isNullish(res) ? nil : PigeonTypedData(res)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in Int64List.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoInt64List(aInt64List: PigeonTypedData, wrappedError: NiTestsError)
    -> PigeonTypedData?
  {
    do {
      let res = try api!.echoInt64List(aInt64List: aInt64List.toInt64Array()!)
      return isNullish(res) ? nil : PigeonTypedData(res)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in Float64List.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoFloat64List(aFloat64List: PigeonTypedData, wrappedError: NiTestsError)
    -> PigeonTypedData?
  {
    do {
      let res = try api!.echoFloat64List(aFloat64List: aFloat64List.toFloat64Array()!)
      return isNullish(res) ? nil : PigeonTypedData(res)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in generic Object.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoObject(anObject: NSObject, wrappedError: NiTestsError) -> NSObject? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoObject(anObject: anObject), isObject: true) as? NSObject
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoList(list: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoList(list: _PigeonFfiCodec.readValue(value: list as NSObject) as! [Any?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoStringList(stringList: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoStringList(
          stringList: _PigeonFfiCodec.readValue(value: stringList as NSObject) as! [String?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoIntList(intList: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoIntList(
          intList: _PigeonFfiCodec.readValue(value: intList as NSObject) as! [Int64?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoDoubleList(doubleList: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoDoubleList(
          doubleList: _PigeonFfiCodec.readValue(value: doubleList as NSObject) as! [Double?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoBoolList(boolList: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoBoolList(
          boolList: _PigeonFfiCodec.readValue(value: boolList as NSObject) as! [Bool?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoEnumList(enumList: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoEnumList(
          enumList: _PigeonFfiCodec.readValue(value: enumList as NSObject) as! [NIAnEnum?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoClassList(classList: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoClassList(
          classList: _PigeonFfiCodec.readValue(value: classList as NSObject)
            as! [NIAllNullableTypesWithoutRecursion?])) as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNonNullEnumList(enumList: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNonNullEnumList(
          enumList: _PigeonFfiCodec.readValue(value: enumList as NSObject) as! [NIAnEnum]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNonNullClassList(classList: [NSObject], wrappedError: NiTestsError) -> [NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNonNullClassList(
          classList: _PigeonFfiCodec.readValue(value: classList as NSObject)
            as! [NIAllNullableTypesWithoutRecursion])) as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoMap(map: [NSObject: NSObject], wrappedError: NiTestsError) -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoMap(
          map: _PigeonFfiCodec.readValue(value: map as NSObject) as! [AnyHashable?: Any?]))
        as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoStringMap(stringMap: [NSObject: NSObject], wrappedError: NiTestsError)
    -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoStringMap(
          stringMap: _PigeonFfiCodec.readValue(value: stringMap as NSObject) as! [String?: String?])
      ) as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoIntMap(intMap: [NSObject: NSObject], wrappedError: NiTestsError) -> [NSObject:
    NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoIntMap(
          intMap: _PigeonFfiCodec.readValue(value: intMap as NSObject) as! [Int64?: Int64?]))
        as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoEnumMap(enumMap: [NSObject: NSObject], wrappedError: NiTestsError) -> [NSObject:
    NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoEnumMap(
          enumMap: _PigeonFfiCodec.readValue(value: enumMap as NSObject) as! [NIAnEnum?: NIAnEnum?])
      ) as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoClassMap(classMap: [NSObject: NSObject], wrappedError: NiTestsError) -> [NSObject:
    NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoClassMap(
          classMap: _PigeonFfiCodec.readValue(value: classMap as NSObject)
            as! [Int64?: NIAllNullableTypesWithoutRecursion?])) as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNonNullStringMap(stringMap: [NSObject: NSObject], wrappedError: NiTestsError)
    -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNonNullStringMap(
          stringMap: _PigeonFfiCodec.readValue(value: stringMap as NSObject) as! [String: String]))
        as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNonNullIntMap(intMap: [NSObject: NSObject], wrappedError: NiTestsError)
    -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNonNullIntMap(
          intMap: _PigeonFfiCodec.readValue(value: intMap as NSObject) as! [Int64: Int64]))
        as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNonNullEnumMap(enumMap: [NSObject: NSObject], wrappedError: NiTestsError)
    -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNonNullEnumMap(
          enumMap: _PigeonFfiCodec.readValue(value: enumMap as NSObject) as! [NIAnEnum: NIAnEnum]))
        as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNonNullClassMap(classMap: [NSObject: NSObject], wrappedError: NiTestsError)
    -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNonNullClassMap(
          classMap: _PigeonFfiCodec.readValue(value: classMap as NSObject)
            as! [Int64: NIAllNullableTypesWithoutRecursion])) as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed class to test nested class serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoClassWrapper(wrapper: NIAllClassesWrapperBridge, wrappedError: NiTestsError)
    -> NIAllClassesWrapperBridge?
  {
    do {
      return try NIAllClassesWrapperBridge.fromSwift(
        api!.echoClassWrapper(wrapper: wrapper.toSwift()))
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed enum to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoEnum(anEnum: NIAnEnum, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try NSNumber(value: api!.echoEnum(anEnum: anEnum).rawValue)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed enum to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoAnotherEnum(anotherEnum: NIAnotherEnum, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try NSNumber(value: api!.echoAnotherEnum(anotherEnum: anotherEnum).rawValue)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed object, to test serialization and deserialization.
  /// Returns the passed object, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoAllNullableTypesWithoutRecursion(
    everything: NIAllNullableTypesWithoutRecursionBridge?, wrappedError: NiTestsError
  ) -> NIAllNullableTypesWithoutRecursionBridge? {
    do {
      return try NIAllNullableTypesWithoutRecursionBridge.fromSwift(
        api!.echoAllNullableTypesWithoutRecursion(
          everything: isNullish(everything) ? nil : everything!.toSwift()))
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the inner `aString` value from the wrapped object, to test
  /// sending of nested objects.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func extractNestedNullableString(
    wrapper: NIAllClassesWrapperBridge, wrappedError: NiTestsError
  ) -> NSString? {
    do {
      return try api!.extractNestedNullableString(wrapper: wrapper.toSwift()) as NSString?
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the inner `aString` value from the wrapped object, to test
  /// sending of nested objects.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func createNestedNullableString(nullableString: NSString?, wrappedError: NiTestsError)
    -> NIAllClassesWrapperBridge?
  {
    do {
      return try NIAllClassesWrapperBridge.fromSwift(
        api!.createNestedNullableString(nullableString: nullableString as String?))
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  @available(iOS 13, macOS 16.0.0, *)
  @objc func sendMultipleNullableTypes(
    aNullableBool: NSNumber?, aNullableInt: NSNumber?, aNullableString: NSString?,
    wrappedError: NiTestsError
  ) -> NIAllNullableTypesWithoutRecursionBridge? {
    do {
      return try NIAllNullableTypesWithoutRecursionBridge.fromSwift(
        api!.sendMultipleNullableTypes(
          aNullableBool: isNullish(aNullableBool) ? nil : aNullableBool!.boolValue,
          aNullableInt: isNullish(aNullableInt) ? nil : aNullableInt!.int64Value,
          aNullableString: aNullableString as String?))
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  @available(iOS 13, macOS 16.0.0, *)
  @objc func sendMultipleNullableTypesWithoutRecursion(
    aNullableBool: NSNumber?, aNullableInt: NSNumber?, aNullableString: NSString?,
    wrappedError: NiTestsError
  ) -> NIAllNullableTypesWithoutRecursionBridge? {
    do {
      return try NIAllNullableTypesWithoutRecursionBridge.fromSwift(
        api!.sendMultipleNullableTypesWithoutRecursion(
          aNullableBool: isNullish(aNullableBool) ? nil : aNullableBool!.boolValue,
          aNullableInt: isNullish(aNullableInt) ? nil : aNullableInt!.int64Value,
          aNullableString: aNullableString as String?))
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns passed in int.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableInt(aNullableInt: NSNumber?, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try api!.echoNullableInt(
        aNullableInt: isNullish(aNullableInt) ? nil : aNullableInt!.int64Value) as? NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns passed in double.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableDouble(aNullableDouble: NSNumber?, wrappedError: NiTestsError) -> NSNumber?
  {
    do {
      return try api!.echoNullableDouble(
        aNullableDouble: isNullish(aNullableDouble) ? nil : aNullableDouble!.doubleValue)
        as? NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in boolean.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableBool(aNullableBool: NSNumber?, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try api!.echoNullableBool(
        aNullableBool: isNullish(aNullableBool) ? nil : aNullableBool!.boolValue) as? NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in string.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableString(aNullableString: NSString?, wrappedError: NiTestsError) -> NSString?
  {
    do {
      return try api!.echoNullableString(aNullableString: aNullableString as String?) as NSString?
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in Uint8List.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableUint8List(aNullableUint8List: PigeonTypedData?, wrappedError: NiTestsError)
    -> PigeonTypedData?
  {
    do {
      let res = try api!.echoNullableUint8List(
        aNullableUint8List: isNullish(aNullableUint8List) ? nil : aNullableUint8List!.toUint8Array()
      )
      return isNullish(res) ? nil : PigeonTypedData(res!)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in Int32List.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableInt32List(aNullableInt32List: PigeonTypedData?, wrappedError: NiTestsError)
    -> PigeonTypedData?
  {
    do {
      let res = try api!.echoNullableInt32List(
        aNullableInt32List: isNullish(aNullableInt32List) ? nil : aNullableInt32List!.toInt32Array()
      )
      return isNullish(res) ? nil : PigeonTypedData(res!)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in Int64List.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableInt64List(aNullableInt64List: PigeonTypedData?, wrappedError: NiTestsError)
    -> PigeonTypedData?
  {
    do {
      let res = try api!.echoNullableInt64List(
        aNullableInt64List: isNullish(aNullableInt64List) ? nil : aNullableInt64List!.toInt64Array()
      )
      return isNullish(res) ? nil : PigeonTypedData(res!)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in Float64List.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableFloat64List(
    aNullableFloat64List: PigeonTypedData?, wrappedError: NiTestsError
  ) -> PigeonTypedData? {
    do {
      let res = try api!.echoNullableFloat64List(
        aNullableFloat64List: isNullish(aNullableFloat64List)
          ? nil : aNullableFloat64List!.toFloat64Array())
      return isNullish(res) ? nil : PigeonTypedData(res!)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in generic Object.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableObject(aNullableObject: NSObject, wrappedError: NiTestsError) -> NSObject?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableObject(aNullableObject: aNullableObject), isObject: true)
        as? NSObject
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableList(aNullableList: [NSObject]?, wrappedError: NiTestsError) -> [NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableList(
          aNullableList: _PigeonFfiCodec.readValue(value: aNullableList as NSObject?) as? [Any?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableEnumList(enumList: [NSObject]?, wrappedError: NiTestsError) -> [NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableEnumList(
          enumList: _PigeonFfiCodec.readValue(value: enumList as NSObject?) as? [NIAnEnum?]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableClassList(classList: [NSObject]?, wrappedError: NiTestsError)
    -> [NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableClassList(
          classList: _PigeonFfiCodec.readValue(value: classList as NSObject?)
            as? [NIAllNullableTypesWithoutRecursion?])) as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableNonNullEnumList(enumList: [NSObject]?, wrappedError: NiTestsError)
    -> [NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableNonNullEnumList(
          enumList: _PigeonFfiCodec.readValue(value: enumList as NSObject?) as? [NIAnEnum]))
        as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableNonNullClassList(classList: [NSObject]?, wrappedError: NiTestsError)
    -> [NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableNonNullClassList(
          classList: _PigeonFfiCodec.readValue(value: classList as NSObject?)
            as? [NIAllNullableTypesWithoutRecursion])) as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableMap(map: [NSObject: NSObject]?, wrappedError: NiTestsError) -> [NSObject:
    NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableMap(
          map: _PigeonFfiCodec.readValue(value: map as NSObject?) as? [AnyHashable?: Any?]))
        as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableStringMap(stringMap: [NSObject: NSObject]?, wrappedError: NiTestsError)
    -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableStringMap(
          stringMap: _PigeonFfiCodec.readValue(value: stringMap as NSObject?) as? [String?: String?]
        )) as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableIntMap(intMap: [NSObject: NSObject]?, wrappedError: NiTestsError)
    -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableIntMap(
          intMap: _PigeonFfiCodec.readValue(value: intMap as NSObject?) as? [Int64?: Int64?]))
        as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableEnumMap(enumMap: [NSObject: NSObject]?, wrappedError: NiTestsError)
    -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableEnumMap(
          enumMap: _PigeonFfiCodec.readValue(value: enumMap as NSObject?) as? [NIAnEnum?: NIAnEnum?]
        )) as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableClassMap(classMap: [NSObject: NSObject]?, wrappedError: NiTestsError)
    -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableClassMap(
          classMap: _PigeonFfiCodec.readValue(value: classMap as NSObject?)
            as? [Int64?: NIAllNullableTypesWithoutRecursion?])) as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableNonNullStringMap(
    stringMap: [NSObject: NSObject]?, wrappedError: NiTestsError
  ) -> [NSObject: NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableNonNullStringMap(
          stringMap: _PigeonFfiCodec.readValue(value: stringMap as NSObject?) as? [String: String]))
        as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableNonNullIntMap(intMap: [NSObject: NSObject]?, wrappedError: NiTestsError)
    -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableNonNullIntMap(
          intMap: _PigeonFfiCodec.readValue(value: intMap as NSObject?) as? [Int64: Int64]))
        as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableNonNullEnumMap(enumMap: [NSObject: NSObject]?, wrappedError: NiTestsError)
    -> [NSObject: NSObject]?
  {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableNonNullEnumMap(
          enumMap: _PigeonFfiCodec.readValue(value: enumMap as NSObject?) as? [NIAnEnum: NIAnEnum]))
        as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableNonNullClassMap(
    classMap: [NSObject: NSObject]?, wrappedError: NiTestsError
  ) -> [NSObject: NSObject]? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoNullableNonNullClassMap(
          classMap: _PigeonFfiCodec.readValue(value: classMap as NSObject?)
            as? [Int64: NIAllNullableTypesWithoutRecursion])) as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoNullableEnum(anEnum: NSNumber?, wrappedError: NiTestsError) -> NSNumber? {
    do {
      let res = try api!.echoNullableEnum(
        anEnum: isNullish(anEnum) ? nil : NIAnEnum.init(rawValue: anEnum!.intValue))?.rawValue
      return isNullish(res) ? nil : NSNumber(value: res!)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoAnotherNullableEnum(anotherEnum: NSNumber?, wrappedError: NiTestsError)
    -> NSNumber?
  {
    do {
      let res = try api!.echoAnotherNullableEnum(
        anotherEnum: isNullish(anotherEnum)
          ? nil : NIAnotherEnum.init(rawValue: anotherEnum!.intValue))?.rawValue
      return isNullish(res) ? nil : NSNumber(value: res!)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
}
