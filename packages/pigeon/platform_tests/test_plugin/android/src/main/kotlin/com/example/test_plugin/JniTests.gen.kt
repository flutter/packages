// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Autogenerated from Pigeon, do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

import androidx.annotation.Keep

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 *
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class JniTestsError(
    val code: String,
    override val message: String? = null,
    val details: Any? = null
) : Throwable()

private fun deepEqualsJniTests(a: Any?, b: Any?): Boolean {
  if (a is ByteArray && b is ByteArray) {
    return a.contentEquals(b)
  }
  if (a is IntArray && b is IntArray) {
    return a.contentEquals(b)
  }
  if (a is LongArray && b is LongArray) {
    return a.contentEquals(b)
  }
  if (a is DoubleArray && b is DoubleArray) {
    return a.contentEquals(b)
  }
  if (a is Array<*> && b is Array<*>) {
    return a.size == b.size && a.indices.all { deepEqualsJniTests(a[it], b[it]) }
  }
  if (a is Map<*, *> && b is Map<*, *>) {
    return a.size == b.size &&
        a.keys.all { (b as Map<Any?, Any?>).containsKey(it) && deepEqualsJniTests(a[it], b[it]) }
  }
  return a == b
}

enum class SomeEnum(val raw: Int) {
  VALUE1(0),
  VALUE2(1),
  VALUE3(2);

  companion object {
    fun ofRaw(raw: Int): SomeEnum? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class SomeOtherEnum(val raw: Int) {
  VALUE1(0),
  VALUE2(1),
  VALUE3(2);

  companion object {
    fun ofRaw(raw: Int): SomeOtherEnum? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SomeTypes(
    val aString: String,
    val anInt: Long,
    val aDouble: Double,
    val aBool: Boolean,
    val aByteArray: ByteArray,
    val a4ByteArray: IntArray,
    val a8ByteArray: LongArray,
    val aFloatArray: DoubleArray,
    val anObject: Any,
    val anEnum: SomeEnum,
    val someNullableTypes: SomeNullableTypes,
    val list: List<Any?>,
    val stringList: List<String>,
    val intList: List<Long>,
    val doubleList: List<Double>,
    val boolList: List<Boolean>,
    val enumList: List<SomeEnum>,
    val classList: List<SomeNullableTypes>,
    val objectList: List<Any>,
    val listList: List<List<Any?>>,
    val mapList: List<Map<Any?, Any?>>,
    val map: Map<Any, Any?>,
    val stringMap: Map<String, String>,
    val intMap: Map<Long, Long>,
    val enumMap: Map<SomeEnum, SomeEnum>,
    val classMap: Map<SomeNullableTypes, SomeNullableTypes>,
    val objectMap: Map<Any, Any>,
    val listMap: Map<Long, List<Any?>>,
    val mapMap: Map<Long, Map<Any?, Any?>>
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SomeTypes {
      val aString = pigeonVar_list[0] as String
      val anInt = pigeonVar_list[1] as Long
      val aDouble = pigeonVar_list[2] as Double
      val aBool = pigeonVar_list[3] as Boolean
      val aByteArray = pigeonVar_list[4] as ByteArray
      val a4ByteArray = pigeonVar_list[5] as IntArray
      val a8ByteArray = pigeonVar_list[6] as LongArray
      val aFloatArray = pigeonVar_list[7] as DoubleArray
      val anObject = pigeonVar_list[8] as Any
      val anEnum = pigeonVar_list[9] as SomeEnum
      val someNullableTypes = pigeonVar_list[10] as SomeNullableTypes
      val list = pigeonVar_list[11] as List<Any?>
      val stringList = pigeonVar_list[12] as List<String>
      val intList = pigeonVar_list[13] as List<Long>
      val doubleList = pigeonVar_list[14] as List<Double>
      val boolList = pigeonVar_list[15] as List<Boolean>
      val enumList = pigeonVar_list[16] as List<SomeEnum>
      val classList = pigeonVar_list[17] as List<SomeNullableTypes>
      val objectList = pigeonVar_list[18] as List<Any>
      val listList = pigeonVar_list[19] as List<List<Any?>>
      val mapList = pigeonVar_list[20] as List<Map<Any?, Any?>>
      val map = pigeonVar_list[21] as Map<Any, Any?>
      val stringMap = pigeonVar_list[22] as Map<String, String>
      val intMap = pigeonVar_list[23] as Map<Long, Long>
      val enumMap = pigeonVar_list[24] as Map<SomeEnum, SomeEnum>
      val classMap = pigeonVar_list[25] as Map<SomeNullableTypes, SomeNullableTypes>
      val objectMap = pigeonVar_list[26] as Map<Any, Any>
      val listMap = pigeonVar_list[27] as Map<Long, List<Any?>>
      val mapMap = pigeonVar_list[28] as Map<Long, Map<Any?, Any?>>
      return SomeTypes(
          aString,
          anInt,
          aDouble,
          aBool,
          aByteArray,
          a4ByteArray,
          a8ByteArray,
          aFloatArray,
          anObject,
          anEnum,
          someNullableTypes,
          list,
          stringList,
          intList,
          doubleList,
          boolList,
          enumList,
          classList,
          objectList,
          listList,
          mapList,
          map,
          stringMap,
          intMap,
          enumMap,
          classMap,
          objectMap,
          listMap,
          mapMap)
    }
  }

  fun toList(): List<Any?> {
    return listOf(
        aString,
        anInt,
        aDouble,
        aBool,
        aByteArray,
        a4ByteArray,
        a8ByteArray,
        aFloatArray,
        anObject,
        anEnum,
        someNullableTypes,
        list,
        stringList,
        intList,
        doubleList,
        boolList,
        enumList,
        classList,
        objectList,
        listList,
        mapList,
        map,
        stringMap,
        intMap,
        enumMap,
        classMap,
        objectMap,
        listMap,
        mapMap,
    )
  }

  override fun equals(other: Any?): Boolean {
    if (other !is SomeTypes) {
      return false
    }
    if (this === other) {
      return true
    }
    return aString == other.aString &&
        anInt == other.anInt &&
        aDouble == other.aDouble &&
        aBool == other.aBool &&
        deepEqualsJniTests(aByteArray, other.aByteArray) &&
        deepEqualsJniTests(a4ByteArray, other.a4ByteArray) &&
        deepEqualsJniTests(a8ByteArray, other.a8ByteArray) &&
        deepEqualsJniTests(aFloatArray, other.aFloatArray) &&
        anObject == other.anObject &&
        anEnum == other.anEnum &&
        someNullableTypes == other.someNullableTypes &&
        deepEqualsJniTests(list, other.list) &&
        deepEqualsJniTests(stringList, other.stringList) &&
        deepEqualsJniTests(intList, other.intList) &&
        deepEqualsJniTests(doubleList, other.doubleList) &&
        deepEqualsJniTests(boolList, other.boolList) &&
        deepEqualsJniTests(enumList, other.enumList) &&
        deepEqualsJniTests(classList, other.classList) &&
        deepEqualsJniTests(objectList, other.objectList) &&
        deepEqualsJniTests(listList, other.listList) &&
        deepEqualsJniTests(mapList, other.mapList) &&
        deepEqualsJniTests(map, other.map) &&
        deepEqualsJniTests(stringMap, other.stringMap) &&
        deepEqualsJniTests(intMap, other.intMap) &&
        deepEqualsJniTests(enumMap, other.enumMap) &&
        deepEqualsJniTests(classMap, other.classMap) &&
        deepEqualsJniTests(objectMap, other.objectMap) &&
        deepEqualsJniTests(listMap, other.listMap) &&
        deepEqualsJniTests(mapMap, other.mapMap)
  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SomeNullableTypes(
    val aString: String? = null,
    val anInt: Long? = null,
    val aDouble: Double? = null,
    val aBool: Boolean? = null,
    val aByteArray: ByteArray? = null,
    val a4ByteArray: IntArray? = null,
    val a8ByteArray: LongArray? = null,
    val aFloatArray: DoubleArray? = null,
    val anObject: Any? = null,
    val anEnum: SomeEnum? = null,
    val someTypes: SomeTypes? = null,
    val list: List<Any?>? = null,
    val map: Map<Any, Any?>? = null
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SomeNullableTypes {
      val aString = pigeonVar_list[0] as String?
      val anInt = pigeonVar_list[1] as Long?
      val aDouble = pigeonVar_list[2] as Double?
      val aBool = pigeonVar_list[3] as Boolean?
      val aByteArray = pigeonVar_list[4] as ByteArray?
      val a4ByteArray = pigeonVar_list[5] as IntArray?
      val a8ByteArray = pigeonVar_list[6] as LongArray?
      val aFloatArray = pigeonVar_list[7] as DoubleArray?
      val anObject = pigeonVar_list[8]
      val anEnum = pigeonVar_list[9] as SomeEnum?
      val someTypes = pigeonVar_list[10] as SomeTypes?
      val list = pigeonVar_list[11] as List<Any?>?
      val map = pigeonVar_list[12] as Map<Any, Any?>?
      return SomeNullableTypes(
          aString,
          anInt,
          aDouble,
          aBool,
          aByteArray,
          a4ByteArray,
          a8ByteArray,
          aFloatArray,
          anObject,
          anEnum,
          someTypes,
          list,
          map)
    }
  }

  fun toList(): List<Any?> {
    return listOf(
        aString,
        anInt,
        aDouble,
        aBool,
        aByteArray,
        a4ByteArray,
        a8ByteArray,
        aFloatArray,
        anObject,
        anEnum,
        someTypes,
        list,
        map,
    )
  }

  override fun equals(other: Any?): Boolean {
    if (other !is SomeNullableTypes) {
      return false
    }
    if (this === other) {
      return true
    }
    return aString == other.aString &&
        anInt == other.anInt &&
        aDouble == other.aDouble &&
        aBool == other.aBool &&
        deepEqualsJniTests(aByteArray, other.aByteArray) &&
        deepEqualsJniTests(a4ByteArray, other.a4ByteArray) &&
        deepEqualsJniTests(a8ByteArray, other.a8ByteArray) &&
        deepEqualsJniTests(aFloatArray, other.aFloatArray) &&
        anObject == other.anObject &&
        anEnum == other.anEnum &&
        someTypes == other.someTypes &&
        deepEqualsJniTests(list, other.list) &&
        deepEqualsJniTests(map, other.map)
  }

  override fun hashCode(): Int = toList().hashCode()
}

val JniMessageApiInstances: MutableMap<String, JniMessageApiRegistrar> = mutableMapOf()

@Keep
abstract class JniMessageApi {
  abstract fun doNothing()

  abstract fun echoString(request: String): String

  abstract fun echoInt(request: Long): Long

  abstract fun echoDouble(request: Double): Double

  abstract fun echoBool(request: Boolean): Boolean

  abstract fun echoObj(request: Any): Any

  abstract fun sendSomeTypes(someTypes: SomeTypes): SomeTypes

  abstract fun sendSomeEnum(anEnum: SomeEnum): SomeEnum

  abstract fun echoList(list: List<Any?>): List<Any?>

  abstract fun echoMap(map: Map<Any, Any?>): Map<Any, Any?>
}

@Keep
class JniMessageApiRegistrar : JniMessageApi() {
  var api: JniMessageApi? = null

  fun register(
      api: JniMessageApi,
      name: String = "PigeonDefaultClassName32uh4ui3lh445uh4h3l2l455g4y34u"
  ): JniMessageApiRegistrar {
    this.api = api
    JniMessageApiInstances[name] = this
    return this
  }

  @Keep
  fun getInstance(name: String): JniMessageApiRegistrar? {
    return JniMessageApiInstances[name]
  }

  override fun doNothing() {
    api?.let {
      try {
        return api!!.doNothing()
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApi has not been set")
  }

  override fun echoString(request: String): String {
    api?.let {
      try {
        return api!!.echoString(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApi has not been set")
  }

  override fun echoInt(request: Long): Long {
    api?.let {
      try {
        return api!!.echoInt(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApi has not been set")
  }

  override fun echoDouble(request: Double): Double {
    api?.let {
      try {
        return api!!.echoDouble(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApi has not been set")
  }

  override fun echoBool(request: Boolean): Boolean {
    api?.let {
      try {
        return api!!.echoBool(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApi has not been set")
  }

  override fun echoObj(request: Any): Any {
    api?.let {
      try {
        return api!!.echoObj(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApi has not been set")
  }

  override fun sendSomeTypes(someTypes: SomeTypes): SomeTypes {
    api?.let {
      try {
        return api!!.sendSomeTypes(someTypes)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApi has not been set")
  }

  override fun sendSomeEnum(anEnum: SomeEnum): SomeEnum {
    api?.let {
      try {
        return api!!.sendSomeEnum(anEnum)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApi has not been set")
  }

  override fun echoList(list: List<Any?>): List<Any?> {
    api?.let {
      try {
        return api!!.echoList(list)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApi has not been set")
  }

  override fun echoMap(map: Map<Any, Any?>): Map<Any, Any?> {
    api?.let {
      try {
        return api!!.echoMap(map)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApi has not been set")
  }
}

val JniMessageApiNullableInstances: MutableMap<String, JniMessageApiNullableRegistrar> =
    mutableMapOf()

@Keep
abstract class JniMessageApiNullable {
  abstract fun echoString(request: String?): String?

  abstract fun echoInt(request: Long?): Long?

  abstract fun echoDouble(request: Double?): Double?

  abstract fun echoBool(request: Boolean?): Boolean?

  abstract fun echoObj(request: Any?): Any?

  abstract fun sendSomeNullableTypes(someTypes: SomeNullableTypes?): SomeNullableTypes?

  abstract fun sendSomeEnum(anEnum: SomeEnum?): SomeEnum?

  abstract fun echoList(list: List<Any?>?): List<Any?>?

  abstract fun echoMap(map: Map<Any, Any?>?): Map<Any, Any?>?
}

@Keep
class JniMessageApiNullableRegistrar : JniMessageApiNullable() {
  var api: JniMessageApiNullable? = null

  fun register(
      api: JniMessageApiNullable,
      name: String = "PigeonDefaultClassName32uh4ui3lh445uh4h3l2l455g4y34u"
  ): JniMessageApiNullableRegistrar {
    this.api = api
    JniMessageApiNullableInstances[name] = this
    return this
  }

  @Keep
  fun getInstance(name: String): JniMessageApiNullableRegistrar? {
    return JniMessageApiNullableInstances[name]
  }

  override fun echoString(request: String?): String? {
    api?.let {
      try {
        return api!!.echoString(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullable has not been set")
  }

  override fun echoInt(request: Long?): Long? {
    api?.let {
      try {
        return api!!.echoInt(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullable has not been set")
  }

  override fun echoDouble(request: Double?): Double? {
    api?.let {
      try {
        return api!!.echoDouble(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullable has not been set")
  }

  override fun echoBool(request: Boolean?): Boolean? {
    api?.let {
      try {
        return api!!.echoBool(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullable has not been set")
  }

  override fun echoObj(request: Any?): Any? {
    api?.let {
      try {
        return api!!.echoObj(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullable has not been set")
  }

  override fun sendSomeNullableTypes(someTypes: SomeNullableTypes?): SomeNullableTypes? {
    api?.let {
      try {
        return api!!.sendSomeNullableTypes(someTypes)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullable has not been set")
  }

  override fun sendSomeEnum(anEnum: SomeEnum?): SomeEnum? {
    api?.let {
      try {
        return api!!.sendSomeEnum(anEnum)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullable has not been set")
  }

  override fun echoList(list: List<Any?>?): List<Any?>? {
    api?.let {
      try {
        return api!!.echoList(list)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullable has not been set")
  }

  override fun echoMap(map: Map<Any, Any?>?): Map<Any, Any?>? {
    api?.let {
      try {
        return api!!.echoMap(map)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullable has not been set")
  }
}

val JniMessageApiAsyncInstances: MutableMap<String, JniMessageApiAsyncRegistrar> = mutableMapOf()

@Keep
abstract class JniMessageApiAsync {
  abstract suspend fun doNothing()

  abstract suspend fun echoString(request: String): String

  abstract suspend fun echoInt(request: Long): Long

  abstract suspend fun echoDouble(request: Double): Double

  abstract suspend fun echoBool(request: Boolean): Boolean

  abstract suspend fun echoObj(request: Any): Any

  abstract suspend fun sendSomeTypes(someTypes: SomeTypes): SomeTypes

  abstract suspend fun sendSomeEnum(anEnum: SomeEnum): SomeEnum

  abstract suspend fun echoList(list: List<Any?>): List<Any?>

  abstract suspend fun echoMap(map: Map<Any, Any?>): Map<Any, Any?>
}

@Keep
class JniMessageApiAsyncRegistrar : JniMessageApiAsync() {
  var api: JniMessageApiAsync? = null

  fun register(
      api: JniMessageApiAsync,
      name: String = "PigeonDefaultClassName32uh4ui3lh445uh4h3l2l455g4y34u"
  ): JniMessageApiAsyncRegistrar {
    this.api = api
    JniMessageApiAsyncInstances[name] = this
    return this
  }

  @Keep
  fun getInstance(name: String): JniMessageApiAsyncRegistrar? {
    return JniMessageApiAsyncInstances[name]
  }

  override suspend fun doNothing() {
    api?.let {
      try {
        return api!!.doNothing()
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiAsync has not been set")
  }

  override suspend fun echoString(request: String): String {
    api?.let {
      try {
        return api!!.echoString(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiAsync has not been set")
  }

  override suspend fun echoInt(request: Long): Long {
    api?.let {
      try {
        return api!!.echoInt(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiAsync has not been set")
  }

  override suspend fun echoDouble(request: Double): Double {
    api?.let {
      try {
        return api!!.echoDouble(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiAsync has not been set")
  }

  override suspend fun echoBool(request: Boolean): Boolean {
    api?.let {
      try {
        return api!!.echoBool(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiAsync has not been set")
  }

  override suspend fun echoObj(request: Any): Any {
    api?.let {
      try {
        return api!!.echoObj(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiAsync has not been set")
  }

  override suspend fun sendSomeTypes(someTypes: SomeTypes): SomeTypes {
    api?.let {
      try {
        return api!!.sendSomeTypes(someTypes)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiAsync has not been set")
  }

  override suspend fun sendSomeEnum(anEnum: SomeEnum): SomeEnum {
    api?.let {
      try {
        return api!!.sendSomeEnum(anEnum)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiAsync has not been set")
  }

  override suspend fun echoList(list: List<Any?>): List<Any?> {
    api?.let {
      try {
        return api!!.echoList(list)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiAsync has not been set")
  }

  override suspend fun echoMap(map: Map<Any, Any?>): Map<Any, Any?> {
    api?.let {
      try {
        return api!!.echoMap(map)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiAsync has not been set")
  }
}

val JniMessageApiNullableAsyncInstances: MutableMap<String, JniMessageApiNullableAsyncRegistrar> =
    mutableMapOf()

@Keep
abstract class JniMessageApiNullableAsync {
  abstract suspend fun echoString(request: String?): String?

  abstract suspend fun echoInt(request: Long?): Long?

  abstract suspend fun echoDouble(request: Double?): Double?

  abstract suspend fun echoBool(request: Boolean?): Boolean?

  abstract suspend fun echoObj(request: Any?): Any?

  abstract suspend fun sendSomeNullableTypes(someTypes: SomeNullableTypes?): SomeNullableTypes?

  abstract suspend fun sendSomeEnum(anEnum: SomeEnum?): SomeEnum?

  abstract suspend fun echoList(list: List<Any?>?): List<Any?>?

  abstract suspend fun echoMap(map: Map<Any, Any?>?): Map<Any, Any?>?
}

@Keep
class JniMessageApiNullableAsyncRegistrar : JniMessageApiNullableAsync() {
  var api: JniMessageApiNullableAsync? = null

  fun register(
      api: JniMessageApiNullableAsync,
      name: String = "PigeonDefaultClassName32uh4ui3lh445uh4h3l2l455g4y34u"
  ): JniMessageApiNullableAsyncRegistrar {
    this.api = api
    JniMessageApiNullableAsyncInstances[name] = this
    return this
  }

  @Keep
  fun getInstance(name: String): JniMessageApiNullableAsyncRegistrar? {
    return JniMessageApiNullableAsyncInstances[name]
  }

  override suspend fun echoString(request: String?): String? {
    api?.let {
      try {
        return api!!.echoString(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullableAsync has not been set")
  }

  override suspend fun echoInt(request: Long?): Long? {
    api?.let {
      try {
        return api!!.echoInt(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullableAsync has not been set")
  }

  override suspend fun echoDouble(request: Double?): Double? {
    api?.let {
      try {
        return api!!.echoDouble(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullableAsync has not been set")
  }

  override suspend fun echoBool(request: Boolean?): Boolean? {
    api?.let {
      try {
        return api!!.echoBool(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullableAsync has not been set")
  }

  override suspend fun echoObj(request: Any?): Any? {
    api?.let {
      try {
        return api!!.echoObj(request)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullableAsync has not been set")
  }

  override suspend fun sendSomeNullableTypes(someTypes: SomeNullableTypes?): SomeNullableTypes? {
    api?.let {
      try {
        return api!!.sendSomeNullableTypes(someTypes)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullableAsync has not been set")
  }

  override suspend fun sendSomeEnum(anEnum: SomeEnum?): SomeEnum? {
    api?.let {
      try {
        return api!!.sendSomeEnum(anEnum)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullableAsync has not been set")
  }

  override suspend fun echoList(list: List<Any?>?): List<Any?>? {
    api?.let {
      try {
        return api!!.echoList(list)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullableAsync has not been set")
  }

  override suspend fun echoMap(map: Map<Any, Any?>?): Map<Any, Any?>? {
    api?.let {
      try {
        return api!!.echoMap(map)
      } catch (e: Exception) {
        throw e
      }
    }
    error("JniMessageApiNullableAsync has not been set")
  }
}
