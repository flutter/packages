// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Autogenerated from Pigeon, do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

/// Error class for passing custom error details to Dart side.
@objc final class NiTestsError: NSObject, Error {
  @objc var code: String?
  @objc var message: String?
  @objc var details: String?

  @objc override init() {}

  @objc init(code: String?, message: String?, details: String?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "NiTestsError(code: \(code ?? "<nil>"), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

@objc class NSNumberWrapper: NSObject {
  @objc init(
    number: NSNumber,
    type: Int,
  ) {
    self.number = number
    self.type = type
  }
  @objc var number: NSNumber
  @objc var type: Int
}

private func wrapNumber(number: NSNumber, type: Int) -> NSNumberWrapper {
  return NSNumberWrapper(number: number, type: type)
}

private func unwrapNumber<T>(wrappedNumber: NSNumberWrapper) -> T {
  switch wrappedNumber.type {
  case 1:
    return wrappedNumber.number.intValue as! T
  case 2:
    return wrappedNumber.number.doubleValue as! T
  case 3:
    return wrappedNumber.number.boolValue as! T
  case 4:
    return NIAnEnum(rawValue: wrappedNumber.number.intValue) as! T
  default:
    return wrappedNumber.number.intValue as! T
  }
}

private func numberCodec(number: Any) -> Int {
  switch number {
  case _ as Int:
    return 1
  case _ as Double:
    return 2
  case _ as Float:
    return 2
  case _ as Bool:
    return 3
  case _ as NIAnEnum:
    return 4
  default:
    return 0
  }
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

@objc enum NIAnEnum: Int {
  case one = 0
  case two = 1
  case three = 2
  case fortyTwo = 3
  case fourHundredTwentyTwo = 4
}

/// A class containing all supported types.
///
/// Generated class from Pigeon that represents data sent in messages.
@objc class NIAllTypes: NSObject {
  @objc init(
    aBool: Bool,
    anInt: Int64,
    anInt64: Int64,
    aDouble: Double,
    anEnum: NIAnEnum,
    aString: String,
    list: [Any],
    map: [AnyHashable: Any]
  ) {
    self.aBool = aBool
    self.anInt = anInt
    self.anInt64 = anInt64
    self.aDouble = aDouble
    self.anEnum = anEnum
    self.aString = aString
    self.list = list
    self.map = map
  }
  @objc var aBool: Bool
  @objc var anInt: Int64
  @objc var anInt64: Int64
  @objc var aDouble: Double
  @objc var anEnum: NIAnEnum
  @objc var aString: String
  @objc var list: [Any]
  @objc var map: [AnyHashable: Any]

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NIAllTypes? {
    let aBool = pigeonVar_list[0] as! Bool
    let anInt = pigeonVar_list[1] as! Int64
    let anInt64 = pigeonVar_list[2] as! Int64
    let aDouble = pigeonVar_list[3] as! Double
    let anEnum = pigeonVar_list[4] as! NIAnEnum
    let aString = pigeonVar_list[5] as! String
    let list = pigeonVar_list[6] as! [Any]
    let map = pigeonVar_list[7] as! [AnyHashable: Any]

    return NIAllTypes(
      aBool: aBool,
      anInt: anInt,
      anInt64: anInt64,
      aDouble: aDouble,
      anEnum: anEnum,
      aString: aString,
      list: list,
      map: map
    )
  }
  func toList() -> [Any?] {
    return [
      aBool,
      anInt,
      anInt64,
      aDouble,
      anEnum,
      aString,
      list,
      map,
    ]
  }
}

@available(iOS 13, macOS 16.0.0, *)
class _PigeonFfiCodec {
  static func readValue(value: NSObject?, type: String?) -> Any? {
    if isNullish(value) {
      return nil
    }
    if value is NSNumber {
      if type == "int" {
        return (value as! NSNumber).intValue
      } else if type == "double" {
        return (value as! NSNumber).doubleValue
      } else if type == "bool" {
        return (value as! NSNumber) == 1
      } else if type == "NIAnEnum" {
        return NIAnEnum.init(rawValue: (value as! NSNumber).intValue)
      }
    }
    // } else if (value.isA<NSByteArray>(NSByteArray.type)) {
    //   final Uint8List list = Uint8List(value.as(NSByteArray.type).length)
    //   for (int i = 0; i < value.as(NSByteArray.type).length; i++) {
    //     list[i] = value.as(NSByteArray.type)[i]
    //   }
    //   return list
    // } else if (value.isA<NSIntArray>(NSIntArray.type)) {
    //   final Int32List list = Int32List(value.as(NSIntArray.type).length)
    //   for (int i = 0; i < value.as(NSIntArray.type).length; i++) {
    //     list[i] = value.as(NSIntArray.type)[i]
    //   }
    //   return list
    //   // } else if (value.isA<NSLongArray>(NSLongArray.type)) {
    //   final Int64List list = Int64List(value.as(NSLongArray.type).length)
    //   //   for (int i = 0; i < value.as(NSLongArray.type).length; i++) {
    //     list[i] = value.as(NSLongArray.type)[i]
    //   //   }
    //   return list
    //   // } else if (value.isA<NSDoubleArray>(NSDoubleArray.type)) {
    //   final Float64List list = Float64List(value.as(NSDoubleArray.type).length)
    //   //   for (int i = 0; i < value.as(NSDoubleArray.type).length; i++) {
    //     list[i] = value.as(NSDoubleArray.type)[i]
    //   //   }
    //   return list
    if value is NSMutableArray || value is NSArray {
      var res: [Any?] = []
      for i in 0..<(value as! NSMutableArray).count {
        res.append(readValue(value: (value as! NSMutableArray)[i] as? NSObject, type: nil))
      }
      return res
    }
    if value is NSDictionary {
      var res: [AnyHashable?: Any?] = Dictionary()
      for (key, value) in (value as! NSDictionary) {
        res[readValue(value: key as? NSObject, type: nil) as? AnyHashable] = readValue(
          value: value as? NSObject, type: nil)
      }
      return res
    }
    if value is NSNumberWrapper {
      return unwrapNumber(wrappedNumber: value as! NSNumberWrapper)
    }
    if value is NSString {
      return value as! NSString
    }
    return value
  }

  static func writeValue(value: Any?, isObject: Bool = false) -> Any? {
    if isNullish(value) {
      return nil
    }
    if value is Bool || value is Double || value is Int || value is NIAnEnum {
      if isObject {
        return wrapNumber(number: value as! NSNumber, type: numberCodec(number: value!))
      }
      if value is Bool {
        return (value as! Bool) ? 1 : 0
      } else if value is Double {
        return value
      } else if value is Int {
        return value
      } else if value is NIAnEnum {
        return (value as! NIAnEnum).rawValue
      }
    }
    // } else if (isTypeOrNullableType<NSByteArray>(T)) {
    //   value as List<int>
    //   final NSByteArray array = NSByteArray(value.length)
    //   for (int i = 0; i < value.length; i++) {
    //     array[i] = value[i]
    //   }
    //   return array
    // } else if (isTypeOrNullableType<NSIntArray>(T)) {
    //   value as List<int>
    //   final NSIntArray array = NSIntArray(value.length)
    //   for (int i = 0; i < value.length; i++) {
    //     array[i] = value[i]
    //   }
    //   return array
    // } else if (isTypeOrNullableType<NSLongArray>(T)) {
    //   value as List<int>
    //   final NSLongArray array = NSLongArray(value.length)
    //   for (int i = 0; i < value.length; i++) {
    //     array[i] = value[i]
    //   }
    //   return array
    // } else if (isTypeOrNullableType<NSDoubleArray>(T)) {
    //   value as List<double>
    //   final NSDoubleArray array = NSDoubleArray(value.length)
    //   for (int i = 0; i < value.length; i++) {
    //     array[i] = value[i]
    //   }
    //   return array
    if value is [Any] {
      let res: NSMutableArray = NSMutableArray()
      for i in 0..<(value as! NSMutableArray).count {
        res.add(writeValue(value: (value as! NSMutableArray)[i]) as! NSObject)
      }
      return res
    }
    if value is [AnyHashable: Any] {
      let res: NSMutableDictionary = NSMutableDictionary()
      for (key, value) in (value as! NSDictionary) {
        res.setObject(
          writeValue(value: value) as! NSObject, forKey: writeValue(value: key) as! NSCopying)
      }
      return res
    }
    if value is String {
      return value as! NSString
    }
    return value
  }
}

let defaultInstanceName = "PigeonDefaultClassName32uh4ui3lh445uh4h3l2l455g4y34u"
var instancesOfNIHostIntegrationCoreApi = [String: NIHostIntegrationCoreApiSetup?]()
/// The core interface that each host language plugin must implement in
/// platform_test integration tests.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol NIHostIntegrationCoreApi {
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  func noop() throws
  /// Returns the passed object, to test serialization and deserialization.
  func echoAllTypes(everything: NIAllTypes) throws -> NIAllTypes
  /// Returns passed in int.
  func echoInt(anInt: Int64) throws -> Int64
  /// Returns passed in double.
  func echoDouble(aDouble: Double) throws -> Double
  /// Returns the passed in boolean.
  func echoBool(aBool: Bool) throws -> Bool
  /// Returns the passed in string.
  func echoString(aString: String) throws -> String
  /// Returns the passed in generic Object.
  func echoObject(anObject: Any) throws -> Any
  /// Returns the passed list, to test serialization and deserialization.
  func echoList(list: [Any]) throws -> [Any]
  /// Returns the passed map, to test serialization and deserialization.
  func echoMap(map: [AnyHashable: Any]) throws -> [AnyHashable: Any]
  /// Returns the passed enum to test serialization and deserialization.
  func echoEnum(anEnum: NIAnEnum) throws -> NIAnEnum
}

/// Generated setup class from Pigeon to register implemented NIHostIntegrationCoreApi classes.
@objc class NIHostIntegrationCoreApiSetup: NSObject {
  private var api: NIHostIntegrationCoreApi?
  override init() {}
  static func register(api: NIHostIntegrationCoreApi?, name: String = defaultInstanceName) {
    let wrapper = NIHostIntegrationCoreApiSetup()
    wrapper.api = api
    instancesOfNIHostIntegrationCoreApi[name] = wrapper
  }
  @objc static func getInstance(name: String) -> NIHostIntegrationCoreApiSetup? {
    return instancesOfNIHostIntegrationCoreApi[name] ?? nil
  }
  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func noop(wrappedError: NiTestsError) {
    do {
      return try api!.noop()
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return
  }
  /// Returns the passed object, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoAllTypes(everything: NIAllTypes, wrappedError: NiTestsError) -> NIAllTypes? {
    do {
      return try api!.echoAllTypes(everything: everything)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns passed in int.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoInt(anInt: NSNumber, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try api!.echoInt(anInt: anInt.int64Value) as NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns passed in double.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoDouble(aDouble: NSNumber, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try api!.echoDouble(aDouble: aDouble.doubleValue) as NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in boolean.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoBool(aBool: NSNumber, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try api!.echoBool(aBool: aBool.boolValue) as NSNumber
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in string.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoString(aString: String, wrappedError: NiTestsError) -> String? {
    do {
      return try api!.echoString(aString: aString)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed in generic Object.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoObject(anObject: Any, wrappedError: NiTestsError) -> Any? {
    do {
      return try _PigeonFfiCodec.writeValue(
        value: api!.echoObject(
          anObject: _PigeonFfiCodec.readValue(value: anObject as? NSObject, type: nil) as Any),
        isObject: true)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed list, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoList(list: [NSObject], wrappedError: NiTestsError) -> [NSObject]? {
    do {
      return try api!.echoList(list: list) as? [NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed map, to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoMap(map: [NSObject: NSObject], wrappedError: NiTestsError) -> [NSObject: NSObject]?
  {
    do {
      return try api!.echoMap(map: map) as? [NSObject: NSObject]
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
  /// Returns the passed enum to test serialization and deserialization.
  @available(iOS 13, macOS 16.0.0, *)
  @objc func echoEnum(anEnum: NIAnEnum, wrappedError: NiTestsError) -> NSNumber? {
    do {
      return try NSNumber(value: api!.echoEnum(anEnum: anEnum).rawValue)
    } catch let error as NiTestsError {
      wrappedError.code = error.code
      wrappedError.message = error.message
      wrappedError.details = error.details
    } catch let error {
      wrappedError.code = "\(error)"
      wrappedError.message = "\(type(of: error))"
      wrappedError.details = "Stacktrace: \(Thread.callStackSymbols)"
    }
    return nil
  }
}
