// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `JniHostIntegrationCoreApi`
class JniHostIntegrationCoreApi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniHostIntegrationCoreApi> $type;

  @jni$_.internal
  JniHostIntegrationCoreApi.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniHostIntegrationCoreApi');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniHostIntegrationCoreApi$NullableType();
  static const type = $JniHostIntegrationCoreApi$Type();
  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }

  static final _id_echoAllTypes = _class.instanceMethodId(
    r'echoAllTypes',
    r'(LJniAllTypes;)LJniAllTypes;',
  );

  static final _echoAllTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllTypes echoAllTypes(JniAllTypes jniAllTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes echoAllTypes(
    JniAllTypes jniAllTypes,
  ) {
    final _$jniAllTypes = jniAllTypes.reference;
    return _echoAllTypes(reference.pointer,
            _id_echoAllTypes as jni$_.JMethodIDPtr, _$jniAllTypes.pointer)
        .object<JniAllTypes>(const $JniAllTypes$Type());
  }

  static final _id_throwError = _class.instanceMethodId(
    r'throwError',
    r'()Ljava/lang/Object;',
  );

  static final _throwError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.Object throwError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwError() {
    return _throwError(reference.pointer, _id_throwError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_throwErrorFromVoid = _class.instanceMethodId(
    r'throwErrorFromVoid',
    r'()V',
  );

  static final _throwErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void throwErrorFromVoid()`
  void throwErrorFromVoid() {
    _throwErrorFromVoid(
            reference.pointer, _id_throwErrorFromVoid as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_throwFlutterError = _class.instanceMethodId(
    r'throwFlutterError',
    r'()Ljava/lang/Object;',
  );

  static final _throwFlutterError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.Object throwFlutterError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwFlutterError() {
    return _throwFlutterError(
            reference.pointer, _id_throwFlutterError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_echoInt = _class.instanceMethodId(
    r'echoInt',
    r'(J)J',
  );

  static final _echoInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract long echoInt(long j)`
  int echoInt(
    int j,
  ) {
    return _echoInt(reference.pointer, _id_echoInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoDouble = _class.instanceMethodId(
    r'echoDouble',
    r'(D)D',
  );

  static final _echoDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public abstract double echoDouble(double d)`
  double echoDouble(
    double d,
  ) {
    return _echoDouble(
            reference.pointer, _id_echoDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoBool = _class.instanceMethodId(
    r'echoBool',
    r'(Z)Z',
  );

  static final _echoBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract boolean echoBool(boolean z)`
  bool echoBool(
    bool z,
  ) {
    return _echoBool(
            reference.pointer, _id_echoBool as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_echoString = _class.instanceMethodId(
    r'echoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoString(reference.pointer, _id_echoString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoUint8List = _class.instanceMethodId(
    r'echoUint8List',
    r'([B)[B',
  );

  static final _echoUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] echoUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray echoUint8List(
    jni$_.JByteArray bs,
  ) {
    final _$bs = bs.reference;
    return _echoUint8List(reference.pointer,
            _id_echoUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_echoInt32List = _class.instanceMethodId(
    r'echoInt32List',
    r'([I)[I',
  );

  static final _echoInt32List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract int[] echoInt32List(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray echoInt32List(
    jni$_.JIntArray is$,
  ) {
    final _$is$ = is$.reference;
    return _echoInt32List(reference.pointer,
            _id_echoInt32List as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<jni$_.JIntArray>(const jni$_.JIntArrayType());
  }

  static final _id_echoInt64List = _class.instanceMethodId(
    r'echoInt64List',
    r'([J)[J',
  );

  static final _echoInt64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract long[] echoInt64List(long[] js)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray echoInt64List(
    jni$_.JLongArray js,
  ) {
    final _$js = js.reference;
    return _echoInt64List(reference.pointer,
            _id_echoInt64List as jni$_.JMethodIDPtr, _$js.pointer)
        .object<jni$_.JLongArray>(const jni$_.JLongArrayType());
  }

  static final _id_echoFloat64List = _class.instanceMethodId(
    r'echoFloat64List',
    r'([D)[D',
  );

  static final _echoFloat64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract double[] echoFloat64List(double[] ds)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray echoFloat64List(
    jni$_.JDoubleArray ds,
  ) {
    final _$ds = ds.reference;
    return _echoFloat64List(reference.pointer,
            _id_echoFloat64List as jni$_.JMethodIDPtr, _$ds.pointer)
        .object<jni$_.JDoubleArray>(const jni$_.JDoubleArrayType());
  }

  static final _id_echoObject = _class.instanceMethodId(
    r'echoObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoObject = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoObject(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject echoObject(
    jni$_.JObject object,
  ) {
    final _$object = object.reference;
    return _echoObject(reference.pointer, _id_echoObject as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_echoList = _class.instanceMethodId(
    r'echoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> echoList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> echoList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _echoList(reference.pointer, _id_echoList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_echoEnumList = _class.instanceMethodId(
    r'echoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> echoEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?> echoEnumList(
    jni$_.JList<JniAnEnum?> list,
  ) {
    final _$list = list.reference;
    return _echoEnumList(reference.pointer,
            _id_echoEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>>(
            const jni$_.JListType<JniAnEnum?>($JniAnEnum$NullableType()));
  }

  static final _id_echoClassList = _class.instanceMethodId(
    r'echoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> echoClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?> echoClassList(
    jni$_.JList<JniAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _echoClassList(reference.pointer,
            _id_echoClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>>(
            const jni$_.JListType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullEnumList = _class.instanceMethodId(
    r'echoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> echoNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum> echoNonNullEnumList(
    jni$_.JList<JniAnEnum> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullEnumList(reference.pointer,
            _id_echoNonNullEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum>>(
            const jni$_.JListType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_echoNonNullClassList = _class.instanceMethodId(
    r'echoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> echoNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes> echoNonNullClassList(
    jni$_.JList<JniAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullClassList(reference.pointer,
            _id_echoNonNullClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>>(
            const jni$_.JListType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_echoMap = _class.instanceMethodId(
    r'echoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> echoMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _echoMap(
            reference.pointer, _id_echoMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoStringMap = _class.instanceMethodId(
    r'echoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _echoStringMap(reference.pointer,
            _id_echoStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoIntMap = _class.instanceMethodId(
    r'echoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _echoIntMap(reference.pointer, _id_echoIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
            const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoEnumMap = _class.instanceMethodId(
    r'echoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> echoEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?> echoEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _echoEnumMap(reference.pointer,
            _id_echoEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>>(
            const jni$_.JMapType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_echoClassMap = _class.instanceMethodId(
    r'echoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> echoClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> echoClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _echoClassMap(reference.pointer,
            _id_echoClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullStringMap = _class.instanceMethodId(
    r'echoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullStringMap(reference.pointer,
            _id_echoNonNullStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNonNullIntMap = _class.instanceMethodId(
    r'echoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullIntMap(reference.pointer,
            _id_echoNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNonNullEnumMap = _class.instanceMethodId(
    r'echoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> echoNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum> echoNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullEnumMap(reference.pointer,
            _id_echoNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>>(
            const jni$_.JMapType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_echoNonNullClassMap = _class.instanceMethodId(
    r'echoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> echoNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes> echoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullClassMap(reference.pointer,
            _id_echoNonNullClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>>(
            const jni$_.JMapType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_echoClassWrapper = _class.instanceMethodId(
    r'echoClassWrapper',
    r'(LJniAllClassesWrapper;)LJniAllClassesWrapper;',
  );

  static final _echoClassWrapper = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllClassesWrapper echoClassWrapper(JniAllClassesWrapper jniAllClassesWrapper)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllClassesWrapper echoClassWrapper(
    JniAllClassesWrapper jniAllClassesWrapper,
  ) {
    final _$jniAllClassesWrapper = jniAllClassesWrapper.reference;
    return _echoClassWrapper(
            reference.pointer,
            _id_echoClassWrapper as jni$_.JMethodIDPtr,
            _$jniAllClassesWrapper.pointer)
        .object<JniAllClassesWrapper>(const $JniAllClassesWrapper$Type());
  }

  static final _id_echoEnum = _class.instanceMethodId(
    r'echoEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _echoEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnEnum echoEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum echoEnum(
    JniAnEnum jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum.reference;
    return _echoEnum(reference.pointer, _id_echoEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer)
        .object<JniAnEnum>(const $JniAnEnum$Type());
  }

  static final _id_echoAnotherEnum = _class.instanceMethodId(
    r'echoAnotherEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _echoAnotherEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnotherEnum echoAnotherEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum echoAnotherEnum(
    JniAnotherEnum jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    return _echoAnotherEnum(reference.pointer,
            _id_echoAnotherEnum as jni$_.JMethodIDPtr, _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum>(const $JniAnotherEnum$Type());
  }

  static final _id_echoNamedDefaultString = _class.instanceMethodId(
    r'echoNamedDefaultString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNamedDefaultString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoNamedDefaultString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoNamedDefaultString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoNamedDefaultString(reference.pointer,
            _id_echoNamedDefaultString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoOptionalDefaultDouble = _class.instanceMethodId(
    r'echoOptionalDefaultDouble',
    r'(D)D',
  );

  static final _echoOptionalDefaultDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public abstract double echoOptionalDefaultDouble(double d)`
  double echoOptionalDefaultDouble(
    double d,
  ) {
    return _echoOptionalDefaultDouble(reference.pointer,
            _id_echoOptionalDefaultDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoRequiredInt = _class.instanceMethodId(
    r'echoRequiredInt',
    r'(J)J',
  );

  static final _echoRequiredInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract long echoRequiredInt(long j)`
  int echoRequiredInt(
    int j,
  ) {
    return _echoRequiredInt(
            reference.pointer, _id_echoRequiredInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoAllNullableTypes = _class.instanceMethodId(
    r'echoAllNullableTypes',
    r'(LJniAllNullableTypes;)LJniAllNullableTypes;',
  );

  static final _echoAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypes echoAllNullableTypes(JniAllNullableTypes jniAllNullableTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes? echoAllNullableTypes(
    JniAllNullableTypes? jniAllNullableTypes,
  ) {
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypes(
            reference.pointer,
            _id_echoAllNullableTypes as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer)
        .object<JniAllNullableTypes?>(
            const $JniAllNullableTypes$NullableType());
  }

  static final _id_echoAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoAllNullableTypesWithoutRecursion',
    r'(LJniAllNullableTypesWithoutRecursion;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _echoAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypesWithoutRecursion echoAllNullableTypesWithoutRecursion(JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion? echoAllNullableTypesWithoutRecursion(
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
  ) {
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$jniAllNullableTypesWithoutRecursion.pointer)
        .object<JniAllNullableTypesWithoutRecursion?>(
            const $JniAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_extractNestedNullableString = _class.instanceMethodId(
    r'extractNestedNullableString',
    r'(LJniAllClassesWrapper;)Ljava/lang/String;',
  );

  static final _extractNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String extractNestedNullableString(JniAllClassesWrapper jniAllClassesWrapper)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? extractNestedNullableString(
    JniAllClassesWrapper jniAllClassesWrapper,
  ) {
    final _$jniAllClassesWrapper = jniAllClassesWrapper.reference;
    return _extractNestedNullableString(
            reference.pointer,
            _id_extractNestedNullableString as jni$_.JMethodIDPtr,
            _$jniAllClassesWrapper.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_createNestedNullableString = _class.instanceMethodId(
    r'createNestedNullableString',
    r'(Ljava/lang/String;)LJniAllClassesWrapper;',
  );

  static final _createNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllClassesWrapper createNestedNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllClassesWrapper createNestedNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createNestedNullableString(
            reference.pointer,
            _id_createNestedNullableString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<JniAllClassesWrapper>(const $JniAllClassesWrapper$Type());
  }

  static final _id_sendMultipleNullableTypes = _class.instanceMethodId(
    r'sendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypes;',
  );

  static final _sendMultipleNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypes sendMultipleNullableTypes(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes sendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypes(
            reference.pointer,
            _id_sendMultipleNullableTypes as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_sendMultipleNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'sendMultipleNullableTypesWithoutRecursion',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _sendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypesWithoutRecursion(
            reference.pointer,
            _id_sendMultipleNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypesWithoutRecursion>(
            const $JniAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_echoNullableInt = _class.instanceMethodId(
    r'echoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Long echoNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoNullableInt(reference.pointer,
            _id_echoNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNullableDouble = _class.instanceMethodId(
    r'echoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _echoNullableDouble = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Double echoNullableDouble(java.lang.Double double)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? echoNullableDouble(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _echoNullableDouble(reference.pointer,
            _id_echoNullableDouble as jni$_.JMethodIDPtr, _$double.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_echoNullableBool = _class.instanceMethodId(
    r'echoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _echoNullableBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Boolean echoNullableBool(java.lang.Boolean boolean)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? echoNullableBool(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _echoNullableBool(reference.pointer,
            _id_echoNullableBool as jni$_.JMethodIDPtr, _$boolean.pointer)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_echoNullableString = _class.instanceMethodId(
    r'echoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNullableString(reference.pointer,
            _id_echoNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_echoNullableUint8List = _class.instanceMethodId(
    r'echoNullableUint8List',
    r'([B)[B',
  );

  static final _echoNullableUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] echoNullableUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? echoNullableUint8List(
    jni$_.JByteArray? bs,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _echoNullableUint8List(reference.pointer,
            _id_echoNullableUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_echoNullableInt32List = _class.instanceMethodId(
    r'echoNullableInt32List',
    r'([I)[I',
  );

  static final _echoNullableInt32List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract int[] echoNullableInt32List(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? echoNullableInt32List(
    jni$_.JIntArray? is$,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _echoNullableInt32List(reference.pointer,
            _id_echoNullableInt32List as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_echoNullableInt64List = _class.instanceMethodId(
    r'echoNullableInt64List',
    r'([J)[J',
  );

  static final _echoNullableInt64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract long[] echoNullableInt64List(long[] js)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? echoNullableInt64List(
    jni$_.JLongArray? js,
  ) {
    final _$js = js?.reference ?? jni$_.jNullReference;
    return _echoNullableInt64List(reference.pointer,
            _id_echoNullableInt64List as jni$_.JMethodIDPtr, _$js.pointer)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_echoNullableFloat64List = _class.instanceMethodId(
    r'echoNullableFloat64List',
    r'([D)[D',
  );

  static final _echoNullableFloat64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract double[] echoNullableFloat64List(double[] ds)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? echoNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    return _echoNullableFloat64List(reference.pointer,
            _id_echoNullableFloat64List as jni$_.JMethodIDPtr, _$ds.pointer)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_echoNullableObject = _class.instanceMethodId(
    r'echoNullableObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoNullableObject = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoNullableObject(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? echoNullableObject(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _echoNullableObject(reference.pointer,
            _id_echoNullableObject as jni$_.JMethodIDPtr, _$object.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_echoNullableList = _class.instanceMethodId(
    r'echoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> echoNullableList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? echoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableList(reference.pointer,
            _id_echoNullableList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableEnumList = _class.instanceMethodId(
    r'echoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> echoNullableEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? echoNullableEnumList(
    jni$_.JList<JniAnEnum?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumList(reference.pointer,
            _id_echoNullableEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_echoNullableClassList = _class.instanceMethodId(
    r'echoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> echoNullableClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?>? echoNullableClassList(
    jni$_.JList<JniAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableClassList(reference.pointer,
            _id_echoNullableClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>?>(
            const jni$_.JListNullableType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullEnumList = _class.instanceMethodId(
    r'echoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> echoNullableNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum>? echoNullableNonNullEnumList(
    jni$_.JList<JniAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumList(
            reference.pointer,
            _id_echoNullableNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAnEnum>?>(
            const jni$_.JListNullableType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassList = _class.instanceMethodId(
    r'echoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> echoNullableNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes>? echoNullableNonNullClassList(
    jni$_.JList<JniAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassList(
            reference.pointer,
            _id_echoNullableNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>?>(
            const jni$_.JListNullableType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_echoNullableMap = _class.instanceMethodId(
    r'echoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> echoNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableMap(reference.pointer,
            _id_echoNullableMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableStringMap = _class.instanceMethodId(
    r'echoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableStringMap(reference.pointer,
            _id_echoNullableStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoNullableIntMap = _class.instanceMethodId(
    r'echoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableIntMap(reference.pointer,
            _id_echoNullableIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoNullableEnumMap = _class.instanceMethodId(
    r'echoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> echoNullableEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? echoNullableEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumMap(reference.pointer,
            _id_echoNullableEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_echoNullableClassMap = _class.instanceMethodId(
    r'echoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> echoNullableClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? echoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableClassMap(reference.pointer,
            _id_echoNullableClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullStringMap = _class.instanceMethodId(
    r'echoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNullableNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullStringMap(
            reference.pointer,
            _id_echoNullableNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNullableNonNullIntMap = _class.instanceMethodId(
    r'echoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNullableNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullIntMap(reference.pointer,
            _id_echoNullableNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
            const jni$_.JMapNullableType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNullableNonNullEnumMap = _class.instanceMethodId(
    r'echoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> echoNullableNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum>? echoNullableNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumMap(reference.pointer,
            _id_echoNullableNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>?>(
            const jni$_.JMapNullableType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassMap = _class.instanceMethodId(
    r'echoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> echoNullableNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? echoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassMap(
            reference.pointer,
            _id_echoNullableNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>?>(
            const jni$_.JMapNullableType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_echoNullableEnum = _class.instanceMethodId(
    r'echoNullableEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _echoNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnEnum echoNullableEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? echoNullableEnum(
    JniAnEnum? jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    return _echoNullableEnum(reference.pointer,
            _id_echoNullableEnum as jni$_.JMethodIDPtr, _$jniAnEnum.pointer)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_echoAnotherNullableEnum = _class.instanceMethodId(
    r'echoAnotherNullableEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _echoAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnotherEnum echoAnotherNullableEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? echoAnotherNullableEnum(
    JniAnotherEnum? jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    return _echoAnotherNullableEnum(
            reference.pointer,
            _id_echoAnotherNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_echoOptionalNullableInt = _class.instanceMethodId(
    r'echoOptionalNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoOptionalNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Long echoOptionalNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoOptionalNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoOptionalNullableInt(reference.pointer,
            _id_echoOptionalNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNamedNullableString = _class.instanceMethodId(
    r'echoNamedNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNamedNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoNamedNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNamedNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNamedNullableString(reference.pointer,
            _id_echoNamedNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_noopAsync = _class.instanceMethodId(
    r'noopAsync',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _noopAsync = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object noopAsync(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> noopAsync() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _noopAsync(reference.pointer,
            _id_noopAsync as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt = _class.instanceMethodId(
    r'echoAsyncInt',
    r'(JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncInt(long j, kotlin.coroutines.Continuation<? super java.lang.Long> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong> echoAsyncInt(
    int j,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncInt(reference.pointer,
            _id_echoAsyncInt as jni$_.JMethodIDPtr, j, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLong>(
      const jni$_.JLongType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncDouble = _class.instanceMethodId(
    r'echoAsyncDouble',
    r'(DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, double, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncDouble(double d, kotlin.coroutines.Continuation<? super java.lang.Double> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble> echoAsyncDouble(
    double d,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncDouble(
            reference.pointer,
            _id_echoAsyncDouble as jni$_.JMethodIDPtr,
            d,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDouble>(
      const jni$_.JDoubleType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncBool = _class.instanceMethodId(
    r'echoAsyncBool',
    r'(ZLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncBool(boolean z, kotlin.coroutines.Continuation<? super java.lang.Boolean> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean> echoAsyncBool(
    bool z,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncBool(
            reference.pointer,
            _id_echoAsyncBool as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JBoolean>(
      const jni$_.JBooleanType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncString = _class.instanceMethodId(
    r'echoAsyncString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncString(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echoAsyncString(
    jni$_.JString string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echoAsyncString(
            reference.pointer,
            _id_echoAsyncString as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.JStringType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncUint8List = _class.instanceMethodId(
    r'echoAsyncUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncUint8List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncUint8List(byte[] bs, kotlin.coroutines.Continuation<? super byte[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray> echoAsyncUint8List(
    jni$_.JByteArray bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs.reference;
    final $r = _echoAsyncUint8List(
            reference.pointer,
            _id_echoAsyncUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JByteArray>(
      const jni$_.JByteArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt32List = _class.instanceMethodId(
    r'echoAsyncInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt32List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncInt32List(int[] is, kotlin.coroutines.Continuation<? super int[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray> echoAsyncInt32List(
    jni$_.JIntArray is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$.reference;
    final $r = _echoAsyncInt32List(
            reference.pointer,
            _id_echoAsyncInt32List as jni$_.JMethodIDPtr,
            _$is$.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JIntArray>(
      const jni$_.JIntArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt64List = _class.instanceMethodId(
    r'echoAsyncInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt64List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncInt64List(long[] js, kotlin.coroutines.Continuation<? super long[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray> echoAsyncInt64List(
    jni$_.JLongArray js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js.reference;
    final $r = _echoAsyncInt64List(
            reference.pointer,
            _id_echoAsyncInt64List as jni$_.JMethodIDPtr,
            _$js.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLongArray>(
      const jni$_.JLongArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncFloat64List = _class.instanceMethodId(
    r'echoAsyncFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncFloat64List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncFloat64List(double[] ds, kotlin.coroutines.Continuation<? super double[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray> echoAsyncFloat64List(
    jni$_.JDoubleArray ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds.reference;
    final $r = _echoAsyncFloat64List(
            reference.pointer,
            _id_echoAsyncFloat64List as jni$_.JMethodIDPtr,
            _$ds.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDoubleArray>(
      const jni$_.JDoubleArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncObject = _class.instanceMethodId(
    r'echoAsyncObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncObject(java.lang.Object object, kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> echoAsyncObject(
    jni$_.JObject object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object.reference;
    final $r = _echoAsyncObject(
            reference.pointer,
            _id_echoAsyncObject as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncList = _class.instanceMethodId(
    r'echoAsyncList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncList(java.util.List<? extends java.lang.Object> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>> echoAsyncList(
    jni$_.JList<jni$_.JObject?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncList(
            reference.pointer,
            _id_echoAsyncList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumList = _class.instanceMethodId(
    r'echoAsyncEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncEnumList(java.util.List<? extends JniAnEnum> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAnEnum?>> echoAsyncEnumList(
    jni$_.JList<JniAnEnum?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncEnumList(
            reference.pointer,
            _id_echoAsyncEnumList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<JniAnEnum?>>(
      const jni$_.JListType<JniAnEnum?>($JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassList = _class.instanceMethodId(
    r'echoAsyncClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncClassList(java.util.List<JniAllNullableTypes> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAllNullableTypes?>> echoAsyncClassList(
    jni$_.JList<JniAllNullableTypes?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncClassList(
            reference.pointer,
            _id_echoAsyncClassList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<JniAllNullableTypes?>>(
      const jni$_.JListType<JniAllNullableTypes?>(
          $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncMap = _class.instanceMethodId(
    r'echoAsyncMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> echoAsyncMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncMap(
            reference.pointer,
            _id_echoAsyncMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
      const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
          jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncStringMap = _class.instanceMethodId(
    r'echoAsyncStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncStringMap(java.util.Map<java.lang.String, java.lang.String> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>> echoAsyncStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncStringMap(
            reference.pointer,
            _id_echoAsyncStringMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
      const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(), jni$_.JStringNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncIntMap = _class.instanceMethodId(
    r'echoAsyncIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncIntMap(java.util.Map<java.lang.Long, java.lang.Long> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>> echoAsyncIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncIntMap(
            reference.pointer,
            _id_echoAsyncIntMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
      const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
          jni$_.JLongNullableType(), jni$_.JLongNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumMap = _class.instanceMethodId(
    r'echoAsyncEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<JniAnEnum?, JniAnEnum?>> echoAsyncEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncEnumMap(
            reference.pointer,
            _id_echoAsyncEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<JniAnEnum?, JniAnEnum?>>(
      const jni$_.JMapType<JniAnEnum?, JniAnEnum?>(
          $JniAnEnum$NullableType(), $JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassMap = _class.instanceMethodId(
    r'echoAsyncClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>
      echoAsyncClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncClassMap(
            reference.pointer,
            _id_echoAsyncClassMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>(
      const jni$_.JMapType<jni$_.JLong?, JniAllNullableTypes?>(
          jni$_.JLongNullableType(), $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnum = _class.instanceMethodId(
    r'echoAsyncEnum',
    r'(LJniAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncEnum(JniAnEnum jniAnEnum, kotlin.coroutines.Continuation<? super JniAnEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnEnum> echoAsyncEnum(
    JniAnEnum jniAnEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnEnum = jniAnEnum.reference;
    final $r = _echoAsyncEnum(
            reference.pointer,
            _id_echoAsyncEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<JniAnEnum>(
      const $JniAnEnum$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncEnum = _class.instanceMethodId(
    r'echoAnotherAsyncEnum',
    r'(LJniAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAnotherAsyncEnum(JniAnotherEnum jniAnotherEnum, kotlin.coroutines.Continuation<? super JniAnotherEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnotherEnum> echoAnotherAsyncEnum(
    JniAnotherEnum jniAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    final $r = _echoAnotherAsyncEnum(
            reference.pointer,
            _id_echoAnotherAsyncEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<JniAnotherEnum>(
      const $JniAnotherEnum$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncError = _class.instanceMethodId(
    r'throwAsyncError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object throwAsyncError(kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncError(reference.pointer,
            _id_throwAsyncError as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncErrorFromVoid = _class.instanceMethodId(
    r'throwAsyncErrorFromVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object throwAsyncErrorFromVoid(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> throwAsyncErrorFromVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncErrorFromVoid(
            reference.pointer,
            _id_throwAsyncErrorFromVoid as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncFlutterError = _class.instanceMethodId(
    r'throwAsyncFlutterError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncFlutterError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object throwAsyncFlutterError(kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncFlutterError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncFlutterError(
            reference.pointer,
            _id_throwAsyncFlutterError as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncJniAllTypes = _class.instanceMethodId(
    r'echoAsyncJniAllTypes',
    r'(LJniAllTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncJniAllTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncJniAllTypes(JniAllTypes jniAllTypes, kotlin.coroutines.Continuation<? super JniAllTypes> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAllTypes> echoAsyncJniAllTypes(
    JniAllTypes jniAllTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAllTypes = jniAllTypes.reference;
    final $r = _echoAsyncJniAllTypes(
            reference.pointer,
            _id_echoAsyncJniAllTypes as jni$_.JMethodIDPtr,
            _$jniAllTypes.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<JniAllTypes>(
      const $JniAllTypes$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableJniAllNullableTypes =
      _class.instanceMethodId(
    r'echoAsyncNullableJniAllNullableTypes',
    r'(LJniAllNullableTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableJniAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableJniAllNullableTypes(JniAllNullableTypes jniAllNullableTypes, kotlin.coroutines.Continuation<? super JniAllNullableTypes> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAllNullableTypes?> echoAsyncNullableJniAllNullableTypes(
    JniAllNullableTypes? jniAllNullableTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableJniAllNullableTypes(
            reference.pointer,
            _id_echoAsyncNullableJniAllNullableTypes as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAllNullableTypes?>(
      const $JniAllNullableTypes$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableJniAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoAsyncNullableJniAllNullableTypesWithoutRecursion',
    r'(LJniAllNullableTypesWithoutRecursion;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableJniAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableJniAllNullableTypesWithoutRecursion(JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion, kotlin.coroutines.Continuation<? super JniAllNullableTypesWithoutRecursion> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAllNullableTypesWithoutRecursion?>
      echoAsyncNullableJniAllNullableTypesWithoutRecursion(
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableJniAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoAsyncNullableJniAllNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$jniAllNullableTypesWithoutRecursion.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAllNullableTypesWithoutRecursion?>(
      const $JniAllNullableTypesWithoutRecursion$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt = _class.instanceMethodId(
    r'echoAsyncNullableInt',
    r'(Ljava/lang/Long;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableInt(java.lang.Long long, kotlin.coroutines.Continuation<? super java.lang.Long> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong?> echoAsyncNullableInt(
    jni$_.JLong? long,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$long = long?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt(
            reference.pointer,
            _id_echoAsyncNullableInt as jni$_.JMethodIDPtr,
            _$long.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLong?>(
      const jni$_.JLongNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableDouble = _class.instanceMethodId(
    r'echoAsyncNullableDouble',
    r'(Ljava/lang/Double;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableDouble(java.lang.Double double, kotlin.coroutines.Continuation<? super java.lang.Double> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble?> echoAsyncNullableDouble(
    jni$_.JDouble? double,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$double = double?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableDouble(
            reference.pointer,
            _id_echoAsyncNullableDouble as jni$_.JMethodIDPtr,
            _$double.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDouble?>(
      const jni$_.JDoubleNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableBool = _class.instanceMethodId(
    r'echoAsyncNullableBool',
    r'(Ljava/lang/Boolean;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableBool(java.lang.Boolean boolean, kotlin.coroutines.Continuation<? super java.lang.Boolean> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean?> echoAsyncNullableBool(
    jni$_.JBoolean? boolean,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableBool(
            reference.pointer,
            _id_echoAsyncNullableBool as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JBoolean?>(
      const jni$_.JBooleanNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableString = _class.instanceMethodId(
    r'echoAsyncNullableString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableString(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString?> echoAsyncNullableString(
    jni$_.JString? string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableString(
            reference.pointer,
            _id_echoAsyncNullableString as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JString?>(
      const jni$_.JStringNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableUint8List = _class.instanceMethodId(
    r'echoAsyncNullableUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableUint8List(byte[] bs, kotlin.coroutines.Continuation<? super byte[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray?> echoAsyncNullableUint8List(
    jni$_.JByteArray? bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableUint8List(
            reference.pointer,
            _id_echoAsyncNullableUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JByteArray?>(
      const jni$_.JByteArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt32List = _class.instanceMethodId(
    r'echoAsyncNullableInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt32List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableInt32List(int[] is, kotlin.coroutines.Continuation<? super int[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray?> echoAsyncNullableInt32List(
    jni$_.JIntArray? is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt32List(
            reference.pointer,
            _id_echoAsyncNullableInt32List as jni$_.JMethodIDPtr,
            _$is$.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JIntArray?>(
      const jni$_.JIntArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt64List = _class.instanceMethodId(
    r'echoAsyncNullableInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt64List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableInt64List(long[] js, kotlin.coroutines.Continuation<? super long[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray?> echoAsyncNullableInt64List(
    jni$_.JLongArray? js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt64List(
            reference.pointer,
            _id_echoAsyncNullableInt64List as jni$_.JMethodIDPtr,
            _$js.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLongArray?>(
      const jni$_.JLongArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableFloat64List = _class.instanceMethodId(
    r'echoAsyncNullableFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableFloat64List(double[] ds, kotlin.coroutines.Continuation<? super double[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray?> echoAsyncNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableFloat64List(
            reference.pointer,
            _id_echoAsyncNullableFloat64List as jni$_.JMethodIDPtr,
            _$ds.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDoubleArray?>(
      const jni$_.JDoubleArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableObject = _class.instanceMethodId(
    r'echoAsyncNullableObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableObject(java.lang.Object object, kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> echoAsyncNullableObject(
    jni$_.JObject? object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableObject(
            reference.pointer,
            _id_echoAsyncNullableObject as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableList = _class.instanceMethodId(
    r'echoAsyncNullableList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableList(java.util.List<? extends java.lang.Object> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>?> echoAsyncNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableList(
            reference.pointer,
            _id_echoAsyncNullableList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.JListNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumList = _class.instanceMethodId(
    r'echoAsyncNullableEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableEnumList(java.util.List<? extends JniAnEnum> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAnEnum?>?> echoAsyncNullableEnumList(
    jni$_.JList<JniAnEnum?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumList(
            reference.pointer,
            _id_echoAsyncNullableEnumList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<JniAnEnum?>?>(
      const jni$_.JListNullableType<JniAnEnum?>($JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassList = _class.instanceMethodId(
    r'echoAsyncNullableClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableClassList(java.util.List<JniAllNullableTypes> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAllNullableTypes?>?> echoAsyncNullableClassList(
    jni$_.JList<JniAllNullableTypes?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassList(
            reference.pointer,
            _id_echoAsyncNullableClassList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<JniAllNullableTypes?>?>(
      const jni$_.JListNullableType<JniAllNullableTypes?>(
          $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableMap = _class.instanceMethodId(
    r'echoAsyncNullableMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>
      echoAsyncNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableMap(
            reference.pointer,
            _id_echoAsyncNullableMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
          jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableStringMap = _class.instanceMethodId(
    r'echoAsyncNullableStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>
      echoAsyncNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableStringMap(
            reference.pointer,
            _id_echoAsyncNullableStringMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(), jni$_.JStringNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableIntMap = _class.instanceMethodId(
    r'echoAsyncNullableIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>
      echoAsyncNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableIntMap(
            reference.pointer,
            _id_echoAsyncNullableIntMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
          jni$_.JLongNullableType(), jni$_.JLongNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumMap = _class.instanceMethodId(
    r'echoAsyncNullableEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<JniAnEnum?, JniAnEnum?>?> echoAsyncNullableEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumMap(
            reference.pointer,
            _id_echoAsyncNullableEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
      const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
          $JniAnEnum$NullableType(), $JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassMap = _class.instanceMethodId(
    r'echoAsyncNullableClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>
      echoAsyncNullableClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassMap(
            reference.pointer,
            _id_echoAsyncNullableClassMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
      const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
          jni$_.JLongNullableType(), $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnum = _class.instanceMethodId(
    r'echoAsyncNullableEnum',
    r'(LJniAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableEnum(JniAnEnum jniAnEnum, kotlin.coroutines.Continuation<? super JniAnEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnEnum?> echoAsyncNullableEnum(
    JniAnEnum? jniAnEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnum(
            reference.pointer,
            _id_echoAsyncNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAnEnum?>(
      const $JniAnEnum$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncNullableEnum = _class.instanceMethodId(
    r'echoAnotherAsyncNullableEnum',
    r'(LJniAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAnotherAsyncNullableEnum(JniAnotherEnum jniAnotherEnum, kotlin.coroutines.Continuation<? super JniAnotherEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnotherEnum?> echoAnotherAsyncNullableEnum(
    JniAnotherEnum? jniAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAnotherAsyncNullableEnum(
            reference.pointer,
            _id_echoAnotherAsyncNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAnotherEnum?>(
      const $JniAnotherEnum$NullableType(),
      releaseOriginal: true,
    );
  }
}

final class $JniHostIntegrationCoreApi$NullableType
    extends jni$_.JObjType<JniHostIntegrationCoreApi?> {
  @jni$_.internal
  const $JniHostIntegrationCoreApi$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  JniHostIntegrationCoreApi? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniHostIntegrationCoreApi.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostIntegrationCoreApi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniHostIntegrationCoreApi$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostIntegrationCoreApi$NullableType) &&
        other is $JniHostIntegrationCoreApi$NullableType;
  }
}

final class $JniHostIntegrationCoreApi$Type
    extends jni$_.JObjType<JniHostIntegrationCoreApi> {
  @jni$_.internal
  const $JniHostIntegrationCoreApi$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  JniHostIntegrationCoreApi fromReference(jni$_.JReference reference) =>
      JniHostIntegrationCoreApi.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostIntegrationCoreApi?> get nullableType =>
      const $JniHostIntegrationCoreApi$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniHostIntegrationCoreApi$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostIntegrationCoreApi$Type) &&
        other is $JniHostIntegrationCoreApi$Type;
  }
}

/// from: `JniHostIntegrationCoreApiRegistrar`
class JniHostIntegrationCoreApiRegistrar extends JniHostIntegrationCoreApi {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniHostIntegrationCoreApiRegistrar> $type;

  @jni$_.internal
  JniHostIntegrationCoreApiRegistrar.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'JniHostIntegrationCoreApiRegistrar');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $JniHostIntegrationCoreApiRegistrar$NullableType();
  static const type = $JniHostIntegrationCoreApiRegistrar$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniHostIntegrationCoreApiRegistrar() {
    return JniHostIntegrationCoreApiRegistrar.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getApi = _class.instanceMethodId(
    r'getApi',
    r'()LJniHostIntegrationCoreApi;',
  );

  static final _getApi = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniHostIntegrationCoreApi getApi()`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostIntegrationCoreApi? getApi() {
    return _getApi(reference.pointer, _id_getApi as jni$_.JMethodIDPtr)
        .object<JniHostIntegrationCoreApi?>(
            const $JniHostIntegrationCoreApi$NullableType());
  }

  static final _id_setApi = _class.instanceMethodId(
    r'setApi',
    r'(LJniHostIntegrationCoreApi;)V',
  );

  static final _setApi = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setApi(JniHostIntegrationCoreApi jniHostIntegrationCoreApi)`
  void setApi(
    JniHostIntegrationCoreApi? jniHostIntegrationCoreApi,
  ) {
    final _$jniHostIntegrationCoreApi =
        jniHostIntegrationCoreApi?.reference ?? jni$_.jNullReference;
    _setApi(reference.pointer, _id_setApi as jni$_.JMethodIDPtr,
            _$jniHostIntegrationCoreApi.pointer)
        .check();
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(LJniHostIntegrationCoreApi;Ljava/lang/String;)LJniHostIntegrationCoreApiRegistrar;',
  );

  static final _register = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniHostIntegrationCoreApiRegistrar register(JniHostIntegrationCoreApi jniHostIntegrationCoreApi, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostIntegrationCoreApiRegistrar register(
    JniHostIntegrationCoreApi jniHostIntegrationCoreApi,
    jni$_.JString string,
  ) {
    final _$jniHostIntegrationCoreApi = jniHostIntegrationCoreApi.reference;
    final _$string = string.reference;
    return _register(reference.pointer, _id_register as jni$_.JMethodIDPtr,
            _$jniHostIntegrationCoreApi.pointer, _$string.pointer)
        .object<JniHostIntegrationCoreApiRegistrar>(
            const $JniHostIntegrationCoreApiRegistrar$Type());
  }

  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Ljava/lang/String;)LJniHostIntegrationCoreApiRegistrar;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniHostIntegrationCoreApiRegistrar getInstance(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostIntegrationCoreApiRegistrar? getInstance(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getInstance(reference.pointer,
            _id_getInstance as jni$_.JMethodIDPtr, _$string.pointer)
        .object<JniHostIntegrationCoreApiRegistrar?>(
            const $JniHostIntegrationCoreApiRegistrar$NullableType());
  }

  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }

  static final _id_echoAllTypes = _class.instanceMethodId(
    r'echoAllTypes',
    r'(LJniAllTypes;)LJniAllTypes;',
  );

  static final _echoAllTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllTypes echoAllTypes(JniAllTypes jniAllTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes echoAllTypes(
    JniAllTypes jniAllTypes,
  ) {
    final _$jniAllTypes = jniAllTypes.reference;
    return _echoAllTypes(reference.pointer,
            _id_echoAllTypes as jni$_.JMethodIDPtr, _$jniAllTypes.pointer)
        .object<JniAllTypes>(const $JniAllTypes$Type());
  }

  static final _id_throwError = _class.instanceMethodId(
    r'throwError',
    r'()Ljava/lang/Object;',
  );

  static final _throwError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object throwError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwError() {
    return _throwError(reference.pointer, _id_throwError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_throwErrorFromVoid = _class.instanceMethodId(
    r'throwErrorFromVoid',
    r'()V',
  );

  static final _throwErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void throwErrorFromVoid()`
  void throwErrorFromVoid() {
    _throwErrorFromVoid(
            reference.pointer, _id_throwErrorFromVoid as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_throwFlutterError = _class.instanceMethodId(
    r'throwFlutterError',
    r'()Ljava/lang/Object;',
  );

  static final _throwFlutterError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object throwFlutterError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwFlutterError() {
    return _throwFlutterError(
            reference.pointer, _id_throwFlutterError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_echoInt = _class.instanceMethodId(
    r'echoInt',
    r'(J)J',
  );

  static final _echoInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public long echoInt(long j)`
  int echoInt(
    int j,
  ) {
    return _echoInt(reference.pointer, _id_echoInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoDouble = _class.instanceMethodId(
    r'echoDouble',
    r'(D)D',
  );

  static final _echoDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public double echoDouble(double d)`
  double echoDouble(
    double d,
  ) {
    return _echoDouble(
            reference.pointer, _id_echoDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoBool = _class.instanceMethodId(
    r'echoBool',
    r'(Z)Z',
  );

  static final _echoBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean echoBool(boolean z)`
  bool echoBool(
    bool z,
  ) {
    return _echoBool(
            reference.pointer, _id_echoBool as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_echoString = _class.instanceMethodId(
    r'echoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echoString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoString(reference.pointer, _id_echoString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoUint8List = _class.instanceMethodId(
    r'echoUint8List',
    r'([B)[B',
  );

  static final _echoUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public byte[] echoUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray echoUint8List(
    jni$_.JByteArray bs,
  ) {
    final _$bs = bs.reference;
    return _echoUint8List(reference.pointer,
            _id_echoUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_echoInt32List = _class.instanceMethodId(
    r'echoInt32List',
    r'([I)[I',
  );

  static final _echoInt32List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int[] echoInt32List(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray echoInt32List(
    jni$_.JIntArray is$,
  ) {
    final _$is$ = is$.reference;
    return _echoInt32List(reference.pointer,
            _id_echoInt32List as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<jni$_.JIntArray>(const jni$_.JIntArrayType());
  }

  static final _id_echoInt64List = _class.instanceMethodId(
    r'echoInt64List',
    r'([J)[J',
  );

  static final _echoInt64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long[] echoInt64List(long[] js)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray echoInt64List(
    jni$_.JLongArray js,
  ) {
    final _$js = js.reference;
    return _echoInt64List(reference.pointer,
            _id_echoInt64List as jni$_.JMethodIDPtr, _$js.pointer)
        .object<jni$_.JLongArray>(const jni$_.JLongArrayType());
  }

  static final _id_echoFloat64List = _class.instanceMethodId(
    r'echoFloat64List',
    r'([D)[D',
  );

  static final _echoFloat64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public double[] echoFloat64List(double[] ds)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray echoFloat64List(
    jni$_.JDoubleArray ds,
  ) {
    final _$ds = ds.reference;
    return _echoFloat64List(reference.pointer,
            _id_echoFloat64List as jni$_.JMethodIDPtr, _$ds.pointer)
        .object<jni$_.JDoubleArray>(const jni$_.JDoubleArrayType());
  }

  static final _id_echoObject = _class.instanceMethodId(
    r'echoObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoObject = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoObject(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject echoObject(
    jni$_.JObject object,
  ) {
    final _$object = object.reference;
    return _echoObject(reference.pointer, _id_echoObject as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_echoList = _class.instanceMethodId(
    r'echoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<java.lang.Object> echoList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> echoList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _echoList(reference.pointer, _id_echoList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_echoEnumList = _class.instanceMethodId(
    r'echoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAnEnum> echoEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?> echoEnumList(
    jni$_.JList<JniAnEnum?> list,
  ) {
    final _$list = list.reference;
    return _echoEnumList(reference.pointer,
            _id_echoEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>>(
            const jni$_.JListType<JniAnEnum?>($JniAnEnum$NullableType()));
  }

  static final _id_echoClassList = _class.instanceMethodId(
    r'echoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAllNullableTypes> echoClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?> echoClassList(
    jni$_.JList<JniAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _echoClassList(reference.pointer,
            _id_echoClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>>(
            const jni$_.JListType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullEnumList = _class.instanceMethodId(
    r'echoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAnEnum> echoNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum> echoNonNullEnumList(
    jni$_.JList<JniAnEnum> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullEnumList(reference.pointer,
            _id_echoNonNullEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum>>(
            const jni$_.JListType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_echoNonNullClassList = _class.instanceMethodId(
    r'echoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAllNullableTypes> echoNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes> echoNonNullClassList(
    jni$_.JList<JniAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullClassList(reference.pointer,
            _id_echoNonNullClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>>(
            const jni$_.JListType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_echoMap = _class.instanceMethodId(
    r'echoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Object, java.lang.Object> echoMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _echoMap(
            reference.pointer, _id_echoMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoStringMap = _class.instanceMethodId(
    r'echoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> echoStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _echoStringMap(reference.pointer,
            _id_echoStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoIntMap = _class.instanceMethodId(
    r'echoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> echoIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _echoIntMap(reference.pointer, _id_echoIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
            const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoEnumMap = _class.instanceMethodId(
    r'echoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<JniAnEnum, JniAnEnum> echoEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?> echoEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _echoEnumMap(reference.pointer,
            _id_echoEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>>(
            const jni$_.JMapType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_echoClassMap = _class.instanceMethodId(
    r'echoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, JniAllNullableTypes> echoClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> echoClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _echoClassMap(reference.pointer,
            _id_echoClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullStringMap = _class.instanceMethodId(
    r'echoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> echoNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullStringMap(reference.pointer,
            _id_echoNonNullStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNonNullIntMap = _class.instanceMethodId(
    r'echoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> echoNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullIntMap(reference.pointer,
            _id_echoNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNonNullEnumMap = _class.instanceMethodId(
    r'echoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<JniAnEnum, JniAnEnum> echoNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum> echoNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullEnumMap(reference.pointer,
            _id_echoNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>>(
            const jni$_.JMapType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_echoNonNullClassMap = _class.instanceMethodId(
    r'echoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, JniAllNullableTypes> echoNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes> echoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullClassMap(reference.pointer,
            _id_echoNonNullClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>>(
            const jni$_.JMapType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_echoClassWrapper = _class.instanceMethodId(
    r'echoClassWrapper',
    r'(LJniAllClassesWrapper;)LJniAllClassesWrapper;',
  );

  static final _echoClassWrapper = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllClassesWrapper echoClassWrapper(JniAllClassesWrapper jniAllClassesWrapper)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllClassesWrapper echoClassWrapper(
    JniAllClassesWrapper jniAllClassesWrapper,
  ) {
    final _$jniAllClassesWrapper = jniAllClassesWrapper.reference;
    return _echoClassWrapper(
            reference.pointer,
            _id_echoClassWrapper as jni$_.JMethodIDPtr,
            _$jniAllClassesWrapper.pointer)
        .object<JniAllClassesWrapper>(const $JniAllClassesWrapper$Type());
  }

  static final _id_echoEnum = _class.instanceMethodId(
    r'echoEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _echoEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAnEnum echoEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum echoEnum(
    JniAnEnum jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum.reference;
    return _echoEnum(reference.pointer, _id_echoEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer)
        .object<JniAnEnum>(const $JniAnEnum$Type());
  }

  static final _id_echoAnotherEnum = _class.instanceMethodId(
    r'echoAnotherEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _echoAnotherEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAnotherEnum echoAnotherEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum echoAnotherEnum(
    JniAnotherEnum jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    return _echoAnotherEnum(reference.pointer,
            _id_echoAnotherEnum as jni$_.JMethodIDPtr, _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum>(const $JniAnotherEnum$Type());
  }

  static final _id_echoNamedDefaultString = _class.instanceMethodId(
    r'echoNamedDefaultString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNamedDefaultString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echoNamedDefaultString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoNamedDefaultString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoNamedDefaultString(reference.pointer,
            _id_echoNamedDefaultString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoOptionalDefaultDouble = _class.instanceMethodId(
    r'echoOptionalDefaultDouble',
    r'(D)D',
  );

  static final _echoOptionalDefaultDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public double echoOptionalDefaultDouble(double d)`
  double echoOptionalDefaultDouble(
    double d,
  ) {
    return _echoOptionalDefaultDouble(reference.pointer,
            _id_echoOptionalDefaultDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoRequiredInt = _class.instanceMethodId(
    r'echoRequiredInt',
    r'(J)J',
  );

  static final _echoRequiredInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public long echoRequiredInt(long j)`
  int echoRequiredInt(
    int j,
  ) {
    return _echoRequiredInt(
            reference.pointer, _id_echoRequiredInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoAllNullableTypes = _class.instanceMethodId(
    r'echoAllNullableTypes',
    r'(LJniAllNullableTypes;)LJniAllNullableTypes;',
  );

  static final _echoAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllNullableTypes echoAllNullableTypes(JniAllNullableTypes jniAllNullableTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes? echoAllNullableTypes(
    JniAllNullableTypes? jniAllNullableTypes,
  ) {
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypes(
            reference.pointer,
            _id_echoAllNullableTypes as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer)
        .object<JniAllNullableTypes?>(
            const $JniAllNullableTypes$NullableType());
  }

  static final _id_echoAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoAllNullableTypesWithoutRecursion',
    r'(LJniAllNullableTypesWithoutRecursion;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _echoAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllNullableTypesWithoutRecursion echoAllNullableTypesWithoutRecursion(JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion? echoAllNullableTypesWithoutRecursion(
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
  ) {
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$jniAllNullableTypesWithoutRecursion.pointer)
        .object<JniAllNullableTypesWithoutRecursion?>(
            const $JniAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_extractNestedNullableString = _class.instanceMethodId(
    r'extractNestedNullableString',
    r'(LJniAllClassesWrapper;)Ljava/lang/String;',
  );

  static final _extractNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String extractNestedNullableString(JniAllClassesWrapper jniAllClassesWrapper)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? extractNestedNullableString(
    JniAllClassesWrapper jniAllClassesWrapper,
  ) {
    final _$jniAllClassesWrapper = jniAllClassesWrapper.reference;
    return _extractNestedNullableString(
            reference.pointer,
            _id_extractNestedNullableString as jni$_.JMethodIDPtr,
            _$jniAllClassesWrapper.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_createNestedNullableString = _class.instanceMethodId(
    r'createNestedNullableString',
    r'(Ljava/lang/String;)LJniAllClassesWrapper;',
  );

  static final _createNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllClassesWrapper createNestedNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllClassesWrapper createNestedNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createNestedNullableString(
            reference.pointer,
            _id_createNestedNullableString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<JniAllClassesWrapper>(const $JniAllClassesWrapper$Type());
  }

  static final _id_sendMultipleNullableTypes = _class.instanceMethodId(
    r'sendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypes;',
  );

  static final _sendMultipleNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllNullableTypes sendMultipleNullableTypes(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes sendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypes(
            reference.pointer,
            _id_sendMultipleNullableTypes as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_sendMultipleNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'sendMultipleNullableTypesWithoutRecursion',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _sendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypesWithoutRecursion(
            reference.pointer,
            _id_sendMultipleNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypesWithoutRecursion>(
            const $JniAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_echoNullableInt = _class.instanceMethodId(
    r'echoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Long echoNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoNullableInt(reference.pointer,
            _id_echoNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNullableDouble = _class.instanceMethodId(
    r'echoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _echoNullableDouble = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Double echoNullableDouble(java.lang.Double double)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? echoNullableDouble(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _echoNullableDouble(reference.pointer,
            _id_echoNullableDouble as jni$_.JMethodIDPtr, _$double.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_echoNullableBool = _class.instanceMethodId(
    r'echoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _echoNullableBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Boolean echoNullableBool(java.lang.Boolean boolean)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? echoNullableBool(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _echoNullableBool(reference.pointer,
            _id_echoNullableBool as jni$_.JMethodIDPtr, _$boolean.pointer)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_echoNullableString = _class.instanceMethodId(
    r'echoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echoNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNullableString(reference.pointer,
            _id_echoNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_echoNullableUint8List = _class.instanceMethodId(
    r'echoNullableUint8List',
    r'([B)[B',
  );

  static final _echoNullableUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public byte[] echoNullableUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? echoNullableUint8List(
    jni$_.JByteArray? bs,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _echoNullableUint8List(reference.pointer,
            _id_echoNullableUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_echoNullableInt32List = _class.instanceMethodId(
    r'echoNullableInt32List',
    r'([I)[I',
  );

  static final _echoNullableInt32List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int[] echoNullableInt32List(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? echoNullableInt32List(
    jni$_.JIntArray? is$,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _echoNullableInt32List(reference.pointer,
            _id_echoNullableInt32List as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_echoNullableInt64List = _class.instanceMethodId(
    r'echoNullableInt64List',
    r'([J)[J',
  );

  static final _echoNullableInt64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long[] echoNullableInt64List(long[] js)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? echoNullableInt64List(
    jni$_.JLongArray? js,
  ) {
    final _$js = js?.reference ?? jni$_.jNullReference;
    return _echoNullableInt64List(reference.pointer,
            _id_echoNullableInt64List as jni$_.JMethodIDPtr, _$js.pointer)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_echoNullableFloat64List = _class.instanceMethodId(
    r'echoNullableFloat64List',
    r'([D)[D',
  );

  static final _echoNullableFloat64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public double[] echoNullableFloat64List(double[] ds)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? echoNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    return _echoNullableFloat64List(reference.pointer,
            _id_echoNullableFloat64List as jni$_.JMethodIDPtr, _$ds.pointer)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_echoNullableObject = _class.instanceMethodId(
    r'echoNullableObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoNullableObject = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoNullableObject(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? echoNullableObject(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _echoNullableObject(reference.pointer,
            _id_echoNullableObject as jni$_.JMethodIDPtr, _$object.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_echoNullableList = _class.instanceMethodId(
    r'echoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<java.lang.Object> echoNullableList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? echoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableList(reference.pointer,
            _id_echoNullableList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableEnumList = _class.instanceMethodId(
    r'echoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAnEnum> echoNullableEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? echoNullableEnumList(
    jni$_.JList<JniAnEnum?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumList(reference.pointer,
            _id_echoNullableEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_echoNullableClassList = _class.instanceMethodId(
    r'echoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAllNullableTypes> echoNullableClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?>? echoNullableClassList(
    jni$_.JList<JniAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableClassList(reference.pointer,
            _id_echoNullableClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>?>(
            const jni$_.JListNullableType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullEnumList = _class.instanceMethodId(
    r'echoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAnEnum> echoNullableNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum>? echoNullableNonNullEnumList(
    jni$_.JList<JniAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumList(
            reference.pointer,
            _id_echoNullableNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAnEnum>?>(
            const jni$_.JListNullableType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassList = _class.instanceMethodId(
    r'echoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAllNullableTypes> echoNullableNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes>? echoNullableNonNullClassList(
    jni$_.JList<JniAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassList(
            reference.pointer,
            _id_echoNullableNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>?>(
            const jni$_.JListNullableType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_echoNullableMap = _class.instanceMethodId(
    r'echoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Object, java.lang.Object> echoNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableMap(reference.pointer,
            _id_echoNullableMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableStringMap = _class.instanceMethodId(
    r'echoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> echoNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableStringMap(reference.pointer,
            _id_echoNullableStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoNullableIntMap = _class.instanceMethodId(
    r'echoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> echoNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableIntMap(reference.pointer,
            _id_echoNullableIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoNullableEnumMap = _class.instanceMethodId(
    r'echoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<JniAnEnum, JniAnEnum> echoNullableEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? echoNullableEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumMap(reference.pointer,
            _id_echoNullableEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_echoNullableClassMap = _class.instanceMethodId(
    r'echoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, JniAllNullableTypes> echoNullableClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? echoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableClassMap(reference.pointer,
            _id_echoNullableClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullStringMap = _class.instanceMethodId(
    r'echoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> echoNullableNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullStringMap(
            reference.pointer,
            _id_echoNullableNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNullableNonNullIntMap = _class.instanceMethodId(
    r'echoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> echoNullableNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullIntMap(reference.pointer,
            _id_echoNullableNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
            const jni$_.JMapNullableType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNullableNonNullEnumMap = _class.instanceMethodId(
    r'echoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<JniAnEnum, JniAnEnum> echoNullableNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum>? echoNullableNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumMap(reference.pointer,
            _id_echoNullableNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>?>(
            const jni$_.JMapNullableType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassMap = _class.instanceMethodId(
    r'echoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, JniAllNullableTypes> echoNullableNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? echoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassMap(
            reference.pointer,
            _id_echoNullableNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>?>(
            const jni$_.JMapNullableType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_echoNullableEnum = _class.instanceMethodId(
    r'echoNullableEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _echoNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAnEnum echoNullableEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? echoNullableEnum(
    JniAnEnum? jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    return _echoNullableEnum(reference.pointer,
            _id_echoNullableEnum as jni$_.JMethodIDPtr, _$jniAnEnum.pointer)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_echoAnotherNullableEnum = _class.instanceMethodId(
    r'echoAnotherNullableEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _echoAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAnotherEnum echoAnotherNullableEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? echoAnotherNullableEnum(
    JniAnotherEnum? jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    return _echoAnotherNullableEnum(
            reference.pointer,
            _id_echoAnotherNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_echoOptionalNullableInt = _class.instanceMethodId(
    r'echoOptionalNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoOptionalNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Long echoOptionalNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoOptionalNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoOptionalNullableInt(reference.pointer,
            _id_echoOptionalNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNamedNullableString = _class.instanceMethodId(
    r'echoNamedNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNamedNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echoNamedNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNamedNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNamedNullableString(reference.pointer,
            _id_echoNamedNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_noopAsync = _class.instanceMethodId(
    r'noopAsync',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _noopAsync = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object noopAsync(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> noopAsync() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _noopAsync(reference.pointer,
            _id_noopAsync as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt = _class.instanceMethodId(
    r'echoAsyncInt',
    r'(JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncInt(long j, kotlin.coroutines.Continuation<? super java.lang.Long> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong> echoAsyncInt(
    int j,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncInt(reference.pointer,
            _id_echoAsyncInt as jni$_.JMethodIDPtr, j, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLong>(
      const jni$_.JLongType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncDouble = _class.instanceMethodId(
    r'echoAsyncDouble',
    r'(DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, double, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncDouble(double d, kotlin.coroutines.Continuation<? super java.lang.Double> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble> echoAsyncDouble(
    double d,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncDouble(
            reference.pointer,
            _id_echoAsyncDouble as jni$_.JMethodIDPtr,
            d,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDouble>(
      const jni$_.JDoubleType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncBool = _class.instanceMethodId(
    r'echoAsyncBool',
    r'(ZLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncBool(boolean z, kotlin.coroutines.Continuation<? super java.lang.Boolean> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean> echoAsyncBool(
    bool z,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncBool(
            reference.pointer,
            _id_echoAsyncBool as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JBoolean>(
      const jni$_.JBooleanType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncString = _class.instanceMethodId(
    r'echoAsyncString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncString(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echoAsyncString(
    jni$_.JString string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echoAsyncString(
            reference.pointer,
            _id_echoAsyncString as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.JStringType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncUint8List = _class.instanceMethodId(
    r'echoAsyncUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncUint8List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncUint8List(byte[] bs, kotlin.coroutines.Continuation<? super byte[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray> echoAsyncUint8List(
    jni$_.JByteArray bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs.reference;
    final $r = _echoAsyncUint8List(
            reference.pointer,
            _id_echoAsyncUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JByteArray>(
      const jni$_.JByteArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt32List = _class.instanceMethodId(
    r'echoAsyncInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt32List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncInt32List(int[] is, kotlin.coroutines.Continuation<? super int[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray> echoAsyncInt32List(
    jni$_.JIntArray is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$.reference;
    final $r = _echoAsyncInt32List(
            reference.pointer,
            _id_echoAsyncInt32List as jni$_.JMethodIDPtr,
            _$is$.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JIntArray>(
      const jni$_.JIntArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt64List = _class.instanceMethodId(
    r'echoAsyncInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt64List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncInt64List(long[] js, kotlin.coroutines.Continuation<? super long[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray> echoAsyncInt64List(
    jni$_.JLongArray js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js.reference;
    final $r = _echoAsyncInt64List(
            reference.pointer,
            _id_echoAsyncInt64List as jni$_.JMethodIDPtr,
            _$js.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLongArray>(
      const jni$_.JLongArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncFloat64List = _class.instanceMethodId(
    r'echoAsyncFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncFloat64List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncFloat64List(double[] ds, kotlin.coroutines.Continuation<? super double[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray> echoAsyncFloat64List(
    jni$_.JDoubleArray ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds.reference;
    final $r = _echoAsyncFloat64List(
            reference.pointer,
            _id_echoAsyncFloat64List as jni$_.JMethodIDPtr,
            _$ds.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDoubleArray>(
      const jni$_.JDoubleArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncObject = _class.instanceMethodId(
    r'echoAsyncObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncObject(java.lang.Object object, kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> echoAsyncObject(
    jni$_.JObject object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object.reference;
    final $r = _echoAsyncObject(
            reference.pointer,
            _id_echoAsyncObject as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncList = _class.instanceMethodId(
    r'echoAsyncList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncList(java.util.List<? extends java.lang.Object> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>> echoAsyncList(
    jni$_.JList<jni$_.JObject?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncList(
            reference.pointer,
            _id_echoAsyncList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumList = _class.instanceMethodId(
    r'echoAsyncEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncEnumList(java.util.List<? extends JniAnEnum> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAnEnum?>> echoAsyncEnumList(
    jni$_.JList<JniAnEnum?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncEnumList(
            reference.pointer,
            _id_echoAsyncEnumList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<JniAnEnum?>>(
      const jni$_.JListType<JniAnEnum?>($JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassList = _class.instanceMethodId(
    r'echoAsyncClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncClassList(java.util.List<JniAllNullableTypes> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAllNullableTypes?>> echoAsyncClassList(
    jni$_.JList<JniAllNullableTypes?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncClassList(
            reference.pointer,
            _id_echoAsyncClassList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<JniAllNullableTypes?>>(
      const jni$_.JListType<JniAllNullableTypes?>(
          $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncMap = _class.instanceMethodId(
    r'echoAsyncMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> echoAsyncMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncMap(
            reference.pointer,
            _id_echoAsyncMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
      const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
          jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncStringMap = _class.instanceMethodId(
    r'echoAsyncStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncStringMap(java.util.Map<java.lang.String, java.lang.String> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>> echoAsyncStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncStringMap(
            reference.pointer,
            _id_echoAsyncStringMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
      const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(), jni$_.JStringNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncIntMap = _class.instanceMethodId(
    r'echoAsyncIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncIntMap(java.util.Map<java.lang.Long, java.lang.Long> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>> echoAsyncIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncIntMap(
            reference.pointer,
            _id_echoAsyncIntMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
      const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
          jni$_.JLongNullableType(), jni$_.JLongNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumMap = _class.instanceMethodId(
    r'echoAsyncEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<JniAnEnum?, JniAnEnum?>> echoAsyncEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncEnumMap(
            reference.pointer,
            _id_echoAsyncEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<JniAnEnum?, JniAnEnum?>>(
      const jni$_.JMapType<JniAnEnum?, JniAnEnum?>(
          $JniAnEnum$NullableType(), $JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassMap = _class.instanceMethodId(
    r'echoAsyncClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>
      echoAsyncClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncClassMap(
            reference.pointer,
            _id_echoAsyncClassMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>(
      const jni$_.JMapType<jni$_.JLong?, JniAllNullableTypes?>(
          jni$_.JLongNullableType(), $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnum = _class.instanceMethodId(
    r'echoAsyncEnum',
    r'(LJniAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncEnum(JniAnEnum jniAnEnum, kotlin.coroutines.Continuation<? super JniAnEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnEnum> echoAsyncEnum(
    JniAnEnum jniAnEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnEnum = jniAnEnum.reference;
    final $r = _echoAsyncEnum(
            reference.pointer,
            _id_echoAsyncEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<JniAnEnum>(
      const $JniAnEnum$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncEnum = _class.instanceMethodId(
    r'echoAnotherAsyncEnum',
    r'(LJniAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAnotherAsyncEnum(JniAnotherEnum jniAnotherEnum, kotlin.coroutines.Continuation<? super JniAnotherEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnotherEnum> echoAnotherAsyncEnum(
    JniAnotherEnum jniAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    final $r = _echoAnotherAsyncEnum(
            reference.pointer,
            _id_echoAnotherAsyncEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<JniAnotherEnum>(
      const $JniAnotherEnum$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncError = _class.instanceMethodId(
    r'throwAsyncError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object throwAsyncError(kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncError(reference.pointer,
            _id_throwAsyncError as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncErrorFromVoid = _class.instanceMethodId(
    r'throwAsyncErrorFromVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object throwAsyncErrorFromVoid(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> throwAsyncErrorFromVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncErrorFromVoid(
            reference.pointer,
            _id_throwAsyncErrorFromVoid as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncFlutterError = _class.instanceMethodId(
    r'throwAsyncFlutterError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncFlutterError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object throwAsyncFlutterError(kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncFlutterError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncFlutterError(
            reference.pointer,
            _id_throwAsyncFlutterError as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncJniAllTypes = _class.instanceMethodId(
    r'echoAsyncJniAllTypes',
    r'(LJniAllTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncJniAllTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncJniAllTypes(JniAllTypes jniAllTypes, kotlin.coroutines.Continuation<? super JniAllTypes> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAllTypes> echoAsyncJniAllTypes(
    JniAllTypes jniAllTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAllTypes = jniAllTypes.reference;
    final $r = _echoAsyncJniAllTypes(
            reference.pointer,
            _id_echoAsyncJniAllTypes as jni$_.JMethodIDPtr,
            _$jniAllTypes.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<JniAllTypes>(
      const $JniAllTypes$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableJniAllNullableTypes =
      _class.instanceMethodId(
    r'echoAsyncNullableJniAllNullableTypes',
    r'(LJniAllNullableTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableJniAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableJniAllNullableTypes(JniAllNullableTypes jniAllNullableTypes, kotlin.coroutines.Continuation<? super JniAllNullableTypes> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAllNullableTypes?> echoAsyncNullableJniAllNullableTypes(
    JniAllNullableTypes? jniAllNullableTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableJniAllNullableTypes(
            reference.pointer,
            _id_echoAsyncNullableJniAllNullableTypes as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAllNullableTypes?>(
      const $JniAllNullableTypes$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableJniAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoAsyncNullableJniAllNullableTypesWithoutRecursion',
    r'(LJniAllNullableTypesWithoutRecursion;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableJniAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableJniAllNullableTypesWithoutRecursion(JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion, kotlin.coroutines.Continuation<? super JniAllNullableTypesWithoutRecursion> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAllNullableTypesWithoutRecursion?>
      echoAsyncNullableJniAllNullableTypesWithoutRecursion(
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableJniAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoAsyncNullableJniAllNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$jniAllNullableTypesWithoutRecursion.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAllNullableTypesWithoutRecursion?>(
      const $JniAllNullableTypesWithoutRecursion$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt = _class.instanceMethodId(
    r'echoAsyncNullableInt',
    r'(Ljava/lang/Long;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableInt(java.lang.Long long, kotlin.coroutines.Continuation<? super java.lang.Long> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong?> echoAsyncNullableInt(
    jni$_.JLong? long,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$long = long?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt(
            reference.pointer,
            _id_echoAsyncNullableInt as jni$_.JMethodIDPtr,
            _$long.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLong?>(
      const jni$_.JLongNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableDouble = _class.instanceMethodId(
    r'echoAsyncNullableDouble',
    r'(Ljava/lang/Double;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableDouble(java.lang.Double double, kotlin.coroutines.Continuation<? super java.lang.Double> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble?> echoAsyncNullableDouble(
    jni$_.JDouble? double,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$double = double?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableDouble(
            reference.pointer,
            _id_echoAsyncNullableDouble as jni$_.JMethodIDPtr,
            _$double.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDouble?>(
      const jni$_.JDoubleNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableBool = _class.instanceMethodId(
    r'echoAsyncNullableBool',
    r'(Ljava/lang/Boolean;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableBool(java.lang.Boolean boolean, kotlin.coroutines.Continuation<? super java.lang.Boolean> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean?> echoAsyncNullableBool(
    jni$_.JBoolean? boolean,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableBool(
            reference.pointer,
            _id_echoAsyncNullableBool as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JBoolean?>(
      const jni$_.JBooleanNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableString = _class.instanceMethodId(
    r'echoAsyncNullableString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableString(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString?> echoAsyncNullableString(
    jni$_.JString? string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableString(
            reference.pointer,
            _id_echoAsyncNullableString as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JString?>(
      const jni$_.JStringNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableUint8List = _class.instanceMethodId(
    r'echoAsyncNullableUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableUint8List(byte[] bs, kotlin.coroutines.Continuation<? super byte[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray?> echoAsyncNullableUint8List(
    jni$_.JByteArray? bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableUint8List(
            reference.pointer,
            _id_echoAsyncNullableUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JByteArray?>(
      const jni$_.JByteArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt32List = _class.instanceMethodId(
    r'echoAsyncNullableInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt32List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableInt32List(int[] is, kotlin.coroutines.Continuation<? super int[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray?> echoAsyncNullableInt32List(
    jni$_.JIntArray? is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt32List(
            reference.pointer,
            _id_echoAsyncNullableInt32List as jni$_.JMethodIDPtr,
            _$is$.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JIntArray?>(
      const jni$_.JIntArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt64List = _class.instanceMethodId(
    r'echoAsyncNullableInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt64List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableInt64List(long[] js, kotlin.coroutines.Continuation<? super long[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray?> echoAsyncNullableInt64List(
    jni$_.JLongArray? js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt64List(
            reference.pointer,
            _id_echoAsyncNullableInt64List as jni$_.JMethodIDPtr,
            _$js.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLongArray?>(
      const jni$_.JLongArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableFloat64List = _class.instanceMethodId(
    r'echoAsyncNullableFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableFloat64List(double[] ds, kotlin.coroutines.Continuation<? super double[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray?> echoAsyncNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableFloat64List(
            reference.pointer,
            _id_echoAsyncNullableFloat64List as jni$_.JMethodIDPtr,
            _$ds.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDoubleArray?>(
      const jni$_.JDoubleArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableObject = _class.instanceMethodId(
    r'echoAsyncNullableObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableObject(java.lang.Object object, kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> echoAsyncNullableObject(
    jni$_.JObject? object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableObject(
            reference.pointer,
            _id_echoAsyncNullableObject as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableList = _class.instanceMethodId(
    r'echoAsyncNullableList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableList(java.util.List<? extends java.lang.Object> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>?> echoAsyncNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableList(
            reference.pointer,
            _id_echoAsyncNullableList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.JListNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumList = _class.instanceMethodId(
    r'echoAsyncNullableEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableEnumList(java.util.List<? extends JniAnEnum> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAnEnum?>?> echoAsyncNullableEnumList(
    jni$_.JList<JniAnEnum?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumList(
            reference.pointer,
            _id_echoAsyncNullableEnumList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<JniAnEnum?>?>(
      const jni$_.JListNullableType<JniAnEnum?>($JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassList = _class.instanceMethodId(
    r'echoAsyncNullableClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableClassList(java.util.List<JniAllNullableTypes> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAllNullableTypes?>?> echoAsyncNullableClassList(
    jni$_.JList<JniAllNullableTypes?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassList(
            reference.pointer,
            _id_echoAsyncNullableClassList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<JniAllNullableTypes?>?>(
      const jni$_.JListNullableType<JniAllNullableTypes?>(
          $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableMap = _class.instanceMethodId(
    r'echoAsyncNullableMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>
      echoAsyncNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableMap(
            reference.pointer,
            _id_echoAsyncNullableMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
          jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableStringMap = _class.instanceMethodId(
    r'echoAsyncNullableStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>
      echoAsyncNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableStringMap(
            reference.pointer,
            _id_echoAsyncNullableStringMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(), jni$_.JStringNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableIntMap = _class.instanceMethodId(
    r'echoAsyncNullableIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>
      echoAsyncNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableIntMap(
            reference.pointer,
            _id_echoAsyncNullableIntMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
          jni$_.JLongNullableType(), jni$_.JLongNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumMap = _class.instanceMethodId(
    r'echoAsyncNullableEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<JniAnEnum?, JniAnEnum?>?> echoAsyncNullableEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumMap(
            reference.pointer,
            _id_echoAsyncNullableEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
      const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
          $JniAnEnum$NullableType(), $JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassMap = _class.instanceMethodId(
    r'echoAsyncNullableClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>
      echoAsyncNullableClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassMap(
            reference.pointer,
            _id_echoAsyncNullableClassMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
      const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
          jni$_.JLongNullableType(), $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnum = _class.instanceMethodId(
    r'echoAsyncNullableEnum',
    r'(LJniAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableEnum(JniAnEnum jniAnEnum, kotlin.coroutines.Continuation<? super JniAnEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnEnum?> echoAsyncNullableEnum(
    JniAnEnum? jniAnEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnum(
            reference.pointer,
            _id_echoAsyncNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAnEnum?>(
      const $JniAnEnum$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncNullableEnum = _class.instanceMethodId(
    r'echoAnotherAsyncNullableEnum',
    r'(LJniAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAnotherAsyncNullableEnum(JniAnotherEnum jniAnotherEnum, kotlin.coroutines.Continuation<? super JniAnotherEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnotherEnum?> echoAnotherAsyncNullableEnum(
    JniAnotherEnum? jniAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAnotherAsyncNullableEnum(
            reference.pointer,
            _id_echoAnotherAsyncNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAnotherEnum?>(
      const $JniAnotherEnum$NullableType(),
      releaseOriginal: true,
    );
  }
}

final class $JniHostIntegrationCoreApiRegistrar$NullableType
    extends jni$_.JObjType<JniHostIntegrationCoreApiRegistrar?> {
  @jni$_.internal
  const $JniHostIntegrationCoreApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniHostIntegrationCoreApiRegistrar? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniHostIntegrationCoreApiRegistrar.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $JniHostIntegrationCoreApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostIntegrationCoreApiRegistrar?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode =>
      ($JniHostIntegrationCoreApiRegistrar$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JniHostIntegrationCoreApiRegistrar$NullableType) &&
        other is $JniHostIntegrationCoreApiRegistrar$NullableType;
  }
}

final class $JniHostIntegrationCoreApiRegistrar$Type
    extends jni$_.JObjType<JniHostIntegrationCoreApiRegistrar> {
  @jni$_.internal
  const $JniHostIntegrationCoreApiRegistrar$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniHostIntegrationCoreApiRegistrar fromReference(
          jni$_.JReference reference) =>
      JniHostIntegrationCoreApiRegistrar.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $JniHostIntegrationCoreApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostIntegrationCoreApiRegistrar?> get nullableType =>
      const $JniHostIntegrationCoreApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($JniHostIntegrationCoreApiRegistrar$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostIntegrationCoreApiRegistrar$Type) &&
        other is $JniHostIntegrationCoreApiRegistrar$Type;
  }
}

/// from: `JniHostTrivialApi`
class JniHostTrivialApi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniHostTrivialApi> $type;

  @jni$_.internal
  JniHostTrivialApi.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniHostTrivialApi');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniHostTrivialApi$NullableType();
  static const type = $JniHostTrivialApi$Type();
  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }
}

final class $JniHostTrivialApi$NullableType
    extends jni$_.JObjType<JniHostTrivialApi?> {
  @jni$_.internal
  const $JniHostTrivialApi$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostTrivialApi;';

  @jni$_.internal
  @core$_.override
  JniHostTrivialApi? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniHostTrivialApi.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostTrivialApi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniHostTrivialApi$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostTrivialApi$NullableType) &&
        other is $JniHostTrivialApi$NullableType;
  }
}

final class $JniHostTrivialApi$Type extends jni$_.JObjType<JniHostTrivialApi> {
  @jni$_.internal
  const $JniHostTrivialApi$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostTrivialApi;';

  @jni$_.internal
  @core$_.override
  JniHostTrivialApi fromReference(jni$_.JReference reference) =>
      JniHostTrivialApi.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostTrivialApi?> get nullableType =>
      const $JniHostTrivialApi$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniHostTrivialApi$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostTrivialApi$Type) &&
        other is $JniHostTrivialApi$Type;
  }
}

/// from: `JniHostTrivialApiRegistrar`
class JniHostTrivialApiRegistrar extends JniHostTrivialApi {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniHostTrivialApiRegistrar> $type;

  @jni$_.internal
  JniHostTrivialApiRegistrar.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniHostTrivialApiRegistrar');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniHostTrivialApiRegistrar$NullableType();
  static const type = $JniHostTrivialApiRegistrar$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniHostTrivialApiRegistrar() {
    return JniHostTrivialApiRegistrar.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getApi = _class.instanceMethodId(
    r'getApi',
    r'()LJniHostTrivialApi;',
  );

  static final _getApi = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniHostTrivialApi getApi()`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostTrivialApi? getApi() {
    return _getApi(reference.pointer, _id_getApi as jni$_.JMethodIDPtr)
        .object<JniHostTrivialApi?>(const $JniHostTrivialApi$NullableType());
  }

  static final _id_setApi = _class.instanceMethodId(
    r'setApi',
    r'(LJniHostTrivialApi;)V',
  );

  static final _setApi = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setApi(JniHostTrivialApi jniHostTrivialApi)`
  void setApi(
    JniHostTrivialApi? jniHostTrivialApi,
  ) {
    final _$jniHostTrivialApi =
        jniHostTrivialApi?.reference ?? jni$_.jNullReference;
    _setApi(reference.pointer, _id_setApi as jni$_.JMethodIDPtr,
            _$jniHostTrivialApi.pointer)
        .check();
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(LJniHostTrivialApi;Ljava/lang/String;)LJniHostTrivialApiRegistrar;',
  );

  static final _register = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniHostTrivialApiRegistrar register(JniHostTrivialApi jniHostTrivialApi, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostTrivialApiRegistrar register(
    JniHostTrivialApi jniHostTrivialApi,
    jni$_.JString string,
  ) {
    final _$jniHostTrivialApi = jniHostTrivialApi.reference;
    final _$string = string.reference;
    return _register(reference.pointer, _id_register as jni$_.JMethodIDPtr,
            _$jniHostTrivialApi.pointer, _$string.pointer)
        .object<JniHostTrivialApiRegistrar>(
            const $JniHostTrivialApiRegistrar$Type());
  }

  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Ljava/lang/String;)LJniHostTrivialApiRegistrar;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniHostTrivialApiRegistrar getInstance(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostTrivialApiRegistrar? getInstance(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getInstance(reference.pointer,
            _id_getInstance as jni$_.JMethodIDPtr, _$string.pointer)
        .object<JniHostTrivialApiRegistrar?>(
            const $JniHostTrivialApiRegistrar$NullableType());
  }

  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }
}

final class $JniHostTrivialApiRegistrar$NullableType
    extends jni$_.JObjType<JniHostTrivialApiRegistrar?> {
  @jni$_.internal
  const $JniHostTrivialApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostTrivialApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniHostTrivialApiRegistrar? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniHostTrivialApiRegistrar.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $JniHostTrivialApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostTrivialApiRegistrar?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($JniHostTrivialApiRegistrar$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostTrivialApiRegistrar$NullableType) &&
        other is $JniHostTrivialApiRegistrar$NullableType;
  }
}

final class $JniHostTrivialApiRegistrar$Type
    extends jni$_.JObjType<JniHostTrivialApiRegistrar> {
  @jni$_.internal
  const $JniHostTrivialApiRegistrar$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostTrivialApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniHostTrivialApiRegistrar fromReference(jni$_.JReference reference) =>
      JniHostTrivialApiRegistrar.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $JniHostTrivialApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostTrivialApiRegistrar?> get nullableType =>
      const $JniHostTrivialApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($JniHostTrivialApiRegistrar$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostTrivialApiRegistrar$Type) &&
        other is $JniHostTrivialApiRegistrar$Type;
  }
}

/// from: `JniHostSmallApi`
class JniHostSmallApi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniHostSmallApi> $type;

  @jni$_.internal
  JniHostSmallApi.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniHostSmallApi');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniHostSmallApi$NullableType();
  static const type = $JniHostSmallApi$Type();
  static final _id_echo = _class.instanceMethodId(
    r'echo',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echo(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echo(
    jni$_.JString string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echo(reference.pointer, _id_echo as jni$_.JMethodIDPtr,
            _$string.pointer, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.JStringType(),
      releaseOriginal: true,
    );
  }

  static final _id_voidVoid = _class.instanceMethodId(
    r'voidVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _voidVoid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object voidVoid(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> voidVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _voidVoid(reference.pointer, _id_voidVoid as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }
}

final class $JniHostSmallApi$NullableType
    extends jni$_.JObjType<JniHostSmallApi?> {
  @jni$_.internal
  const $JniHostSmallApi$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostSmallApi;';

  @jni$_.internal
  @core$_.override
  JniHostSmallApi? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : JniHostSmallApi.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostSmallApi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniHostSmallApi$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostSmallApi$NullableType) &&
        other is $JniHostSmallApi$NullableType;
  }
}

final class $JniHostSmallApi$Type extends jni$_.JObjType<JniHostSmallApi> {
  @jni$_.internal
  const $JniHostSmallApi$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostSmallApi;';

  @jni$_.internal
  @core$_.override
  JniHostSmallApi fromReference(jni$_.JReference reference) =>
      JniHostSmallApi.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostSmallApi?> get nullableType =>
      const $JniHostSmallApi$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniHostSmallApi$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostSmallApi$Type) &&
        other is $JniHostSmallApi$Type;
  }
}

/// from: `JniHostSmallApiRegistrar`
class JniHostSmallApiRegistrar extends JniHostSmallApi {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniHostSmallApiRegistrar> $type;

  @jni$_.internal
  JniHostSmallApiRegistrar.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniHostSmallApiRegistrar');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniHostSmallApiRegistrar$NullableType();
  static const type = $JniHostSmallApiRegistrar$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniHostSmallApiRegistrar() {
    return JniHostSmallApiRegistrar.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getApi = _class.instanceMethodId(
    r'getApi',
    r'()LJniHostSmallApi;',
  );

  static final _getApi = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniHostSmallApi getApi()`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostSmallApi? getApi() {
    return _getApi(reference.pointer, _id_getApi as jni$_.JMethodIDPtr)
        .object<JniHostSmallApi?>(const $JniHostSmallApi$NullableType());
  }

  static final _id_setApi = _class.instanceMethodId(
    r'setApi',
    r'(LJniHostSmallApi;)V',
  );

  static final _setApi = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setApi(JniHostSmallApi jniHostSmallApi)`
  void setApi(
    JniHostSmallApi? jniHostSmallApi,
  ) {
    final _$jniHostSmallApi =
        jniHostSmallApi?.reference ?? jni$_.jNullReference;
    _setApi(reference.pointer, _id_setApi as jni$_.JMethodIDPtr,
            _$jniHostSmallApi.pointer)
        .check();
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(LJniHostSmallApi;Ljava/lang/String;)LJniHostSmallApiRegistrar;',
  );

  static final _register = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniHostSmallApiRegistrar register(JniHostSmallApi jniHostSmallApi, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostSmallApiRegistrar register(
    JniHostSmallApi jniHostSmallApi,
    jni$_.JString string,
  ) {
    final _$jniHostSmallApi = jniHostSmallApi.reference;
    final _$string = string.reference;
    return _register(reference.pointer, _id_register as jni$_.JMethodIDPtr,
            _$jniHostSmallApi.pointer, _$string.pointer)
        .object<JniHostSmallApiRegistrar>(
            const $JniHostSmallApiRegistrar$Type());
  }

  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Ljava/lang/String;)LJniHostSmallApiRegistrar;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniHostSmallApiRegistrar getInstance(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostSmallApiRegistrar? getInstance(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getInstance(reference.pointer,
            _id_getInstance as jni$_.JMethodIDPtr, _$string.pointer)
        .object<JniHostSmallApiRegistrar?>(
            const $JniHostSmallApiRegistrar$NullableType());
  }

  static final _id_echo = _class.instanceMethodId(
    r'echo',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echo(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echo(
    jni$_.JString string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echo(reference.pointer, _id_echo as jni$_.JMethodIDPtr,
            _$string.pointer, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.JStringType(),
      releaseOriginal: true,
    );
  }

  static final _id_voidVoid = _class.instanceMethodId(
    r'voidVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _voidVoid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object voidVoid(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> voidVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _voidVoid(reference.pointer, _id_voidVoid as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }
}

final class $JniHostSmallApiRegistrar$NullableType
    extends jni$_.JObjType<JniHostSmallApiRegistrar?> {
  @jni$_.internal
  const $JniHostSmallApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostSmallApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniHostSmallApiRegistrar? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniHostSmallApiRegistrar.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $JniHostSmallApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostSmallApiRegistrar?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($JniHostSmallApiRegistrar$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostSmallApiRegistrar$NullableType) &&
        other is $JniHostSmallApiRegistrar$NullableType;
  }
}

final class $JniHostSmallApiRegistrar$Type
    extends jni$_.JObjType<JniHostSmallApiRegistrar> {
  @jni$_.internal
  const $JniHostSmallApiRegistrar$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostSmallApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniHostSmallApiRegistrar fromReference(jni$_.JReference reference) =>
      JniHostSmallApiRegistrar.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $JniHostSmallApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostSmallApiRegistrar?> get nullableType =>
      const $JniHostSmallApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($JniHostSmallApiRegistrar$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostSmallApiRegistrar$Type) &&
        other is $JniHostSmallApiRegistrar$Type;
  }
}

/// from: `JniUnusedClass$Companion`
class JniUnusedClass$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniUnusedClass$Companion> $type;

  @jni$_.internal
  JniUnusedClass$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniUnusedClass$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniUnusedClass$Companion$NullableType();
  static const type = $JniUnusedClass$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LJniUnusedClass;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniUnusedClass fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  JniUnusedClass fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<JniUnusedClass>(const $JniUnusedClass$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniUnusedClass$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniUnusedClass$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniUnusedClass$Companion$NullableType
    extends jni$_.JObjType<JniUnusedClass$Companion?> {
  @jni$_.internal
  const $JniUnusedClass$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniUnusedClass$Companion;';

  @jni$_.internal
  @core$_.override
  JniUnusedClass$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniUnusedClass$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniUnusedClass$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniUnusedClass$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniUnusedClass$Companion$NullableType) &&
        other is $JniUnusedClass$Companion$NullableType;
  }
}

final class $JniUnusedClass$Companion$Type
    extends jni$_.JObjType<JniUnusedClass$Companion> {
  @jni$_.internal
  const $JniUnusedClass$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniUnusedClass$Companion;';

  @jni$_.internal
  @core$_.override
  JniUnusedClass$Companion fromReference(jni$_.JReference reference) =>
      JniUnusedClass$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniUnusedClass$Companion?> get nullableType =>
      const $JniUnusedClass$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniUnusedClass$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniUnusedClass$Companion$Type) &&
        other is $JniUnusedClass$Companion$Type;
  }
}

/// from: `JniUnusedClass`
class JniUnusedClass extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniUnusedClass> $type;

  @jni$_.internal
  JniUnusedClass.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniUnusedClass');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniUnusedClass$NullableType();
  static const type = $JniUnusedClass$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniUnusedClass$Companion;',
  );

  /// from: `static public final JniUnusedClass$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniUnusedClass$Companion get Companion =>
      _id_Companion.get(_class, const $JniUnusedClass$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniUnusedClass(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return JniUnusedClass.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$object.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Object;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(java.lang.Object object, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniUnusedClass.new$1(
    jni$_.JObject? object,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniUnusedClass.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$object.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getAField = _class.instanceMethodId(
    r'getAField',
    r'()Ljava/lang/Object;',
  );

  static final _getAField = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object getAField()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getAField() {
    return _getAField(reference.pointer, _id_getAField as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/Object;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object component1()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/Object;)LJniUnusedClass;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniUnusedClass copy(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  JniUnusedClass copy(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _copy(
            reference.pointer, _id_copy as jni$_.JMethodIDPtr, _$object.pointer)
        .object<JniUnusedClass>(const $JniUnusedClass$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniUnusedClass.new$2() {
    return JniUnusedClass.fromReference(
        _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $JniUnusedClass$NullableType
    extends jni$_.JObjType<JniUnusedClass?> {
  @jni$_.internal
  const $JniUnusedClass$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniUnusedClass;';

  @jni$_.internal
  @core$_.override
  JniUnusedClass? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : JniUnusedClass.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniUnusedClass?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniUnusedClass$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniUnusedClass$NullableType) &&
        other is $JniUnusedClass$NullableType;
  }
}

final class $JniUnusedClass$Type extends jni$_.JObjType<JniUnusedClass> {
  @jni$_.internal
  const $JniUnusedClass$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniUnusedClass;';

  @jni$_.internal
  @core$_.override
  JniUnusedClass fromReference(jni$_.JReference reference) =>
      JniUnusedClass.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniUnusedClass?> get nullableType =>
      const $JniUnusedClass$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniUnusedClass$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniUnusedClass$Type) &&
        other is $JniUnusedClass$Type;
  }
}

/// from: `JniAllTypes$Companion`
class JniAllTypes$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllTypes$Companion> $type;

  @jni$_.internal
  JniAllTypes$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAllTypes$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAllTypes$Companion$NullableType();
  static const type = $JniAllTypes$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LJniAllTypes;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllTypes fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<JniAllTypes>(const $JniAllTypes$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllTypes$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllTypes$Companion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniAllTypes$Companion$NullableType
    extends jni$_.JObjType<JniAllTypes$Companion?> {
  @jni$_.internal
  const $JniAllTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllTypes$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllTypes$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllTypes$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllTypes$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllTypes$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllTypes$Companion$NullableType) &&
        other is $JniAllTypes$Companion$NullableType;
  }
}

final class $JniAllTypes$Companion$Type
    extends jni$_.JObjType<JniAllTypes$Companion> {
  @jni$_.internal
  const $JniAllTypes$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllTypes$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllTypes$Companion fromReference(jni$_.JReference reference) =>
      JniAllTypes$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllTypes$Companion?> get nullableType =>
      const $JniAllTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllTypes$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllTypes$Companion$Type) &&
        other is $JniAllTypes$Companion$Type;
  }
}

/// from: `JniAllTypes`
class JniAllTypes extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllTypes> $type;

  @jni$_.internal
  JniAllTypes.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAllTypes');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAllTypes$NullableType();
  static const type = $JniAllTypes$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniAllTypes$Companion;',
  );

  /// from: `static public final JniAllTypes$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAllTypes$Companion get Companion =>
      _id_Companion.get(_class, const $JniAllTypes$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(ZJJD[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(boolean z, long j, long j1, double d, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends JniAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<JniAnEnum, ? extends JniAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllTypes(
    bool z,
    int j,
    int j1,
    double d,
    jni$_.JByteArray bs,
    jni$_.JIntArray is$,
    jni$_.JLongArray js,
    jni$_.JDoubleArray ds,
    JniAnEnum jniAnEnum,
    JniAnotherEnum jniAnotherEnum,
    jni$_.JString string,
    jni$_.JObject object,
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JList<jni$_.JString> list1,
    jni$_.JList<jni$_.JLong> list2,
    jni$_.JList<jni$_.JDouble> list3,
    jni$_.JList<jni$_.JBoolean> list4,
    jni$_.JList<JniAnEnum> list5,
    jni$_.JList<jni$_.JObject> list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>> list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?> map,
    jni$_.JMap<jni$_.JString, jni$_.JString> map1,
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map2,
    jni$_.JMap<JniAnEnum, JniAnEnum> map3,
    jni$_.JMap<jni$_.JObject, jni$_.JObject> map4,
    jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> map5,
    jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> map6,
  ) {
    final _$bs = bs.reference;
    final _$is$ = is$.reference;
    final _$js = js.reference;
    final _$ds = ds.reference;
    final _$jniAnEnum = jniAnEnum.reference;
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    final _$string = string.reference;
    final _$object = object.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$list2 = list2.reference;
    final _$list3 = list3.reference;
    final _$list4 = list4.reference;
    final _$list5 = list5.reference;
    final _$list6 = list6.reference;
    final _$list7 = list7.reference;
    final _$list8 = list8.reference;
    final _$map = map.reference;
    final _$map1 = map1.reference;
    final _$map2 = map2.reference;
    final _$map3 = map3.reference;
    final _$map4 = map4.reference;
    final _$map5 = map5.reference;
    final _$map6 = map6.reference;
    return JniAllTypes.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            j,
            j1,
            d,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer)
        .reference);
  }

  static final _id_getABool = _class.instanceMethodId(
    r'getABool',
    r'()Z',
  );

  static final _getABool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final boolean getABool()`
  bool getABool() {
    return _getABool(reference.pointer, _id_getABool as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getAnInt = _class.instanceMethodId(
    r'getAnInt',
    r'()J',
  );

  static final _getAnInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long getAnInt()`
  int getAnInt() {
    return _getAnInt(reference.pointer, _id_getAnInt as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getAnInt64 = _class.instanceMethodId(
    r'getAnInt64',
    r'()J',
  );

  static final _getAnInt64 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long getAnInt64()`
  int getAnInt64() {
    return _getAnInt64(reference.pointer, _id_getAnInt64 as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getADouble = _class.instanceMethodId(
    r'getADouble',
    r'()D',
  );

  static final _getADouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double getADouble()`
  double getADouble() {
    return _getADouble(reference.pointer, _id_getADouble as jni$_.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getAByteArray = _class.instanceMethodId(
    r'getAByteArray',
    r'()[B',
  );

  static final _getAByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] getAByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray getAByteArray() {
    return _getAByteArray(
            reference.pointer, _id_getAByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_getA4ByteArray = _class.instanceMethodId(
    r'getA4ByteArray',
    r'()[I',
  );

  static final _getA4ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] getA4ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray getA4ByteArray() {
    return _getA4ByteArray(
            reference.pointer, _id_getA4ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray>(const jni$_.JIntArrayType());
  }

  static final _id_getA8ByteArray = _class.instanceMethodId(
    r'getA8ByteArray',
    r'()[J',
  );

  static final _getA8ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] getA8ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray getA8ByteArray() {
    return _getA8ByteArray(
            reference.pointer, _id_getA8ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray>(const jni$_.JLongArrayType());
  }

  static final _id_getAFloatArray = _class.instanceMethodId(
    r'getAFloatArray',
    r'()[D',
  );

  static final _getAFloatArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] getAFloatArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray getAFloatArray() {
    return _getAFloatArray(
            reference.pointer, _id_getAFloatArray as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray>(const jni$_.JDoubleArrayType());
  }

  static final _id_getAnEnum = _class.instanceMethodId(
    r'getAnEnum',
    r'()LJniAnEnum;',
  );

  static final _getAnEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnEnum getAnEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum getAnEnum() {
    return _getAnEnum(reference.pointer, _id_getAnEnum as jni$_.JMethodIDPtr)
        .object<JniAnEnum>(const $JniAnEnum$Type());
  }

  static final _id_getAnotherEnum = _class.instanceMethodId(
    r'getAnotherEnum',
    r'()LJniAnotherEnum;',
  );

  static final _getAnotherEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnotherEnum getAnotherEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum getAnotherEnum() {
    return _getAnotherEnum(
            reference.pointer, _id_getAnotherEnum as jni$_.JMethodIDPtr)
        .object<JniAnotherEnum>(const $JniAnotherEnum$Type());
  }

  static final _id_getAString = _class.instanceMethodId(
    r'getAString',
    r'()Ljava/lang/String;',
  );

  static final _getAString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getAString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getAString() {
    return _getAString(reference.pointer, _id_getAString as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getAnObject = _class.instanceMethodId(
    r'getAnObject',
    r'()Ljava/lang/Object;',
  );

  static final _getAnObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object getAnObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getAnObject() {
    return _getAnObject(
            reference.pointer, _id_getAnObject as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getList() {
    return _getList(reference.pointer, _id_getList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString> getStringList() {
    return _getStringList(
            reference.pointer, _id_getStringList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString>>(
            const jni$_.JListType<jni$_.JString>(jni$_.JStringType()));
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong> getIntList() {
    return _getIntList(reference.pointer, _id_getIntList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong>>(
            const jni$_.JListType<jni$_.JLong>(jni$_.JLongType()));
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble> getDoubleList() {
    return _getDoubleList(
            reference.pointer, _id_getDoubleList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble>>(
            const jni$_.JListType<jni$_.JDouble>(jni$_.JDoubleType()));
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean> getBoolList() {
    return _getBoolList(
            reference.pointer, _id_getBoolList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean>>(
            const jni$_.JListType<jni$_.JBoolean>(jni$_.JBooleanType()));
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum> getEnumList() {
    return _getEnumList(
            reference.pointer, _id_getEnumList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAnEnum>>(
            const jni$_.JListType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_getObjectList = _class.instanceMethodId(
    r'getObjectList',
    r'()Ljava/util/List;',
  );

  static final _getObjectList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getObjectList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject> getObjectList() {
    return _getObjectList(
            reference.pointer, _id_getObjectList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject>>(
            const jni$_.JListType<jni$_.JObject>(jni$_.JObjectType()));
  }

  static final _id_getListList = _class.instanceMethodId(
    r'getListList',
    r'()Ljava/util/List;',
  );

  static final _getListList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> getListList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>> getListList() {
    return _getListList(
            reference.pointer, _id_getListList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>>>(
            const jni$_.JListType<jni$_.JList<jni$_.JObject?>>(
                jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType())));
  }

  static final _id_getMapList = _class.instanceMethodId(
    r'getMapList',
    r'()Ljava/util/List;',
  );

  static final _getMapList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> getMapList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> getMapList() {
    return _getMapList(reference.pointer, _id_getMapList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(
            const jni$_.JListType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
                jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?> getMap() {
    return _getMap(reference.pointer, _id_getMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> getStringMap() {
    return _getStringMap(
            reference.pointer, _id_getStringMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_getIntMap = _class.instanceMethodId(
    r'getIntMap',
    r'()Ljava/util/Map;',
  );

  static final _getIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> getIntMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> getIntMap() {
    return _getIntMap(reference.pointer, _id_getIntMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_getEnumMap = _class.instanceMethodId(
    r'getEnumMap',
    r'()Ljava/util/Map;',
  );

  static final _getEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<JniAnEnum, JniAnEnum> getEnumMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum> getEnumMap() {
    return _getEnumMap(reference.pointer, _id_getEnumMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>>(
            const jni$_.JMapType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_getObjectMap = _class.instanceMethodId(
    r'getObjectMap',
    r'()Ljava/util/Map;',
  );

  static final _getObjectMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getObjectMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject> getObjectMap() {
    return _getObjectMap(
            reference.pointer, _id_getObjectMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject>>(
            const jni$_.JMapType<jni$_.JObject, jni$_.JObject>(
                jni$_.JObjectType(), jni$_.JObjectType()));
  }

  static final _id_getListMap = _class.instanceMethodId(
    r'getListMap',
    r'()Ljava/util/Map;',
  );

  static final _getListMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> getListMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> getListMap() {
    return _getListMap(reference.pointer, _id_getListMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JList<jni$_.JObject?>>(
                jni$_.JLongType(),
                jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType())));
  }

  static final _id_getMapMap = _class.instanceMethodId(
    r'getMapMap',
    r'()Ljava/util/Map;',
  );

  static final _getMapMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> getMapMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>
      getMapMap() {
    return _getMapMap(reference.pointer, _id_getMapMap as jni$_.JMethodIDPtr)
        .object<
            jni$_.JMap<jni$_.JLong,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(const jni$_
            .JMapType<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            jni$_.JLongType(),
            jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Z',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final boolean component1()`
  bool component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()J',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long component2()`
  int component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()J',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long component3()`
  int component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()D',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double component4()`
  double component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()[B',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] component5()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()[I',
  );

  static final _component6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] component6()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray component6() {
    return _component6(reference.pointer, _id_component6 as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray>(const jni$_.JIntArrayType());
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()[J',
  );

  static final _component7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] component7()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray component7() {
    return _component7(reference.pointer, _id_component7 as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray>(const jni$_.JLongArrayType());
  }

  static final _id_component8 = _class.instanceMethodId(
    r'component8',
    r'()[D',
  );

  static final _component8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] component8()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray component8() {
    return _component8(reference.pointer, _id_component8 as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray>(const jni$_.JDoubleArrayType());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()LJniAnEnum;',
  );

  static final _component9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnEnum component9()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum component9() {
    return _component9(reference.pointer, _id_component9 as jni$_.JMethodIDPtr)
        .object<JniAnEnum>(const $JniAnEnum$Type());
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()LJniAnotherEnum;',
  );

  static final _component10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnotherEnum component10()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum component10() {
    return _component10(
            reference.pointer, _id_component10 as jni$_.JMethodIDPtr)
        .object<JniAnotherEnum>(const $JniAnotherEnum$Type());
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/lang/String;',
  );

  static final _component11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component11()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString component11() {
    return _component11(
            reference.pointer, _id_component11 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/lang/Object;',
  );

  static final _component12 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object component12()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject component12() {
    return _component12(
            reference.pointer, _id_component12 as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()Ljava/util/List;',
  );

  static final _component13 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component13()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> component13() {
    return _component13(
            reference.pointer, _id_component13 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> component14()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString> component14() {
    return _component14(
            reference.pointer, _id_component14 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString>>(
            const jni$_.JListType<jni$_.JString>(jni$_.JStringType()));
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/List;',
  );

  static final _component15 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> component15()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong> component15() {
    return _component15(
            reference.pointer, _id_component15 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong>>(
            const jni$_.JListType<jni$_.JLong>(jni$_.JLongType()));
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/List;',
  );

  static final _component16 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> component16()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble> component16() {
    return _component16(
            reference.pointer, _id_component16 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble>>(
            const jni$_.JListType<jni$_.JDouble>(jni$_.JDoubleType()));
  }

  static final _id_component17 = _class.instanceMethodId(
    r'component17',
    r'()Ljava/util/List;',
  );

  static final _component17 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> component17()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean> component17() {
    return _component17(
            reference.pointer, _id_component17 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean>>(
            const jni$_.JListType<jni$_.JBoolean>(jni$_.JBooleanType()));
  }

  static final _id_component18 = _class.instanceMethodId(
    r'component18',
    r'()Ljava/util/List;',
  );

  static final _component18 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAnEnum> component18()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum> component18() {
    return _component18(
            reference.pointer, _id_component18 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAnEnum>>(
            const jni$_.JListType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_component19 = _class.instanceMethodId(
    r'component19',
    r'()Ljava/util/List;',
  );

  static final _component19 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component19()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject> component19() {
    return _component19(
            reference.pointer, _id_component19 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject>>(
            const jni$_.JListType<jni$_.JObject>(jni$_.JObjectType()));
  }

  static final _id_component20 = _class.instanceMethodId(
    r'component20',
    r'()Ljava/util/List;',
  );

  static final _component20 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> component20()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>> component20() {
    return _component20(
            reference.pointer, _id_component20 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>>>(
            const jni$_.JListType<jni$_.JList<jni$_.JObject?>>(
                jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType())));
  }

  static final _id_component21 = _class.instanceMethodId(
    r'component21',
    r'()Ljava/util/List;',
  );

  static final _component21 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> component21()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> component21() {
    return _component21(
            reference.pointer, _id_component21 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(
            const jni$_.JListType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
                jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_component22 = _class.instanceMethodId(
    r'component22',
    r'()Ljava/util/Map;',
  );

  static final _component22 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component22()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?> component22() {
    return _component22(
            reference.pointer, _id_component22 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_component23 = _class.instanceMethodId(
    r'component23',
    r'()Ljava/util/Map;',
  );

  static final _component23 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> component23()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> component23() {
    return _component23(
            reference.pointer, _id_component23 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_component24 = _class.instanceMethodId(
    r'component24',
    r'()Ljava/util/Map;',
  );

  static final _component24 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> component24()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> component24() {
    return _component24(
            reference.pointer, _id_component24 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_component25 = _class.instanceMethodId(
    r'component25',
    r'()Ljava/util/Map;',
  );

  static final _component25 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<JniAnEnum, JniAnEnum> component25()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum> component25() {
    return _component25(
            reference.pointer, _id_component25 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>>(
            const jni$_.JMapType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_component26 = _class.instanceMethodId(
    r'component26',
    r'()Ljava/util/Map;',
  );

  static final _component26 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component26()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject> component26() {
    return _component26(
            reference.pointer, _id_component26 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject>>(
            const jni$_.JMapType<jni$_.JObject, jni$_.JObject>(
                jni$_.JObjectType(), jni$_.JObjectType()));
  }

  static final _id_component27 = _class.instanceMethodId(
    r'component27',
    r'()Ljava/util/Map;',
  );

  static final _component27 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> component27()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> component27() {
    return _component27(
            reference.pointer, _id_component27 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JList<jni$_.JObject?>>(
                jni$_.JLongType(),
                jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType())));
  }

  static final _id_component28 = _class.instanceMethodId(
    r'component28',
    r'()Ljava/util/Map;',
  );

  static final _component28 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> component28()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>
      component28() {
    return _component28(
            reference.pointer, _id_component28 as jni$_.JMethodIDPtr)
        .object<
            jni$_.JMap<jni$_.JLong,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(const jni$_
            .JMapType<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            jni$_.JLongType(),
            jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(ZJJD[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)LJniAllTypes;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllTypes copy(boolean z, long j, long j1, double d, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends JniAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<JniAnEnum, ? extends JniAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes copy(
    bool z,
    int j,
    int j1,
    double d,
    jni$_.JByteArray bs,
    jni$_.JIntArray is$,
    jni$_.JLongArray js,
    jni$_.JDoubleArray ds,
    JniAnEnum jniAnEnum,
    JniAnotherEnum jniAnotherEnum,
    jni$_.JString string,
    jni$_.JObject object,
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JList<jni$_.JString> list1,
    jni$_.JList<jni$_.JLong> list2,
    jni$_.JList<jni$_.JDouble> list3,
    jni$_.JList<jni$_.JBoolean> list4,
    jni$_.JList<JniAnEnum> list5,
    jni$_.JList<jni$_.JObject> list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>> list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?> map,
    jni$_.JMap<jni$_.JString, jni$_.JString> map1,
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map2,
    jni$_.JMap<JniAnEnum, JniAnEnum> map3,
    jni$_.JMap<jni$_.JObject, jni$_.JObject> map4,
    jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> map5,
    jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> map6,
  ) {
    final _$bs = bs.reference;
    final _$is$ = is$.reference;
    final _$js = js.reference;
    final _$ds = ds.reference;
    final _$jniAnEnum = jniAnEnum.reference;
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    final _$string = string.reference;
    final _$object = object.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$list2 = list2.reference;
    final _$list3 = list3.reference;
    final _$list4 = list4.reference;
    final _$list5 = list5.reference;
    final _$list6 = list6.reference;
    final _$list7 = list7.reference;
    final _$list8 = list8.reference;
    final _$map = map.reference;
    final _$map1 = map1.reference;
    final _$map2 = map2.reference;
    final _$map3 = map3.reference;
    final _$map4 = map4.reference;
    final _$map5 = map5.reference;
    final _$map6 = map6.reference;
    return _copy(
            reference.pointer,
            _id_copy as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            j,
            j1,
            d,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer)
        .object<JniAllTypes>(const $JniAllTypes$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $JniAllTypes$NullableType extends jni$_.JObjType<JniAllTypes?> {
  @jni$_.internal
  const $JniAllTypes$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllTypes;';

  @jni$_.internal
  @core$_.override
  JniAllTypes? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : JniAllTypes.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllTypes?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllTypes$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllTypes$NullableType) &&
        other is $JniAllTypes$NullableType;
  }
}

final class $JniAllTypes$Type extends jni$_.JObjType<JniAllTypes> {
  @jni$_.internal
  const $JniAllTypes$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllTypes;';

  @jni$_.internal
  @core$_.override
  JniAllTypes fromReference(jni$_.JReference reference) =>
      JniAllTypes.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllTypes?> get nullableType =>
      const $JniAllTypes$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllTypes$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllTypes$Type) &&
        other is $JniAllTypes$Type;
  }
}

/// from: `JniAllNullableTypes$Companion`
class JniAllNullableTypes$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllNullableTypes$Companion> $type;

  @jni$_.internal
  JniAllNullableTypes$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAllNullableTypes$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAllNullableTypes$Companion$NullableType();
  static const type = $JniAllNullableTypes$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LJniAllNullableTypes;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllNullableTypes fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypes$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllNullableTypes$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniAllNullableTypes$Companion$NullableType
    extends jni$_.JObjType<JniAllNullableTypes$Companion?> {
  @jni$_.internal
  const $JniAllNullableTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypes$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypes$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllNullableTypes$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypes$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllNullableTypes$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllNullableTypes$Companion$NullableType) &&
        other is $JniAllNullableTypes$Companion$NullableType;
  }
}

final class $JniAllNullableTypes$Companion$Type
    extends jni$_.JObjType<JniAllNullableTypes$Companion> {
  @jni$_.internal
  const $JniAllNullableTypes$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypes$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypes$Companion fromReference(jni$_.JReference reference) =>
      JniAllNullableTypes$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypes$Companion?> get nullableType =>
      const $JniAllNullableTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllNullableTypes$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllNullableTypes$Companion$Type) &&
        other is $JniAllNullableTypes$Companion$Type;
  }
}

/// from: `JniAllNullableTypes`
class JniAllNullableTypes extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllNullableTypes> $type;

  @jni$_.internal
  JniAllNullableTypes.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAllNullableTypes');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAllNullableTypes$NullableType();
  static const type = $JniAllNullableTypes$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniAllNullableTypes$Companion;',
  );

  /// from: `static public final JniAllNullableTypes$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAllNullableTypes$Companion get Companion =>
      _id_Companion.get(_class, const $JniAllNullableTypes$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;LJniAllNullableTypes;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, JniAllNullableTypes jniAllNullableTypes, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends JniAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.List<JniAllNullableTypes> list9, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<JniAnEnum, ? extends JniAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6, java.util.Map<java.lang.Long, JniAllNullableTypes> map7)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    JniAnEnum? jniAnEnum,
    JniAnotherEnum? jniAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    JniAllNullableTypes? jniAllNullableTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<JniAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JList<JniAllNullableTypes?>? list9,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map7,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$list9 = list9?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$map7 = map7?.reference ?? jni$_.jNullReference;
    return JniAllNullableTypes.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$jniAllNullableTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$list9.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer,
            _$map7.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;LJniAllNullableTypes;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, JniAllNullableTypes jniAllNullableTypes, java.util.List list, java.util.List list1, java.util.List list2, java.util.List list3, java.util.List list4, java.util.List list5, java.util.List list6, java.util.List list7, java.util.List list8, java.util.List list9, java.util.Map map, java.util.Map map1, java.util.Map map2, java.util.Map map3, java.util.Map map4, java.util.Map map5, java.util.Map map6, java.util.Map map7, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypes.new$1(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    JniAnEnum? jniAnEnum,
    JniAnotherEnum? jniAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    JniAllNullableTypes? jniAllNullableTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    jni$_.JList<jni$_.JObject?>? list2,
    jni$_.JList<jni$_.JObject?>? list3,
    jni$_.JList<jni$_.JObject?>? list4,
    jni$_.JList<jni$_.JObject?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JObject?>? list7,
    jni$_.JList<jni$_.JObject?>? list8,
    jni$_.JList<jni$_.JObject?>? list9,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map1,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map2,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map5,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map6,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map7,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$list9 = list9?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$map7 = map7?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllNullableTypes.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$jniAllNullableTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$list9.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer,
            _$map7.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getANullableBool = _class.instanceMethodId(
    r'getANullableBool',
    r'()Ljava/lang/Boolean;',
  );

  static final _getANullableBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Boolean getANullableBool()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? getANullableBool() {
    return _getANullableBool(
            reference.pointer, _id_getANullableBool as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_getANullableInt = _class.instanceMethodId(
    r'getANullableInt',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long getANullableInt()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt() {
    return _getANullableInt(
            reference.pointer, _id_getANullableInt as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_getANullableInt64 = _class.instanceMethodId(
    r'getANullableInt64',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt64 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long getANullableInt64()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt64() {
    return _getANullableInt64(
            reference.pointer, _id_getANullableInt64 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_getANullableDouble = _class.instanceMethodId(
    r'getANullableDouble',
    r'()Ljava/lang/Double;',
  );

  static final _getANullableDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Double getANullableDouble()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getANullableDouble() {
    return _getANullableDouble(
            reference.pointer, _id_getANullableDouble as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_getANullableByteArray = _class.instanceMethodId(
    r'getANullableByteArray',
    r'()[B',
  );

  static final _getANullableByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] getANullableByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getANullableByteArray() {
    return _getANullableByteArray(
            reference.pointer, _id_getANullableByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_getANullable4ByteArray = _class.instanceMethodId(
    r'getANullable4ByteArray',
    r'()[I',
  );

  static final _getANullable4ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] getANullable4ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? getANullable4ByteArray() {
    return _getANullable4ByteArray(
            reference.pointer, _id_getANullable4ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_getANullable8ByteArray = _class.instanceMethodId(
    r'getANullable8ByteArray',
    r'()[J',
  );

  static final _getANullable8ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] getANullable8ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? getANullable8ByteArray() {
    return _getANullable8ByteArray(
            reference.pointer, _id_getANullable8ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_getANullableFloatArray = _class.instanceMethodId(
    r'getANullableFloatArray',
    r'()[D',
  );

  static final _getANullableFloatArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] getANullableFloatArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? getANullableFloatArray() {
    return _getANullableFloatArray(
            reference.pointer, _id_getANullableFloatArray as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_getANullableEnum = _class.instanceMethodId(
    r'getANullableEnum',
    r'()LJniAnEnum;',
  );

  static final _getANullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnEnum getANullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? getANullableEnum() {
    return _getANullableEnum(
            reference.pointer, _id_getANullableEnum as jni$_.JMethodIDPtr)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_getAnotherNullableEnum = _class.instanceMethodId(
    r'getAnotherNullableEnum',
    r'()LJniAnotherEnum;',
  );

  static final _getAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnotherEnum getAnotherNullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? getAnotherNullableEnum() {
    return _getAnotherNullableEnum(
            reference.pointer, _id_getAnotherNullableEnum as jni$_.JMethodIDPtr)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_getANullableString = _class.instanceMethodId(
    r'getANullableString',
    r'()Ljava/lang/String;',
  );

  static final _getANullableString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getANullableString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getANullableString() {
    return _getANullableString(
            reference.pointer, _id_getANullableString as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getANullableObject = _class.instanceMethodId(
    r'getANullableObject',
    r'()Ljava/lang/Object;',
  );

  static final _getANullableObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object getANullableObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getANullableObject() {
    return _getANullableObject(
            reference.pointer, _id_getANullableObject as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getAllNullableTypes = _class.instanceMethodId(
    r'getAllNullableTypes',
    r'()LJniAllNullableTypes;',
  );

  static final _getAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllNullableTypes getAllNullableTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes? getAllNullableTypes() {
    return _getAllNullableTypes(
            reference.pointer, _id_getAllNullableTypes as jni$_.JMethodIDPtr)
        .object<JniAllNullableTypes?>(
            const $JniAllNullableTypes$NullableType());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getList() {
    return _getList(reference.pointer, _id_getList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getStringList() {
    return _getStringList(
            reference.pointer, _id_getStringList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? getIntList() {
    return _getIntList(reference.pointer, _id_getIntList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong?>?>(
            const jni$_.JListNullableType<jni$_.JLong?>(
                jni$_.JLongNullableType()));
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? getDoubleList() {
    return _getDoubleList(
            reference.pointer, _id_getDoubleList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble?>?>(
            const jni$_.JListNullableType<jni$_.JDouble?>(
                jni$_.JDoubleNullableType()));
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? getBoolList() {
    return _getBoolList(
            reference.pointer, _id_getBoolList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean?>?>(
            const jni$_.JListNullableType<jni$_.JBoolean?>(
                jni$_.JBooleanNullableType()));
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? getEnumList() {
    return _getEnumList(
            reference.pointer, _id_getEnumList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_getObjectList = _class.instanceMethodId(
    r'getObjectList',
    r'()Ljava/util/List;',
  );

  static final _getObjectList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getObjectList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getObjectList() {
    return _getObjectList(
            reference.pointer, _id_getObjectList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getListList = _class.instanceMethodId(
    r'getListList',
    r'()Ljava/util/List;',
  );

  static final _getListList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> getListList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? getListList() {
    return _getListList(
            reference.pointer, _id_getListList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_.JListNullableType<jni$_.JList<jni$_.JObject?>?>(
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_getMapList = _class.instanceMethodId(
    r'getMapList',
    r'()Ljava/util/List;',
  );

  static final _getMapList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> getMapList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? getMapList() {
    return _getMapList(reference.pointer, _id_getMapList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_
                .JListNullableType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_getRecursiveClassList = _class.instanceMethodId(
    r'getRecursiveClassList',
    r'()Ljava/util/List;',
  );

  static final _getRecursiveClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAllNullableTypes> getRecursiveClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?>? getRecursiveClassList() {
    return _getRecursiveClassList(
            reference.pointer, _id_getRecursiveClassList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAllNullableTypes?>?>(
            const jni$_.JListNullableType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? getMap() {
    return _getMap(reference.pointer, _id_getMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? getStringMap() {
    return _getStringMap(
            reference.pointer, _id_getStringMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_getIntMap = _class.instanceMethodId(
    r'getIntMap',
    r'()Ljava/util/Map;',
  );

  static final _getIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> getIntMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? getIntMap() {
    return _getIntMap(reference.pointer, _id_getIntMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_getEnumMap = _class.instanceMethodId(
    r'getEnumMap',
    r'()Ljava/util/Map;',
  );

  static final _getEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<JniAnEnum, JniAnEnum> getEnumMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? getEnumMap() {
    return _getEnumMap(reference.pointer, _id_getEnumMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_getObjectMap = _class.instanceMethodId(
    r'getObjectMap',
    r'()Ljava/util/Map;',
  );

  static final _getObjectMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getObjectMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? getObjectMap() {
    return _getObjectMap(
            reference.pointer, _id_getObjectMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_getListMap = _class.instanceMethodId(
    r'getListMap',
    r'()Ljava/util/Map;',
  );

  static final _getListMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> getListMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? getListMap() {
    return _getListMap(reference.pointer, _id_getListMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_
                .JMapNullableType<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_getMapMap = _class.instanceMethodId(
    r'getMapMap',
    r'()Ljava/util/Map;',
  );

  static final _getMapMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> getMapMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
      getMapMap() {
    return _getMapMap(reference.pointer, _id_getMapMap as jni$_.JMethodIDPtr)
        .object<
                jni$_.JMap<jni$_.JLong?,
                    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?,
                    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_getRecursiveClassMap = _class.instanceMethodId(
    r'getRecursiveClassMap',
    r'()Ljava/util/Map;',
  );

  static final _getRecursiveClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, JniAllNullableTypes> getRecursiveClassMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? getRecursiveClassMap() {
    return _getRecursiveClassMap(
            reference.pointer, _id_getRecursiveClassMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/Boolean;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Boolean component1()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()Ljava/lang/Long;',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long component2()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()Ljava/lang/Long;',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long component3()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/lang/Double;',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Double component4()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()[B',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] component5()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()[I',
  );

  static final _component6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] component6()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? component6() {
    return _component6(reference.pointer, _id_component6 as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()[J',
  );

  static final _component7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] component7()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? component7() {
    return _component7(reference.pointer, _id_component7 as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_component8 = _class.instanceMethodId(
    r'component8',
    r'()[D',
  );

  static final _component8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] component8()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? component8() {
    return _component8(reference.pointer, _id_component8 as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()LJniAnEnum;',
  );

  static final _component9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnEnum component9()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? component9() {
    return _component9(reference.pointer, _id_component9 as jni$_.JMethodIDPtr)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()LJniAnotherEnum;',
  );

  static final _component10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnotherEnum component10()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? component10() {
    return _component10(
            reference.pointer, _id_component10 as jni$_.JMethodIDPtr)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/lang/String;',
  );

  static final _component11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component11()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? component11() {
    return _component11(
            reference.pointer, _id_component11 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/lang/Object;',
  );

  static final _component12 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object component12()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? component12() {
    return _component12(
            reference.pointer, _id_component12 as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()LJniAllNullableTypes;',
  );

  static final _component13 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllNullableTypes component13()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes? component13() {
    return _component13(
            reference.pointer, _id_component13 as jni$_.JMethodIDPtr)
        .object<JniAllNullableTypes?>(
            const $JniAllNullableTypes$NullableType());
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component14()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component14() {
    return _component14(
            reference.pointer, _id_component14 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/List;',
  );

  static final _component15 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> component15()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? component15() {
    return _component15(
            reference.pointer, _id_component15 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/List;',
  );

  static final _component16 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> component16()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? component16() {
    return _component16(
            reference.pointer, _id_component16 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong?>?>(
            const jni$_.JListNullableType<jni$_.JLong?>(
                jni$_.JLongNullableType()));
  }

  static final _id_component17 = _class.instanceMethodId(
    r'component17',
    r'()Ljava/util/List;',
  );

  static final _component17 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> component17()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? component17() {
    return _component17(
            reference.pointer, _id_component17 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble?>?>(
            const jni$_.JListNullableType<jni$_.JDouble?>(
                jni$_.JDoubleNullableType()));
  }

  static final _id_component18 = _class.instanceMethodId(
    r'component18',
    r'()Ljava/util/List;',
  );

  static final _component18 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> component18()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? component18() {
    return _component18(
            reference.pointer, _id_component18 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean?>?>(
            const jni$_.JListNullableType<jni$_.JBoolean?>(
                jni$_.JBooleanNullableType()));
  }

  static final _id_component19 = _class.instanceMethodId(
    r'component19',
    r'()Ljava/util/List;',
  );

  static final _component19 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAnEnum> component19()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? component19() {
    return _component19(
            reference.pointer, _id_component19 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_component20 = _class.instanceMethodId(
    r'component20',
    r'()Ljava/util/List;',
  );

  static final _component20 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component20()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component20() {
    return _component20(
            reference.pointer, _id_component20 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_component21 = _class.instanceMethodId(
    r'component21',
    r'()Ljava/util/List;',
  );

  static final _component21 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> component21()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? component21() {
    return _component21(
            reference.pointer, _id_component21 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_.JListNullableType<jni$_.JList<jni$_.JObject?>?>(
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_component22 = _class.instanceMethodId(
    r'component22',
    r'()Ljava/util/List;',
  );

  static final _component22 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> component22()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? component22() {
    return _component22(
            reference.pointer, _id_component22 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_
                .JListNullableType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_component23 = _class.instanceMethodId(
    r'component23',
    r'()Ljava/util/List;',
  );

  static final _component23 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAllNullableTypes> component23()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?>? component23() {
    return _component23(
            reference.pointer, _id_component23 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAllNullableTypes?>?>(
            const jni$_.JListNullableType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_component24 = _class.instanceMethodId(
    r'component24',
    r'()Ljava/util/Map;',
  );

  static final _component24 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component24()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? component24() {
    return _component24(
            reference.pointer, _id_component24 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_component25 = _class.instanceMethodId(
    r'component25',
    r'()Ljava/util/Map;',
  );

  static final _component25 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> component25()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? component25() {
    return _component25(
            reference.pointer, _id_component25 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_component26 = _class.instanceMethodId(
    r'component26',
    r'()Ljava/util/Map;',
  );

  static final _component26 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> component26()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? component26() {
    return _component26(
            reference.pointer, _id_component26 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_component27 = _class.instanceMethodId(
    r'component27',
    r'()Ljava/util/Map;',
  );

  static final _component27 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<JniAnEnum, JniAnEnum> component27()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? component27() {
    return _component27(
            reference.pointer, _id_component27 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_component28 = _class.instanceMethodId(
    r'component28',
    r'()Ljava/util/Map;',
  );

  static final _component28 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component28()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? component28() {
    return _component28(
            reference.pointer, _id_component28 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_component29 = _class.instanceMethodId(
    r'component29',
    r'()Ljava/util/Map;',
  );

  static final _component29 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> component29()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? component29() {
    return _component29(
            reference.pointer, _id_component29 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_
                .JMapNullableType<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_component30 = _class.instanceMethodId(
    r'component30',
    r'()Ljava/util/Map;',
  );

  static final _component30 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> component30()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
      component30() {
    return _component30(reference.pointer, _id_component30 as jni$_.JMethodIDPtr)
        .object<
            jni$_.JMap<jni$_.JLong?,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(const jni$_
            .JMapNullableType<jni$_.JLong?,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            jni$_.JLongNullableType(),
            jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_component31 = _class.instanceMethodId(
    r'component31',
    r'()Ljava/util/Map;',
  );

  static final _component31 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, JniAllNullableTypes> component31()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? component31() {
    return _component31(
            reference.pointer, _id_component31 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;LJniAllNullableTypes;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)LJniAllNullableTypes;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllNullableTypes copy(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, JniAllNullableTypes jniAllNullableTypes, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends JniAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.List<JniAllNullableTypes> list9, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<JniAnEnum, ? extends JniAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6, java.util.Map<java.lang.Long, JniAllNullableTypes> map7)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes copy(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    JniAnEnum? jniAnEnum,
    JniAnotherEnum? jniAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    JniAllNullableTypes? jniAllNullableTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<JniAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JList<JniAllNullableTypes?>? list9,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map7,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$list9 = list9?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$map7 = map7?.reference ?? jni$_.jNullReference;
    return _copy(
            reference.pointer,
            _id_copy as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$jniAllNullableTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$list9.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer,
            _$map7.pointer)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypes.new$2() {
    return JniAllNullableTypes.fromReference(
        _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $JniAllNullableTypes$NullableType
    extends jni$_.JObjType<JniAllNullableTypes?> {
  @jni$_.internal
  const $JniAllNullableTypes$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypes;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypes? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllNullableTypes.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypes?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllNullableTypes$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllNullableTypes$NullableType) &&
        other is $JniAllNullableTypes$NullableType;
  }
}

final class $JniAllNullableTypes$Type
    extends jni$_.JObjType<JniAllNullableTypes> {
  @jni$_.internal
  const $JniAllNullableTypes$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypes;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypes fromReference(jni$_.JReference reference) =>
      JniAllNullableTypes.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypes?> get nullableType =>
      const $JniAllNullableTypes$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllNullableTypes$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllNullableTypes$Type) &&
        other is $JniAllNullableTypes$Type;
  }
}

/// from: `JniAllNullableTypesWithoutRecursion$Companion`
class JniAllNullableTypesWithoutRecursion$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllNullableTypesWithoutRecursion$Companion> $type;

  @jni$_.internal
  JniAllNullableTypesWithoutRecursion$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'JniAllNullableTypesWithoutRecursion$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $JniAllNullableTypesWithoutRecursion$Companion$NullableType();
  static const type = $JniAllNullableTypesWithoutRecursion$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllNullableTypesWithoutRecursion fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<JniAllNullableTypesWithoutRecursion>(
            const $JniAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypesWithoutRecursion$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllNullableTypesWithoutRecursion$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniAllNullableTypesWithoutRecursion$Companion$NullableType
    extends jni$_.JObjType<JniAllNullableTypesWithoutRecursion$Companion?> {
  @jni$_.internal
  const $JniAllNullableTypesWithoutRecursion$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypesWithoutRecursion$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypesWithoutRecursion$Companion? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllNullableTypesWithoutRecursion$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypesWithoutRecursion$Companion?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($JniAllNullableTypesWithoutRecursion$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JniAllNullableTypesWithoutRecursion$Companion$NullableType) &&
        other is $JniAllNullableTypesWithoutRecursion$Companion$NullableType;
  }
}

final class $JniAllNullableTypesWithoutRecursion$Companion$Type
    extends jni$_.JObjType<JniAllNullableTypesWithoutRecursion$Companion> {
  @jni$_.internal
  const $JniAllNullableTypesWithoutRecursion$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypesWithoutRecursion$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypesWithoutRecursion$Companion fromReference(
          jni$_.JReference reference) =>
      JniAllNullableTypesWithoutRecursion$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypesWithoutRecursion$Companion?>
      get nullableType =>
          const $JniAllNullableTypesWithoutRecursion$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($JniAllNullableTypesWithoutRecursion$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JniAllNullableTypesWithoutRecursion$Companion$Type) &&
        other is $JniAllNullableTypesWithoutRecursion$Companion$Type;
  }
}

/// from: `JniAllNullableTypesWithoutRecursion`
class JniAllNullableTypesWithoutRecursion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllNullableTypesWithoutRecursion> $type;

  @jni$_.internal
  JniAllNullableTypesWithoutRecursion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'JniAllNullableTypesWithoutRecursion');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $JniAllNullableTypesWithoutRecursion$NullableType();
  static const type = $JniAllNullableTypesWithoutRecursion$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniAllNullableTypesWithoutRecursion$Companion;',
  );

  /// from: `static public final JniAllNullableTypesWithoutRecursion$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAllNullableTypesWithoutRecursion$Companion get Companion =>
      _id_Companion.get(
          _class, const $JniAllNullableTypesWithoutRecursion$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends JniAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<JniAnEnum, ? extends JniAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    JniAnEnum? jniAnEnum,
    JniAnotherEnum? jniAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<JniAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    return JniAllNullableTypesWithoutRecursion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List list, java.util.List list1, java.util.List list2, java.util.List list3, java.util.List list4, java.util.List list5, java.util.List list6, java.util.List list7, java.util.List list8, java.util.Map map, java.util.Map map1, java.util.Map map2, java.util.Map map3, java.util.Map map4, java.util.Map map5, java.util.Map map6, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypesWithoutRecursion.new$1(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    JniAnEnum? jniAnEnum,
    JniAnotherEnum? jniAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    jni$_.JList<jni$_.JObject?>? list2,
    jni$_.JList<jni$_.JObject?>? list3,
    jni$_.JList<jni$_.JObject?>? list4,
    jni$_.JList<jni$_.JObject?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JObject?>? list7,
    jni$_.JList<jni$_.JObject?>? list8,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map1,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map2,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map5,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map6,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllNullableTypesWithoutRecursion.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getANullableBool = _class.instanceMethodId(
    r'getANullableBool',
    r'()Ljava/lang/Boolean;',
  );

  static final _getANullableBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Boolean getANullableBool()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? getANullableBool() {
    return _getANullableBool(
            reference.pointer, _id_getANullableBool as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_getANullableInt = _class.instanceMethodId(
    r'getANullableInt',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long getANullableInt()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt() {
    return _getANullableInt(
            reference.pointer, _id_getANullableInt as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_getANullableInt64 = _class.instanceMethodId(
    r'getANullableInt64',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt64 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long getANullableInt64()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt64() {
    return _getANullableInt64(
            reference.pointer, _id_getANullableInt64 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_getANullableDouble = _class.instanceMethodId(
    r'getANullableDouble',
    r'()Ljava/lang/Double;',
  );

  static final _getANullableDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Double getANullableDouble()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getANullableDouble() {
    return _getANullableDouble(
            reference.pointer, _id_getANullableDouble as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_getANullableByteArray = _class.instanceMethodId(
    r'getANullableByteArray',
    r'()[B',
  );

  static final _getANullableByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] getANullableByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getANullableByteArray() {
    return _getANullableByteArray(
            reference.pointer, _id_getANullableByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_getANullable4ByteArray = _class.instanceMethodId(
    r'getANullable4ByteArray',
    r'()[I',
  );

  static final _getANullable4ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] getANullable4ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? getANullable4ByteArray() {
    return _getANullable4ByteArray(
            reference.pointer, _id_getANullable4ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_getANullable8ByteArray = _class.instanceMethodId(
    r'getANullable8ByteArray',
    r'()[J',
  );

  static final _getANullable8ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] getANullable8ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? getANullable8ByteArray() {
    return _getANullable8ByteArray(
            reference.pointer, _id_getANullable8ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_getANullableFloatArray = _class.instanceMethodId(
    r'getANullableFloatArray',
    r'()[D',
  );

  static final _getANullableFloatArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] getANullableFloatArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? getANullableFloatArray() {
    return _getANullableFloatArray(
            reference.pointer, _id_getANullableFloatArray as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_getANullableEnum = _class.instanceMethodId(
    r'getANullableEnum',
    r'()LJniAnEnum;',
  );

  static final _getANullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnEnum getANullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? getANullableEnum() {
    return _getANullableEnum(
            reference.pointer, _id_getANullableEnum as jni$_.JMethodIDPtr)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_getAnotherNullableEnum = _class.instanceMethodId(
    r'getAnotherNullableEnum',
    r'()LJniAnotherEnum;',
  );

  static final _getAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnotherEnum getAnotherNullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? getAnotherNullableEnum() {
    return _getAnotherNullableEnum(
            reference.pointer, _id_getAnotherNullableEnum as jni$_.JMethodIDPtr)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_getANullableString = _class.instanceMethodId(
    r'getANullableString',
    r'()Ljava/lang/String;',
  );

  static final _getANullableString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getANullableString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getANullableString() {
    return _getANullableString(
            reference.pointer, _id_getANullableString as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getANullableObject = _class.instanceMethodId(
    r'getANullableObject',
    r'()Ljava/lang/Object;',
  );

  static final _getANullableObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object getANullableObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getANullableObject() {
    return _getANullableObject(
            reference.pointer, _id_getANullableObject as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getList() {
    return _getList(reference.pointer, _id_getList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getStringList() {
    return _getStringList(
            reference.pointer, _id_getStringList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? getIntList() {
    return _getIntList(reference.pointer, _id_getIntList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong?>?>(
            const jni$_.JListNullableType<jni$_.JLong?>(
                jni$_.JLongNullableType()));
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? getDoubleList() {
    return _getDoubleList(
            reference.pointer, _id_getDoubleList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble?>?>(
            const jni$_.JListNullableType<jni$_.JDouble?>(
                jni$_.JDoubleNullableType()));
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? getBoolList() {
    return _getBoolList(
            reference.pointer, _id_getBoolList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean?>?>(
            const jni$_.JListNullableType<jni$_.JBoolean?>(
                jni$_.JBooleanNullableType()));
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? getEnumList() {
    return _getEnumList(
            reference.pointer, _id_getEnumList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_getObjectList = _class.instanceMethodId(
    r'getObjectList',
    r'()Ljava/util/List;',
  );

  static final _getObjectList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getObjectList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getObjectList() {
    return _getObjectList(
            reference.pointer, _id_getObjectList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getListList = _class.instanceMethodId(
    r'getListList',
    r'()Ljava/util/List;',
  );

  static final _getListList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> getListList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? getListList() {
    return _getListList(
            reference.pointer, _id_getListList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_.JListNullableType<jni$_.JList<jni$_.JObject?>?>(
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_getMapList = _class.instanceMethodId(
    r'getMapList',
    r'()Ljava/util/List;',
  );

  static final _getMapList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> getMapList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? getMapList() {
    return _getMapList(reference.pointer, _id_getMapList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_
                .JListNullableType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? getMap() {
    return _getMap(reference.pointer, _id_getMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? getStringMap() {
    return _getStringMap(
            reference.pointer, _id_getStringMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_getIntMap = _class.instanceMethodId(
    r'getIntMap',
    r'()Ljava/util/Map;',
  );

  static final _getIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> getIntMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? getIntMap() {
    return _getIntMap(reference.pointer, _id_getIntMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_getEnumMap = _class.instanceMethodId(
    r'getEnumMap',
    r'()Ljava/util/Map;',
  );

  static final _getEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<JniAnEnum, JniAnEnum> getEnumMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? getEnumMap() {
    return _getEnumMap(reference.pointer, _id_getEnumMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_getObjectMap = _class.instanceMethodId(
    r'getObjectMap',
    r'()Ljava/util/Map;',
  );

  static final _getObjectMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getObjectMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? getObjectMap() {
    return _getObjectMap(
            reference.pointer, _id_getObjectMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_getListMap = _class.instanceMethodId(
    r'getListMap',
    r'()Ljava/util/Map;',
  );

  static final _getListMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> getListMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? getListMap() {
    return _getListMap(reference.pointer, _id_getListMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_
                .JMapNullableType<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_getMapMap = _class.instanceMethodId(
    r'getMapMap',
    r'()Ljava/util/Map;',
  );

  static final _getMapMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> getMapMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
      getMapMap() {
    return _getMapMap(reference.pointer, _id_getMapMap as jni$_.JMethodIDPtr)
        .object<
                jni$_.JMap<jni$_.JLong?,
                    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?,
                    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/Boolean;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Boolean component1()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()Ljava/lang/Long;',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long component2()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()Ljava/lang/Long;',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long component3()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/lang/Double;',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Double component4()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()[B',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] component5()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()[I',
  );

  static final _component6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] component6()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? component6() {
    return _component6(reference.pointer, _id_component6 as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()[J',
  );

  static final _component7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] component7()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? component7() {
    return _component7(reference.pointer, _id_component7 as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_component8 = _class.instanceMethodId(
    r'component8',
    r'()[D',
  );

  static final _component8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] component8()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? component8() {
    return _component8(reference.pointer, _id_component8 as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()LJniAnEnum;',
  );

  static final _component9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnEnum component9()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? component9() {
    return _component9(reference.pointer, _id_component9 as jni$_.JMethodIDPtr)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()LJniAnotherEnum;',
  );

  static final _component10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnotherEnum component10()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? component10() {
    return _component10(
            reference.pointer, _id_component10 as jni$_.JMethodIDPtr)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/lang/String;',
  );

  static final _component11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component11()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? component11() {
    return _component11(
            reference.pointer, _id_component11 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/lang/Object;',
  );

  static final _component12 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object component12()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? component12() {
    return _component12(
            reference.pointer, _id_component12 as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()Ljava/util/List;',
  );

  static final _component13 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component13()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component13() {
    return _component13(
            reference.pointer, _id_component13 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> component14()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? component14() {
    return _component14(
            reference.pointer, _id_component14 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/List;',
  );

  static final _component15 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> component15()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? component15() {
    return _component15(
            reference.pointer, _id_component15 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong?>?>(
            const jni$_.JListNullableType<jni$_.JLong?>(
                jni$_.JLongNullableType()));
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/List;',
  );

  static final _component16 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> component16()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? component16() {
    return _component16(
            reference.pointer, _id_component16 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble?>?>(
            const jni$_.JListNullableType<jni$_.JDouble?>(
                jni$_.JDoubleNullableType()));
  }

  static final _id_component17 = _class.instanceMethodId(
    r'component17',
    r'()Ljava/util/List;',
  );

  static final _component17 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> component17()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? component17() {
    return _component17(
            reference.pointer, _id_component17 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean?>?>(
            const jni$_.JListNullableType<jni$_.JBoolean?>(
                jni$_.JBooleanNullableType()));
  }

  static final _id_component18 = _class.instanceMethodId(
    r'component18',
    r'()Ljava/util/List;',
  );

  static final _component18 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAnEnum> component18()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? component18() {
    return _component18(
            reference.pointer, _id_component18 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_component19 = _class.instanceMethodId(
    r'component19',
    r'()Ljava/util/List;',
  );

  static final _component19 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component19()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component19() {
    return _component19(
            reference.pointer, _id_component19 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_component20 = _class.instanceMethodId(
    r'component20',
    r'()Ljava/util/List;',
  );

  static final _component20 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> component20()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? component20() {
    return _component20(
            reference.pointer, _id_component20 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_.JListNullableType<jni$_.JList<jni$_.JObject?>?>(
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_component21 = _class.instanceMethodId(
    r'component21',
    r'()Ljava/util/List;',
  );

  static final _component21 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> component21()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? component21() {
    return _component21(
            reference.pointer, _id_component21 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_
                .JListNullableType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_component22 = _class.instanceMethodId(
    r'component22',
    r'()Ljava/util/Map;',
  );

  static final _component22 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component22()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? component22() {
    return _component22(
            reference.pointer, _id_component22 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_component23 = _class.instanceMethodId(
    r'component23',
    r'()Ljava/util/Map;',
  );

  static final _component23 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> component23()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? component23() {
    return _component23(
            reference.pointer, _id_component23 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_component24 = _class.instanceMethodId(
    r'component24',
    r'()Ljava/util/Map;',
  );

  static final _component24 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> component24()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? component24() {
    return _component24(
            reference.pointer, _id_component24 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_component25 = _class.instanceMethodId(
    r'component25',
    r'()Ljava/util/Map;',
  );

  static final _component25 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<JniAnEnum, JniAnEnum> component25()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? component25() {
    return _component25(
            reference.pointer, _id_component25 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_component26 = _class.instanceMethodId(
    r'component26',
    r'()Ljava/util/Map;',
  );

  static final _component26 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component26()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? component26() {
    return _component26(
            reference.pointer, _id_component26 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_component27 = _class.instanceMethodId(
    r'component27',
    r'()Ljava/util/Map;',
  );

  static final _component27 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> component27()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? component27() {
    return _component27(
            reference.pointer, _id_component27 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_
                .JMapNullableType<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_component28 = _class.instanceMethodId(
    r'component28',
    r'()Ljava/util/Map;',
  );

  static final _component28 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> component28()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
      component28() {
    return _component28(reference.pointer, _id_component28 as jni$_.JMethodIDPtr)
        .object<
            jni$_.JMap<jni$_.JLong?,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(const jni$_
            .JMapNullableType<jni$_.JLong?,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            jni$_.JLongNullableType(),
            jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllNullableTypesWithoutRecursion copy(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends JniAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<JniAnEnum, ? extends JniAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion copy(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    JniAnEnum? jniAnEnum,
    JniAnotherEnum? jniAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<JniAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    return _copy(
            reference.pointer,
            _id_copy as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer)
        .object<JniAllNullableTypesWithoutRecursion>(
            const $JniAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypesWithoutRecursion.new$2() {
    return JniAllNullableTypesWithoutRecursion.fromReference(
        _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $JniAllNullableTypesWithoutRecursion$NullableType
    extends jni$_.JObjType<JniAllNullableTypesWithoutRecursion?> {
  @jni$_.internal
  const $JniAllNullableTypesWithoutRecursion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypesWithoutRecursion;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypesWithoutRecursion? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllNullableTypesWithoutRecursion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypesWithoutRecursion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($JniAllNullableTypesWithoutRecursion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JniAllNullableTypesWithoutRecursion$NullableType) &&
        other is $JniAllNullableTypesWithoutRecursion$NullableType;
  }
}

final class $JniAllNullableTypesWithoutRecursion$Type
    extends jni$_.JObjType<JniAllNullableTypesWithoutRecursion> {
  @jni$_.internal
  const $JniAllNullableTypesWithoutRecursion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypesWithoutRecursion;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypesWithoutRecursion fromReference(
          jni$_.JReference reference) =>
      JniAllNullableTypesWithoutRecursion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypesWithoutRecursion?> get nullableType =>
      const $JniAllNullableTypesWithoutRecursion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllNullableTypesWithoutRecursion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllNullableTypesWithoutRecursion$Type) &&
        other is $JniAllNullableTypesWithoutRecursion$Type;
  }
}

/// from: `JniAllClassesWrapper$Companion`
class JniAllClassesWrapper$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllClassesWrapper$Companion> $type;

  @jni$_.internal
  JniAllClassesWrapper$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAllClassesWrapper$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAllClassesWrapper$Companion$NullableType();
  static const type = $JniAllClassesWrapper$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LJniAllClassesWrapper;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllClassesWrapper fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllClassesWrapper fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<JniAllClassesWrapper>(const $JniAllClassesWrapper$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllClassesWrapper$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllClassesWrapper$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniAllClassesWrapper$Companion$NullableType
    extends jni$_.JObjType<JniAllClassesWrapper$Companion?> {
  @jni$_.internal
  const $JniAllClassesWrapper$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllClassesWrapper$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllClassesWrapper$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllClassesWrapper$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllClassesWrapper$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllClassesWrapper$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JniAllClassesWrapper$Companion$NullableType) &&
        other is $JniAllClassesWrapper$Companion$NullableType;
  }
}

final class $JniAllClassesWrapper$Companion$Type
    extends jni$_.JObjType<JniAllClassesWrapper$Companion> {
  @jni$_.internal
  const $JniAllClassesWrapper$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllClassesWrapper$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllClassesWrapper$Companion fromReference(jni$_.JReference reference) =>
      JniAllClassesWrapper$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllClassesWrapper$Companion?> get nullableType =>
      const $JniAllClassesWrapper$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllClassesWrapper$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllClassesWrapper$Companion$Type) &&
        other is $JniAllClassesWrapper$Companion$Type;
  }
}

/// from: `JniAllClassesWrapper`
class JniAllClassesWrapper extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllClassesWrapper> $type;

  @jni$_.internal
  JniAllClassesWrapper.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAllClassesWrapper');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAllClassesWrapper$NullableType();
  static const type = $JniAllClassesWrapper$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniAllClassesWrapper$Companion;',
  );

  /// from: `static public final JniAllClassesWrapper$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAllClassesWrapper$Companion get Companion =>
      _id_Companion.get(_class, const $JniAllClassesWrapper$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(LJniAllNullableTypes;LJniAllNullableTypesWithoutRecursion;LJniAllTypes;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(JniAllNullableTypes jniAllNullableTypes, JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion, JniAllTypes jniAllTypes, java.util.List<JniAllTypes> list, java.util.List<JniAllNullableTypesWithoutRecursion> list1, java.util.Map<java.lang.Long, JniAllTypes> map, java.util.Map<java.lang.Long, JniAllNullableTypesWithoutRecursion> map1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllClassesWrapper(
    JniAllNullableTypes jniAllNullableTypes,
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
    JniAllTypes? jniAllTypes,
    jni$_.JList<JniAllTypes?> list,
    jni$_.JList<JniAllNullableTypesWithoutRecursion?>? list1,
    jni$_.JMap<jni$_.JLong?, JniAllTypes?> map,
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypesWithoutRecursion?>? map1,
  ) {
    final _$jniAllNullableTypes = jniAllNullableTypes.reference;
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$jniAllTypes = jniAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list.reference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$map = map.reference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    return JniAllClassesWrapper.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer,
            _$jniAllNullableTypesWithoutRecursion.pointer,
            _$jniAllTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$map.pointer,
            _$map1.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(LJniAllNullableTypes;LJniAllNullableTypesWithoutRecursion;LJniAllTypes;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(JniAllNullableTypes jniAllNullableTypes, JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion, JniAllTypes jniAllTypes, java.util.List list, java.util.List list1, java.util.Map map, java.util.Map map1, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllClassesWrapper.new$1(
    JniAllNullableTypes? jniAllNullableTypes,
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
    JniAllTypes? jniAllTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map1,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$jniAllTypes = jniAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllClassesWrapper.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer,
            _$jniAllNullableTypesWithoutRecursion.pointer,
            _$jniAllTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$map.pointer,
            _$map1.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getAllNullableTypes = _class.instanceMethodId(
    r'getAllNullableTypes',
    r'()LJniAllNullableTypes;',
  );

  static final _getAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllNullableTypes getAllNullableTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes getAllNullableTypes() {
    return _getAllNullableTypes(
            reference.pointer, _id_getAllNullableTypes as jni$_.JMethodIDPtr)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_getAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'getAllNullableTypesWithoutRecursion',
    r'()LJniAllNullableTypesWithoutRecursion;',
  );

  static final _getAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public final JniAllNullableTypesWithoutRecursion getAllNullableTypesWithoutRecursion()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion? getAllNullableTypesWithoutRecursion() {
    return _getAllNullableTypesWithoutRecursion(reference.pointer,
            _id_getAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr)
        .object<JniAllNullableTypesWithoutRecursion?>(
            const $JniAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_getAllTypes = _class.instanceMethodId(
    r'getAllTypes',
    r'()LJniAllTypes;',
  );

  static final _getAllTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllTypes getAllTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes? getAllTypes() {
    return _getAllTypes(
            reference.pointer, _id_getAllTypes as jni$_.JMethodIDPtr)
        .object<JniAllTypes?>(const $JniAllTypes$NullableType());
  }

  static final _id_getClassList = _class.instanceMethodId(
    r'getClassList',
    r'()Ljava/util/List;',
  );

  static final _getClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAllTypes> getClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllTypes?> getClassList() {
    return _getClassList(
            reference.pointer, _id_getClassList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAllTypes?>>(
            const jni$_.JListType<JniAllTypes?>($JniAllTypes$NullableType()));
  }

  static final _id_getNullableClassList = _class.instanceMethodId(
    r'getNullableClassList',
    r'()Ljava/util/List;',
  );

  static final _getNullableClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAllNullableTypesWithoutRecursion> getNullableClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypesWithoutRecursion?>? getNullableClassList() {
    return _getNullableClassList(
            reference.pointer, _id_getNullableClassList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAllNullableTypesWithoutRecursion?>?>(
            const jni$_.JListNullableType<JniAllNullableTypesWithoutRecursion?>(
                $JniAllNullableTypesWithoutRecursion$NullableType()));
  }

  static final _id_getClassMap = _class.instanceMethodId(
    r'getClassMap',
    r'()Ljava/util/Map;',
  );

  static final _getClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, JniAllTypes> getClassMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllTypes?> getClassMap() {
    return _getClassMap(
            reference.pointer, _id_getClassMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, JniAllTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, JniAllTypes?>(
                jni$_.JLongNullableType(), $JniAllTypes$NullableType()));
  }

  static final _id_getNullableClassMap = _class.instanceMethodId(
    r'getNullableClassMap',
    r'()Ljava/util/Map;',
  );

  static final _getNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, JniAllNullableTypesWithoutRecursion> getNullableClassMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypesWithoutRecursion?>?
      getNullableClassMap() {
    return _getNullableClassMap(
            reference.pointer, _id_getNullableClassMap as jni$_.JMethodIDPtr)
        .object<
                jni$_
                .JMap<jni$_.JLong?, JniAllNullableTypesWithoutRecursion?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?,
                    JniAllNullableTypesWithoutRecursion?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypesWithoutRecursion$NullableType()));
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()LJniAllNullableTypes;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllNullableTypes component1()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()LJniAllNullableTypesWithoutRecursion;',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllNullableTypesWithoutRecursion component2()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion? component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .object<JniAllNullableTypesWithoutRecursion?>(
            const $JniAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()LJniAllTypes;',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllTypes component3()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes? component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .object<JniAllTypes?>(const $JniAllTypes$NullableType());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/util/List;',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAllTypes> component4()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllTypes?> component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAllTypes?>>(
            const jni$_.JListType<JniAllTypes?>($JniAllTypes$NullableType()));
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()Ljava/util/List;',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAllNullableTypesWithoutRecursion> component5()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypesWithoutRecursion?>? component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAllNullableTypesWithoutRecursion?>?>(
            const jni$_.JListNullableType<JniAllNullableTypesWithoutRecursion?>(
                $JniAllNullableTypesWithoutRecursion$NullableType()));
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()Ljava/util/Map;',
  );

  static final _component6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, JniAllTypes> component6()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllTypes?> component6() {
    return _component6(reference.pointer, _id_component6 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, JniAllTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, JniAllTypes?>(
                jni$_.JLongNullableType(), $JniAllTypes$NullableType()));
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()Ljava/util/Map;',
  );

  static final _component7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, JniAllNullableTypesWithoutRecursion> component7()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypesWithoutRecursion?>? component7() {
    return _component7(reference.pointer, _id_component7 as jni$_.JMethodIDPtr)
        .object<
                jni$_
                .JMap<jni$_.JLong?, JniAllNullableTypesWithoutRecursion?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?,
                    JniAllNullableTypesWithoutRecursion?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypesWithoutRecursion$NullableType()));
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(LJniAllNullableTypes;LJniAllNullableTypesWithoutRecursion;LJniAllTypes;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;)LJniAllClassesWrapper;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllClassesWrapper copy(JniAllNullableTypes jniAllNullableTypes, JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion, JniAllTypes jniAllTypes, java.util.List<JniAllTypes> list, java.util.List<JniAllNullableTypesWithoutRecursion> list1, java.util.Map<java.lang.Long, JniAllTypes> map, java.util.Map<java.lang.Long, JniAllNullableTypesWithoutRecursion> map1)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllClassesWrapper copy(
    JniAllNullableTypes jniAllNullableTypes,
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
    JniAllTypes? jniAllTypes,
    jni$_.JList<JniAllTypes?> list,
    jni$_.JList<JniAllNullableTypesWithoutRecursion?>? list1,
    jni$_.JMap<jni$_.JLong?, JniAllTypes?> map,
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypesWithoutRecursion?>? map1,
  ) {
    final _$jniAllNullableTypes = jniAllNullableTypes.reference;
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$jniAllTypes = jniAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list.reference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$map = map.reference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    return _copy(
            reference.pointer,
            _id_copy as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer,
            _$jniAllNullableTypesWithoutRecursion.pointer,
            _$jniAllTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$map.pointer,
            _$map1.pointer)
        .object<JniAllClassesWrapper>(const $JniAllClassesWrapper$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $JniAllClassesWrapper$NullableType
    extends jni$_.JObjType<JniAllClassesWrapper?> {
  @jni$_.internal
  const $JniAllClassesWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllClassesWrapper;';

  @jni$_.internal
  @core$_.override
  JniAllClassesWrapper? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllClassesWrapper.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllClassesWrapper?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllClassesWrapper$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllClassesWrapper$NullableType) &&
        other is $JniAllClassesWrapper$NullableType;
  }
}

final class $JniAllClassesWrapper$Type
    extends jni$_.JObjType<JniAllClassesWrapper> {
  @jni$_.internal
  const $JniAllClassesWrapper$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllClassesWrapper;';

  @jni$_.internal
  @core$_.override
  JniAllClassesWrapper fromReference(jni$_.JReference reference) =>
      JniAllClassesWrapper.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllClassesWrapper?> get nullableType =>
      const $JniAllClassesWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllClassesWrapper$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllClassesWrapper$Type) &&
        other is $JniAllClassesWrapper$Type;
  }
}

/// from: `JniAnEnum$Companion`
class JniAnEnum$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAnEnum$Companion> $type;

  @jni$_.internal
  JniAnEnum$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAnEnum$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAnEnum$Companion$NullableType();
  static const type = $JniAnEnum$Companion$Type();
  static final _id_ofRaw = _class.instanceMethodId(
    r'ofRaw',
    r'(I)LJniAnEnum;',
  );

  static final _ofRaw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final JniAnEnum ofRaw(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? ofRaw(
    int i,
  ) {
    return _ofRaw(reference.pointer, _id_ofRaw as jni$_.JMethodIDPtr, i)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAnEnum$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAnEnum$Companion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniAnEnum$Companion$NullableType
    extends jni$_.JObjType<JniAnEnum$Companion?> {
  @jni$_.internal
  const $JniAnEnum$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnEnum$Companion;';

  @jni$_.internal
  @core$_.override
  JniAnEnum$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAnEnum$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnEnum$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnEnum$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnEnum$Companion$NullableType) &&
        other is $JniAnEnum$Companion$NullableType;
  }
}

final class $JniAnEnum$Companion$Type
    extends jni$_.JObjType<JniAnEnum$Companion> {
  @jni$_.internal
  const $JniAnEnum$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnEnum$Companion;';

  @jni$_.internal
  @core$_.override
  JniAnEnum$Companion fromReference(jni$_.JReference reference) =>
      JniAnEnum$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnEnum$Companion?> get nullableType =>
      const $JniAnEnum$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnEnum$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnEnum$Companion$Type) &&
        other is $JniAnEnum$Companion$Type;
  }
}

/// from: `JniAnEnum`
class JniAnEnum extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAnEnum> $type;

  @jni$_.internal
  JniAnEnum.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAnEnum');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAnEnum$NullableType();
  static const type = $JniAnEnum$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniAnEnum$Companion;',
  );

  /// from: `static public final JniAnEnum$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum$Companion get Companion =>
      _id_Companion.get(_class, const $JniAnEnum$Companion$Type());

  static final _id_ONE = _class.staticFieldId(
    r'ONE',
    r'LJniAnEnum;',
  );

  /// from: `static public final JniAnEnum ONE`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum get ONE => _id_ONE.get(_class, const $JniAnEnum$Type());

  static final _id_TWO = _class.staticFieldId(
    r'TWO',
    r'LJniAnEnum;',
  );

  /// from: `static public final JniAnEnum TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum get TWO => _id_TWO.get(_class, const $JniAnEnum$Type());

  static final _id_THREE = _class.staticFieldId(
    r'THREE',
    r'LJniAnEnum;',
  );

  /// from: `static public final JniAnEnum THREE`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum get THREE => _id_THREE.get(_class, const $JniAnEnum$Type());

  static final _id_FORTY_TWO = _class.staticFieldId(
    r'FORTY_TWO',
    r'LJniAnEnum;',
  );

  /// from: `static public final JniAnEnum FORTY_TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum get FORTY_TWO =>
      _id_FORTY_TWO.get(_class, const $JniAnEnum$Type());

  static final _id_FOUR_HUNDRED_TWENTY_TWO = _class.staticFieldId(
    r'FOUR_HUNDRED_TWENTY_TWO',
    r'LJniAnEnum;',
  );

  /// from: `static public final JniAnEnum FOUR_HUNDRED_TWENTY_TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum get FOUR_HUNDRED_TWENTY_TWO =>
      _id_FOUR_HUNDRED_TWENTY_TWO.get(_class, const $JniAnEnum$Type());

  static final _id_getRaw = _class.instanceMethodId(
    r'getRaw',
    r'()I',
  );

  static final _getRaw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int getRaw()`
  int getRaw() {
    return _getRaw(reference.pointer, _id_getRaw as jni$_.JMethodIDPtr).integer;
  }

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[LJniAnEnum;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public JniAnEnum[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<JniAnEnum?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<JniAnEnum?>?>(
            const jni$_.JArrayNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)LJniAnEnum;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public JniAnEnum valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public kotlin.enums.EnumEntries<JniAnEnum> getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
            _class.reference.pointer, _id_getEntries as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $JniAnEnum$NullableType extends jni$_.JObjType<JniAnEnum?> {
  @jni$_.internal
  const $JniAnEnum$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnEnum;';

  @jni$_.internal
  @core$_.override
  JniAnEnum? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : JniAnEnum.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnEnum?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnEnum$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnEnum$NullableType) &&
        other is $JniAnEnum$NullableType;
  }
}

final class $JniAnEnum$Type extends jni$_.JObjType<JniAnEnum> {
  @jni$_.internal
  const $JniAnEnum$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnEnum;';

  @jni$_.internal
  @core$_.override
  JniAnEnum fromReference(jni$_.JReference reference) =>
      JniAnEnum.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnEnum?> get nullableType =>
      const $JniAnEnum$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnEnum$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnEnum$Type) && other is $JniAnEnum$Type;
  }
}

/// from: `JniAnotherEnum$Companion`
class JniAnotherEnum$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAnotherEnum$Companion> $type;

  @jni$_.internal
  JniAnotherEnum$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAnotherEnum$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAnotherEnum$Companion$NullableType();
  static const type = $JniAnotherEnum$Companion$Type();
  static final _id_ofRaw = _class.instanceMethodId(
    r'ofRaw',
    r'(I)LJniAnotherEnum;',
  );

  static final _ofRaw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final JniAnotherEnum ofRaw(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? ofRaw(
    int i,
  ) {
    return _ofRaw(reference.pointer, _id_ofRaw as jni$_.JMethodIDPtr, i)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAnotherEnum$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAnotherEnum$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniAnotherEnum$Companion$NullableType
    extends jni$_.JObjType<JniAnotherEnum$Companion?> {
  @jni$_.internal
  const $JniAnotherEnum$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnotherEnum$Companion;';

  @jni$_.internal
  @core$_.override
  JniAnotherEnum$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAnotherEnum$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnotherEnum$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnotherEnum$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnotherEnum$Companion$NullableType) &&
        other is $JniAnotherEnum$Companion$NullableType;
  }
}

final class $JniAnotherEnum$Companion$Type
    extends jni$_.JObjType<JniAnotherEnum$Companion> {
  @jni$_.internal
  const $JniAnotherEnum$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnotherEnum$Companion;';

  @jni$_.internal
  @core$_.override
  JniAnotherEnum$Companion fromReference(jni$_.JReference reference) =>
      JniAnotherEnum$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnotherEnum$Companion?> get nullableType =>
      const $JniAnotherEnum$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnotherEnum$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnotherEnum$Companion$Type) &&
        other is $JniAnotherEnum$Companion$Type;
  }
}

/// from: `JniAnotherEnum`
class JniAnotherEnum extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAnotherEnum> $type;

  @jni$_.internal
  JniAnotherEnum.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAnotherEnum');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAnotherEnum$NullableType();
  static const type = $JniAnotherEnum$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniAnotherEnum$Companion;',
  );

  /// from: `static public final JniAnotherEnum$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnotherEnum$Companion get Companion =>
      _id_Companion.get(_class, const $JniAnotherEnum$Companion$Type());

  static final _id_JUST_IN_CASE = _class.staticFieldId(
    r'JUST_IN_CASE',
    r'LJniAnotherEnum;',
  );

  /// from: `static public final JniAnotherEnum JUST_IN_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnotherEnum get JUST_IN_CASE =>
      _id_JUST_IN_CASE.get(_class, const $JniAnotherEnum$Type());

  static final _id_getRaw = _class.instanceMethodId(
    r'getRaw',
    r'()I',
  );

  static final _getRaw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int getRaw()`
  int getRaw() {
    return _getRaw(reference.pointer, _id_getRaw as jni$_.JMethodIDPtr).integer;
  }

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[LJniAnotherEnum;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public JniAnotherEnum[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<JniAnotherEnum?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<JniAnotherEnum?>?>(
            const jni$_.JArrayNullableType<JniAnotherEnum?>(
                $JniAnotherEnum$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)LJniAnotherEnum;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public JniAnotherEnum valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnotherEnum? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public kotlin.enums.EnumEntries<JniAnotherEnum> getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
            _class.reference.pointer, _id_getEntries as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $JniAnotherEnum$NullableType
    extends jni$_.JObjType<JniAnotherEnum?> {
  @jni$_.internal
  const $JniAnotherEnum$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnotherEnum;';

  @jni$_.internal
  @core$_.override
  JniAnotherEnum? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : JniAnotherEnum.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnotherEnum?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnotherEnum$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnotherEnum$NullableType) &&
        other is $JniAnotherEnum$NullableType;
  }
}

final class $JniAnotherEnum$Type extends jni$_.JObjType<JniAnotherEnum> {
  @jni$_.internal
  const $JniAnotherEnum$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnotherEnum;';

  @jni$_.internal
  @core$_.override
  JniAnotherEnum fromReference(jni$_.JReference reference) =>
      JniAnotherEnum.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnotherEnum?> get nullableType =>
      const $JniAnotherEnum$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnotherEnum$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnotherEnum$Type) &&
        other is $JniAnotherEnum$Type;
  }
}
