// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `JniHostIntegrationCoreApi`
class JniHostIntegrationCoreApi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniHostIntegrationCoreApi> $type;

  @jni$_.internal
  JniHostIntegrationCoreApi.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniHostIntegrationCoreApi');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniHostIntegrationCoreApi$NullableType();
  static const type = $JniHostIntegrationCoreApi$Type();
  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }

  static final _id_echoAllTypes = _class.instanceMethodId(
    r'echoAllTypes',
    r'(LJniAllTypes;)LJniAllTypes;',
  );

  static final _echoAllTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllTypes echoAllTypes(JniAllTypes jniAllTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes echoAllTypes(
    JniAllTypes jniAllTypes,
  ) {
    final _$jniAllTypes = jniAllTypes.reference;
    return _echoAllTypes(reference.pointer,
            _id_echoAllTypes as jni$_.JMethodIDPtr, _$jniAllTypes.pointer)
        .object<JniAllTypes>(const $JniAllTypes$Type());
  }

  static final _id_throwError = _class.instanceMethodId(
    r'throwError',
    r'()Ljava/lang/Object;',
  );

  static final _throwError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.Object throwError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwError() {
    return _throwError(reference.pointer, _id_throwError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_throwErrorFromVoid = _class.instanceMethodId(
    r'throwErrorFromVoid',
    r'()V',
  );

  static final _throwErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void throwErrorFromVoid()`
  void throwErrorFromVoid() {
    _throwErrorFromVoid(
            reference.pointer, _id_throwErrorFromVoid as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_throwFlutterError = _class.instanceMethodId(
    r'throwFlutterError',
    r'()Ljava/lang/Object;',
  );

  static final _throwFlutterError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.Object throwFlutterError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwFlutterError() {
    return _throwFlutterError(
            reference.pointer, _id_throwFlutterError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_echoInt = _class.instanceMethodId(
    r'echoInt',
    r'(J)J',
  );

  static final _echoInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract long echoInt(long j)`
  int echoInt(
    int j,
  ) {
    return _echoInt(reference.pointer, _id_echoInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoDouble = _class.instanceMethodId(
    r'echoDouble',
    r'(D)D',
  );

  static final _echoDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public abstract double echoDouble(double d)`
  double echoDouble(
    double d,
  ) {
    return _echoDouble(
            reference.pointer, _id_echoDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoBool = _class.instanceMethodId(
    r'echoBool',
    r'(Z)Z',
  );

  static final _echoBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract boolean echoBool(boolean z)`
  bool echoBool(
    bool z,
  ) {
    return _echoBool(
            reference.pointer, _id_echoBool as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_echoString = _class.instanceMethodId(
    r'echoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoString(reference.pointer, _id_echoString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoUint8List = _class.instanceMethodId(
    r'echoUint8List',
    r'([B)[B',
  );

  static final _echoUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] echoUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray echoUint8List(
    jni$_.JByteArray bs,
  ) {
    final _$bs = bs.reference;
    return _echoUint8List(reference.pointer,
            _id_echoUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_echoInt32List = _class.instanceMethodId(
    r'echoInt32List',
    r'([I)[I',
  );

  static final _echoInt32List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract int[] echoInt32List(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray echoInt32List(
    jni$_.JIntArray is$,
  ) {
    final _$is$ = is$.reference;
    return _echoInt32List(reference.pointer,
            _id_echoInt32List as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<jni$_.JIntArray>(const jni$_.JIntArrayType());
  }

  static final _id_echoInt64List = _class.instanceMethodId(
    r'echoInt64List',
    r'([J)[J',
  );

  static final _echoInt64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract long[] echoInt64List(long[] js)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray echoInt64List(
    jni$_.JLongArray js,
  ) {
    final _$js = js.reference;
    return _echoInt64List(reference.pointer,
            _id_echoInt64List as jni$_.JMethodIDPtr, _$js.pointer)
        .object<jni$_.JLongArray>(const jni$_.JLongArrayType());
  }

  static final _id_echoFloat64List = _class.instanceMethodId(
    r'echoFloat64List',
    r'([D)[D',
  );

  static final _echoFloat64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract double[] echoFloat64List(double[] ds)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray echoFloat64List(
    jni$_.JDoubleArray ds,
  ) {
    final _$ds = ds.reference;
    return _echoFloat64List(reference.pointer,
            _id_echoFloat64List as jni$_.JMethodIDPtr, _$ds.pointer)
        .object<jni$_.JDoubleArray>(const jni$_.JDoubleArrayType());
  }

  static final _id_echoObject = _class.instanceMethodId(
    r'echoObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoObject = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoObject(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject echoObject(
    jni$_.JObject object,
  ) {
    final _$object = object.reference;
    return _echoObject(reference.pointer, _id_echoObject as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_echoList = _class.instanceMethodId(
    r'echoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> echoList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> echoList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _echoList(reference.pointer, _id_echoList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_echoEnumList = _class.instanceMethodId(
    r'echoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> echoEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?> echoEnumList(
    jni$_.JList<JniAnEnum?> list,
  ) {
    final _$list = list.reference;
    return _echoEnumList(reference.pointer,
            _id_echoEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>>(
            const jni$_.JListType<JniAnEnum?>($JniAnEnum$NullableType()));
  }

  static final _id_echoClassList = _class.instanceMethodId(
    r'echoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> echoClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?> echoClassList(
    jni$_.JList<JniAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _echoClassList(reference.pointer,
            _id_echoClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>>(
            const jni$_.JListType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullEnumList = _class.instanceMethodId(
    r'echoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> echoNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum> echoNonNullEnumList(
    jni$_.JList<JniAnEnum> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullEnumList(reference.pointer,
            _id_echoNonNullEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum>>(
            const jni$_.JListType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_echoNonNullClassList = _class.instanceMethodId(
    r'echoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> echoNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes> echoNonNullClassList(
    jni$_.JList<JniAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullClassList(reference.pointer,
            _id_echoNonNullClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>>(
            const jni$_.JListType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_echoMap = _class.instanceMethodId(
    r'echoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> echoMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _echoMap(
            reference.pointer, _id_echoMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoStringMap = _class.instanceMethodId(
    r'echoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _echoStringMap(reference.pointer,
            _id_echoStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoIntMap = _class.instanceMethodId(
    r'echoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _echoIntMap(reference.pointer, _id_echoIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
            const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoEnumMap = _class.instanceMethodId(
    r'echoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> echoEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?> echoEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _echoEnumMap(reference.pointer,
            _id_echoEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>>(
            const jni$_.JMapType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_echoClassMap = _class.instanceMethodId(
    r'echoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> echoClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> echoClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _echoClassMap(reference.pointer,
            _id_echoClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullStringMap = _class.instanceMethodId(
    r'echoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullStringMap(reference.pointer,
            _id_echoNonNullStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNonNullIntMap = _class.instanceMethodId(
    r'echoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullIntMap(reference.pointer,
            _id_echoNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNonNullEnumMap = _class.instanceMethodId(
    r'echoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> echoNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum> echoNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullEnumMap(reference.pointer,
            _id_echoNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>>(
            const jni$_.JMapType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_echoNonNullClassMap = _class.instanceMethodId(
    r'echoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> echoNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes> echoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullClassMap(reference.pointer,
            _id_echoNonNullClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>>(
            const jni$_.JMapType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_echoClassWrapper = _class.instanceMethodId(
    r'echoClassWrapper',
    r'(LJniAllClassesWrapper;)LJniAllClassesWrapper;',
  );

  static final _echoClassWrapper = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllClassesWrapper echoClassWrapper(JniAllClassesWrapper jniAllClassesWrapper)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllClassesWrapper echoClassWrapper(
    JniAllClassesWrapper jniAllClassesWrapper,
  ) {
    final _$jniAllClassesWrapper = jniAllClassesWrapper.reference;
    return _echoClassWrapper(
            reference.pointer,
            _id_echoClassWrapper as jni$_.JMethodIDPtr,
            _$jniAllClassesWrapper.pointer)
        .object<JniAllClassesWrapper>(const $JniAllClassesWrapper$Type());
  }

  static final _id_echoEnum = _class.instanceMethodId(
    r'echoEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _echoEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnEnum echoEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum echoEnum(
    JniAnEnum jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum.reference;
    return _echoEnum(reference.pointer, _id_echoEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer)
        .object<JniAnEnum>(const $JniAnEnum$Type());
  }

  static final _id_echoAnotherEnum = _class.instanceMethodId(
    r'echoAnotherEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _echoAnotherEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnotherEnum echoAnotherEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum echoAnotherEnum(
    JniAnotherEnum jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    return _echoAnotherEnum(reference.pointer,
            _id_echoAnotherEnum as jni$_.JMethodIDPtr, _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum>(const $JniAnotherEnum$Type());
  }

  static final _id_echoNamedDefaultString = _class.instanceMethodId(
    r'echoNamedDefaultString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNamedDefaultString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoNamedDefaultString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoNamedDefaultString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoNamedDefaultString(reference.pointer,
            _id_echoNamedDefaultString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoOptionalDefaultDouble = _class.instanceMethodId(
    r'echoOptionalDefaultDouble',
    r'(D)D',
  );

  static final _echoOptionalDefaultDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public abstract double echoOptionalDefaultDouble(double d)`
  double echoOptionalDefaultDouble(
    double d,
  ) {
    return _echoOptionalDefaultDouble(reference.pointer,
            _id_echoOptionalDefaultDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoRequiredInt = _class.instanceMethodId(
    r'echoRequiredInt',
    r'(J)J',
  );

  static final _echoRequiredInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract long echoRequiredInt(long j)`
  int echoRequiredInt(
    int j,
  ) {
    return _echoRequiredInt(
            reference.pointer, _id_echoRequiredInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoAllNullableTypes = _class.instanceMethodId(
    r'echoAllNullableTypes',
    r'(LJniAllNullableTypes;)LJniAllNullableTypes;',
  );

  static final _echoAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypes echoAllNullableTypes(JniAllNullableTypes jniAllNullableTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes? echoAllNullableTypes(
    JniAllNullableTypes? jniAllNullableTypes,
  ) {
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypes(
            reference.pointer,
            _id_echoAllNullableTypes as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer)
        .object<JniAllNullableTypes?>(
            const $JniAllNullableTypes$NullableType());
  }

  static final _id_echoAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoAllNullableTypesWithoutRecursion',
    r'(LJniAllNullableTypesWithoutRecursion;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _echoAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypesWithoutRecursion echoAllNullableTypesWithoutRecursion(JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion? echoAllNullableTypesWithoutRecursion(
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
  ) {
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$jniAllNullableTypesWithoutRecursion.pointer)
        .object<JniAllNullableTypesWithoutRecursion?>(
            const $JniAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_extractNestedNullableString = _class.instanceMethodId(
    r'extractNestedNullableString',
    r'(LJniAllClassesWrapper;)Ljava/lang/String;',
  );

  static final _extractNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String extractNestedNullableString(JniAllClassesWrapper jniAllClassesWrapper)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? extractNestedNullableString(
    JniAllClassesWrapper jniAllClassesWrapper,
  ) {
    final _$jniAllClassesWrapper = jniAllClassesWrapper.reference;
    return _extractNestedNullableString(
            reference.pointer,
            _id_extractNestedNullableString as jni$_.JMethodIDPtr,
            _$jniAllClassesWrapper.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_createNestedNullableString = _class.instanceMethodId(
    r'createNestedNullableString',
    r'(Ljava/lang/String;)LJniAllClassesWrapper;',
  );

  static final _createNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllClassesWrapper createNestedNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllClassesWrapper createNestedNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createNestedNullableString(
            reference.pointer,
            _id_createNestedNullableString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<JniAllClassesWrapper>(const $JniAllClassesWrapper$Type());
  }

  static final _id_sendMultipleNullableTypes = _class.instanceMethodId(
    r'sendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypes;',
  );

  static final _sendMultipleNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypes sendMultipleNullableTypes(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes sendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypes(
            reference.pointer,
            _id_sendMultipleNullableTypes as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_sendMultipleNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'sendMultipleNullableTypesWithoutRecursion',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _sendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypesWithoutRecursion(
            reference.pointer,
            _id_sendMultipleNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypesWithoutRecursion>(
            const $JniAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_echoNullableInt = _class.instanceMethodId(
    r'echoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Long echoNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoNullableInt(reference.pointer,
            _id_echoNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNullableDouble = _class.instanceMethodId(
    r'echoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _echoNullableDouble = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Double echoNullableDouble(java.lang.Double double)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? echoNullableDouble(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _echoNullableDouble(reference.pointer,
            _id_echoNullableDouble as jni$_.JMethodIDPtr, _$double.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_echoNullableBool = _class.instanceMethodId(
    r'echoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _echoNullableBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Boolean echoNullableBool(java.lang.Boolean boolean)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? echoNullableBool(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _echoNullableBool(reference.pointer,
            _id_echoNullableBool as jni$_.JMethodIDPtr, _$boolean.pointer)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_echoNullableString = _class.instanceMethodId(
    r'echoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNullableString(reference.pointer,
            _id_echoNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_echoNullableUint8List = _class.instanceMethodId(
    r'echoNullableUint8List',
    r'([B)[B',
  );

  static final _echoNullableUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] echoNullableUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? echoNullableUint8List(
    jni$_.JByteArray? bs,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _echoNullableUint8List(reference.pointer,
            _id_echoNullableUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_echoNullableInt32List = _class.instanceMethodId(
    r'echoNullableInt32List',
    r'([I)[I',
  );

  static final _echoNullableInt32List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract int[] echoNullableInt32List(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? echoNullableInt32List(
    jni$_.JIntArray? is$,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _echoNullableInt32List(reference.pointer,
            _id_echoNullableInt32List as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_echoNullableInt64List = _class.instanceMethodId(
    r'echoNullableInt64List',
    r'([J)[J',
  );

  static final _echoNullableInt64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract long[] echoNullableInt64List(long[] js)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? echoNullableInt64List(
    jni$_.JLongArray? js,
  ) {
    final _$js = js?.reference ?? jni$_.jNullReference;
    return _echoNullableInt64List(reference.pointer,
            _id_echoNullableInt64List as jni$_.JMethodIDPtr, _$js.pointer)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_echoNullableFloat64List = _class.instanceMethodId(
    r'echoNullableFloat64List',
    r'([D)[D',
  );

  static final _echoNullableFloat64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract double[] echoNullableFloat64List(double[] ds)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? echoNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    return _echoNullableFloat64List(reference.pointer,
            _id_echoNullableFloat64List as jni$_.JMethodIDPtr, _$ds.pointer)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_echoNullableObject = _class.instanceMethodId(
    r'echoNullableObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoNullableObject = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoNullableObject(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? echoNullableObject(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _echoNullableObject(reference.pointer,
            _id_echoNullableObject as jni$_.JMethodIDPtr, _$object.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_echoNullableList = _class.instanceMethodId(
    r'echoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> echoNullableList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? echoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableList(reference.pointer,
            _id_echoNullableList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableEnumList = _class.instanceMethodId(
    r'echoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> echoNullableEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? echoNullableEnumList(
    jni$_.JList<JniAnEnum?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumList(reference.pointer,
            _id_echoNullableEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_echoNullableClassList = _class.instanceMethodId(
    r'echoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> echoNullableClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?>? echoNullableClassList(
    jni$_.JList<JniAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableClassList(reference.pointer,
            _id_echoNullableClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>?>(
            const jni$_.JListNullableType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullEnumList = _class.instanceMethodId(
    r'echoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> echoNullableNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum>? echoNullableNonNullEnumList(
    jni$_.JList<JniAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumList(
            reference.pointer,
            _id_echoNullableNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAnEnum>?>(
            const jni$_.JListNullableType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassList = _class.instanceMethodId(
    r'echoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> echoNullableNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes>? echoNullableNonNullClassList(
    jni$_.JList<JniAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassList(
            reference.pointer,
            _id_echoNullableNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>?>(
            const jni$_.JListNullableType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_echoNullableMap = _class.instanceMethodId(
    r'echoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> echoNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableMap(reference.pointer,
            _id_echoNullableMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableStringMap = _class.instanceMethodId(
    r'echoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableStringMap(reference.pointer,
            _id_echoNullableStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoNullableIntMap = _class.instanceMethodId(
    r'echoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableIntMap(reference.pointer,
            _id_echoNullableIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoNullableEnumMap = _class.instanceMethodId(
    r'echoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> echoNullableEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? echoNullableEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumMap(reference.pointer,
            _id_echoNullableEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_echoNullableClassMap = _class.instanceMethodId(
    r'echoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> echoNullableClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? echoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableClassMap(reference.pointer,
            _id_echoNullableClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullStringMap = _class.instanceMethodId(
    r'echoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNullableNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullStringMap(
            reference.pointer,
            _id_echoNullableNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNullableNonNullIntMap = _class.instanceMethodId(
    r'echoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNullableNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullIntMap(reference.pointer,
            _id_echoNullableNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
            const jni$_.JMapNullableType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNullableNonNullEnumMap = _class.instanceMethodId(
    r'echoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> echoNullableNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum>? echoNullableNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumMap(reference.pointer,
            _id_echoNullableNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>?>(
            const jni$_.JMapNullableType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassMap = _class.instanceMethodId(
    r'echoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> echoNullableNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? echoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassMap(
            reference.pointer,
            _id_echoNullableNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>?>(
            const jni$_.JMapNullableType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_echoNullableEnum = _class.instanceMethodId(
    r'echoNullableEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _echoNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnEnum echoNullableEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? echoNullableEnum(
    JniAnEnum? jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    return _echoNullableEnum(reference.pointer,
            _id_echoNullableEnum as jni$_.JMethodIDPtr, _$jniAnEnum.pointer)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_echoAnotherNullableEnum = _class.instanceMethodId(
    r'echoAnotherNullableEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _echoAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnotherEnum echoAnotherNullableEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? echoAnotherNullableEnum(
    JniAnotherEnum? jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    return _echoAnotherNullableEnum(
            reference.pointer,
            _id_echoAnotherNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_echoOptionalNullableInt = _class.instanceMethodId(
    r'echoOptionalNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoOptionalNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Long echoOptionalNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoOptionalNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoOptionalNullableInt(reference.pointer,
            _id_echoOptionalNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNamedNullableString = _class.instanceMethodId(
    r'echoNamedNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNamedNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoNamedNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNamedNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNamedNullableString(reference.pointer,
            _id_echoNamedNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_noopAsync = _class.instanceMethodId(
    r'noopAsync',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _noopAsync = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object noopAsync(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> noopAsync() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _noopAsync(reference.pointer,
            _id_noopAsync as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt = _class.instanceMethodId(
    r'echoAsyncInt',
    r'(JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncInt(long j, kotlin.coroutines.Continuation<? super java.lang.Long> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong> echoAsyncInt(
    int j,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncInt(reference.pointer,
            _id_echoAsyncInt as jni$_.JMethodIDPtr, j, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLong>(
      const jni$_.JLongType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncDouble = _class.instanceMethodId(
    r'echoAsyncDouble',
    r'(DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, double, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncDouble(double d, kotlin.coroutines.Continuation<? super java.lang.Double> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble> echoAsyncDouble(
    double d,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncDouble(
            reference.pointer,
            _id_echoAsyncDouble as jni$_.JMethodIDPtr,
            d,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDouble>(
      const jni$_.JDoubleType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncBool = _class.instanceMethodId(
    r'echoAsyncBool',
    r'(ZLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncBool(boolean z, kotlin.coroutines.Continuation<? super java.lang.Boolean> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean> echoAsyncBool(
    bool z,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncBool(
            reference.pointer,
            _id_echoAsyncBool as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JBoolean>(
      const jni$_.JBooleanType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncString = _class.instanceMethodId(
    r'echoAsyncString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncString(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echoAsyncString(
    jni$_.JString string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echoAsyncString(
            reference.pointer,
            _id_echoAsyncString as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.JStringType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncUint8List = _class.instanceMethodId(
    r'echoAsyncUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncUint8List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncUint8List(byte[] bs, kotlin.coroutines.Continuation<? super byte[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray> echoAsyncUint8List(
    jni$_.JByteArray bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs.reference;
    final $r = _echoAsyncUint8List(
            reference.pointer,
            _id_echoAsyncUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JByteArray>(
      const jni$_.JByteArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt32List = _class.instanceMethodId(
    r'echoAsyncInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt32List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncInt32List(int[] is, kotlin.coroutines.Continuation<? super int[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray> echoAsyncInt32List(
    jni$_.JIntArray is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$.reference;
    final $r = _echoAsyncInt32List(
            reference.pointer,
            _id_echoAsyncInt32List as jni$_.JMethodIDPtr,
            _$is$.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JIntArray>(
      const jni$_.JIntArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt64List = _class.instanceMethodId(
    r'echoAsyncInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt64List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncInt64List(long[] js, kotlin.coroutines.Continuation<? super long[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray> echoAsyncInt64List(
    jni$_.JLongArray js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js.reference;
    final $r = _echoAsyncInt64List(
            reference.pointer,
            _id_echoAsyncInt64List as jni$_.JMethodIDPtr,
            _$js.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLongArray>(
      const jni$_.JLongArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncFloat64List = _class.instanceMethodId(
    r'echoAsyncFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncFloat64List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncFloat64List(double[] ds, kotlin.coroutines.Continuation<? super double[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray> echoAsyncFloat64List(
    jni$_.JDoubleArray ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds.reference;
    final $r = _echoAsyncFloat64List(
            reference.pointer,
            _id_echoAsyncFloat64List as jni$_.JMethodIDPtr,
            _$ds.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDoubleArray>(
      const jni$_.JDoubleArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncObject = _class.instanceMethodId(
    r'echoAsyncObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncObject(java.lang.Object object, kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> echoAsyncObject(
    jni$_.JObject object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object.reference;
    final $r = _echoAsyncObject(
            reference.pointer,
            _id_echoAsyncObject as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncList = _class.instanceMethodId(
    r'echoAsyncList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncList(java.util.List<? extends java.lang.Object> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>> echoAsyncList(
    jni$_.JList<jni$_.JObject?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncList(
            reference.pointer,
            _id_echoAsyncList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumList = _class.instanceMethodId(
    r'echoAsyncEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncEnumList(java.util.List<? extends JniAnEnum> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAnEnum?>> echoAsyncEnumList(
    jni$_.JList<JniAnEnum?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncEnumList(
            reference.pointer,
            _id_echoAsyncEnumList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<JniAnEnum?>>(
      const jni$_.JListType<JniAnEnum?>($JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassList = _class.instanceMethodId(
    r'echoAsyncClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncClassList(java.util.List<JniAllNullableTypes> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAllNullableTypes?>> echoAsyncClassList(
    jni$_.JList<JniAllNullableTypes?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncClassList(
            reference.pointer,
            _id_echoAsyncClassList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<JniAllNullableTypes?>>(
      const jni$_.JListType<JniAllNullableTypes?>(
          $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncMap = _class.instanceMethodId(
    r'echoAsyncMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> echoAsyncMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncMap(
            reference.pointer,
            _id_echoAsyncMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
      const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
          jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncStringMap = _class.instanceMethodId(
    r'echoAsyncStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncStringMap(java.util.Map<java.lang.String, java.lang.String> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>> echoAsyncStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncStringMap(
            reference.pointer,
            _id_echoAsyncStringMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
      const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(), jni$_.JStringNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncIntMap = _class.instanceMethodId(
    r'echoAsyncIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncIntMap(java.util.Map<java.lang.Long, java.lang.Long> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>> echoAsyncIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncIntMap(
            reference.pointer,
            _id_echoAsyncIntMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
      const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
          jni$_.JLongNullableType(), jni$_.JLongNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumMap = _class.instanceMethodId(
    r'echoAsyncEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<JniAnEnum?, JniAnEnum?>> echoAsyncEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncEnumMap(
            reference.pointer,
            _id_echoAsyncEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<JniAnEnum?, JniAnEnum?>>(
      const jni$_.JMapType<JniAnEnum?, JniAnEnum?>(
          $JniAnEnum$NullableType(), $JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassMap = _class.instanceMethodId(
    r'echoAsyncClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>
      echoAsyncClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncClassMap(
            reference.pointer,
            _id_echoAsyncClassMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>(
      const jni$_.JMapType<jni$_.JLong?, JniAllNullableTypes?>(
          jni$_.JLongNullableType(), $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnum = _class.instanceMethodId(
    r'echoAsyncEnum',
    r'(LJniAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncEnum(JniAnEnum jniAnEnum, kotlin.coroutines.Continuation<? super JniAnEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnEnum> echoAsyncEnum(
    JniAnEnum jniAnEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnEnum = jniAnEnum.reference;
    final $r = _echoAsyncEnum(
            reference.pointer,
            _id_echoAsyncEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<JniAnEnum>(
      const $JniAnEnum$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncEnum = _class.instanceMethodId(
    r'echoAnotherAsyncEnum',
    r'(LJniAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAnotherAsyncEnum(JniAnotherEnum jniAnotherEnum, kotlin.coroutines.Continuation<? super JniAnotherEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnotherEnum> echoAnotherAsyncEnum(
    JniAnotherEnum jniAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    final $r = _echoAnotherAsyncEnum(
            reference.pointer,
            _id_echoAnotherAsyncEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<JniAnotherEnum>(
      const $JniAnotherEnum$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncError = _class.instanceMethodId(
    r'throwAsyncError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object throwAsyncError(kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncError(reference.pointer,
            _id_throwAsyncError as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncErrorFromVoid = _class.instanceMethodId(
    r'throwAsyncErrorFromVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object throwAsyncErrorFromVoid(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> throwAsyncErrorFromVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncErrorFromVoid(
            reference.pointer,
            _id_throwAsyncErrorFromVoid as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncFlutterError = _class.instanceMethodId(
    r'throwAsyncFlutterError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncFlutterError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object throwAsyncFlutterError(kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncFlutterError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncFlutterError(
            reference.pointer,
            _id_throwAsyncFlutterError as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncJniAllTypes = _class.instanceMethodId(
    r'echoAsyncJniAllTypes',
    r'(LJniAllTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncJniAllTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncJniAllTypes(JniAllTypes jniAllTypes, kotlin.coroutines.Continuation<? super JniAllTypes> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAllTypes> echoAsyncJniAllTypes(
    JniAllTypes jniAllTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAllTypes = jniAllTypes.reference;
    final $r = _echoAsyncJniAllTypes(
            reference.pointer,
            _id_echoAsyncJniAllTypes as jni$_.JMethodIDPtr,
            _$jniAllTypes.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<JniAllTypes>(
      const $JniAllTypes$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableJniAllNullableTypes =
      _class.instanceMethodId(
    r'echoAsyncNullableJniAllNullableTypes',
    r'(LJniAllNullableTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableJniAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableJniAllNullableTypes(JniAllNullableTypes jniAllNullableTypes, kotlin.coroutines.Continuation<? super JniAllNullableTypes> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAllNullableTypes?> echoAsyncNullableJniAllNullableTypes(
    JniAllNullableTypes? jniAllNullableTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableJniAllNullableTypes(
            reference.pointer,
            _id_echoAsyncNullableJniAllNullableTypes as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAllNullableTypes?>(
      const $JniAllNullableTypes$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableJniAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoAsyncNullableJniAllNullableTypesWithoutRecursion',
    r'(LJniAllNullableTypesWithoutRecursion;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableJniAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableJniAllNullableTypesWithoutRecursion(JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion, kotlin.coroutines.Continuation<? super JniAllNullableTypesWithoutRecursion> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAllNullableTypesWithoutRecursion?>
      echoAsyncNullableJniAllNullableTypesWithoutRecursion(
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableJniAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoAsyncNullableJniAllNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$jniAllNullableTypesWithoutRecursion.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAllNullableTypesWithoutRecursion?>(
      const $JniAllNullableTypesWithoutRecursion$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt = _class.instanceMethodId(
    r'echoAsyncNullableInt',
    r'(Ljava/lang/Long;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableInt(java.lang.Long long, kotlin.coroutines.Continuation<? super java.lang.Long> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong?> echoAsyncNullableInt(
    jni$_.JLong? long,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$long = long?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt(
            reference.pointer,
            _id_echoAsyncNullableInt as jni$_.JMethodIDPtr,
            _$long.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLong?>(
      const jni$_.JLongNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableDouble = _class.instanceMethodId(
    r'echoAsyncNullableDouble',
    r'(Ljava/lang/Double;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableDouble(java.lang.Double double, kotlin.coroutines.Continuation<? super java.lang.Double> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble?> echoAsyncNullableDouble(
    jni$_.JDouble? double,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$double = double?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableDouble(
            reference.pointer,
            _id_echoAsyncNullableDouble as jni$_.JMethodIDPtr,
            _$double.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDouble?>(
      const jni$_.JDoubleNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableBool = _class.instanceMethodId(
    r'echoAsyncNullableBool',
    r'(Ljava/lang/Boolean;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableBool(java.lang.Boolean boolean, kotlin.coroutines.Continuation<? super java.lang.Boolean> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean?> echoAsyncNullableBool(
    jni$_.JBoolean? boolean,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableBool(
            reference.pointer,
            _id_echoAsyncNullableBool as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JBoolean?>(
      const jni$_.JBooleanNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableString = _class.instanceMethodId(
    r'echoAsyncNullableString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableString(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString?> echoAsyncNullableString(
    jni$_.JString? string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableString(
            reference.pointer,
            _id_echoAsyncNullableString as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JString?>(
      const jni$_.JStringNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableUint8List = _class.instanceMethodId(
    r'echoAsyncNullableUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableUint8List(byte[] bs, kotlin.coroutines.Continuation<? super byte[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray?> echoAsyncNullableUint8List(
    jni$_.JByteArray? bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableUint8List(
            reference.pointer,
            _id_echoAsyncNullableUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JByteArray?>(
      const jni$_.JByteArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt32List = _class.instanceMethodId(
    r'echoAsyncNullableInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt32List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableInt32List(int[] is, kotlin.coroutines.Continuation<? super int[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray?> echoAsyncNullableInt32List(
    jni$_.JIntArray? is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt32List(
            reference.pointer,
            _id_echoAsyncNullableInt32List as jni$_.JMethodIDPtr,
            _$is$.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JIntArray?>(
      const jni$_.JIntArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt64List = _class.instanceMethodId(
    r'echoAsyncNullableInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt64List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableInt64List(long[] js, kotlin.coroutines.Continuation<? super long[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray?> echoAsyncNullableInt64List(
    jni$_.JLongArray? js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt64List(
            reference.pointer,
            _id_echoAsyncNullableInt64List as jni$_.JMethodIDPtr,
            _$js.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLongArray?>(
      const jni$_.JLongArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableFloat64List = _class.instanceMethodId(
    r'echoAsyncNullableFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableFloat64List(double[] ds, kotlin.coroutines.Continuation<? super double[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray?> echoAsyncNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableFloat64List(
            reference.pointer,
            _id_echoAsyncNullableFloat64List as jni$_.JMethodIDPtr,
            _$ds.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDoubleArray?>(
      const jni$_.JDoubleArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableObject = _class.instanceMethodId(
    r'echoAsyncNullableObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableObject(java.lang.Object object, kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> echoAsyncNullableObject(
    jni$_.JObject? object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableObject(
            reference.pointer,
            _id_echoAsyncNullableObject as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableList = _class.instanceMethodId(
    r'echoAsyncNullableList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableList(java.util.List<? extends java.lang.Object> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>?> echoAsyncNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableList(
            reference.pointer,
            _id_echoAsyncNullableList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.JListNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumList = _class.instanceMethodId(
    r'echoAsyncNullableEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableEnumList(java.util.List<? extends JniAnEnum> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAnEnum?>?> echoAsyncNullableEnumList(
    jni$_.JList<JniAnEnum?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumList(
            reference.pointer,
            _id_echoAsyncNullableEnumList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<JniAnEnum?>?>(
      const jni$_.JListNullableType<JniAnEnum?>($JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassList = _class.instanceMethodId(
    r'echoAsyncNullableClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableClassList(java.util.List<JniAllNullableTypes> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAllNullableTypes?>?> echoAsyncNullableClassList(
    jni$_.JList<JniAllNullableTypes?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassList(
            reference.pointer,
            _id_echoAsyncNullableClassList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<JniAllNullableTypes?>?>(
      const jni$_.JListNullableType<JniAllNullableTypes?>(
          $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableMap = _class.instanceMethodId(
    r'echoAsyncNullableMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>
      echoAsyncNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableMap(
            reference.pointer,
            _id_echoAsyncNullableMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
          jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableStringMap = _class.instanceMethodId(
    r'echoAsyncNullableStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>
      echoAsyncNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableStringMap(
            reference.pointer,
            _id_echoAsyncNullableStringMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(), jni$_.JStringNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableIntMap = _class.instanceMethodId(
    r'echoAsyncNullableIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>
      echoAsyncNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableIntMap(
            reference.pointer,
            _id_echoAsyncNullableIntMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
          jni$_.JLongNullableType(), jni$_.JLongNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumMap = _class.instanceMethodId(
    r'echoAsyncNullableEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<JniAnEnum?, JniAnEnum?>?> echoAsyncNullableEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumMap(
            reference.pointer,
            _id_echoAsyncNullableEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
      const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
          $JniAnEnum$NullableType(), $JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassMap = _class.instanceMethodId(
    r'echoAsyncNullableClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>
      echoAsyncNullableClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassMap(
            reference.pointer,
            _id_echoAsyncNullableClassMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
      const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
          jni$_.JLongNullableType(), $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnum = _class.instanceMethodId(
    r'echoAsyncNullableEnum',
    r'(LJniAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableEnum(JniAnEnum jniAnEnum, kotlin.coroutines.Continuation<? super JniAnEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnEnum?> echoAsyncNullableEnum(
    JniAnEnum? jniAnEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnum(
            reference.pointer,
            _id_echoAsyncNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAnEnum?>(
      const $JniAnEnum$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncNullableEnum = _class.instanceMethodId(
    r'echoAnotherAsyncNullableEnum',
    r'(LJniAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAnotherAsyncNullableEnum(JniAnotherEnum jniAnotherEnum, kotlin.coroutines.Continuation<? super JniAnotherEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnotherEnum?> echoAnotherAsyncNullableEnum(
    JniAnotherEnum? jniAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAnotherAsyncNullableEnum(
            reference.pointer,
            _id_echoAnotherAsyncNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAnotherEnum?>(
      const $JniAnotherEnum$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_callFlutterNoop = _class.instanceMethodId(
    r'callFlutterNoop',
    r'()V',
  );

  static final _callFlutterNoop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void callFlutterNoop()`
  void callFlutterNoop() {
    _callFlutterNoop(
            reference.pointer, _id_callFlutterNoop as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_callFlutterThrowError = _class.instanceMethodId(
    r'callFlutterThrowError',
    r'()Ljava/lang/Object;',
  );

  static final _callFlutterThrowError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.Object callFlutterThrowError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? callFlutterThrowError() {
    return _callFlutterThrowError(
            reference.pointer, _id_callFlutterThrowError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_callFlutterThrowErrorFromVoid = _class.instanceMethodId(
    r'callFlutterThrowErrorFromVoid',
    r'()V',
  );

  static final _callFlutterThrowErrorFromVoid =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public abstract void callFlutterThrowErrorFromVoid()`
  void callFlutterThrowErrorFromVoid() {
    _callFlutterThrowErrorFromVoid(reference.pointer,
            _id_callFlutterThrowErrorFromVoid as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_callFlutterEchoJniAllTypes = _class.instanceMethodId(
    r'callFlutterEchoJniAllTypes',
    r'(LJniAllTypes;)LJniAllTypes;',
  );

  static final _callFlutterEchoJniAllTypes =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllTypes callFlutterEchoJniAllTypes(JniAllTypes jniAllTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes callFlutterEchoJniAllTypes(
    JniAllTypes jniAllTypes,
  ) {
    final _$jniAllTypes = jniAllTypes.reference;
    return _callFlutterEchoJniAllTypes(
            reference.pointer,
            _id_callFlutterEchoJniAllTypes as jni$_.JMethodIDPtr,
            _$jniAllTypes.pointer)
        .object<JniAllTypes>(const $JniAllTypes$Type());
  }

  static final _id_callFlutterEchoJniAllNullableTypes = _class.instanceMethodId(
    r'callFlutterEchoJniAllNullableTypes',
    r'(LJniAllNullableTypes;)LJniAllNullableTypes;',
  );

  static final _callFlutterEchoJniAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypes callFlutterEchoJniAllNullableTypes(JniAllNullableTypes jniAllNullableTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes? callFlutterEchoJniAllNullableTypes(
    JniAllNullableTypes? jniAllNullableTypes,
  ) {
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoJniAllNullableTypes(
            reference.pointer,
            _id_callFlutterEchoJniAllNullableTypes as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer)
        .object<JniAllNullableTypes?>(
            const $JniAllNullableTypes$NullableType());
  }

  static final _id_callFlutterSendMultipleNullableTypes =
      _class.instanceMethodId(
    r'callFlutterSendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypes;',
  );

  static final _callFlutterSendMultipleNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypes callFlutterSendMultipleNullableTypes(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes callFlutterSendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _callFlutterSendMultipleNullableTypes(
            reference.pointer,
            _id_callFlutterSendMultipleNullableTypes as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_callFlutterEchoJniAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'callFlutterEchoJniAllNullableTypesWithoutRecursion',
    r'(LJniAllNullableTypesWithoutRecursion;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _callFlutterEchoJniAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypesWithoutRecursion callFlutterEchoJniAllNullableTypesWithoutRecursion(JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion?
      callFlutterEchoJniAllNullableTypesWithoutRecursion(
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
  ) {
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoJniAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_callFlutterEchoJniAllNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$jniAllNullableTypesWithoutRecursion.pointer)
        .object<JniAllNullableTypesWithoutRecursion?>(
            const $JniAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_callFlutterSendMultipleNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'callFlutterSendMultipleNullableTypesWithoutRecursion',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _callFlutterSendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypesWithoutRecursion callFlutterSendMultipleNullableTypesWithoutRecursion(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion
      callFlutterSendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _callFlutterSendMultipleNullableTypesWithoutRecursion(
            reference.pointer,
            _id_callFlutterSendMultipleNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypesWithoutRecursion>(
            const $JniAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_callFlutterEchoBool = _class.instanceMethodId(
    r'callFlutterEchoBool',
    r'(Z)Z',
  );

  static final _callFlutterEchoBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract boolean callFlutterEchoBool(boolean z)`
  bool callFlutterEchoBool(
    bool z,
  ) {
    return _callFlutterEchoBool(reference.pointer,
            _id_callFlutterEchoBool as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_callFlutterEchoInt = _class.instanceMethodId(
    r'callFlutterEchoInt',
    r'(J)J',
  );

  static final _callFlutterEchoInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract long callFlutterEchoInt(long j)`
  int callFlutterEchoInt(
    int j,
  ) {
    return _callFlutterEchoInt(
            reference.pointer, _id_callFlutterEchoInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_callFlutterEchoDouble = _class.instanceMethodId(
    r'callFlutterEchoDouble',
    r'(D)D',
  );

  static final _callFlutterEchoDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public abstract double callFlutterEchoDouble(double d)`
  double callFlutterEchoDouble(
    double d,
  ) {
    return _callFlutterEchoDouble(reference.pointer,
            _id_callFlutterEchoDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_callFlutterEchoString = _class.instanceMethodId(
    r'callFlutterEchoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _callFlutterEchoString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String callFlutterEchoString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString callFlutterEchoString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _callFlutterEchoString(reference.pointer,
            _id_callFlutterEchoString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_callFlutterEchoUint8List = _class.instanceMethodId(
    r'callFlutterEchoUint8List',
    r'([B)[B',
  );

  static final _callFlutterEchoUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] callFlutterEchoUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray callFlutterEchoUint8List(
    jni$_.JByteArray bs,
  ) {
    final _$bs = bs.reference;
    return _callFlutterEchoUint8List(reference.pointer,
            _id_callFlutterEchoUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_callFlutterEchoList = _class.instanceMethodId(
    r'callFlutterEchoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> callFlutterEchoList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> callFlutterEchoList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoList(reference.pointer,
            _id_callFlutterEchoList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoEnumList = _class.instanceMethodId(
    r'callFlutterEchoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> callFlutterEchoEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?> callFlutterEchoEnumList(
    jni$_.JList<JniAnEnum?> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoEnumList(reference.pointer,
            _id_callFlutterEchoEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>>(
            const jni$_.JListType<JniAnEnum?>($JniAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoClassList = _class.instanceMethodId(
    r'callFlutterEchoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> callFlutterEchoClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?> callFlutterEchoClassList(
    jni$_.JList<JniAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoClassList(reference.pointer,
            _id_callFlutterEchoClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>>(
            const jni$_.JListType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNonNullEnumList = _class.instanceMethodId(
    r'callFlutterEchoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> callFlutterEchoNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum> callFlutterEchoNonNullEnumList(
    jni$_.JList<JniAnEnum> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoNonNullEnumList(
            reference.pointer,
            _id_callFlutterEchoNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAnEnum>>(
            const jni$_.JListType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_callFlutterEchoNonNullClassList = _class.instanceMethodId(
    r'callFlutterEchoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> callFlutterEchoNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes> callFlutterEchoNonNullClassList(
    jni$_.JList<JniAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoNonNullClassList(
            reference.pointer,
            _id_callFlutterEchoNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>>(
            const jni$_.JListType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoMap = _class.instanceMethodId(
    r'callFlutterEchoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> callFlutterEchoMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> callFlutterEchoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoMap(reference.pointer,
            _id_callFlutterEchoMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoStringMap = _class.instanceMethodId(
    r'callFlutterEchoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> callFlutterEchoStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> callFlutterEchoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoStringMap(reference.pointer,
            _id_callFlutterEchoStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_callFlutterEchoIntMap = _class.instanceMethodId(
    r'callFlutterEchoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> callFlutterEchoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoIntMap(reference.pointer,
            _id_callFlutterEchoIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
            const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_callFlutterEchoEnumMap = _class.instanceMethodId(
    r'callFlutterEchoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> callFlutterEchoEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?> callFlutterEchoEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoEnumMap(reference.pointer,
            _id_callFlutterEchoEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>>(
            const jni$_.JMapType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoClassMap = _class.instanceMethodId(
    r'callFlutterEchoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> callFlutterEchoClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> callFlutterEchoClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoClassMap(reference.pointer,
            _id_callFlutterEchoClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNonNullStringMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> callFlutterEchoNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> callFlutterEchoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullStringMap(
            reference.pointer,
            _id_callFlutterEchoNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_callFlutterEchoNonNullIntMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullIntMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> callFlutterEchoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullIntMap(
            reference.pointer,
            _id_callFlutterEchoNonNullIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_callFlutterEchoNonNullEnumMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> callFlutterEchoNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum> callFlutterEchoNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullEnumMap(
            reference.pointer,
            _id_callFlutterEchoNonNullEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>>(
            const jni$_.JMapType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_callFlutterEchoNonNullClassMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> callFlutterEchoNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes> callFlutterEchoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullClassMap(
            reference.pointer,
            _id_callFlutterEchoNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>>(
            const jni$_.JMapType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoEnum = _class.instanceMethodId(
    r'callFlutterEchoEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _callFlutterEchoEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnEnum callFlutterEchoEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum callFlutterEchoEnum(
    JniAnEnum jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum.reference;
    return _callFlutterEchoEnum(reference.pointer,
            _id_callFlutterEchoEnum as jni$_.JMethodIDPtr, _$jniAnEnum.pointer)
        .object<JniAnEnum>(const $JniAnEnum$Type());
  }

  static final _id_callFlutterEchoJniAnotherEnum = _class.instanceMethodId(
    r'callFlutterEchoJniAnotherEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _callFlutterEchoJniAnotherEnum =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnotherEnum callFlutterEchoJniAnotherEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum callFlutterEchoJniAnotherEnum(
    JniAnotherEnum jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    return _callFlutterEchoJniAnotherEnum(
            reference.pointer,
            _id_callFlutterEchoJniAnotherEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum>(const $JniAnotherEnum$Type());
  }

  static final _id_callFlutterEchoNullableBool = _class.instanceMethodId(
    r'callFlutterEchoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _callFlutterEchoNullableBool =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Boolean callFlutterEchoNullableBool(java.lang.Boolean boolean)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? callFlutterEchoNullableBool(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableBool(
            reference.pointer,
            _id_callFlutterEchoNullableBool as jni$_.JMethodIDPtr,
            _$boolean.pointer)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_callFlutterEchoNullableInt = _class.instanceMethodId(
    r'callFlutterEchoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _callFlutterEchoNullableInt =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Long callFlutterEchoNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? callFlutterEchoNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableInt(
            reference.pointer,
            _id_callFlutterEchoNullableInt as jni$_.JMethodIDPtr,
            _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_callFlutterEchoNullableDouble = _class.instanceMethodId(
    r'callFlutterEchoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _callFlutterEchoNullableDouble =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Double callFlutterEchoNullableDouble(java.lang.Double double)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? callFlutterEchoNullableDouble(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableDouble(
            reference.pointer,
            _id_callFlutterEchoNullableDouble as jni$_.JMethodIDPtr,
            _$double.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_callFlutterEchoNullableString = _class.instanceMethodId(
    r'callFlutterEchoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _callFlutterEchoNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String callFlutterEchoNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? callFlutterEchoNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableString(
            reference.pointer,
            _id_callFlutterEchoNullableString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_callFlutterEchoNullableUint8List = _class.instanceMethodId(
    r'callFlutterEchoNullableUint8List',
    r'([B)[B',
  );

  static final _callFlutterEchoNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] callFlutterEchoNullableUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? callFlutterEchoNullableUint8List(
    jni$_.JByteArray? bs,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableUint8List(
            reference.pointer,
            _id_callFlutterEchoNullableUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_callFlutterEchoNullableList = _class.instanceMethodId(
    r'callFlutterEchoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> callFlutterEchoNullableList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? callFlutterEchoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableList(
            reference.pointer,
            _id_callFlutterEchoNullableList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoNullableEnumList = _class.instanceMethodId(
    r'callFlutterEchoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> callFlutterEchoNullableEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? callFlutterEchoNullableEnumList(
    jni$_.JList<JniAnEnum?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableEnumList(
            reference.pointer,
            _id_callFlutterEchoNullableEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoNullableClassList = _class.instanceMethodId(
    r'callFlutterEchoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> callFlutterEchoNullableClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?>? callFlutterEchoNullableClassList(
    jni$_.JList<JniAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableClassList(
            reference.pointer,
            _id_callFlutterEchoNullableClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>?>(
            const jni$_.JListNullableType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNullableNonNullEnumList =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> callFlutterEchoNullableNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum>? callFlutterEchoNullableNonNullEnumList(
    jni$_.JList<JniAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullEnumList(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAnEnum>?>(
            const jni$_.JListNullableType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_callFlutterEchoNullableNonNullClassList =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> callFlutterEchoNullableNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes>? callFlutterEchoNullableNonNullClassList(
    jni$_.JList<JniAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullClassList(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>?>(
            const jni$_.JListNullableType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoNullableMap = _class.instanceMethodId(
    r'callFlutterEchoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> callFlutterEchoNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? callFlutterEchoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableMap(reference.pointer,
            _id_callFlutterEchoNullableMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoNullableStringMap = _class.instanceMethodId(
    r'callFlutterEchoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> callFlutterEchoNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? callFlutterEchoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableStringMap(
            reference.pointer,
            _id_callFlutterEchoNullableStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_callFlutterEchoNullableIntMap = _class.instanceMethodId(
    r'callFlutterEchoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableIntMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? callFlutterEchoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableIntMap(
            reference.pointer,
            _id_callFlutterEchoNullableIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_callFlutterEchoNullableEnumMap = _class.instanceMethodId(
    r'callFlutterEchoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> callFlutterEchoNullableEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? callFlutterEchoNullableEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableEnumMap(
            reference.pointer,
            _id_callFlutterEchoNullableEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoNullableClassMap = _class.instanceMethodId(
    r'callFlutterEchoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> callFlutterEchoNullableClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?
      callFlutterEchoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableClassMap(
            reference.pointer,
            _id_callFlutterEchoNullableClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNullableNonNullStringMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> callFlutterEchoNullableNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>?
      callFlutterEchoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullStringMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_callFlutterEchoNullableNonNullIntMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullIntMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoNullableNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? callFlutterEchoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullIntMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
            const jni$_.JMapNullableType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_callFlutterEchoNullableNonNullEnumMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> callFlutterEchoNullableNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum>? callFlutterEchoNullableNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullEnumMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>?>(
            const jni$_.JMapNullableType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_callFlutterEchoNullableNonNullClassMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> callFlutterEchoNullableNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes>?
      callFlutterEchoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullClassMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>?>(
            const jni$_.JMapNullableType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoNullableEnum = _class.instanceMethodId(
    r'callFlutterEchoNullableEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _callFlutterEchoNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnEnum callFlutterEchoNullableEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? callFlutterEchoNullableEnum(
    JniAnEnum? jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableEnum(
            reference.pointer,
            _id_callFlutterEchoNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_callFlutterEchoAnotherNullableEnum = _class.instanceMethodId(
    r'callFlutterEchoAnotherNullableEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _callFlutterEchoAnotherNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnotherEnum callFlutterEchoAnotherNullableEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? callFlutterEchoAnotherNullableEnum(
    JniAnotherEnum? jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoAnotherNullableEnum(
            reference.pointer,
            _id_callFlutterEchoAnotherNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }
}

final class $JniHostIntegrationCoreApi$NullableType
    extends jni$_.JObjType<JniHostIntegrationCoreApi?> {
  @jni$_.internal
  const $JniHostIntegrationCoreApi$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  JniHostIntegrationCoreApi? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniHostIntegrationCoreApi.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostIntegrationCoreApi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniHostIntegrationCoreApi$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostIntegrationCoreApi$NullableType) &&
        other is $JniHostIntegrationCoreApi$NullableType;
  }
}

final class $JniHostIntegrationCoreApi$Type
    extends jni$_.JObjType<JniHostIntegrationCoreApi> {
  @jni$_.internal
  const $JniHostIntegrationCoreApi$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  JniHostIntegrationCoreApi fromReference(jni$_.JReference reference) =>
      JniHostIntegrationCoreApi.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostIntegrationCoreApi?> get nullableType =>
      const $JniHostIntegrationCoreApi$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniHostIntegrationCoreApi$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostIntegrationCoreApi$Type) &&
        other is $JniHostIntegrationCoreApi$Type;
  }
}

/// from: `JniHostIntegrationCoreApiRegistrar`
class JniHostIntegrationCoreApiRegistrar extends JniHostIntegrationCoreApi {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniHostIntegrationCoreApiRegistrar> $type;

  @jni$_.internal
  JniHostIntegrationCoreApiRegistrar.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'JniHostIntegrationCoreApiRegistrar');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $JniHostIntegrationCoreApiRegistrar$NullableType();
  static const type = $JniHostIntegrationCoreApiRegistrar$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniHostIntegrationCoreApiRegistrar() {
    return JniHostIntegrationCoreApiRegistrar.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getApi = _class.instanceMethodId(
    r'getApi',
    r'()LJniHostIntegrationCoreApi;',
  );

  static final _getApi = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniHostIntegrationCoreApi getApi()`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostIntegrationCoreApi? getApi() {
    return _getApi(reference.pointer, _id_getApi as jni$_.JMethodIDPtr)
        .object<JniHostIntegrationCoreApi?>(
            const $JniHostIntegrationCoreApi$NullableType());
  }

  static final _id_setApi = _class.instanceMethodId(
    r'setApi',
    r'(LJniHostIntegrationCoreApi;)V',
  );

  static final _setApi = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setApi(JniHostIntegrationCoreApi jniHostIntegrationCoreApi)`
  void setApi(
    JniHostIntegrationCoreApi? jniHostIntegrationCoreApi,
  ) {
    final _$jniHostIntegrationCoreApi =
        jniHostIntegrationCoreApi?.reference ?? jni$_.jNullReference;
    _setApi(reference.pointer, _id_setApi as jni$_.JMethodIDPtr,
            _$jniHostIntegrationCoreApi.pointer)
        .check();
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(LJniHostIntegrationCoreApi;Ljava/lang/String;)LJniHostIntegrationCoreApiRegistrar;',
  );

  static final _register = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniHostIntegrationCoreApiRegistrar register(JniHostIntegrationCoreApi jniHostIntegrationCoreApi, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostIntegrationCoreApiRegistrar register(
    JniHostIntegrationCoreApi jniHostIntegrationCoreApi,
    jni$_.JString string,
  ) {
    final _$jniHostIntegrationCoreApi = jniHostIntegrationCoreApi.reference;
    final _$string = string.reference;
    return _register(reference.pointer, _id_register as jni$_.JMethodIDPtr,
            _$jniHostIntegrationCoreApi.pointer, _$string.pointer)
        .object<JniHostIntegrationCoreApiRegistrar>(
            const $JniHostIntegrationCoreApiRegistrar$Type());
  }

  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Ljava/lang/String;)LJniHostIntegrationCoreApiRegistrar;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniHostIntegrationCoreApiRegistrar getInstance(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostIntegrationCoreApiRegistrar? getInstance(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getInstance(reference.pointer,
            _id_getInstance as jni$_.JMethodIDPtr, _$string.pointer)
        .object<JniHostIntegrationCoreApiRegistrar?>(
            const $JniHostIntegrationCoreApiRegistrar$NullableType());
  }

  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }

  static final _id_echoAllTypes = _class.instanceMethodId(
    r'echoAllTypes',
    r'(LJniAllTypes;)LJniAllTypes;',
  );

  static final _echoAllTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllTypes echoAllTypes(JniAllTypes jniAllTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes echoAllTypes(
    JniAllTypes jniAllTypes,
  ) {
    final _$jniAllTypes = jniAllTypes.reference;
    return _echoAllTypes(reference.pointer,
            _id_echoAllTypes as jni$_.JMethodIDPtr, _$jniAllTypes.pointer)
        .object<JniAllTypes>(const $JniAllTypes$Type());
  }

  static final _id_throwError = _class.instanceMethodId(
    r'throwError',
    r'()Ljava/lang/Object;',
  );

  static final _throwError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object throwError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwError() {
    return _throwError(reference.pointer, _id_throwError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_throwErrorFromVoid = _class.instanceMethodId(
    r'throwErrorFromVoid',
    r'()V',
  );

  static final _throwErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void throwErrorFromVoid()`
  void throwErrorFromVoid() {
    _throwErrorFromVoid(
            reference.pointer, _id_throwErrorFromVoid as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_throwFlutterError = _class.instanceMethodId(
    r'throwFlutterError',
    r'()Ljava/lang/Object;',
  );

  static final _throwFlutterError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object throwFlutterError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwFlutterError() {
    return _throwFlutterError(
            reference.pointer, _id_throwFlutterError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_echoInt = _class.instanceMethodId(
    r'echoInt',
    r'(J)J',
  );

  static final _echoInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public long echoInt(long j)`
  int echoInt(
    int j,
  ) {
    return _echoInt(reference.pointer, _id_echoInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoDouble = _class.instanceMethodId(
    r'echoDouble',
    r'(D)D',
  );

  static final _echoDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public double echoDouble(double d)`
  double echoDouble(
    double d,
  ) {
    return _echoDouble(
            reference.pointer, _id_echoDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoBool = _class.instanceMethodId(
    r'echoBool',
    r'(Z)Z',
  );

  static final _echoBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean echoBool(boolean z)`
  bool echoBool(
    bool z,
  ) {
    return _echoBool(
            reference.pointer, _id_echoBool as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_echoString = _class.instanceMethodId(
    r'echoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echoString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoString(reference.pointer, _id_echoString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoUint8List = _class.instanceMethodId(
    r'echoUint8List',
    r'([B)[B',
  );

  static final _echoUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public byte[] echoUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray echoUint8List(
    jni$_.JByteArray bs,
  ) {
    final _$bs = bs.reference;
    return _echoUint8List(reference.pointer,
            _id_echoUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_echoInt32List = _class.instanceMethodId(
    r'echoInt32List',
    r'([I)[I',
  );

  static final _echoInt32List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int[] echoInt32List(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray echoInt32List(
    jni$_.JIntArray is$,
  ) {
    final _$is$ = is$.reference;
    return _echoInt32List(reference.pointer,
            _id_echoInt32List as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<jni$_.JIntArray>(const jni$_.JIntArrayType());
  }

  static final _id_echoInt64List = _class.instanceMethodId(
    r'echoInt64List',
    r'([J)[J',
  );

  static final _echoInt64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long[] echoInt64List(long[] js)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray echoInt64List(
    jni$_.JLongArray js,
  ) {
    final _$js = js.reference;
    return _echoInt64List(reference.pointer,
            _id_echoInt64List as jni$_.JMethodIDPtr, _$js.pointer)
        .object<jni$_.JLongArray>(const jni$_.JLongArrayType());
  }

  static final _id_echoFloat64List = _class.instanceMethodId(
    r'echoFloat64List',
    r'([D)[D',
  );

  static final _echoFloat64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public double[] echoFloat64List(double[] ds)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray echoFloat64List(
    jni$_.JDoubleArray ds,
  ) {
    final _$ds = ds.reference;
    return _echoFloat64List(reference.pointer,
            _id_echoFloat64List as jni$_.JMethodIDPtr, _$ds.pointer)
        .object<jni$_.JDoubleArray>(const jni$_.JDoubleArrayType());
  }

  static final _id_echoObject = _class.instanceMethodId(
    r'echoObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoObject = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoObject(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject echoObject(
    jni$_.JObject object,
  ) {
    final _$object = object.reference;
    return _echoObject(reference.pointer, _id_echoObject as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_echoList = _class.instanceMethodId(
    r'echoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<java.lang.Object> echoList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> echoList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _echoList(reference.pointer, _id_echoList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_echoEnumList = _class.instanceMethodId(
    r'echoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAnEnum> echoEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?> echoEnumList(
    jni$_.JList<JniAnEnum?> list,
  ) {
    final _$list = list.reference;
    return _echoEnumList(reference.pointer,
            _id_echoEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>>(
            const jni$_.JListType<JniAnEnum?>($JniAnEnum$NullableType()));
  }

  static final _id_echoClassList = _class.instanceMethodId(
    r'echoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAllNullableTypes> echoClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?> echoClassList(
    jni$_.JList<JniAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _echoClassList(reference.pointer,
            _id_echoClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>>(
            const jni$_.JListType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullEnumList = _class.instanceMethodId(
    r'echoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAnEnum> echoNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum> echoNonNullEnumList(
    jni$_.JList<JniAnEnum> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullEnumList(reference.pointer,
            _id_echoNonNullEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum>>(
            const jni$_.JListType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_echoNonNullClassList = _class.instanceMethodId(
    r'echoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAllNullableTypes> echoNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes> echoNonNullClassList(
    jni$_.JList<JniAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullClassList(reference.pointer,
            _id_echoNonNullClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>>(
            const jni$_.JListType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_echoMap = _class.instanceMethodId(
    r'echoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Object, java.lang.Object> echoMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _echoMap(
            reference.pointer, _id_echoMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoStringMap = _class.instanceMethodId(
    r'echoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> echoStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _echoStringMap(reference.pointer,
            _id_echoStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoIntMap = _class.instanceMethodId(
    r'echoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> echoIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _echoIntMap(reference.pointer, _id_echoIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
            const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoEnumMap = _class.instanceMethodId(
    r'echoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<JniAnEnum, JniAnEnum> echoEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?> echoEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _echoEnumMap(reference.pointer,
            _id_echoEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>>(
            const jni$_.JMapType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_echoClassMap = _class.instanceMethodId(
    r'echoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, JniAllNullableTypes> echoClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> echoClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _echoClassMap(reference.pointer,
            _id_echoClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullStringMap = _class.instanceMethodId(
    r'echoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> echoNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullStringMap(reference.pointer,
            _id_echoNonNullStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNonNullIntMap = _class.instanceMethodId(
    r'echoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> echoNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullIntMap(reference.pointer,
            _id_echoNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNonNullEnumMap = _class.instanceMethodId(
    r'echoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<JniAnEnum, JniAnEnum> echoNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum> echoNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullEnumMap(reference.pointer,
            _id_echoNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>>(
            const jni$_.JMapType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_echoNonNullClassMap = _class.instanceMethodId(
    r'echoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, JniAllNullableTypes> echoNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes> echoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullClassMap(reference.pointer,
            _id_echoNonNullClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>>(
            const jni$_.JMapType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_echoClassWrapper = _class.instanceMethodId(
    r'echoClassWrapper',
    r'(LJniAllClassesWrapper;)LJniAllClassesWrapper;',
  );

  static final _echoClassWrapper = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllClassesWrapper echoClassWrapper(JniAllClassesWrapper jniAllClassesWrapper)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllClassesWrapper echoClassWrapper(
    JniAllClassesWrapper jniAllClassesWrapper,
  ) {
    final _$jniAllClassesWrapper = jniAllClassesWrapper.reference;
    return _echoClassWrapper(
            reference.pointer,
            _id_echoClassWrapper as jni$_.JMethodIDPtr,
            _$jniAllClassesWrapper.pointer)
        .object<JniAllClassesWrapper>(const $JniAllClassesWrapper$Type());
  }

  static final _id_echoEnum = _class.instanceMethodId(
    r'echoEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _echoEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAnEnum echoEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum echoEnum(
    JniAnEnum jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum.reference;
    return _echoEnum(reference.pointer, _id_echoEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer)
        .object<JniAnEnum>(const $JniAnEnum$Type());
  }

  static final _id_echoAnotherEnum = _class.instanceMethodId(
    r'echoAnotherEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _echoAnotherEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAnotherEnum echoAnotherEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum echoAnotherEnum(
    JniAnotherEnum jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    return _echoAnotherEnum(reference.pointer,
            _id_echoAnotherEnum as jni$_.JMethodIDPtr, _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum>(const $JniAnotherEnum$Type());
  }

  static final _id_echoNamedDefaultString = _class.instanceMethodId(
    r'echoNamedDefaultString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNamedDefaultString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echoNamedDefaultString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoNamedDefaultString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoNamedDefaultString(reference.pointer,
            _id_echoNamedDefaultString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoOptionalDefaultDouble = _class.instanceMethodId(
    r'echoOptionalDefaultDouble',
    r'(D)D',
  );

  static final _echoOptionalDefaultDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public double echoOptionalDefaultDouble(double d)`
  double echoOptionalDefaultDouble(
    double d,
  ) {
    return _echoOptionalDefaultDouble(reference.pointer,
            _id_echoOptionalDefaultDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoRequiredInt = _class.instanceMethodId(
    r'echoRequiredInt',
    r'(J)J',
  );

  static final _echoRequiredInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public long echoRequiredInt(long j)`
  int echoRequiredInt(
    int j,
  ) {
    return _echoRequiredInt(
            reference.pointer, _id_echoRequiredInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoAllNullableTypes = _class.instanceMethodId(
    r'echoAllNullableTypes',
    r'(LJniAllNullableTypes;)LJniAllNullableTypes;',
  );

  static final _echoAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllNullableTypes echoAllNullableTypes(JniAllNullableTypes jniAllNullableTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes? echoAllNullableTypes(
    JniAllNullableTypes? jniAllNullableTypes,
  ) {
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypes(
            reference.pointer,
            _id_echoAllNullableTypes as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer)
        .object<JniAllNullableTypes?>(
            const $JniAllNullableTypes$NullableType());
  }

  static final _id_echoAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoAllNullableTypesWithoutRecursion',
    r'(LJniAllNullableTypesWithoutRecursion;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _echoAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllNullableTypesWithoutRecursion echoAllNullableTypesWithoutRecursion(JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion? echoAllNullableTypesWithoutRecursion(
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
  ) {
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$jniAllNullableTypesWithoutRecursion.pointer)
        .object<JniAllNullableTypesWithoutRecursion?>(
            const $JniAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_extractNestedNullableString = _class.instanceMethodId(
    r'extractNestedNullableString',
    r'(LJniAllClassesWrapper;)Ljava/lang/String;',
  );

  static final _extractNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String extractNestedNullableString(JniAllClassesWrapper jniAllClassesWrapper)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? extractNestedNullableString(
    JniAllClassesWrapper jniAllClassesWrapper,
  ) {
    final _$jniAllClassesWrapper = jniAllClassesWrapper.reference;
    return _extractNestedNullableString(
            reference.pointer,
            _id_extractNestedNullableString as jni$_.JMethodIDPtr,
            _$jniAllClassesWrapper.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_createNestedNullableString = _class.instanceMethodId(
    r'createNestedNullableString',
    r'(Ljava/lang/String;)LJniAllClassesWrapper;',
  );

  static final _createNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllClassesWrapper createNestedNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllClassesWrapper createNestedNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createNestedNullableString(
            reference.pointer,
            _id_createNestedNullableString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<JniAllClassesWrapper>(const $JniAllClassesWrapper$Type());
  }

  static final _id_sendMultipleNullableTypes = _class.instanceMethodId(
    r'sendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypes;',
  );

  static final _sendMultipleNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllNullableTypes sendMultipleNullableTypes(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes sendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypes(
            reference.pointer,
            _id_sendMultipleNullableTypes as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_sendMultipleNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'sendMultipleNullableTypesWithoutRecursion',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _sendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypesWithoutRecursion(
            reference.pointer,
            _id_sendMultipleNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypesWithoutRecursion>(
            const $JniAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_echoNullableInt = _class.instanceMethodId(
    r'echoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Long echoNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoNullableInt(reference.pointer,
            _id_echoNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNullableDouble = _class.instanceMethodId(
    r'echoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _echoNullableDouble = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Double echoNullableDouble(java.lang.Double double)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? echoNullableDouble(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _echoNullableDouble(reference.pointer,
            _id_echoNullableDouble as jni$_.JMethodIDPtr, _$double.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_echoNullableBool = _class.instanceMethodId(
    r'echoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _echoNullableBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Boolean echoNullableBool(java.lang.Boolean boolean)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? echoNullableBool(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _echoNullableBool(reference.pointer,
            _id_echoNullableBool as jni$_.JMethodIDPtr, _$boolean.pointer)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_echoNullableString = _class.instanceMethodId(
    r'echoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echoNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNullableString(reference.pointer,
            _id_echoNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_echoNullableUint8List = _class.instanceMethodId(
    r'echoNullableUint8List',
    r'([B)[B',
  );

  static final _echoNullableUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public byte[] echoNullableUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? echoNullableUint8List(
    jni$_.JByteArray? bs,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _echoNullableUint8List(reference.pointer,
            _id_echoNullableUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_echoNullableInt32List = _class.instanceMethodId(
    r'echoNullableInt32List',
    r'([I)[I',
  );

  static final _echoNullableInt32List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int[] echoNullableInt32List(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? echoNullableInt32List(
    jni$_.JIntArray? is$,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _echoNullableInt32List(reference.pointer,
            _id_echoNullableInt32List as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_echoNullableInt64List = _class.instanceMethodId(
    r'echoNullableInt64List',
    r'([J)[J',
  );

  static final _echoNullableInt64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long[] echoNullableInt64List(long[] js)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? echoNullableInt64List(
    jni$_.JLongArray? js,
  ) {
    final _$js = js?.reference ?? jni$_.jNullReference;
    return _echoNullableInt64List(reference.pointer,
            _id_echoNullableInt64List as jni$_.JMethodIDPtr, _$js.pointer)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_echoNullableFloat64List = _class.instanceMethodId(
    r'echoNullableFloat64List',
    r'([D)[D',
  );

  static final _echoNullableFloat64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public double[] echoNullableFloat64List(double[] ds)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? echoNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    return _echoNullableFloat64List(reference.pointer,
            _id_echoNullableFloat64List as jni$_.JMethodIDPtr, _$ds.pointer)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_echoNullableObject = _class.instanceMethodId(
    r'echoNullableObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoNullableObject = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoNullableObject(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? echoNullableObject(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _echoNullableObject(reference.pointer,
            _id_echoNullableObject as jni$_.JMethodIDPtr, _$object.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_echoNullableList = _class.instanceMethodId(
    r'echoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<java.lang.Object> echoNullableList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? echoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableList(reference.pointer,
            _id_echoNullableList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableEnumList = _class.instanceMethodId(
    r'echoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAnEnum> echoNullableEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? echoNullableEnumList(
    jni$_.JList<JniAnEnum?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumList(reference.pointer,
            _id_echoNullableEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_echoNullableClassList = _class.instanceMethodId(
    r'echoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAllNullableTypes> echoNullableClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?>? echoNullableClassList(
    jni$_.JList<JniAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableClassList(reference.pointer,
            _id_echoNullableClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>?>(
            const jni$_.JListNullableType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullEnumList = _class.instanceMethodId(
    r'echoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAnEnum> echoNullableNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum>? echoNullableNonNullEnumList(
    jni$_.JList<JniAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumList(
            reference.pointer,
            _id_echoNullableNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAnEnum>?>(
            const jni$_.JListNullableType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassList = _class.instanceMethodId(
    r'echoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAllNullableTypes> echoNullableNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes>? echoNullableNonNullClassList(
    jni$_.JList<JniAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassList(
            reference.pointer,
            _id_echoNullableNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>?>(
            const jni$_.JListNullableType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_echoNullableMap = _class.instanceMethodId(
    r'echoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Object, java.lang.Object> echoNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableMap(reference.pointer,
            _id_echoNullableMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableStringMap = _class.instanceMethodId(
    r'echoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> echoNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableStringMap(reference.pointer,
            _id_echoNullableStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoNullableIntMap = _class.instanceMethodId(
    r'echoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> echoNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableIntMap(reference.pointer,
            _id_echoNullableIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoNullableEnumMap = _class.instanceMethodId(
    r'echoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<JniAnEnum, JniAnEnum> echoNullableEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? echoNullableEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumMap(reference.pointer,
            _id_echoNullableEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_echoNullableClassMap = _class.instanceMethodId(
    r'echoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, JniAllNullableTypes> echoNullableClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? echoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableClassMap(reference.pointer,
            _id_echoNullableClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullStringMap = _class.instanceMethodId(
    r'echoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> echoNullableNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullStringMap(
            reference.pointer,
            _id_echoNullableNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNullableNonNullIntMap = _class.instanceMethodId(
    r'echoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> echoNullableNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullIntMap(reference.pointer,
            _id_echoNullableNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
            const jni$_.JMapNullableType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNullableNonNullEnumMap = _class.instanceMethodId(
    r'echoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<JniAnEnum, JniAnEnum> echoNullableNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum>? echoNullableNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumMap(reference.pointer,
            _id_echoNullableNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>?>(
            const jni$_.JMapNullableType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassMap = _class.instanceMethodId(
    r'echoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, JniAllNullableTypes> echoNullableNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? echoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassMap(
            reference.pointer,
            _id_echoNullableNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>?>(
            const jni$_.JMapNullableType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_echoNullableEnum = _class.instanceMethodId(
    r'echoNullableEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _echoNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAnEnum echoNullableEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? echoNullableEnum(
    JniAnEnum? jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    return _echoNullableEnum(reference.pointer,
            _id_echoNullableEnum as jni$_.JMethodIDPtr, _$jniAnEnum.pointer)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_echoAnotherNullableEnum = _class.instanceMethodId(
    r'echoAnotherNullableEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _echoAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAnotherEnum echoAnotherNullableEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? echoAnotherNullableEnum(
    JniAnotherEnum? jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    return _echoAnotherNullableEnum(
            reference.pointer,
            _id_echoAnotherNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_echoOptionalNullableInt = _class.instanceMethodId(
    r'echoOptionalNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoOptionalNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Long echoOptionalNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoOptionalNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoOptionalNullableInt(reference.pointer,
            _id_echoOptionalNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNamedNullableString = _class.instanceMethodId(
    r'echoNamedNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNamedNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echoNamedNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNamedNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNamedNullableString(reference.pointer,
            _id_echoNamedNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_noopAsync = _class.instanceMethodId(
    r'noopAsync',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _noopAsync = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object noopAsync(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> noopAsync() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _noopAsync(reference.pointer,
            _id_noopAsync as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt = _class.instanceMethodId(
    r'echoAsyncInt',
    r'(JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncInt(long j, kotlin.coroutines.Continuation<? super java.lang.Long> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong> echoAsyncInt(
    int j,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncInt(reference.pointer,
            _id_echoAsyncInt as jni$_.JMethodIDPtr, j, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLong>(
      const jni$_.JLongType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncDouble = _class.instanceMethodId(
    r'echoAsyncDouble',
    r'(DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, double, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncDouble(double d, kotlin.coroutines.Continuation<? super java.lang.Double> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble> echoAsyncDouble(
    double d,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncDouble(
            reference.pointer,
            _id_echoAsyncDouble as jni$_.JMethodIDPtr,
            d,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDouble>(
      const jni$_.JDoubleType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncBool = _class.instanceMethodId(
    r'echoAsyncBool',
    r'(ZLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncBool(boolean z, kotlin.coroutines.Continuation<? super java.lang.Boolean> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean> echoAsyncBool(
    bool z,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncBool(
            reference.pointer,
            _id_echoAsyncBool as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JBoolean>(
      const jni$_.JBooleanType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncString = _class.instanceMethodId(
    r'echoAsyncString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncString(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echoAsyncString(
    jni$_.JString string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echoAsyncString(
            reference.pointer,
            _id_echoAsyncString as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.JStringType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncUint8List = _class.instanceMethodId(
    r'echoAsyncUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncUint8List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncUint8List(byte[] bs, kotlin.coroutines.Continuation<? super byte[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray> echoAsyncUint8List(
    jni$_.JByteArray bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs.reference;
    final $r = _echoAsyncUint8List(
            reference.pointer,
            _id_echoAsyncUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JByteArray>(
      const jni$_.JByteArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt32List = _class.instanceMethodId(
    r'echoAsyncInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt32List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncInt32List(int[] is, kotlin.coroutines.Continuation<? super int[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray> echoAsyncInt32List(
    jni$_.JIntArray is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$.reference;
    final $r = _echoAsyncInt32List(
            reference.pointer,
            _id_echoAsyncInt32List as jni$_.JMethodIDPtr,
            _$is$.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JIntArray>(
      const jni$_.JIntArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt64List = _class.instanceMethodId(
    r'echoAsyncInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt64List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncInt64List(long[] js, kotlin.coroutines.Continuation<? super long[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray> echoAsyncInt64List(
    jni$_.JLongArray js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js.reference;
    final $r = _echoAsyncInt64List(
            reference.pointer,
            _id_echoAsyncInt64List as jni$_.JMethodIDPtr,
            _$js.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLongArray>(
      const jni$_.JLongArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncFloat64List = _class.instanceMethodId(
    r'echoAsyncFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncFloat64List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncFloat64List(double[] ds, kotlin.coroutines.Continuation<? super double[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray> echoAsyncFloat64List(
    jni$_.JDoubleArray ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds.reference;
    final $r = _echoAsyncFloat64List(
            reference.pointer,
            _id_echoAsyncFloat64List as jni$_.JMethodIDPtr,
            _$ds.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDoubleArray>(
      const jni$_.JDoubleArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncObject = _class.instanceMethodId(
    r'echoAsyncObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncObject(java.lang.Object object, kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> echoAsyncObject(
    jni$_.JObject object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object.reference;
    final $r = _echoAsyncObject(
            reference.pointer,
            _id_echoAsyncObject as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncList = _class.instanceMethodId(
    r'echoAsyncList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncList(java.util.List<? extends java.lang.Object> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>> echoAsyncList(
    jni$_.JList<jni$_.JObject?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncList(
            reference.pointer,
            _id_echoAsyncList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumList = _class.instanceMethodId(
    r'echoAsyncEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncEnumList(java.util.List<? extends JniAnEnum> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAnEnum?>> echoAsyncEnumList(
    jni$_.JList<JniAnEnum?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncEnumList(
            reference.pointer,
            _id_echoAsyncEnumList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<JniAnEnum?>>(
      const jni$_.JListType<JniAnEnum?>($JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassList = _class.instanceMethodId(
    r'echoAsyncClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncClassList(java.util.List<JniAllNullableTypes> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAllNullableTypes?>> echoAsyncClassList(
    jni$_.JList<JniAllNullableTypes?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncClassList(
            reference.pointer,
            _id_echoAsyncClassList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<JniAllNullableTypes?>>(
      const jni$_.JListType<JniAllNullableTypes?>(
          $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncMap = _class.instanceMethodId(
    r'echoAsyncMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> echoAsyncMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncMap(
            reference.pointer,
            _id_echoAsyncMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
      const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
          jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncStringMap = _class.instanceMethodId(
    r'echoAsyncStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncStringMap(java.util.Map<java.lang.String, java.lang.String> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>> echoAsyncStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncStringMap(
            reference.pointer,
            _id_echoAsyncStringMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
      const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(), jni$_.JStringNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncIntMap = _class.instanceMethodId(
    r'echoAsyncIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncIntMap(java.util.Map<java.lang.Long, java.lang.Long> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>> echoAsyncIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncIntMap(
            reference.pointer,
            _id_echoAsyncIntMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
      const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
          jni$_.JLongNullableType(), jni$_.JLongNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumMap = _class.instanceMethodId(
    r'echoAsyncEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<JniAnEnum?, JniAnEnum?>> echoAsyncEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncEnumMap(
            reference.pointer,
            _id_echoAsyncEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<JniAnEnum?, JniAnEnum?>>(
      const jni$_.JMapType<JniAnEnum?, JniAnEnum?>(
          $JniAnEnum$NullableType(), $JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassMap = _class.instanceMethodId(
    r'echoAsyncClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>
      echoAsyncClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncClassMap(
            reference.pointer,
            _id_echoAsyncClassMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>(
      const jni$_.JMapType<jni$_.JLong?, JniAllNullableTypes?>(
          jni$_.JLongNullableType(), $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnum = _class.instanceMethodId(
    r'echoAsyncEnum',
    r'(LJniAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncEnum(JniAnEnum jniAnEnum, kotlin.coroutines.Continuation<? super JniAnEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnEnum> echoAsyncEnum(
    JniAnEnum jniAnEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnEnum = jniAnEnum.reference;
    final $r = _echoAsyncEnum(
            reference.pointer,
            _id_echoAsyncEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<JniAnEnum>(
      const $JniAnEnum$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncEnum = _class.instanceMethodId(
    r'echoAnotherAsyncEnum',
    r'(LJniAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAnotherAsyncEnum(JniAnotherEnum jniAnotherEnum, kotlin.coroutines.Continuation<? super JniAnotherEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnotherEnum> echoAnotherAsyncEnum(
    JniAnotherEnum jniAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    final $r = _echoAnotherAsyncEnum(
            reference.pointer,
            _id_echoAnotherAsyncEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<JniAnotherEnum>(
      const $JniAnotherEnum$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncError = _class.instanceMethodId(
    r'throwAsyncError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object throwAsyncError(kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncError(reference.pointer,
            _id_throwAsyncError as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncErrorFromVoid = _class.instanceMethodId(
    r'throwAsyncErrorFromVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object throwAsyncErrorFromVoid(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> throwAsyncErrorFromVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncErrorFromVoid(
            reference.pointer,
            _id_throwAsyncErrorFromVoid as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncFlutterError = _class.instanceMethodId(
    r'throwAsyncFlutterError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncFlutterError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object throwAsyncFlutterError(kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncFlutterError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncFlutterError(
            reference.pointer,
            _id_throwAsyncFlutterError as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncJniAllTypes = _class.instanceMethodId(
    r'echoAsyncJniAllTypes',
    r'(LJniAllTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncJniAllTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncJniAllTypes(JniAllTypes jniAllTypes, kotlin.coroutines.Continuation<? super JniAllTypes> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAllTypes> echoAsyncJniAllTypes(
    JniAllTypes jniAllTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAllTypes = jniAllTypes.reference;
    final $r = _echoAsyncJniAllTypes(
            reference.pointer,
            _id_echoAsyncJniAllTypes as jni$_.JMethodIDPtr,
            _$jniAllTypes.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<JniAllTypes>(
      const $JniAllTypes$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableJniAllNullableTypes =
      _class.instanceMethodId(
    r'echoAsyncNullableJniAllNullableTypes',
    r'(LJniAllNullableTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableJniAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableJniAllNullableTypes(JniAllNullableTypes jniAllNullableTypes, kotlin.coroutines.Continuation<? super JniAllNullableTypes> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAllNullableTypes?> echoAsyncNullableJniAllNullableTypes(
    JniAllNullableTypes? jniAllNullableTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableJniAllNullableTypes(
            reference.pointer,
            _id_echoAsyncNullableJniAllNullableTypes as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAllNullableTypes?>(
      const $JniAllNullableTypes$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableJniAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoAsyncNullableJniAllNullableTypesWithoutRecursion',
    r'(LJniAllNullableTypesWithoutRecursion;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableJniAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableJniAllNullableTypesWithoutRecursion(JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion, kotlin.coroutines.Continuation<? super JniAllNullableTypesWithoutRecursion> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAllNullableTypesWithoutRecursion?>
      echoAsyncNullableJniAllNullableTypesWithoutRecursion(
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableJniAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoAsyncNullableJniAllNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$jniAllNullableTypesWithoutRecursion.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAllNullableTypesWithoutRecursion?>(
      const $JniAllNullableTypesWithoutRecursion$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt = _class.instanceMethodId(
    r'echoAsyncNullableInt',
    r'(Ljava/lang/Long;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableInt(java.lang.Long long, kotlin.coroutines.Continuation<? super java.lang.Long> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong?> echoAsyncNullableInt(
    jni$_.JLong? long,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$long = long?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt(
            reference.pointer,
            _id_echoAsyncNullableInt as jni$_.JMethodIDPtr,
            _$long.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLong?>(
      const jni$_.JLongNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableDouble = _class.instanceMethodId(
    r'echoAsyncNullableDouble',
    r'(Ljava/lang/Double;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableDouble(java.lang.Double double, kotlin.coroutines.Continuation<? super java.lang.Double> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble?> echoAsyncNullableDouble(
    jni$_.JDouble? double,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$double = double?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableDouble(
            reference.pointer,
            _id_echoAsyncNullableDouble as jni$_.JMethodIDPtr,
            _$double.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDouble?>(
      const jni$_.JDoubleNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableBool = _class.instanceMethodId(
    r'echoAsyncNullableBool',
    r'(Ljava/lang/Boolean;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableBool(java.lang.Boolean boolean, kotlin.coroutines.Continuation<? super java.lang.Boolean> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean?> echoAsyncNullableBool(
    jni$_.JBoolean? boolean,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableBool(
            reference.pointer,
            _id_echoAsyncNullableBool as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JBoolean?>(
      const jni$_.JBooleanNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableString = _class.instanceMethodId(
    r'echoAsyncNullableString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableString(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString?> echoAsyncNullableString(
    jni$_.JString? string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableString(
            reference.pointer,
            _id_echoAsyncNullableString as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JString?>(
      const jni$_.JStringNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableUint8List = _class.instanceMethodId(
    r'echoAsyncNullableUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableUint8List(byte[] bs, kotlin.coroutines.Continuation<? super byte[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray?> echoAsyncNullableUint8List(
    jni$_.JByteArray? bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableUint8List(
            reference.pointer,
            _id_echoAsyncNullableUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JByteArray?>(
      const jni$_.JByteArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt32List = _class.instanceMethodId(
    r'echoAsyncNullableInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt32List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableInt32List(int[] is, kotlin.coroutines.Continuation<? super int[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray?> echoAsyncNullableInt32List(
    jni$_.JIntArray? is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt32List(
            reference.pointer,
            _id_echoAsyncNullableInt32List as jni$_.JMethodIDPtr,
            _$is$.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JIntArray?>(
      const jni$_.JIntArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt64List = _class.instanceMethodId(
    r'echoAsyncNullableInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt64List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableInt64List(long[] js, kotlin.coroutines.Continuation<? super long[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray?> echoAsyncNullableInt64List(
    jni$_.JLongArray? js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt64List(
            reference.pointer,
            _id_echoAsyncNullableInt64List as jni$_.JMethodIDPtr,
            _$js.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLongArray?>(
      const jni$_.JLongArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableFloat64List = _class.instanceMethodId(
    r'echoAsyncNullableFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableFloat64List(double[] ds, kotlin.coroutines.Continuation<? super double[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray?> echoAsyncNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableFloat64List(
            reference.pointer,
            _id_echoAsyncNullableFloat64List as jni$_.JMethodIDPtr,
            _$ds.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDoubleArray?>(
      const jni$_.JDoubleArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableObject = _class.instanceMethodId(
    r'echoAsyncNullableObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableObject(java.lang.Object object, kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> echoAsyncNullableObject(
    jni$_.JObject? object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableObject(
            reference.pointer,
            _id_echoAsyncNullableObject as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableList = _class.instanceMethodId(
    r'echoAsyncNullableList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableList(java.util.List<? extends java.lang.Object> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>?> echoAsyncNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableList(
            reference.pointer,
            _id_echoAsyncNullableList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.JListNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumList = _class.instanceMethodId(
    r'echoAsyncNullableEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableEnumList(java.util.List<? extends JniAnEnum> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAnEnum?>?> echoAsyncNullableEnumList(
    jni$_.JList<JniAnEnum?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumList(
            reference.pointer,
            _id_echoAsyncNullableEnumList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<JniAnEnum?>?>(
      const jni$_.JListNullableType<JniAnEnum?>($JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassList = _class.instanceMethodId(
    r'echoAsyncNullableClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableClassList(java.util.List<JniAllNullableTypes> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<JniAllNullableTypes?>?> echoAsyncNullableClassList(
    jni$_.JList<JniAllNullableTypes?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassList(
            reference.pointer,
            _id_echoAsyncNullableClassList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<JniAllNullableTypes?>?>(
      const jni$_.JListNullableType<JniAllNullableTypes?>(
          $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableMap = _class.instanceMethodId(
    r'echoAsyncNullableMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>
      echoAsyncNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableMap(
            reference.pointer,
            _id_echoAsyncNullableMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
          jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableStringMap = _class.instanceMethodId(
    r'echoAsyncNullableStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>
      echoAsyncNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableStringMap(
            reference.pointer,
            _id_echoAsyncNullableStringMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(), jni$_.JStringNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableIntMap = _class.instanceMethodId(
    r'echoAsyncNullableIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>
      echoAsyncNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableIntMap(
            reference.pointer,
            _id_echoAsyncNullableIntMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
          jni$_.JLongNullableType(), jni$_.JLongNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumMap = _class.instanceMethodId(
    r'echoAsyncNullableEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<JniAnEnum?, JniAnEnum?>?> echoAsyncNullableEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumMap(
            reference.pointer,
            _id_echoAsyncNullableEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
      const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
          $JniAnEnum$NullableType(), $JniAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassMap = _class.instanceMethodId(
    r'echoAsyncNullableClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>
      echoAsyncNullableClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassMap(
            reference.pointer,
            _id_echoAsyncNullableClassMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
      const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
          jni$_.JLongNullableType(), $JniAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnum = _class.instanceMethodId(
    r'echoAsyncNullableEnum',
    r'(LJniAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableEnum(JniAnEnum jniAnEnum, kotlin.coroutines.Continuation<? super JniAnEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnEnum?> echoAsyncNullableEnum(
    JniAnEnum? jniAnEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnum(
            reference.pointer,
            _id_echoAsyncNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAnEnum?>(
      const $JniAnEnum$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncNullableEnum = _class.instanceMethodId(
    r'echoAnotherAsyncNullableEnum',
    r'(LJniAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAnotherAsyncNullableEnum(JniAnotherEnum jniAnotherEnum, kotlin.coroutines.Continuation<? super JniAnotherEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<JniAnotherEnum?> echoAnotherAsyncNullableEnum(
    JniAnotherEnum? jniAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAnotherAsyncNullableEnum(
            reference.pointer,
            _id_echoAnotherAsyncNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<JniAnotherEnum?>(
      const $JniAnotherEnum$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_callFlutterNoop = _class.instanceMethodId(
    r'callFlutterNoop',
    r'()V',
  );

  static final _callFlutterNoop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void callFlutterNoop()`
  void callFlutterNoop() {
    _callFlutterNoop(
            reference.pointer, _id_callFlutterNoop as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_callFlutterThrowError = _class.instanceMethodId(
    r'callFlutterThrowError',
    r'()Ljava/lang/Object;',
  );

  static final _callFlutterThrowError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object callFlutterThrowError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? callFlutterThrowError() {
    return _callFlutterThrowError(
            reference.pointer, _id_callFlutterThrowError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_callFlutterThrowErrorFromVoid = _class.instanceMethodId(
    r'callFlutterThrowErrorFromVoid',
    r'()V',
  );

  static final _callFlutterThrowErrorFromVoid =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public void callFlutterThrowErrorFromVoid()`
  void callFlutterThrowErrorFromVoid() {
    _callFlutterThrowErrorFromVoid(reference.pointer,
            _id_callFlutterThrowErrorFromVoid as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_callFlutterEchoJniAllTypes = _class.instanceMethodId(
    r'callFlutterEchoJniAllTypes',
    r'(LJniAllTypes;)LJniAllTypes;',
  );

  static final _callFlutterEchoJniAllTypes =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllTypes callFlutterEchoJniAllTypes(JniAllTypes jniAllTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes callFlutterEchoJniAllTypes(
    JniAllTypes jniAllTypes,
  ) {
    final _$jniAllTypes = jniAllTypes.reference;
    return _callFlutterEchoJniAllTypes(
            reference.pointer,
            _id_callFlutterEchoJniAllTypes as jni$_.JMethodIDPtr,
            _$jniAllTypes.pointer)
        .object<JniAllTypes>(const $JniAllTypes$Type());
  }

  static final _id_callFlutterEchoJniAllNullableTypes = _class.instanceMethodId(
    r'callFlutterEchoJniAllNullableTypes',
    r'(LJniAllNullableTypes;)LJniAllNullableTypes;',
  );

  static final _callFlutterEchoJniAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllNullableTypes callFlutterEchoJniAllNullableTypes(JniAllNullableTypes jniAllNullableTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes? callFlutterEchoJniAllNullableTypes(
    JniAllNullableTypes? jniAllNullableTypes,
  ) {
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoJniAllNullableTypes(
            reference.pointer,
            _id_callFlutterEchoJniAllNullableTypes as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer)
        .object<JniAllNullableTypes?>(
            const $JniAllNullableTypes$NullableType());
  }

  static final _id_callFlutterSendMultipleNullableTypes =
      _class.instanceMethodId(
    r'callFlutterSendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypes;',
  );

  static final _callFlutterSendMultipleNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllNullableTypes callFlutterSendMultipleNullableTypes(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes callFlutterSendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _callFlutterSendMultipleNullableTypes(
            reference.pointer,
            _id_callFlutterSendMultipleNullableTypes as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_callFlutterEchoJniAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'callFlutterEchoJniAllNullableTypesWithoutRecursion',
    r'(LJniAllNullableTypesWithoutRecursion;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _callFlutterEchoJniAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllNullableTypesWithoutRecursion callFlutterEchoJniAllNullableTypesWithoutRecursion(JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion?
      callFlutterEchoJniAllNullableTypesWithoutRecursion(
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
  ) {
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoJniAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_callFlutterEchoJniAllNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$jniAllNullableTypesWithoutRecursion.pointer)
        .object<JniAllNullableTypesWithoutRecursion?>(
            const $JniAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_callFlutterSendMultipleNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'callFlutterSendMultipleNullableTypesWithoutRecursion',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _callFlutterSendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAllNullableTypesWithoutRecursion callFlutterSendMultipleNullableTypesWithoutRecursion(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion
      callFlutterSendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _callFlutterSendMultipleNullableTypesWithoutRecursion(
            reference.pointer,
            _id_callFlutterSendMultipleNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypesWithoutRecursion>(
            const $JniAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_callFlutterEchoBool = _class.instanceMethodId(
    r'callFlutterEchoBool',
    r'(Z)Z',
  );

  static final _callFlutterEchoBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean callFlutterEchoBool(boolean z)`
  bool callFlutterEchoBool(
    bool z,
  ) {
    return _callFlutterEchoBool(reference.pointer,
            _id_callFlutterEchoBool as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_callFlutterEchoInt = _class.instanceMethodId(
    r'callFlutterEchoInt',
    r'(J)J',
  );

  static final _callFlutterEchoInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public long callFlutterEchoInt(long j)`
  int callFlutterEchoInt(
    int j,
  ) {
    return _callFlutterEchoInt(
            reference.pointer, _id_callFlutterEchoInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_callFlutterEchoDouble = _class.instanceMethodId(
    r'callFlutterEchoDouble',
    r'(D)D',
  );

  static final _callFlutterEchoDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public double callFlutterEchoDouble(double d)`
  double callFlutterEchoDouble(
    double d,
  ) {
    return _callFlutterEchoDouble(reference.pointer,
            _id_callFlutterEchoDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_callFlutterEchoString = _class.instanceMethodId(
    r'callFlutterEchoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _callFlutterEchoString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String callFlutterEchoString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString callFlutterEchoString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _callFlutterEchoString(reference.pointer,
            _id_callFlutterEchoString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_callFlutterEchoUint8List = _class.instanceMethodId(
    r'callFlutterEchoUint8List',
    r'([B)[B',
  );

  static final _callFlutterEchoUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public byte[] callFlutterEchoUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray callFlutterEchoUint8List(
    jni$_.JByteArray bs,
  ) {
    final _$bs = bs.reference;
    return _callFlutterEchoUint8List(reference.pointer,
            _id_callFlutterEchoUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_callFlutterEchoList = _class.instanceMethodId(
    r'callFlutterEchoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<java.lang.Object> callFlutterEchoList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> callFlutterEchoList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoList(reference.pointer,
            _id_callFlutterEchoList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoEnumList = _class.instanceMethodId(
    r'callFlutterEchoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAnEnum> callFlutterEchoEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?> callFlutterEchoEnumList(
    jni$_.JList<JniAnEnum?> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoEnumList(reference.pointer,
            _id_callFlutterEchoEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>>(
            const jni$_.JListType<JniAnEnum?>($JniAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoClassList = _class.instanceMethodId(
    r'callFlutterEchoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAllNullableTypes> callFlutterEchoClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?> callFlutterEchoClassList(
    jni$_.JList<JniAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoClassList(reference.pointer,
            _id_callFlutterEchoClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>>(
            const jni$_.JListType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNonNullEnumList = _class.instanceMethodId(
    r'callFlutterEchoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAnEnum> callFlutterEchoNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum> callFlutterEchoNonNullEnumList(
    jni$_.JList<JniAnEnum> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoNonNullEnumList(
            reference.pointer,
            _id_callFlutterEchoNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAnEnum>>(
            const jni$_.JListType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_callFlutterEchoNonNullClassList = _class.instanceMethodId(
    r'callFlutterEchoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAllNullableTypes> callFlutterEchoNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes> callFlutterEchoNonNullClassList(
    jni$_.JList<JniAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoNonNullClassList(
            reference.pointer,
            _id_callFlutterEchoNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>>(
            const jni$_.JListType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoMap = _class.instanceMethodId(
    r'callFlutterEchoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Object, java.lang.Object> callFlutterEchoMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> callFlutterEchoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoMap(reference.pointer,
            _id_callFlutterEchoMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoStringMap = _class.instanceMethodId(
    r'callFlutterEchoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> callFlutterEchoStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> callFlutterEchoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoStringMap(reference.pointer,
            _id_callFlutterEchoStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_callFlutterEchoIntMap = _class.instanceMethodId(
    r'callFlutterEchoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> callFlutterEchoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoIntMap(reference.pointer,
            _id_callFlutterEchoIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
            const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_callFlutterEchoEnumMap = _class.instanceMethodId(
    r'callFlutterEchoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<JniAnEnum, JniAnEnum> callFlutterEchoEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?> callFlutterEchoEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoEnumMap(reference.pointer,
            _id_callFlutterEchoEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>>(
            const jni$_.JMapType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoClassMap = _class.instanceMethodId(
    r'callFlutterEchoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, JniAllNullableTypes> callFlutterEchoClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> callFlutterEchoClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoClassMap(reference.pointer,
            _id_callFlutterEchoClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNonNullStringMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> callFlutterEchoNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> callFlutterEchoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullStringMap(
            reference.pointer,
            _id_callFlutterEchoNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_callFlutterEchoNonNullIntMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullIntMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> callFlutterEchoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullIntMap(
            reference.pointer,
            _id_callFlutterEchoNonNullIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_callFlutterEchoNonNullEnumMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<JniAnEnum, JniAnEnum> callFlutterEchoNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum> callFlutterEchoNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullEnumMap(
            reference.pointer,
            _id_callFlutterEchoNonNullEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>>(
            const jni$_.JMapType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_callFlutterEchoNonNullClassMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, JniAllNullableTypes> callFlutterEchoNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes> callFlutterEchoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullClassMap(
            reference.pointer,
            _id_callFlutterEchoNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>>(
            const jni$_.JMapType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoEnum = _class.instanceMethodId(
    r'callFlutterEchoEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _callFlutterEchoEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAnEnum callFlutterEchoEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum callFlutterEchoEnum(
    JniAnEnum jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum.reference;
    return _callFlutterEchoEnum(reference.pointer,
            _id_callFlutterEchoEnum as jni$_.JMethodIDPtr, _$jniAnEnum.pointer)
        .object<JniAnEnum>(const $JniAnEnum$Type());
  }

  static final _id_callFlutterEchoJniAnotherEnum = _class.instanceMethodId(
    r'callFlutterEchoJniAnotherEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _callFlutterEchoJniAnotherEnum =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAnotherEnum callFlutterEchoJniAnotherEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum callFlutterEchoJniAnotherEnum(
    JniAnotherEnum jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    return _callFlutterEchoJniAnotherEnum(
            reference.pointer,
            _id_callFlutterEchoJniAnotherEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum>(const $JniAnotherEnum$Type());
  }

  static final _id_callFlutterEchoNullableBool = _class.instanceMethodId(
    r'callFlutterEchoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _callFlutterEchoNullableBool =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Boolean callFlutterEchoNullableBool(java.lang.Boolean boolean)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? callFlutterEchoNullableBool(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableBool(
            reference.pointer,
            _id_callFlutterEchoNullableBool as jni$_.JMethodIDPtr,
            _$boolean.pointer)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_callFlutterEchoNullableInt = _class.instanceMethodId(
    r'callFlutterEchoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _callFlutterEchoNullableInt =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Long callFlutterEchoNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? callFlutterEchoNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableInt(
            reference.pointer,
            _id_callFlutterEchoNullableInt as jni$_.JMethodIDPtr,
            _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_callFlutterEchoNullableDouble = _class.instanceMethodId(
    r'callFlutterEchoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _callFlutterEchoNullableDouble =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Double callFlutterEchoNullableDouble(java.lang.Double double)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? callFlutterEchoNullableDouble(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableDouble(
            reference.pointer,
            _id_callFlutterEchoNullableDouble as jni$_.JMethodIDPtr,
            _$double.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_callFlutterEchoNullableString = _class.instanceMethodId(
    r'callFlutterEchoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _callFlutterEchoNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String callFlutterEchoNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? callFlutterEchoNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableString(
            reference.pointer,
            _id_callFlutterEchoNullableString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_callFlutterEchoNullableUint8List = _class.instanceMethodId(
    r'callFlutterEchoNullableUint8List',
    r'([B)[B',
  );

  static final _callFlutterEchoNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public byte[] callFlutterEchoNullableUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? callFlutterEchoNullableUint8List(
    jni$_.JByteArray? bs,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableUint8List(
            reference.pointer,
            _id_callFlutterEchoNullableUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_callFlutterEchoNullableList = _class.instanceMethodId(
    r'callFlutterEchoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<java.lang.Object> callFlutterEchoNullableList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? callFlutterEchoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableList(
            reference.pointer,
            _id_callFlutterEchoNullableList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoNullableEnumList = _class.instanceMethodId(
    r'callFlutterEchoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAnEnum> callFlutterEchoNullableEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? callFlutterEchoNullableEnumList(
    jni$_.JList<JniAnEnum?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableEnumList(
            reference.pointer,
            _id_callFlutterEchoNullableEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoNullableClassList = _class.instanceMethodId(
    r'callFlutterEchoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAllNullableTypes> callFlutterEchoNullableClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?>? callFlutterEchoNullableClassList(
    jni$_.JList<JniAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableClassList(
            reference.pointer,
            _id_callFlutterEchoNullableClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>?>(
            const jni$_.JListNullableType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNullableNonNullEnumList =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAnEnum> callFlutterEchoNullableNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum>? callFlutterEchoNullableNonNullEnumList(
    jni$_.JList<JniAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullEnumList(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAnEnum>?>(
            const jni$_.JListNullableType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_callFlutterEchoNullableNonNullClassList =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<JniAllNullableTypes> callFlutterEchoNullableNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes>? callFlutterEchoNullableNonNullClassList(
    jni$_.JList<JniAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullClassList(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>?>(
            const jni$_.JListNullableType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoNullableMap = _class.instanceMethodId(
    r'callFlutterEchoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Object, java.lang.Object> callFlutterEchoNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? callFlutterEchoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableMap(reference.pointer,
            _id_callFlutterEchoNullableMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoNullableStringMap = _class.instanceMethodId(
    r'callFlutterEchoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> callFlutterEchoNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? callFlutterEchoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableStringMap(
            reference.pointer,
            _id_callFlutterEchoNullableStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_callFlutterEchoNullableIntMap = _class.instanceMethodId(
    r'callFlutterEchoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableIntMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? callFlutterEchoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableIntMap(
            reference.pointer,
            _id_callFlutterEchoNullableIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_callFlutterEchoNullableEnumMap = _class.instanceMethodId(
    r'callFlutterEchoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<JniAnEnum, JniAnEnum> callFlutterEchoNullableEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? callFlutterEchoNullableEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableEnumMap(
            reference.pointer,
            _id_callFlutterEchoNullableEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoNullableClassMap = _class.instanceMethodId(
    r'callFlutterEchoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, JniAllNullableTypes> callFlutterEchoNullableClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?
      callFlutterEchoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableClassMap(
            reference.pointer,
            _id_callFlutterEchoNullableClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNullableNonNullStringMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> callFlutterEchoNullableNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>?
      callFlutterEchoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullStringMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_callFlutterEchoNullableNonNullIntMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullIntMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoNullableNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? callFlutterEchoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullIntMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
            const jni$_.JMapNullableType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_callFlutterEchoNullableNonNullEnumMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<JniAnEnum, JniAnEnum> callFlutterEchoNullableNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum>? callFlutterEchoNullableNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullEnumMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>?>(
            const jni$_.JMapNullableType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_callFlutterEchoNullableNonNullClassMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, JniAllNullableTypes> callFlutterEchoNullableNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes>?
      callFlutterEchoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullClassMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>?>(
            const jni$_.JMapNullableType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoNullableEnum = _class.instanceMethodId(
    r'callFlutterEchoNullableEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _callFlutterEchoNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAnEnum callFlutterEchoNullableEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? callFlutterEchoNullableEnum(
    JniAnEnum? jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableEnum(
            reference.pointer,
            _id_callFlutterEchoNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_callFlutterEchoAnotherNullableEnum = _class.instanceMethodId(
    r'callFlutterEchoAnotherNullableEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _callFlutterEchoAnotherNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public JniAnotherEnum callFlutterEchoAnotherNullableEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? callFlutterEchoAnotherNullableEnum(
    JniAnotherEnum? jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoAnotherNullableEnum(
            reference.pointer,
            _id_callFlutterEchoAnotherNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }
}

final class $JniHostIntegrationCoreApiRegistrar$NullableType
    extends jni$_.JObjType<JniHostIntegrationCoreApiRegistrar?> {
  @jni$_.internal
  const $JniHostIntegrationCoreApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniHostIntegrationCoreApiRegistrar? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniHostIntegrationCoreApiRegistrar.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $JniHostIntegrationCoreApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostIntegrationCoreApiRegistrar?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode =>
      ($JniHostIntegrationCoreApiRegistrar$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JniHostIntegrationCoreApiRegistrar$NullableType) &&
        other is $JniHostIntegrationCoreApiRegistrar$NullableType;
  }
}

final class $JniHostIntegrationCoreApiRegistrar$Type
    extends jni$_.JObjType<JniHostIntegrationCoreApiRegistrar> {
  @jni$_.internal
  const $JniHostIntegrationCoreApiRegistrar$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniHostIntegrationCoreApiRegistrar fromReference(
          jni$_.JReference reference) =>
      JniHostIntegrationCoreApiRegistrar.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $JniHostIntegrationCoreApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostIntegrationCoreApiRegistrar?> get nullableType =>
      const $JniHostIntegrationCoreApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($JniHostIntegrationCoreApiRegistrar$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostIntegrationCoreApiRegistrar$Type) &&
        other is $JniHostIntegrationCoreApiRegistrar$Type;
  }
}

/// from: `JniHostTrivialApi`
class JniHostTrivialApi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniHostTrivialApi> $type;

  @jni$_.internal
  JniHostTrivialApi.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniHostTrivialApi');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniHostTrivialApi$NullableType();
  static const type = $JniHostTrivialApi$Type();
  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }
}

final class $JniHostTrivialApi$NullableType
    extends jni$_.JObjType<JniHostTrivialApi?> {
  @jni$_.internal
  const $JniHostTrivialApi$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostTrivialApi;';

  @jni$_.internal
  @core$_.override
  JniHostTrivialApi? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniHostTrivialApi.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostTrivialApi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniHostTrivialApi$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostTrivialApi$NullableType) &&
        other is $JniHostTrivialApi$NullableType;
  }
}

final class $JniHostTrivialApi$Type extends jni$_.JObjType<JniHostTrivialApi> {
  @jni$_.internal
  const $JniHostTrivialApi$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostTrivialApi;';

  @jni$_.internal
  @core$_.override
  JniHostTrivialApi fromReference(jni$_.JReference reference) =>
      JniHostTrivialApi.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostTrivialApi?> get nullableType =>
      const $JniHostTrivialApi$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniHostTrivialApi$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostTrivialApi$Type) &&
        other is $JniHostTrivialApi$Type;
  }
}

/// from: `JniHostTrivialApiRegistrar`
class JniHostTrivialApiRegistrar extends JniHostTrivialApi {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniHostTrivialApiRegistrar> $type;

  @jni$_.internal
  JniHostTrivialApiRegistrar.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniHostTrivialApiRegistrar');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniHostTrivialApiRegistrar$NullableType();
  static const type = $JniHostTrivialApiRegistrar$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniHostTrivialApiRegistrar() {
    return JniHostTrivialApiRegistrar.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getApi = _class.instanceMethodId(
    r'getApi',
    r'()LJniHostTrivialApi;',
  );

  static final _getApi = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniHostTrivialApi getApi()`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostTrivialApi? getApi() {
    return _getApi(reference.pointer, _id_getApi as jni$_.JMethodIDPtr)
        .object<JniHostTrivialApi?>(const $JniHostTrivialApi$NullableType());
  }

  static final _id_setApi = _class.instanceMethodId(
    r'setApi',
    r'(LJniHostTrivialApi;)V',
  );

  static final _setApi = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setApi(JniHostTrivialApi jniHostTrivialApi)`
  void setApi(
    JniHostTrivialApi? jniHostTrivialApi,
  ) {
    final _$jniHostTrivialApi =
        jniHostTrivialApi?.reference ?? jni$_.jNullReference;
    _setApi(reference.pointer, _id_setApi as jni$_.JMethodIDPtr,
            _$jniHostTrivialApi.pointer)
        .check();
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(LJniHostTrivialApi;Ljava/lang/String;)LJniHostTrivialApiRegistrar;',
  );

  static final _register = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniHostTrivialApiRegistrar register(JniHostTrivialApi jniHostTrivialApi, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostTrivialApiRegistrar register(
    JniHostTrivialApi jniHostTrivialApi,
    jni$_.JString string,
  ) {
    final _$jniHostTrivialApi = jniHostTrivialApi.reference;
    final _$string = string.reference;
    return _register(reference.pointer, _id_register as jni$_.JMethodIDPtr,
            _$jniHostTrivialApi.pointer, _$string.pointer)
        .object<JniHostTrivialApiRegistrar>(
            const $JniHostTrivialApiRegistrar$Type());
  }

  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Ljava/lang/String;)LJniHostTrivialApiRegistrar;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniHostTrivialApiRegistrar getInstance(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostTrivialApiRegistrar? getInstance(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getInstance(reference.pointer,
            _id_getInstance as jni$_.JMethodIDPtr, _$string.pointer)
        .object<JniHostTrivialApiRegistrar?>(
            const $JniHostTrivialApiRegistrar$NullableType());
  }

  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }
}

final class $JniHostTrivialApiRegistrar$NullableType
    extends jni$_.JObjType<JniHostTrivialApiRegistrar?> {
  @jni$_.internal
  const $JniHostTrivialApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostTrivialApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniHostTrivialApiRegistrar? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniHostTrivialApiRegistrar.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $JniHostTrivialApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostTrivialApiRegistrar?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($JniHostTrivialApiRegistrar$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostTrivialApiRegistrar$NullableType) &&
        other is $JniHostTrivialApiRegistrar$NullableType;
  }
}

final class $JniHostTrivialApiRegistrar$Type
    extends jni$_.JObjType<JniHostTrivialApiRegistrar> {
  @jni$_.internal
  const $JniHostTrivialApiRegistrar$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostTrivialApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniHostTrivialApiRegistrar fromReference(jni$_.JReference reference) =>
      JniHostTrivialApiRegistrar.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $JniHostTrivialApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostTrivialApiRegistrar?> get nullableType =>
      const $JniHostTrivialApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($JniHostTrivialApiRegistrar$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostTrivialApiRegistrar$Type) &&
        other is $JniHostTrivialApiRegistrar$Type;
  }
}

/// from: `JniHostSmallApi`
class JniHostSmallApi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniHostSmallApi> $type;

  @jni$_.internal
  JniHostSmallApi.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniHostSmallApi');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniHostSmallApi$NullableType();
  static const type = $JniHostSmallApi$Type();
  static final _id_echo = _class.instanceMethodId(
    r'echo',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echo(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echo(
    jni$_.JString string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echo(reference.pointer, _id_echo as jni$_.JMethodIDPtr,
            _$string.pointer, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.JStringType(),
      releaseOriginal: true,
    );
  }

  static final _id_voidVoid = _class.instanceMethodId(
    r'voidVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _voidVoid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object voidVoid(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> voidVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _voidVoid(reference.pointer, _id_voidVoid as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }
}

final class $JniHostSmallApi$NullableType
    extends jni$_.JObjType<JniHostSmallApi?> {
  @jni$_.internal
  const $JniHostSmallApi$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostSmallApi;';

  @jni$_.internal
  @core$_.override
  JniHostSmallApi? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : JniHostSmallApi.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostSmallApi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniHostSmallApi$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostSmallApi$NullableType) &&
        other is $JniHostSmallApi$NullableType;
  }
}

final class $JniHostSmallApi$Type extends jni$_.JObjType<JniHostSmallApi> {
  @jni$_.internal
  const $JniHostSmallApi$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostSmallApi;';

  @jni$_.internal
  @core$_.override
  JniHostSmallApi fromReference(jni$_.JReference reference) =>
      JniHostSmallApi.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostSmallApi?> get nullableType =>
      const $JniHostSmallApi$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniHostSmallApi$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostSmallApi$Type) &&
        other is $JniHostSmallApi$Type;
  }
}

/// from: `JniHostSmallApiRegistrar`
class JniHostSmallApiRegistrar extends JniHostSmallApi {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniHostSmallApiRegistrar> $type;

  @jni$_.internal
  JniHostSmallApiRegistrar.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniHostSmallApiRegistrar');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniHostSmallApiRegistrar$NullableType();
  static const type = $JniHostSmallApiRegistrar$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniHostSmallApiRegistrar() {
    return JniHostSmallApiRegistrar.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getApi = _class.instanceMethodId(
    r'getApi',
    r'()LJniHostSmallApi;',
  );

  static final _getApi = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniHostSmallApi getApi()`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostSmallApi? getApi() {
    return _getApi(reference.pointer, _id_getApi as jni$_.JMethodIDPtr)
        .object<JniHostSmallApi?>(const $JniHostSmallApi$NullableType());
  }

  static final _id_setApi = _class.instanceMethodId(
    r'setApi',
    r'(LJniHostSmallApi;)V',
  );

  static final _setApi = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setApi(JniHostSmallApi jniHostSmallApi)`
  void setApi(
    JniHostSmallApi? jniHostSmallApi,
  ) {
    final _$jniHostSmallApi =
        jniHostSmallApi?.reference ?? jni$_.jNullReference;
    _setApi(reference.pointer, _id_setApi as jni$_.JMethodIDPtr,
            _$jniHostSmallApi.pointer)
        .check();
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(LJniHostSmallApi;Ljava/lang/String;)LJniHostSmallApiRegistrar;',
  );

  static final _register = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniHostSmallApiRegistrar register(JniHostSmallApi jniHostSmallApi, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostSmallApiRegistrar register(
    JniHostSmallApi jniHostSmallApi,
    jni$_.JString string,
  ) {
    final _$jniHostSmallApi = jniHostSmallApi.reference;
    final _$string = string.reference;
    return _register(reference.pointer, _id_register as jni$_.JMethodIDPtr,
            _$jniHostSmallApi.pointer, _$string.pointer)
        .object<JniHostSmallApiRegistrar>(
            const $JniHostSmallApiRegistrar$Type());
  }

  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Ljava/lang/String;)LJniHostSmallApiRegistrar;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniHostSmallApiRegistrar getInstance(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniHostSmallApiRegistrar? getInstance(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getInstance(reference.pointer,
            _id_getInstance as jni$_.JMethodIDPtr, _$string.pointer)
        .object<JniHostSmallApiRegistrar?>(
            const $JniHostSmallApiRegistrar$NullableType());
  }

  static final _id_echo = _class.instanceMethodId(
    r'echo',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echo(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echo(
    jni$_.JString string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echo(reference.pointer, _id_echo as jni$_.JMethodIDPtr,
            _$string.pointer, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.JStringType(),
      releaseOriginal: true,
    );
  }

  static final _id_voidVoid = _class.instanceMethodId(
    r'voidVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _voidVoid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object voidVoid(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> voidVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _voidVoid(reference.pointer, _id_voidVoid as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }
}

final class $JniHostSmallApiRegistrar$NullableType
    extends jni$_.JObjType<JniHostSmallApiRegistrar?> {
  @jni$_.internal
  const $JniHostSmallApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostSmallApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniHostSmallApiRegistrar? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniHostSmallApiRegistrar.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $JniHostSmallApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostSmallApiRegistrar?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($JniHostSmallApiRegistrar$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostSmallApiRegistrar$NullableType) &&
        other is $JniHostSmallApiRegistrar$NullableType;
  }
}

final class $JniHostSmallApiRegistrar$Type
    extends jni$_.JObjType<JniHostSmallApiRegistrar> {
  @jni$_.internal
  const $JniHostSmallApiRegistrar$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniHostSmallApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniHostSmallApiRegistrar fromReference(jni$_.JReference reference) =>
      JniHostSmallApiRegistrar.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $JniHostSmallApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniHostSmallApiRegistrar?> get nullableType =>
      const $JniHostSmallApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($JniHostSmallApiRegistrar$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniHostSmallApiRegistrar$Type) &&
        other is $JniHostSmallApiRegistrar$Type;
  }
}

/// from: `JniFlutterIntegrationCoreApi`
class JniFlutterIntegrationCoreApi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniFlutterIntegrationCoreApi> $type;

  @jni$_.internal
  JniFlutterIntegrationCoreApi.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniFlutterIntegrationCoreApi');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniFlutterIntegrationCoreApi$NullableType();
  static const type = $JniFlutterIntegrationCoreApi$Type();
  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }

  static final _id_throwError = _class.instanceMethodId(
    r'throwError',
    r'()Ljava/lang/Object;',
  );

  static final _throwError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.Object throwError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwError() {
    return _throwError(reference.pointer, _id_throwError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_throwErrorFromVoid = _class.instanceMethodId(
    r'throwErrorFromVoid',
    r'()V',
  );

  static final _throwErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void throwErrorFromVoid()`
  void throwErrorFromVoid() {
    _throwErrorFromVoid(
            reference.pointer, _id_throwErrorFromVoid as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_echoJniAllTypes = _class.instanceMethodId(
    r'echoJniAllTypes',
    r'(LJniAllTypes;)LJniAllTypes;',
  );

  static final _echoJniAllTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllTypes echoJniAllTypes(JniAllTypes jniAllTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes echoJniAllTypes(
    JniAllTypes jniAllTypes,
  ) {
    final _$jniAllTypes = jniAllTypes.reference;
    return _echoJniAllTypes(reference.pointer,
            _id_echoJniAllTypes as jni$_.JMethodIDPtr, _$jniAllTypes.pointer)
        .object<JniAllTypes>(const $JniAllTypes$Type());
  }

  static final _id_echoJniAllNullableTypes = _class.instanceMethodId(
    r'echoJniAllNullableTypes',
    r'(LJniAllNullableTypes;)LJniAllNullableTypes;',
  );

  static final _echoJniAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypes echoJniAllNullableTypes(JniAllNullableTypes jniAllNullableTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes? echoJniAllNullableTypes(
    JniAllNullableTypes? jniAllNullableTypes,
  ) {
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _echoJniAllNullableTypes(
            reference.pointer,
            _id_echoJniAllNullableTypes as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer)
        .object<JniAllNullableTypes?>(
            const $JniAllNullableTypes$NullableType());
  }

  static final _id_sendMultipleNullableTypes = _class.instanceMethodId(
    r'sendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypes;',
  );

  static final _sendMultipleNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypes sendMultipleNullableTypes(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes sendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypes(
            reference.pointer,
            _id_sendMultipleNullableTypes as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_echoJniAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoJniAllNullableTypesWithoutRecursion',
    r'(LJniAllNullableTypesWithoutRecursion;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _echoJniAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypesWithoutRecursion echoJniAllNullableTypesWithoutRecursion(JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion? echoJniAllNullableTypesWithoutRecursion(
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
  ) {
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _echoJniAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoJniAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$jniAllNullableTypesWithoutRecursion.pointer)
        .object<JniAllNullableTypesWithoutRecursion?>(
            const $JniAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_sendMultipleNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'sendMultipleNullableTypesWithoutRecursion',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _sendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypesWithoutRecursion(
            reference.pointer,
            _id_sendMultipleNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<JniAllNullableTypesWithoutRecursion>(
            const $JniAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_echoBool = _class.instanceMethodId(
    r'echoBool',
    r'(Z)Z',
  );

  static final _echoBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract boolean echoBool(boolean z)`
  bool echoBool(
    bool z,
  ) {
    return _echoBool(
            reference.pointer, _id_echoBool as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_echoInt = _class.instanceMethodId(
    r'echoInt',
    r'(J)J',
  );

  static final _echoInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract long echoInt(long j)`
  int echoInt(
    int j,
  ) {
    return _echoInt(reference.pointer, _id_echoInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoDouble = _class.instanceMethodId(
    r'echoDouble',
    r'(D)D',
  );

  static final _echoDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public abstract double echoDouble(double d)`
  double echoDouble(
    double d,
  ) {
    return _echoDouble(
            reference.pointer, _id_echoDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoString = _class.instanceMethodId(
    r'echoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoString(reference.pointer, _id_echoString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoUint8List = _class.instanceMethodId(
    r'echoUint8List',
    r'([B)[B',
  );

  static final _echoUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] echoUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray echoUint8List(
    jni$_.JByteArray bs,
  ) {
    final _$bs = bs.reference;
    return _echoUint8List(reference.pointer,
            _id_echoUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_echoList = _class.instanceMethodId(
    r'echoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> echoList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> echoList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _echoList(reference.pointer, _id_echoList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_echoEnumList = _class.instanceMethodId(
    r'echoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> echoEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?> echoEnumList(
    jni$_.JList<JniAnEnum?> list,
  ) {
    final _$list = list.reference;
    return _echoEnumList(reference.pointer,
            _id_echoEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>>(
            const jni$_.JListType<JniAnEnum?>($JniAnEnum$NullableType()));
  }

  static final _id_echoClassList = _class.instanceMethodId(
    r'echoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> echoClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?> echoClassList(
    jni$_.JList<JniAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _echoClassList(reference.pointer,
            _id_echoClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>>(
            const jni$_.JListType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullEnumList = _class.instanceMethodId(
    r'echoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> echoNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum> echoNonNullEnumList(
    jni$_.JList<JniAnEnum> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullEnumList(reference.pointer,
            _id_echoNonNullEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum>>(
            const jni$_.JListType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_echoNonNullClassList = _class.instanceMethodId(
    r'echoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> echoNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes> echoNonNullClassList(
    jni$_.JList<JniAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullClassList(reference.pointer,
            _id_echoNonNullClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>>(
            const jni$_.JListType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_echoMap = _class.instanceMethodId(
    r'echoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> echoMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _echoMap(
            reference.pointer, _id_echoMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoStringMap = _class.instanceMethodId(
    r'echoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _echoStringMap(reference.pointer,
            _id_echoStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoIntMap = _class.instanceMethodId(
    r'echoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _echoIntMap(reference.pointer, _id_echoIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
            const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoEnumMap = _class.instanceMethodId(
    r'echoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> echoEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?> echoEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _echoEnumMap(reference.pointer,
            _id_echoEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>>(
            const jni$_.JMapType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_echoClassMap = _class.instanceMethodId(
    r'echoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> echoClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> echoClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _echoClassMap(reference.pointer,
            _id_echoClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullStringMap = _class.instanceMethodId(
    r'echoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullStringMap(reference.pointer,
            _id_echoNonNullStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNonNullIntMap = _class.instanceMethodId(
    r'echoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullIntMap(reference.pointer,
            _id_echoNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNonNullEnumMap = _class.instanceMethodId(
    r'echoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> echoNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum> echoNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullEnumMap(reference.pointer,
            _id_echoNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>>(
            const jni$_.JMapType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_echoNonNullClassMap = _class.instanceMethodId(
    r'echoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> echoNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes> echoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullClassMap(reference.pointer,
            _id_echoNonNullClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>>(
            const jni$_.JMapType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_echoEnum = _class.instanceMethodId(
    r'echoEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _echoEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnEnum echoEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum echoEnum(
    JniAnEnum jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum.reference;
    return _echoEnum(reference.pointer, _id_echoEnum as jni$_.JMethodIDPtr,
            _$jniAnEnum.pointer)
        .object<JniAnEnum>(const $JniAnEnum$Type());
  }

  static final _id_echoJniAnotherEnum = _class.instanceMethodId(
    r'echoJniAnotherEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _echoJniAnotherEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnotherEnum echoJniAnotherEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum echoJniAnotherEnum(
    JniAnotherEnum jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    return _echoJniAnotherEnum(
            reference.pointer,
            _id_echoJniAnotherEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum>(const $JniAnotherEnum$Type());
  }

  static final _id_echoNullableBool = _class.instanceMethodId(
    r'echoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _echoNullableBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Boolean echoNullableBool(java.lang.Boolean boolean)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? echoNullableBool(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _echoNullableBool(reference.pointer,
            _id_echoNullableBool as jni$_.JMethodIDPtr, _$boolean.pointer)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_echoNullableInt = _class.instanceMethodId(
    r'echoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Long echoNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoNullableInt(reference.pointer,
            _id_echoNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNullableDouble = _class.instanceMethodId(
    r'echoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _echoNullableDouble = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Double echoNullableDouble(java.lang.Double double)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? echoNullableDouble(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _echoNullableDouble(reference.pointer,
            _id_echoNullableDouble as jni$_.JMethodIDPtr, _$double.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_echoNullableString = _class.instanceMethodId(
    r'echoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNullableString(reference.pointer,
            _id_echoNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_echoNullableUint8List = _class.instanceMethodId(
    r'echoNullableUint8List',
    r'([B)[B',
  );

  static final _echoNullableUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] echoNullableUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? echoNullableUint8List(
    jni$_.JByteArray? bs,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _echoNullableUint8List(reference.pointer,
            _id_echoNullableUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_echoNullableList = _class.instanceMethodId(
    r'echoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> echoNullableList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? echoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableList(reference.pointer,
            _id_echoNullableList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableEnumList = _class.instanceMethodId(
    r'echoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> echoNullableEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? echoNullableEnumList(
    jni$_.JList<JniAnEnum?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumList(reference.pointer,
            _id_echoNullableEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_echoNullableClassList = _class.instanceMethodId(
    r'echoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> echoNullableClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?>? echoNullableClassList(
    jni$_.JList<JniAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableClassList(reference.pointer,
            _id_echoNullableClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes?>?>(
            const jni$_.JListNullableType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullEnumList = _class.instanceMethodId(
    r'echoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAnEnum> echoNullableNonNullEnumList(java.util.List<? extends JniAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum>? echoNullableNonNullEnumList(
    jni$_.JList<JniAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumList(
            reference.pointer,
            _id_echoNullableNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAnEnum>?>(
            const jni$_.JListNullableType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassList = _class.instanceMethodId(
    r'echoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<JniAllNullableTypes> echoNullableNonNullClassList(java.util.List<JniAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes>? echoNullableNonNullClassList(
    jni$_.JList<JniAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassList(
            reference.pointer,
            _id_echoNullableNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<JniAllNullableTypes>?>(
            const jni$_.JListNullableType<JniAllNullableTypes>(
                $JniAllNullableTypes$Type()));
  }

  static final _id_echoNullableMap = _class.instanceMethodId(
    r'echoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> echoNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableMap(reference.pointer,
            _id_echoNullableMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableStringMap = _class.instanceMethodId(
    r'echoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableStringMap(reference.pointer,
            _id_echoNullableStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoNullableIntMap = _class.instanceMethodId(
    r'echoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableIntMap(reference.pointer,
            _id_echoNullableIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoNullableEnumMap = _class.instanceMethodId(
    r'echoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> echoNullableEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? echoNullableEnumMap(
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumMap(reference.pointer,
            _id_echoNullableEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_echoNullableClassMap = _class.instanceMethodId(
    r'echoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> echoNullableClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? echoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableClassMap(reference.pointer,
            _id_echoNullableClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullStringMap = _class.instanceMethodId(
    r'echoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNullableNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullStringMap(
            reference.pointer,
            _id_echoNullableNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNullableNonNullIntMap = _class.instanceMethodId(
    r'echoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNullableNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullIntMap(reference.pointer,
            _id_echoNullableNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
            const jni$_.JMapNullableType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNullableNonNullEnumMap = _class.instanceMethodId(
    r'echoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<JniAnEnum, JniAnEnum> echoNullableNonNullEnumMap(java.util.Map<JniAnEnum, ? extends JniAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum>? echoNullableNonNullEnumMap(
    jni$_.JMap<JniAnEnum, JniAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumMap(reference.pointer,
            _id_echoNullableNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>?>(
            const jni$_.JMapNullableType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassMap = _class.instanceMethodId(
    r'echoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, JniAllNullableTypes> echoNullableNonNullClassMap(java.util.Map<java.lang.Long, JniAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? echoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassMap(
            reference.pointer,
            _id_echoNullableNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, JniAllNullableTypes>?>(
            const jni$_.JMapNullableType<jni$_.JLong, JniAllNullableTypes>(
                jni$_.JLongType(), $JniAllNullableTypes$Type()));
  }

  static final _id_echoNullableEnum = _class.instanceMethodId(
    r'echoNullableEnum',
    r'(LJniAnEnum;)LJniAnEnum;',
  );

  static final _echoNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnEnum echoNullableEnum(JniAnEnum jniAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? echoNullableEnum(
    JniAnEnum? jniAnEnum,
  ) {
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    return _echoNullableEnum(reference.pointer,
            _id_echoNullableEnum as jni$_.JMethodIDPtr, _$jniAnEnum.pointer)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_echoAnotherNullableEnum = _class.instanceMethodId(
    r'echoAnotherNullableEnum',
    r'(LJniAnotherEnum;)LJniAnotherEnum;',
  );

  static final _echoAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract JniAnotherEnum echoAnotherNullableEnum(JniAnotherEnum jniAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? echoAnotherNullableEnum(
    JniAnotherEnum? jniAnotherEnum,
  ) {
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    return _echoAnotherNullableEnum(
            reference.pointer,
            _id_echoAnotherNullableEnum as jni$_.JMethodIDPtr,
            _$jniAnotherEnum.pointer)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $JniFlutterIntegrationCoreApi> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'noop()V') {
        _$impls[$p]!.noop();
        return jni$_.nullptr;
      }
      if ($d == r'throwError()Ljava/lang/Object;') {
        final $r = _$impls[$p]!.throwError();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'throwErrorFromVoid()V') {
        _$impls[$p]!.throwErrorFromVoid();
        return jni$_.nullptr;
      }
      if ($d == r'echoJniAllTypes(LJniAllTypes;)LJniAllTypes;') {
        final $r = _$impls[$p]!.echoJniAllTypes(
          $a![0]!.as(const $JniAllTypes$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'echoJniAllNullableTypes(LJniAllNullableTypes;)LJniAllNullableTypes;') {
        final $r = _$impls[$p]!.echoJniAllNullableTypes(
          $a![0]?.as(const $JniAllNullableTypes$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'sendMultipleNullableTypes(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypes;') {
        final $r = _$impls[$p]!.sendMultipleNullableTypes(
          $a![0]?.as(const jni$_.JBooleanType(), releaseOriginal: true),
          $a![1]?.as(const jni$_.JLongType(), releaseOriginal: true),
          $a![2]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'echoJniAllNullableTypesWithoutRecursion(LJniAllNullableTypesWithoutRecursion;)LJniAllNullableTypesWithoutRecursion;') {
        final $r = _$impls[$p]!.echoJniAllNullableTypesWithoutRecursion(
          $a![0]?.as(const $JniAllNullableTypesWithoutRecursion$Type(),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'sendMultipleNullableTypesWithoutRecursion(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LJniAllNullableTypesWithoutRecursion;') {
        final $r = _$impls[$p]!.sendMultipleNullableTypesWithoutRecursion(
          $a![0]?.as(const jni$_.JBooleanType(), releaseOriginal: true),
          $a![1]?.as(const jni$_.JLongType(), releaseOriginal: true),
          $a![2]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoBool(Z)Z') {
        final $r = _$impls[$p]!.echoBool(
          $a![0]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'echoInt(J)J') {
        final $r = _$impls[$p]!.echoInt(
          $a![0]!
              .as(const jni$_.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'echoDouble(D)D') {
        final $r = _$impls[$p]!.echoDouble(
          $a![0]!
              .as(const jni$_.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni$_.JDouble($r).reference.toPointer();
      }
      if ($d == r'echoString(Ljava/lang/String;)Ljava/lang/String;') {
        final $r = _$impls[$p]!.echoString(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoUint8List([B)[B') {
        final $r = _$impls[$p]!.echoUint8List(
          $a![0]!.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoList(
          $a![0]!.as(
              const jni$_.JListType<jni$_.JObject?>(
                  jni$_.JObjectNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoEnumList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoEnumList(
          $a![0]!.as(
              const jni$_.JListType<JniAnEnum?>($JniAnEnum$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoClassList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoClassList(
          $a![0]!.as(
              const jni$_.JListType<JniAllNullableTypes?>(
                  $JniAllNullableTypes$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNonNullEnumList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNonNullEnumList(
          $a![0]!.as(const jni$_.JListType<JniAnEnum>($JniAnEnum$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNonNullClassList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNonNullClassList(
          $a![0]!.as(
              const jni$_.JListType<JniAllNullableTypes>(
                  $JniAllNullableTypes$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                  jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoStringMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoStringMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                  jni$_.JStringNullableType(), jni$_.JStringNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoIntMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoIntMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                  jni$_.JLongNullableType(), jni$_.JLongNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoEnumMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoEnumMap(
          $a![0]!.as(
              const jni$_.JMapType<JniAnEnum?, JniAnEnum?>(
                  $JniAnEnum$NullableType(), $JniAnEnum$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoClassMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoClassMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JLong?, JniAllNullableTypes?>(
                  jni$_.JLongNullableType(),
                  $JniAllNullableTypes$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNonNullStringMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNonNullStringMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                  jni$_.JStringType(), jni$_.JStringType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNonNullIntMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNonNullIntMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                  jni$_.JLongType(), jni$_.JLongType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNonNullEnumMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNonNullEnumMap(
          $a![0]!.as(
              const jni$_.JMapType<JniAnEnum, JniAnEnum>(
                  $JniAnEnum$Type(), $JniAnEnum$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNonNullClassMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNonNullClassMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JLong, JniAllNullableTypes>(
                  jni$_.JLongType(), $JniAllNullableTypes$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoEnum(LJniAnEnum;)LJniAnEnum;') {
        final $r = _$impls[$p]!.echoEnum(
          $a![0]!.as(const $JniAnEnum$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoJniAnotherEnum(LJniAnotherEnum;)LJniAnotherEnum;') {
        final $r = _$impls[$p]!.echoJniAnotherEnum(
          $a![0]!.as(const $JniAnotherEnum$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableBool(Ljava/lang/Boolean;)Ljava/lang/Boolean;') {
        final $r = _$impls[$p]!.echoNullableBool(
          $a![0]?.as(const jni$_.JBooleanType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableInt(Ljava/lang/Long;)Ljava/lang/Long;') {
        final $r = _$impls[$p]!.echoNullableInt(
          $a![0]?.as(const jni$_.JLongType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableDouble(Ljava/lang/Double;)Ljava/lang/Double;') {
        final $r = _$impls[$p]!.echoNullableDouble(
          $a![0]?.as(const jni$_.JDoubleType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableString(Ljava/lang/String;)Ljava/lang/String;') {
        final $r = _$impls[$p]!.echoNullableString(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableUint8List([B)[B') {
        final $r = _$impls[$p]!.echoNullableUint8List(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNullableList(
          $a![0]?.as(
              const jni$_.JListType<jni$_.JObject?>(
                  jni$_.JObjectNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableEnumList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNullableEnumList(
          $a![0]?.as(
              const jni$_.JListType<JniAnEnum?>($JniAnEnum$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableClassList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNullableClassList(
          $a![0]?.as(
              const jni$_.JListType<JniAllNullableTypes?>(
                  $JniAllNullableTypes$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'echoNullableNonNullEnumList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNullableNonNullEnumList(
          $a![0]?.as(const jni$_.JListType<JniAnEnum>($JniAnEnum$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'echoNullableNonNullClassList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNullableNonNullClassList(
          $a![0]?.as(
              const jni$_.JListType<JniAllNullableTypes>(
                  $JniAllNullableTypes$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                  jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableStringMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableStringMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                  jni$_.JStringNullableType(), jni$_.JStringNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableIntMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableIntMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                  jni$_.JLongNullableType(), jni$_.JLongNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableEnumMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableEnumMap(
          $a![0]?.as(
              const jni$_.JMapType<JniAnEnum?, JniAnEnum?>(
                  $JniAnEnum$NullableType(), $JniAnEnum$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableClassMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableClassMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JLong?, JniAllNullableTypes?>(
                  jni$_.JLongNullableType(),
                  $JniAllNullableTypes$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'echoNullableNonNullStringMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableNonNullStringMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                  jni$_.JStringType(), jni$_.JStringType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableNonNullIntMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableNonNullIntMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                  jni$_.JLongType(), jni$_.JLongType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableNonNullEnumMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableNonNullEnumMap(
          $a![0]?.as(
              const jni$_.JMapType<JniAnEnum, JniAnEnum>(
                  $JniAnEnum$Type(), $JniAnEnum$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'echoNullableNonNullClassMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableNonNullClassMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JLong, JniAllNullableTypes>(
                  jni$_.JLongType(), $JniAllNullableTypes$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableEnum(LJniAnEnum;)LJniAnEnum;') {
        final $r = _$impls[$p]!.echoNullableEnum(
          $a![0]?.as(const $JniAnEnum$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoAnotherNullableEnum(LJniAnotherEnum;)LJniAnotherEnum;') {
        final $r = _$impls[$p]!.echoAnotherNullableEnum(
          $a![0]?.as(const $JniAnotherEnum$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $JniFlutterIntegrationCoreApi $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'JniFlutterIntegrationCoreApi',
      $p,
      _$invokePointer,
      [
        if ($impl.noop$async) r'noop()V',
        if ($impl.throwErrorFromVoid$async) r'throwErrorFromVoid()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory JniFlutterIntegrationCoreApi.implement(
    $JniFlutterIntegrationCoreApi $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return JniFlutterIntegrationCoreApi.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $JniFlutterIntegrationCoreApi {
  factory $JniFlutterIntegrationCoreApi({
    required void Function() noop,
    bool noop$async,
    required jni$_.JObject? Function() throwError,
    required void Function() throwErrorFromVoid,
    bool throwErrorFromVoid$async,
    required JniAllTypes Function(JniAllTypes jniAllTypes) echoJniAllTypes,
    required JniAllNullableTypes? Function(
            JniAllNullableTypes? jniAllNullableTypes)
        echoJniAllNullableTypes,
    required JniAllNullableTypes Function(
            jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string)
        sendMultipleNullableTypes,
    required JniAllNullableTypesWithoutRecursion? Function(
            JniAllNullableTypesWithoutRecursion?
                jniAllNullableTypesWithoutRecursion)
        echoJniAllNullableTypesWithoutRecursion,
    required JniAllNullableTypesWithoutRecursion Function(
            jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string)
        sendMultipleNullableTypesWithoutRecursion,
    required bool Function(bool z) echoBool,
    required int Function(int j) echoInt,
    required double Function(double d) echoDouble,
    required jni$_.JString Function(jni$_.JString string) echoString,
    required jni$_.JByteArray Function(jni$_.JByteArray bs) echoUint8List,
    required jni$_.JList<jni$_.JObject?> Function(
            jni$_.JList<jni$_.JObject?> list)
        echoList,
    required jni$_.JList<JniAnEnum?> Function(jni$_.JList<JniAnEnum?> list)
        echoEnumList,
    required jni$_.JList<JniAllNullableTypes?> Function(
            jni$_.JList<JniAllNullableTypes?> list)
        echoClassList,
    required jni$_.JList<JniAnEnum> Function(jni$_.JList<JniAnEnum> list)
        echoNonNullEnumList,
    required jni$_.JList<JniAllNullableTypes> Function(
            jni$_.JList<JniAllNullableTypes> list)
        echoNonNullClassList,
    required jni$_.JMap<jni$_.JObject?, jni$_.JObject?> Function(
            jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map)
        echoMap,
    required jni$_.JMap<jni$_.JString?, jni$_.JString?> Function(
            jni$_.JMap<jni$_.JString?, jni$_.JString?> map)
        echoStringMap,
    required jni$_.JMap<jni$_.JLong?, jni$_.JLong?> Function(
            jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map)
        echoIntMap,
    required jni$_.JMap<JniAnEnum?, JniAnEnum?> Function(
            jni$_.JMap<JniAnEnum?, JniAnEnum?> map)
        echoEnumMap,
    required jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> Function(
            jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map)
        echoClassMap,
    required jni$_.JMap<jni$_.JString, jni$_.JString> Function(
            jni$_.JMap<jni$_.JString, jni$_.JString> map)
        echoNonNullStringMap,
    required jni$_.JMap<jni$_.JLong, jni$_.JLong> Function(
            jni$_.JMap<jni$_.JLong, jni$_.JLong> map)
        echoNonNullIntMap,
    required jni$_.JMap<JniAnEnum, JniAnEnum> Function(
            jni$_.JMap<JniAnEnum, JniAnEnum> map)
        echoNonNullEnumMap,
    required jni$_.JMap<jni$_.JLong, JniAllNullableTypes> Function(
            jni$_.JMap<jni$_.JLong, JniAllNullableTypes> map)
        echoNonNullClassMap,
    required JniAnEnum Function(JniAnEnum jniAnEnum) echoEnum,
    required JniAnotherEnum Function(JniAnotherEnum jniAnotherEnum)
        echoJniAnotherEnum,
    required jni$_.JBoolean? Function(jni$_.JBoolean? boolean) echoNullableBool,
    required jni$_.JLong? Function(jni$_.JLong? long) echoNullableInt,
    required jni$_.JDouble? Function(jni$_.JDouble? double) echoNullableDouble,
    required jni$_.JString? Function(jni$_.JString? string) echoNullableString,
    required jni$_.JByteArray? Function(jni$_.JByteArray? bs)
        echoNullableUint8List,
    required jni$_.JList<jni$_.JObject?>? Function(
            jni$_.JList<jni$_.JObject?>? list)
        echoNullableList,
    required jni$_.JList<JniAnEnum?>? Function(jni$_.JList<JniAnEnum?>? list)
        echoNullableEnumList,
    required jni$_.JList<JniAllNullableTypes?>? Function(
            jni$_.JList<JniAllNullableTypes?>? list)
        echoNullableClassList,
    required jni$_.JList<JniAnEnum>? Function(jni$_.JList<JniAnEnum>? list)
        echoNullableNonNullEnumList,
    required jni$_.JList<JniAllNullableTypes>? Function(
            jni$_.JList<JniAllNullableTypes>? list)
        echoNullableNonNullClassList,
    required jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? Function(
            jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
        echoNullableMap,
    required jni$_.JMap<jni$_.JString?, jni$_.JString?>? Function(
            jni$_.JMap<jni$_.JString?, jni$_.JString?>? map)
        echoNullableStringMap,
    required jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? Function(
            jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map)
        echoNullableIntMap,
    required jni$_.JMap<JniAnEnum?, JniAnEnum?>? Function(
            jni$_.JMap<JniAnEnum?, JniAnEnum?>? map)
        echoNullableEnumMap,
    required jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? Function(
            jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map)
        echoNullableClassMap,
    required jni$_.JMap<jni$_.JString, jni$_.JString>? Function(
            jni$_.JMap<jni$_.JString, jni$_.JString>? map)
        echoNullableNonNullStringMap,
    required jni$_.JMap<jni$_.JLong, jni$_.JLong>? Function(
            jni$_.JMap<jni$_.JLong, jni$_.JLong>? map)
        echoNullableNonNullIntMap,
    required jni$_.JMap<JniAnEnum, JniAnEnum>? Function(
            jni$_.JMap<JniAnEnum, JniAnEnum>? map)
        echoNullableNonNullEnumMap,
    required jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? Function(
            jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? map)
        echoNullableNonNullClassMap,
    required JniAnEnum? Function(JniAnEnum? jniAnEnum) echoNullableEnum,
    required JniAnotherEnum? Function(JniAnotherEnum? jniAnotherEnum)
        echoAnotherNullableEnum,
  }) = _$JniFlutterIntegrationCoreApi;

  void noop();
  bool get noop$async => false;
  jni$_.JObject? throwError();
  void throwErrorFromVoid();
  bool get throwErrorFromVoid$async => false;
  JniAllTypes echoJniAllTypes(JniAllTypes jniAllTypes);
  JniAllNullableTypes? echoJniAllNullableTypes(
      JniAllNullableTypes? jniAllNullableTypes);
  JniAllNullableTypes sendMultipleNullableTypes(
      jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string);
  JniAllNullableTypesWithoutRecursion? echoJniAllNullableTypesWithoutRecursion(
      JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion);
  JniAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
      jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string);
  bool echoBool(bool z);
  int echoInt(int j);
  double echoDouble(double d);
  jni$_.JString echoString(jni$_.JString string);
  jni$_.JByteArray echoUint8List(jni$_.JByteArray bs);
  jni$_.JList<jni$_.JObject?> echoList(jni$_.JList<jni$_.JObject?> list);
  jni$_.JList<JniAnEnum?> echoEnumList(jni$_.JList<JniAnEnum?> list);
  jni$_.JList<JniAllNullableTypes?> echoClassList(
      jni$_.JList<JniAllNullableTypes?> list);
  jni$_.JList<JniAnEnum> echoNonNullEnumList(jni$_.JList<JniAnEnum> list);
  jni$_.JList<JniAllNullableTypes> echoNonNullClassList(
      jni$_.JList<JniAllNullableTypes> list);
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
      jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map);
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
      jni$_.JMap<jni$_.JString?, jni$_.JString?> map);
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
      jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map);
  jni$_.JMap<JniAnEnum?, JniAnEnum?> echoEnumMap(
      jni$_.JMap<JniAnEnum?, JniAnEnum?> map);
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> echoClassMap(
      jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map);
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
      jni$_.JMap<jni$_.JString, jni$_.JString> map);
  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
      jni$_.JMap<jni$_.JLong, jni$_.JLong> map);
  jni$_.JMap<JniAnEnum, JniAnEnum> echoNonNullEnumMap(
      jni$_.JMap<JniAnEnum, JniAnEnum> map);
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes> echoNonNullClassMap(
      jni$_.JMap<jni$_.JLong, JniAllNullableTypes> map);
  JniAnEnum echoEnum(JniAnEnum jniAnEnum);
  JniAnotherEnum echoJniAnotherEnum(JniAnotherEnum jniAnotherEnum);
  jni$_.JBoolean? echoNullableBool(jni$_.JBoolean? boolean);
  jni$_.JLong? echoNullableInt(jni$_.JLong? long);
  jni$_.JDouble? echoNullableDouble(jni$_.JDouble? double);
  jni$_.JString? echoNullableString(jni$_.JString? string);
  jni$_.JByteArray? echoNullableUint8List(jni$_.JByteArray? bs);
  jni$_.JList<jni$_.JObject?>? echoNullableList(
      jni$_.JList<jni$_.JObject?>? list);
  jni$_.JList<JniAnEnum?>? echoNullableEnumList(jni$_.JList<JniAnEnum?>? list);
  jni$_.JList<JniAllNullableTypes?>? echoNullableClassList(
      jni$_.JList<JniAllNullableTypes?>? list);
  jni$_.JList<JniAnEnum>? echoNullableNonNullEnumList(
      jni$_.JList<JniAnEnum>? list);
  jni$_.JList<JniAllNullableTypes>? echoNullableNonNullClassList(
      jni$_.JList<JniAllNullableTypes>? list);
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
      jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map);
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
      jni$_.JMap<jni$_.JString?, jni$_.JString?>? map);
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
      jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map);
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? echoNullableEnumMap(
      jni$_.JMap<JniAnEnum?, JniAnEnum?>? map);
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? echoNullableClassMap(
      jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map);
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
      jni$_.JMap<jni$_.JString, jni$_.JString>? map);
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
      jni$_.JMap<jni$_.JLong, jni$_.JLong>? map);
  jni$_.JMap<JniAnEnum, JniAnEnum>? echoNullableNonNullEnumMap(
      jni$_.JMap<JniAnEnum, JniAnEnum>? map);
  jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? echoNullableNonNullClassMap(
      jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? map);
  JniAnEnum? echoNullableEnum(JniAnEnum? jniAnEnum);
  JniAnotherEnum? echoAnotherNullableEnum(JniAnotherEnum? jniAnotherEnum);
}

final class _$JniFlutterIntegrationCoreApi with $JniFlutterIntegrationCoreApi {
  _$JniFlutterIntegrationCoreApi({
    required void Function() noop,
    this.noop$async = false,
    required jni$_.JObject? Function() throwError,
    required void Function() throwErrorFromVoid,
    this.throwErrorFromVoid$async = false,
    required JniAllTypes Function(JniAllTypes jniAllTypes) echoJniAllTypes,
    required JniAllNullableTypes? Function(
            JniAllNullableTypes? jniAllNullableTypes)
        echoJniAllNullableTypes,
    required JniAllNullableTypes Function(
            jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string)
        sendMultipleNullableTypes,
    required JniAllNullableTypesWithoutRecursion? Function(
            JniAllNullableTypesWithoutRecursion?
                jniAllNullableTypesWithoutRecursion)
        echoJniAllNullableTypesWithoutRecursion,
    required JniAllNullableTypesWithoutRecursion Function(
            jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string)
        sendMultipleNullableTypesWithoutRecursion,
    required bool Function(bool z) echoBool,
    required int Function(int j) echoInt,
    required double Function(double d) echoDouble,
    required jni$_.JString Function(jni$_.JString string) echoString,
    required jni$_.JByteArray Function(jni$_.JByteArray bs) echoUint8List,
    required jni$_.JList<jni$_.JObject?> Function(
            jni$_.JList<jni$_.JObject?> list)
        echoList,
    required jni$_.JList<JniAnEnum?> Function(jni$_.JList<JniAnEnum?> list)
        echoEnumList,
    required jni$_.JList<JniAllNullableTypes?> Function(
            jni$_.JList<JniAllNullableTypes?> list)
        echoClassList,
    required jni$_.JList<JniAnEnum> Function(jni$_.JList<JniAnEnum> list)
        echoNonNullEnumList,
    required jni$_.JList<JniAllNullableTypes> Function(
            jni$_.JList<JniAllNullableTypes> list)
        echoNonNullClassList,
    required jni$_.JMap<jni$_.JObject?, jni$_.JObject?> Function(
            jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map)
        echoMap,
    required jni$_.JMap<jni$_.JString?, jni$_.JString?> Function(
            jni$_.JMap<jni$_.JString?, jni$_.JString?> map)
        echoStringMap,
    required jni$_.JMap<jni$_.JLong?, jni$_.JLong?> Function(
            jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map)
        echoIntMap,
    required jni$_.JMap<JniAnEnum?, JniAnEnum?> Function(
            jni$_.JMap<JniAnEnum?, JniAnEnum?> map)
        echoEnumMap,
    required jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> Function(
            jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map)
        echoClassMap,
    required jni$_.JMap<jni$_.JString, jni$_.JString> Function(
            jni$_.JMap<jni$_.JString, jni$_.JString> map)
        echoNonNullStringMap,
    required jni$_.JMap<jni$_.JLong, jni$_.JLong> Function(
            jni$_.JMap<jni$_.JLong, jni$_.JLong> map)
        echoNonNullIntMap,
    required jni$_.JMap<JniAnEnum, JniAnEnum> Function(
            jni$_.JMap<JniAnEnum, JniAnEnum> map)
        echoNonNullEnumMap,
    required jni$_.JMap<jni$_.JLong, JniAllNullableTypes> Function(
            jni$_.JMap<jni$_.JLong, JniAllNullableTypes> map)
        echoNonNullClassMap,
    required JniAnEnum Function(JniAnEnum jniAnEnum) echoEnum,
    required JniAnotherEnum Function(JniAnotherEnum jniAnotherEnum)
        echoJniAnotherEnum,
    required jni$_.JBoolean? Function(jni$_.JBoolean? boolean) echoNullableBool,
    required jni$_.JLong? Function(jni$_.JLong? long) echoNullableInt,
    required jni$_.JDouble? Function(jni$_.JDouble? double) echoNullableDouble,
    required jni$_.JString? Function(jni$_.JString? string) echoNullableString,
    required jni$_.JByteArray? Function(jni$_.JByteArray? bs)
        echoNullableUint8List,
    required jni$_.JList<jni$_.JObject?>? Function(
            jni$_.JList<jni$_.JObject?>? list)
        echoNullableList,
    required jni$_.JList<JniAnEnum?>? Function(jni$_.JList<JniAnEnum?>? list)
        echoNullableEnumList,
    required jni$_.JList<JniAllNullableTypes?>? Function(
            jni$_.JList<JniAllNullableTypes?>? list)
        echoNullableClassList,
    required jni$_.JList<JniAnEnum>? Function(jni$_.JList<JniAnEnum>? list)
        echoNullableNonNullEnumList,
    required jni$_.JList<JniAllNullableTypes>? Function(
            jni$_.JList<JniAllNullableTypes>? list)
        echoNullableNonNullClassList,
    required jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? Function(
            jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
        echoNullableMap,
    required jni$_.JMap<jni$_.JString?, jni$_.JString?>? Function(
            jni$_.JMap<jni$_.JString?, jni$_.JString?>? map)
        echoNullableStringMap,
    required jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? Function(
            jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map)
        echoNullableIntMap,
    required jni$_.JMap<JniAnEnum?, JniAnEnum?>? Function(
            jni$_.JMap<JniAnEnum?, JniAnEnum?>? map)
        echoNullableEnumMap,
    required jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? Function(
            jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map)
        echoNullableClassMap,
    required jni$_.JMap<jni$_.JString, jni$_.JString>? Function(
            jni$_.JMap<jni$_.JString, jni$_.JString>? map)
        echoNullableNonNullStringMap,
    required jni$_.JMap<jni$_.JLong, jni$_.JLong>? Function(
            jni$_.JMap<jni$_.JLong, jni$_.JLong>? map)
        echoNullableNonNullIntMap,
    required jni$_.JMap<JniAnEnum, JniAnEnum>? Function(
            jni$_.JMap<JniAnEnum, JniAnEnum>? map)
        echoNullableNonNullEnumMap,
    required jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? Function(
            jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? map)
        echoNullableNonNullClassMap,
    required JniAnEnum? Function(JniAnEnum? jniAnEnum) echoNullableEnum,
    required JniAnotherEnum? Function(JniAnotherEnum? jniAnotherEnum)
        echoAnotherNullableEnum,
  })  : _noop = noop,
        _throwError = throwError,
        _throwErrorFromVoid = throwErrorFromVoid,
        _echoJniAllTypes = echoJniAllTypes,
        _echoJniAllNullableTypes = echoJniAllNullableTypes,
        _sendMultipleNullableTypes = sendMultipleNullableTypes,
        _echoJniAllNullableTypesWithoutRecursion =
            echoJniAllNullableTypesWithoutRecursion,
        _sendMultipleNullableTypesWithoutRecursion =
            sendMultipleNullableTypesWithoutRecursion,
        _echoBool = echoBool,
        _echoInt = echoInt,
        _echoDouble = echoDouble,
        _echoString = echoString,
        _echoUint8List = echoUint8List,
        _echoList = echoList,
        _echoEnumList = echoEnumList,
        _echoClassList = echoClassList,
        _echoNonNullEnumList = echoNonNullEnumList,
        _echoNonNullClassList = echoNonNullClassList,
        _echoMap = echoMap,
        _echoStringMap = echoStringMap,
        _echoIntMap = echoIntMap,
        _echoEnumMap = echoEnumMap,
        _echoClassMap = echoClassMap,
        _echoNonNullStringMap = echoNonNullStringMap,
        _echoNonNullIntMap = echoNonNullIntMap,
        _echoNonNullEnumMap = echoNonNullEnumMap,
        _echoNonNullClassMap = echoNonNullClassMap,
        _echoEnum = echoEnum,
        _echoJniAnotherEnum = echoJniAnotherEnum,
        _echoNullableBool = echoNullableBool,
        _echoNullableInt = echoNullableInt,
        _echoNullableDouble = echoNullableDouble,
        _echoNullableString = echoNullableString,
        _echoNullableUint8List = echoNullableUint8List,
        _echoNullableList = echoNullableList,
        _echoNullableEnumList = echoNullableEnumList,
        _echoNullableClassList = echoNullableClassList,
        _echoNullableNonNullEnumList = echoNullableNonNullEnumList,
        _echoNullableNonNullClassList = echoNullableNonNullClassList,
        _echoNullableMap = echoNullableMap,
        _echoNullableStringMap = echoNullableStringMap,
        _echoNullableIntMap = echoNullableIntMap,
        _echoNullableEnumMap = echoNullableEnumMap,
        _echoNullableClassMap = echoNullableClassMap,
        _echoNullableNonNullStringMap = echoNullableNonNullStringMap,
        _echoNullableNonNullIntMap = echoNullableNonNullIntMap,
        _echoNullableNonNullEnumMap = echoNullableNonNullEnumMap,
        _echoNullableNonNullClassMap = echoNullableNonNullClassMap,
        _echoNullableEnum = echoNullableEnum,
        _echoAnotherNullableEnum = echoAnotherNullableEnum;

  final void Function() _noop;
  final bool noop$async;
  final jni$_.JObject? Function() _throwError;
  final void Function() _throwErrorFromVoid;
  final bool throwErrorFromVoid$async;
  final JniAllTypes Function(JniAllTypes jniAllTypes) _echoJniAllTypes;
  final JniAllNullableTypes? Function(JniAllNullableTypes? jniAllNullableTypes)
      _echoJniAllNullableTypes;
  final JniAllNullableTypes Function(
          jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string)
      _sendMultipleNullableTypes;
  final JniAllNullableTypesWithoutRecursion? Function(
          JniAllNullableTypesWithoutRecursion?
              jniAllNullableTypesWithoutRecursion)
      _echoJniAllNullableTypesWithoutRecursion;
  final JniAllNullableTypesWithoutRecursion Function(
          jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string)
      _sendMultipleNullableTypesWithoutRecursion;
  final bool Function(bool z) _echoBool;
  final int Function(int j) _echoInt;
  final double Function(double d) _echoDouble;
  final jni$_.JString Function(jni$_.JString string) _echoString;
  final jni$_.JByteArray Function(jni$_.JByteArray bs) _echoUint8List;
  final jni$_.JList<jni$_.JObject?> Function(jni$_.JList<jni$_.JObject?> list)
      _echoList;
  final jni$_.JList<JniAnEnum?> Function(jni$_.JList<JniAnEnum?> list)
      _echoEnumList;
  final jni$_.JList<JniAllNullableTypes?> Function(
      jni$_.JList<JniAllNullableTypes?> list) _echoClassList;
  final jni$_.JList<JniAnEnum> Function(jni$_.JList<JniAnEnum> list)
      _echoNonNullEnumList;
  final jni$_.JList<JniAllNullableTypes> Function(
      jni$_.JList<JniAllNullableTypes> list) _echoNonNullClassList;
  final jni$_.JMap<jni$_.JObject?, jni$_.JObject?> Function(
      jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map) _echoMap;
  final jni$_.JMap<jni$_.JString?, jni$_.JString?> Function(
      jni$_.JMap<jni$_.JString?, jni$_.JString?> map) _echoStringMap;
  final jni$_.JMap<jni$_.JLong?, jni$_.JLong?> Function(
      jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map) _echoIntMap;
  final jni$_.JMap<JniAnEnum?, JniAnEnum?> Function(
      jni$_.JMap<JniAnEnum?, JniAnEnum?> map) _echoEnumMap;
  final jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> Function(
      jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map) _echoClassMap;
  final jni$_.JMap<jni$_.JString, jni$_.JString> Function(
      jni$_.JMap<jni$_.JString, jni$_.JString> map) _echoNonNullStringMap;
  final jni$_.JMap<jni$_.JLong, jni$_.JLong> Function(
      jni$_.JMap<jni$_.JLong, jni$_.JLong> map) _echoNonNullIntMap;
  final jni$_.JMap<JniAnEnum, JniAnEnum> Function(
      jni$_.JMap<JniAnEnum, JniAnEnum> map) _echoNonNullEnumMap;
  final jni$_.JMap<jni$_.JLong, JniAllNullableTypes> Function(
      jni$_.JMap<jni$_.JLong, JniAllNullableTypes> map) _echoNonNullClassMap;
  final JniAnEnum Function(JniAnEnum jniAnEnum) _echoEnum;
  final JniAnotherEnum Function(JniAnotherEnum jniAnotherEnum)
      _echoJniAnotherEnum;
  final jni$_.JBoolean? Function(jni$_.JBoolean? boolean) _echoNullableBool;
  final jni$_.JLong? Function(jni$_.JLong? long) _echoNullableInt;
  final jni$_.JDouble? Function(jni$_.JDouble? double) _echoNullableDouble;
  final jni$_.JString? Function(jni$_.JString? string) _echoNullableString;
  final jni$_.JByteArray? Function(jni$_.JByteArray? bs) _echoNullableUint8List;
  final jni$_.JList<jni$_.JObject?>? Function(jni$_.JList<jni$_.JObject?>? list)
      _echoNullableList;
  final jni$_.JList<JniAnEnum?>? Function(jni$_.JList<JniAnEnum?>? list)
      _echoNullableEnumList;
  final jni$_.JList<JniAllNullableTypes?>? Function(
      jni$_.JList<JniAllNullableTypes?>? list) _echoNullableClassList;
  final jni$_.JList<JniAnEnum>? Function(jni$_.JList<JniAnEnum>? list)
      _echoNullableNonNullEnumList;
  final jni$_.JList<JniAllNullableTypes>? Function(
      jni$_.JList<JniAllNullableTypes>? list) _echoNullableNonNullClassList;
  final jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? Function(
      jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map) _echoNullableMap;
  final jni$_.JMap<jni$_.JString?, jni$_.JString?>? Function(
      jni$_.JMap<jni$_.JString?, jni$_.JString?>? map) _echoNullableStringMap;
  final jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? Function(
      jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map) _echoNullableIntMap;
  final jni$_.JMap<JniAnEnum?, JniAnEnum?>? Function(
      jni$_.JMap<JniAnEnum?, JniAnEnum?>? map) _echoNullableEnumMap;
  final jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? Function(
          jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map)
      _echoNullableClassMap;
  final jni$_.JMap<jni$_.JString, jni$_.JString>? Function(
          jni$_.JMap<jni$_.JString, jni$_.JString>? map)
      _echoNullableNonNullStringMap;
  final jni$_.JMap<jni$_.JLong, jni$_.JLong>? Function(
      jni$_.JMap<jni$_.JLong, jni$_.JLong>? map) _echoNullableNonNullIntMap;
  final jni$_.JMap<JniAnEnum, JniAnEnum>? Function(
      jni$_.JMap<JniAnEnum, JniAnEnum>? map) _echoNullableNonNullEnumMap;
  final jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? Function(
          jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? map)
      _echoNullableNonNullClassMap;
  final JniAnEnum? Function(JniAnEnum? jniAnEnum) _echoNullableEnum;
  final JniAnotherEnum? Function(JniAnotherEnum? jniAnotherEnum)
      _echoAnotherNullableEnum;

  void noop() {
    return _noop();
  }

  jni$_.JObject? throwError() {
    return _throwError();
  }

  void throwErrorFromVoid() {
    return _throwErrorFromVoid();
  }

  JniAllTypes echoJniAllTypes(JniAllTypes jniAllTypes) {
    return _echoJniAllTypes(jniAllTypes);
  }

  JniAllNullableTypes? echoJniAllNullableTypes(
      JniAllNullableTypes? jniAllNullableTypes) {
    return _echoJniAllNullableTypes(jniAllNullableTypes);
  }

  JniAllNullableTypes sendMultipleNullableTypes(
      jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string) {
    return _sendMultipleNullableTypes(boolean, long, string);
  }

  JniAllNullableTypesWithoutRecursion? echoJniAllNullableTypesWithoutRecursion(
      JniAllNullableTypesWithoutRecursion?
          jniAllNullableTypesWithoutRecursion) {
    return _echoJniAllNullableTypesWithoutRecursion(
        jniAllNullableTypesWithoutRecursion);
  }

  JniAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
      jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string) {
    return _sendMultipleNullableTypesWithoutRecursion(boolean, long, string);
  }

  bool echoBool(bool z) {
    return _echoBool(z);
  }

  int echoInt(int j) {
    return _echoInt(j);
  }

  double echoDouble(double d) {
    return _echoDouble(d);
  }

  jni$_.JString echoString(jni$_.JString string) {
    return _echoString(string);
  }

  jni$_.JByteArray echoUint8List(jni$_.JByteArray bs) {
    return _echoUint8List(bs);
  }

  jni$_.JList<jni$_.JObject?> echoList(jni$_.JList<jni$_.JObject?> list) {
    return _echoList(list);
  }

  jni$_.JList<JniAnEnum?> echoEnumList(jni$_.JList<JniAnEnum?> list) {
    return _echoEnumList(list);
  }

  jni$_.JList<JniAllNullableTypes?> echoClassList(
      jni$_.JList<JniAllNullableTypes?> list) {
    return _echoClassList(list);
  }

  jni$_.JList<JniAnEnum> echoNonNullEnumList(jni$_.JList<JniAnEnum> list) {
    return _echoNonNullEnumList(list);
  }

  jni$_.JList<JniAllNullableTypes> echoNonNullClassList(
      jni$_.JList<JniAllNullableTypes> list) {
    return _echoNonNullClassList(list);
  }

  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
      jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map) {
    return _echoMap(map);
  }

  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
      jni$_.JMap<jni$_.JString?, jni$_.JString?> map) {
    return _echoStringMap(map);
  }

  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
      jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map) {
    return _echoIntMap(map);
  }

  jni$_.JMap<JniAnEnum?, JniAnEnum?> echoEnumMap(
      jni$_.JMap<JniAnEnum?, JniAnEnum?> map) {
    return _echoEnumMap(map);
  }

  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> echoClassMap(
      jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?> map) {
    return _echoClassMap(map);
  }

  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
      jni$_.JMap<jni$_.JString, jni$_.JString> map) {
    return _echoNonNullStringMap(map);
  }

  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
      jni$_.JMap<jni$_.JLong, jni$_.JLong> map) {
    return _echoNonNullIntMap(map);
  }

  jni$_.JMap<JniAnEnum, JniAnEnum> echoNonNullEnumMap(
      jni$_.JMap<JniAnEnum, JniAnEnum> map) {
    return _echoNonNullEnumMap(map);
  }

  jni$_.JMap<jni$_.JLong, JniAllNullableTypes> echoNonNullClassMap(
      jni$_.JMap<jni$_.JLong, JniAllNullableTypes> map) {
    return _echoNonNullClassMap(map);
  }

  JniAnEnum echoEnum(JniAnEnum jniAnEnum) {
    return _echoEnum(jniAnEnum);
  }

  JniAnotherEnum echoJniAnotherEnum(JniAnotherEnum jniAnotherEnum) {
    return _echoJniAnotherEnum(jniAnotherEnum);
  }

  jni$_.JBoolean? echoNullableBool(jni$_.JBoolean? boolean) {
    return _echoNullableBool(boolean);
  }

  jni$_.JLong? echoNullableInt(jni$_.JLong? long) {
    return _echoNullableInt(long);
  }

  jni$_.JDouble? echoNullableDouble(jni$_.JDouble? double) {
    return _echoNullableDouble(double);
  }

  jni$_.JString? echoNullableString(jni$_.JString? string) {
    return _echoNullableString(string);
  }

  jni$_.JByteArray? echoNullableUint8List(jni$_.JByteArray? bs) {
    return _echoNullableUint8List(bs);
  }

  jni$_.JList<jni$_.JObject?>? echoNullableList(
      jni$_.JList<jni$_.JObject?>? list) {
    return _echoNullableList(list);
  }

  jni$_.JList<JniAnEnum?>? echoNullableEnumList(jni$_.JList<JniAnEnum?>? list) {
    return _echoNullableEnumList(list);
  }

  jni$_.JList<JniAllNullableTypes?>? echoNullableClassList(
      jni$_.JList<JniAllNullableTypes?>? list) {
    return _echoNullableClassList(list);
  }

  jni$_.JList<JniAnEnum>? echoNullableNonNullEnumList(
      jni$_.JList<JniAnEnum>? list) {
    return _echoNullableNonNullEnumList(list);
  }

  jni$_.JList<JniAllNullableTypes>? echoNullableNonNullClassList(
      jni$_.JList<JniAllNullableTypes>? list) {
    return _echoNullableNonNullClassList(list);
  }

  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
      jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map) {
    return _echoNullableMap(map);
  }

  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
      jni$_.JMap<jni$_.JString?, jni$_.JString?>? map) {
    return _echoNullableStringMap(map);
  }

  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
      jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map) {
    return _echoNullableIntMap(map);
  }

  jni$_.JMap<JniAnEnum?, JniAnEnum?>? echoNullableEnumMap(
      jni$_.JMap<JniAnEnum?, JniAnEnum?>? map) {
    return _echoNullableEnumMap(map);
  }

  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? echoNullableClassMap(
      jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map) {
    return _echoNullableClassMap(map);
  }

  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
      jni$_.JMap<jni$_.JString, jni$_.JString>? map) {
    return _echoNullableNonNullStringMap(map);
  }

  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
      jni$_.JMap<jni$_.JLong, jni$_.JLong>? map) {
    return _echoNullableNonNullIntMap(map);
  }

  jni$_.JMap<JniAnEnum, JniAnEnum>? echoNullableNonNullEnumMap(
      jni$_.JMap<JniAnEnum, JniAnEnum>? map) {
    return _echoNullableNonNullEnumMap(map);
  }

  jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? echoNullableNonNullClassMap(
      jni$_.JMap<jni$_.JLong, JniAllNullableTypes>? map) {
    return _echoNullableNonNullClassMap(map);
  }

  JniAnEnum? echoNullableEnum(JniAnEnum? jniAnEnum) {
    return _echoNullableEnum(jniAnEnum);
  }

  JniAnotherEnum? echoAnotherNullableEnum(JniAnotherEnum? jniAnotherEnum) {
    return _echoAnotherNullableEnum(jniAnotherEnum);
  }
}

final class $JniFlutterIntegrationCoreApi$NullableType
    extends jni$_.JObjType<JniFlutterIntegrationCoreApi?> {
  @jni$_.internal
  const $JniFlutterIntegrationCoreApi$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniFlutterIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  JniFlutterIntegrationCoreApi? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniFlutterIntegrationCoreApi.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniFlutterIntegrationCoreApi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniFlutterIntegrationCoreApi$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniFlutterIntegrationCoreApi$NullableType) &&
        other is $JniFlutterIntegrationCoreApi$NullableType;
  }
}

final class $JniFlutterIntegrationCoreApi$Type
    extends jni$_.JObjType<JniFlutterIntegrationCoreApi> {
  @jni$_.internal
  const $JniFlutterIntegrationCoreApi$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniFlutterIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  JniFlutterIntegrationCoreApi fromReference(jni$_.JReference reference) =>
      JniFlutterIntegrationCoreApi.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniFlutterIntegrationCoreApi?> get nullableType =>
      const $JniFlutterIntegrationCoreApi$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniFlutterIntegrationCoreApi$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniFlutterIntegrationCoreApi$Type) &&
        other is $JniFlutterIntegrationCoreApi$Type;
  }
}

/// from: `JniFlutterIntegrationCoreApiRegistrar`
class JniFlutterIntegrationCoreApiRegistrar extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniFlutterIntegrationCoreApiRegistrar> $type;

  @jni$_.internal
  JniFlutterIntegrationCoreApiRegistrar.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'JniFlutterIntegrationCoreApiRegistrar');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $JniFlutterIntegrationCoreApiRegistrar$NullableType();
  static const type = $JniFlutterIntegrationCoreApiRegistrar$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniFlutterIntegrationCoreApiRegistrar() {
    return JniFlutterIntegrationCoreApiRegistrar.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_registerInstance = _class.instanceMethodId(
    r'registerInstance',
    r'(LJniFlutterIntegrationCoreApi;Ljava/lang/String;)V',
  );

  static final _registerInstance = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void registerInstance(JniFlutterIntegrationCoreApi jniFlutterIntegrationCoreApi, java.lang.String string)`
  void registerInstance(
    JniFlutterIntegrationCoreApi jniFlutterIntegrationCoreApi,
    jni$_.JString string,
  ) {
    final _$jniFlutterIntegrationCoreApi =
        jniFlutterIntegrationCoreApi.reference;
    final _$string = string.reference;
    _registerInstance(
            reference.pointer,
            _id_registerInstance as jni$_.JMethodIDPtr,
            _$jniFlutterIntegrationCoreApi.pointer,
            _$string.pointer)
        .check();
  }

  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Ljava/lang/String;)LJniFlutterIntegrationCoreApi;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniFlutterIntegrationCoreApi getInstance(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  JniFlutterIntegrationCoreApi? getInstance(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getInstance(reference.pointer,
            _id_getInstance as jni$_.JMethodIDPtr, _$string.pointer)
        .object<JniFlutterIntegrationCoreApi?>(
            const $JniFlutterIntegrationCoreApi$NullableType());
  }
}

final class $JniFlutterIntegrationCoreApiRegistrar$NullableType
    extends jni$_.JObjType<JniFlutterIntegrationCoreApiRegistrar?> {
  @jni$_.internal
  const $JniFlutterIntegrationCoreApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniFlutterIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniFlutterIntegrationCoreApiRegistrar? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniFlutterIntegrationCoreApiRegistrar.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniFlutterIntegrationCoreApiRegistrar?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($JniFlutterIntegrationCoreApiRegistrar$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JniFlutterIntegrationCoreApiRegistrar$NullableType) &&
        other is $JniFlutterIntegrationCoreApiRegistrar$NullableType;
  }
}

final class $JniFlutterIntegrationCoreApiRegistrar$Type
    extends jni$_.JObjType<JniFlutterIntegrationCoreApiRegistrar> {
  @jni$_.internal
  const $JniFlutterIntegrationCoreApiRegistrar$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniFlutterIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  JniFlutterIntegrationCoreApiRegistrar fromReference(
          jni$_.JReference reference) =>
      JniFlutterIntegrationCoreApiRegistrar.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniFlutterIntegrationCoreApiRegistrar?> get nullableType =>
      const $JniFlutterIntegrationCoreApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniFlutterIntegrationCoreApiRegistrar$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniFlutterIntegrationCoreApiRegistrar$Type) &&
        other is $JniFlutterIntegrationCoreApiRegistrar$Type;
  }
}

/// from: `JniUnusedClass$Companion`
class JniUnusedClass$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniUnusedClass$Companion> $type;

  @jni$_.internal
  JniUnusedClass$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniUnusedClass$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniUnusedClass$Companion$NullableType();
  static const type = $JniUnusedClass$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LJniUnusedClass;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniUnusedClass fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  JniUnusedClass fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<JniUnusedClass>(const $JniUnusedClass$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniUnusedClass$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniUnusedClass$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniUnusedClass$Companion$NullableType
    extends jni$_.JObjType<JniUnusedClass$Companion?> {
  @jni$_.internal
  const $JniUnusedClass$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniUnusedClass$Companion;';

  @jni$_.internal
  @core$_.override
  JniUnusedClass$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniUnusedClass$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniUnusedClass$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniUnusedClass$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniUnusedClass$Companion$NullableType) &&
        other is $JniUnusedClass$Companion$NullableType;
  }
}

final class $JniUnusedClass$Companion$Type
    extends jni$_.JObjType<JniUnusedClass$Companion> {
  @jni$_.internal
  const $JniUnusedClass$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniUnusedClass$Companion;';

  @jni$_.internal
  @core$_.override
  JniUnusedClass$Companion fromReference(jni$_.JReference reference) =>
      JniUnusedClass$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniUnusedClass$Companion?> get nullableType =>
      const $JniUnusedClass$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniUnusedClass$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniUnusedClass$Companion$Type) &&
        other is $JniUnusedClass$Companion$Type;
  }
}

/// from: `JniUnusedClass`
class JniUnusedClass extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniUnusedClass> $type;

  @jni$_.internal
  JniUnusedClass.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniUnusedClass');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniUnusedClass$NullableType();
  static const type = $JniUnusedClass$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniUnusedClass$Companion;',
  );

  /// from: `static public final JniUnusedClass$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniUnusedClass$Companion get Companion =>
      _id_Companion.get(_class, const $JniUnusedClass$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniUnusedClass(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return JniUnusedClass.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$object.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Object;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(java.lang.Object object, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniUnusedClass.new$1(
    jni$_.JObject? object,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniUnusedClass.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$object.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getAField = _class.instanceMethodId(
    r'getAField',
    r'()Ljava/lang/Object;',
  );

  static final _getAField = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object getAField()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getAField() {
    return _getAField(reference.pointer, _id_getAField as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/Object;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object component1()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/Object;)LJniUnusedClass;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniUnusedClass copy(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  JniUnusedClass copy(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _copy(
            reference.pointer, _id_copy as jni$_.JMethodIDPtr, _$object.pointer)
        .object<JniUnusedClass>(const $JniUnusedClass$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniUnusedClass.new$2() {
    return JniUnusedClass.fromReference(
        _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $JniUnusedClass$NullableType
    extends jni$_.JObjType<JniUnusedClass?> {
  @jni$_.internal
  const $JniUnusedClass$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniUnusedClass;';

  @jni$_.internal
  @core$_.override
  JniUnusedClass? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : JniUnusedClass.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniUnusedClass?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniUnusedClass$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniUnusedClass$NullableType) &&
        other is $JniUnusedClass$NullableType;
  }
}

final class $JniUnusedClass$Type extends jni$_.JObjType<JniUnusedClass> {
  @jni$_.internal
  const $JniUnusedClass$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniUnusedClass;';

  @jni$_.internal
  @core$_.override
  JniUnusedClass fromReference(jni$_.JReference reference) =>
      JniUnusedClass.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniUnusedClass?> get nullableType =>
      const $JniUnusedClass$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniUnusedClass$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniUnusedClass$Type) &&
        other is $JniUnusedClass$Type;
  }
}

/// from: `JniAllTypes$Companion`
class JniAllTypes$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllTypes$Companion> $type;

  @jni$_.internal
  JniAllTypes$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAllTypes$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAllTypes$Companion$NullableType();
  static const type = $JniAllTypes$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LJniAllTypes;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllTypes fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<JniAllTypes>(const $JniAllTypes$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllTypes$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllTypes$Companion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniAllTypes$Companion$NullableType
    extends jni$_.JObjType<JniAllTypes$Companion?> {
  @jni$_.internal
  const $JniAllTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllTypes$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllTypes$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllTypes$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllTypes$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllTypes$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllTypes$Companion$NullableType) &&
        other is $JniAllTypes$Companion$NullableType;
  }
}

final class $JniAllTypes$Companion$Type
    extends jni$_.JObjType<JniAllTypes$Companion> {
  @jni$_.internal
  const $JniAllTypes$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllTypes$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllTypes$Companion fromReference(jni$_.JReference reference) =>
      JniAllTypes$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllTypes$Companion?> get nullableType =>
      const $JniAllTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllTypes$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllTypes$Companion$Type) &&
        other is $JniAllTypes$Companion$Type;
  }
}

/// from: `JniAllTypes`
class JniAllTypes extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllTypes> $type;

  @jni$_.internal
  JniAllTypes.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAllTypes');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAllTypes$NullableType();
  static const type = $JniAllTypes$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniAllTypes$Companion;',
  );

  /// from: `static public final JniAllTypes$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAllTypes$Companion get Companion =>
      _id_Companion.get(_class, const $JniAllTypes$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(ZJJD[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(boolean z, long j, long j1, double d, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends JniAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<JniAnEnum, ? extends JniAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllTypes(
    bool z,
    int j,
    int j1,
    double d,
    jni$_.JByteArray bs,
    jni$_.JIntArray is$,
    jni$_.JLongArray js,
    jni$_.JDoubleArray ds,
    JniAnEnum jniAnEnum,
    JniAnotherEnum jniAnotherEnum,
    jni$_.JString string,
    jni$_.JObject object,
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JList<jni$_.JString> list1,
    jni$_.JList<jni$_.JLong> list2,
    jni$_.JList<jni$_.JDouble> list3,
    jni$_.JList<jni$_.JBoolean> list4,
    jni$_.JList<JniAnEnum> list5,
    jni$_.JList<jni$_.JObject> list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>> list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?> map,
    jni$_.JMap<jni$_.JString, jni$_.JString> map1,
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map2,
    jni$_.JMap<JniAnEnum, JniAnEnum> map3,
    jni$_.JMap<jni$_.JObject, jni$_.JObject> map4,
    jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> map5,
    jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> map6,
  ) {
    final _$bs = bs.reference;
    final _$is$ = is$.reference;
    final _$js = js.reference;
    final _$ds = ds.reference;
    final _$jniAnEnum = jniAnEnum.reference;
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    final _$string = string.reference;
    final _$object = object.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$list2 = list2.reference;
    final _$list3 = list3.reference;
    final _$list4 = list4.reference;
    final _$list5 = list5.reference;
    final _$list6 = list6.reference;
    final _$list7 = list7.reference;
    final _$list8 = list8.reference;
    final _$map = map.reference;
    final _$map1 = map1.reference;
    final _$map2 = map2.reference;
    final _$map3 = map3.reference;
    final _$map4 = map4.reference;
    final _$map5 = map5.reference;
    final _$map6 = map6.reference;
    return JniAllTypes.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            j,
            j1,
            d,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer)
        .reference);
  }

  static final _id_getABool = _class.instanceMethodId(
    r'getABool',
    r'()Z',
  );

  static final _getABool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final boolean getABool()`
  bool getABool() {
    return _getABool(reference.pointer, _id_getABool as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getAnInt = _class.instanceMethodId(
    r'getAnInt',
    r'()J',
  );

  static final _getAnInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long getAnInt()`
  int getAnInt() {
    return _getAnInt(reference.pointer, _id_getAnInt as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getAnInt64 = _class.instanceMethodId(
    r'getAnInt64',
    r'()J',
  );

  static final _getAnInt64 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long getAnInt64()`
  int getAnInt64() {
    return _getAnInt64(reference.pointer, _id_getAnInt64 as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getADouble = _class.instanceMethodId(
    r'getADouble',
    r'()D',
  );

  static final _getADouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double getADouble()`
  double getADouble() {
    return _getADouble(reference.pointer, _id_getADouble as jni$_.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getAByteArray = _class.instanceMethodId(
    r'getAByteArray',
    r'()[B',
  );

  static final _getAByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] getAByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray getAByteArray() {
    return _getAByteArray(
            reference.pointer, _id_getAByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_getA4ByteArray = _class.instanceMethodId(
    r'getA4ByteArray',
    r'()[I',
  );

  static final _getA4ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] getA4ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray getA4ByteArray() {
    return _getA4ByteArray(
            reference.pointer, _id_getA4ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray>(const jni$_.JIntArrayType());
  }

  static final _id_getA8ByteArray = _class.instanceMethodId(
    r'getA8ByteArray',
    r'()[J',
  );

  static final _getA8ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] getA8ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray getA8ByteArray() {
    return _getA8ByteArray(
            reference.pointer, _id_getA8ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray>(const jni$_.JLongArrayType());
  }

  static final _id_getAFloatArray = _class.instanceMethodId(
    r'getAFloatArray',
    r'()[D',
  );

  static final _getAFloatArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] getAFloatArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray getAFloatArray() {
    return _getAFloatArray(
            reference.pointer, _id_getAFloatArray as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray>(const jni$_.JDoubleArrayType());
  }

  static final _id_getAnEnum = _class.instanceMethodId(
    r'getAnEnum',
    r'()LJniAnEnum;',
  );

  static final _getAnEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnEnum getAnEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum getAnEnum() {
    return _getAnEnum(reference.pointer, _id_getAnEnum as jni$_.JMethodIDPtr)
        .object<JniAnEnum>(const $JniAnEnum$Type());
  }

  static final _id_getAnotherEnum = _class.instanceMethodId(
    r'getAnotherEnum',
    r'()LJniAnotherEnum;',
  );

  static final _getAnotherEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnotherEnum getAnotherEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum getAnotherEnum() {
    return _getAnotherEnum(
            reference.pointer, _id_getAnotherEnum as jni$_.JMethodIDPtr)
        .object<JniAnotherEnum>(const $JniAnotherEnum$Type());
  }

  static final _id_getAString = _class.instanceMethodId(
    r'getAString',
    r'()Ljava/lang/String;',
  );

  static final _getAString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getAString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getAString() {
    return _getAString(reference.pointer, _id_getAString as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getAnObject = _class.instanceMethodId(
    r'getAnObject',
    r'()Ljava/lang/Object;',
  );

  static final _getAnObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object getAnObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getAnObject() {
    return _getAnObject(
            reference.pointer, _id_getAnObject as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getList() {
    return _getList(reference.pointer, _id_getList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString> getStringList() {
    return _getStringList(
            reference.pointer, _id_getStringList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString>>(
            const jni$_.JListType<jni$_.JString>(jni$_.JStringType()));
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong> getIntList() {
    return _getIntList(reference.pointer, _id_getIntList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong>>(
            const jni$_.JListType<jni$_.JLong>(jni$_.JLongType()));
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble> getDoubleList() {
    return _getDoubleList(
            reference.pointer, _id_getDoubleList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble>>(
            const jni$_.JListType<jni$_.JDouble>(jni$_.JDoubleType()));
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean> getBoolList() {
    return _getBoolList(
            reference.pointer, _id_getBoolList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean>>(
            const jni$_.JListType<jni$_.JBoolean>(jni$_.JBooleanType()));
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum> getEnumList() {
    return _getEnumList(
            reference.pointer, _id_getEnumList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAnEnum>>(
            const jni$_.JListType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_getObjectList = _class.instanceMethodId(
    r'getObjectList',
    r'()Ljava/util/List;',
  );

  static final _getObjectList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getObjectList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject> getObjectList() {
    return _getObjectList(
            reference.pointer, _id_getObjectList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject>>(
            const jni$_.JListType<jni$_.JObject>(jni$_.JObjectType()));
  }

  static final _id_getListList = _class.instanceMethodId(
    r'getListList',
    r'()Ljava/util/List;',
  );

  static final _getListList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> getListList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>> getListList() {
    return _getListList(
            reference.pointer, _id_getListList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>>>(
            const jni$_.JListType<jni$_.JList<jni$_.JObject?>>(
                jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType())));
  }

  static final _id_getMapList = _class.instanceMethodId(
    r'getMapList',
    r'()Ljava/util/List;',
  );

  static final _getMapList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> getMapList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> getMapList() {
    return _getMapList(reference.pointer, _id_getMapList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(
            const jni$_.JListType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
                jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?> getMap() {
    return _getMap(reference.pointer, _id_getMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> getStringMap() {
    return _getStringMap(
            reference.pointer, _id_getStringMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_getIntMap = _class.instanceMethodId(
    r'getIntMap',
    r'()Ljava/util/Map;',
  );

  static final _getIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> getIntMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> getIntMap() {
    return _getIntMap(reference.pointer, _id_getIntMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_getEnumMap = _class.instanceMethodId(
    r'getEnumMap',
    r'()Ljava/util/Map;',
  );

  static final _getEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<JniAnEnum, JniAnEnum> getEnumMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum> getEnumMap() {
    return _getEnumMap(reference.pointer, _id_getEnumMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>>(
            const jni$_.JMapType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_getObjectMap = _class.instanceMethodId(
    r'getObjectMap',
    r'()Ljava/util/Map;',
  );

  static final _getObjectMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getObjectMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject> getObjectMap() {
    return _getObjectMap(
            reference.pointer, _id_getObjectMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject>>(
            const jni$_.JMapType<jni$_.JObject, jni$_.JObject>(
                jni$_.JObjectType(), jni$_.JObjectType()));
  }

  static final _id_getListMap = _class.instanceMethodId(
    r'getListMap',
    r'()Ljava/util/Map;',
  );

  static final _getListMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> getListMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> getListMap() {
    return _getListMap(reference.pointer, _id_getListMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JList<jni$_.JObject?>>(
                jni$_.JLongType(),
                jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType())));
  }

  static final _id_getMapMap = _class.instanceMethodId(
    r'getMapMap',
    r'()Ljava/util/Map;',
  );

  static final _getMapMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> getMapMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>
      getMapMap() {
    return _getMapMap(reference.pointer, _id_getMapMap as jni$_.JMethodIDPtr)
        .object<
            jni$_.JMap<jni$_.JLong,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(const jni$_
            .JMapType<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            jni$_.JLongType(),
            jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Z',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final boolean component1()`
  bool component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()J',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long component2()`
  int component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()J',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long component3()`
  int component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()D',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double component4()`
  double component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()[B',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] component5()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()[I',
  );

  static final _component6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] component6()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray component6() {
    return _component6(reference.pointer, _id_component6 as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray>(const jni$_.JIntArrayType());
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()[J',
  );

  static final _component7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] component7()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray component7() {
    return _component7(reference.pointer, _id_component7 as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray>(const jni$_.JLongArrayType());
  }

  static final _id_component8 = _class.instanceMethodId(
    r'component8',
    r'()[D',
  );

  static final _component8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] component8()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray component8() {
    return _component8(reference.pointer, _id_component8 as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray>(const jni$_.JDoubleArrayType());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()LJniAnEnum;',
  );

  static final _component9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnEnum component9()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum component9() {
    return _component9(reference.pointer, _id_component9 as jni$_.JMethodIDPtr)
        .object<JniAnEnum>(const $JniAnEnum$Type());
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()LJniAnotherEnum;',
  );

  static final _component10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnotherEnum component10()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum component10() {
    return _component10(
            reference.pointer, _id_component10 as jni$_.JMethodIDPtr)
        .object<JniAnotherEnum>(const $JniAnotherEnum$Type());
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/lang/String;',
  );

  static final _component11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component11()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString component11() {
    return _component11(
            reference.pointer, _id_component11 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/lang/Object;',
  );

  static final _component12 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object component12()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject component12() {
    return _component12(
            reference.pointer, _id_component12 as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()Ljava/util/List;',
  );

  static final _component13 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component13()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> component13() {
    return _component13(
            reference.pointer, _id_component13 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> component14()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString> component14() {
    return _component14(
            reference.pointer, _id_component14 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString>>(
            const jni$_.JListType<jni$_.JString>(jni$_.JStringType()));
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/List;',
  );

  static final _component15 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> component15()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong> component15() {
    return _component15(
            reference.pointer, _id_component15 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong>>(
            const jni$_.JListType<jni$_.JLong>(jni$_.JLongType()));
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/List;',
  );

  static final _component16 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> component16()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble> component16() {
    return _component16(
            reference.pointer, _id_component16 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble>>(
            const jni$_.JListType<jni$_.JDouble>(jni$_.JDoubleType()));
  }

  static final _id_component17 = _class.instanceMethodId(
    r'component17',
    r'()Ljava/util/List;',
  );

  static final _component17 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> component17()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean> component17() {
    return _component17(
            reference.pointer, _id_component17 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean>>(
            const jni$_.JListType<jni$_.JBoolean>(jni$_.JBooleanType()));
  }

  static final _id_component18 = _class.instanceMethodId(
    r'component18',
    r'()Ljava/util/List;',
  );

  static final _component18 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAnEnum> component18()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum> component18() {
    return _component18(
            reference.pointer, _id_component18 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAnEnum>>(
            const jni$_.JListType<JniAnEnum>($JniAnEnum$Type()));
  }

  static final _id_component19 = _class.instanceMethodId(
    r'component19',
    r'()Ljava/util/List;',
  );

  static final _component19 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component19()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject> component19() {
    return _component19(
            reference.pointer, _id_component19 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject>>(
            const jni$_.JListType<jni$_.JObject>(jni$_.JObjectType()));
  }

  static final _id_component20 = _class.instanceMethodId(
    r'component20',
    r'()Ljava/util/List;',
  );

  static final _component20 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> component20()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>> component20() {
    return _component20(
            reference.pointer, _id_component20 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>>>(
            const jni$_.JListType<jni$_.JList<jni$_.JObject?>>(
                jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType())));
  }

  static final _id_component21 = _class.instanceMethodId(
    r'component21',
    r'()Ljava/util/List;',
  );

  static final _component21 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> component21()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> component21() {
    return _component21(
            reference.pointer, _id_component21 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(
            const jni$_.JListType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
                jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_component22 = _class.instanceMethodId(
    r'component22',
    r'()Ljava/util/Map;',
  );

  static final _component22 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component22()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?> component22() {
    return _component22(
            reference.pointer, _id_component22 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_component23 = _class.instanceMethodId(
    r'component23',
    r'()Ljava/util/Map;',
  );

  static final _component23 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> component23()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> component23() {
    return _component23(
            reference.pointer, _id_component23 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_component24 = _class.instanceMethodId(
    r'component24',
    r'()Ljava/util/Map;',
  );

  static final _component24 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> component24()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> component24() {
    return _component24(
            reference.pointer, _id_component24 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_component25 = _class.instanceMethodId(
    r'component25',
    r'()Ljava/util/Map;',
  );

  static final _component25 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<JniAnEnum, JniAnEnum> component25()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum, JniAnEnum> component25() {
    return _component25(
            reference.pointer, _id_component25 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<JniAnEnum, JniAnEnum>>(
            const jni$_.JMapType<JniAnEnum, JniAnEnum>(
                $JniAnEnum$Type(), $JniAnEnum$Type()));
  }

  static final _id_component26 = _class.instanceMethodId(
    r'component26',
    r'()Ljava/util/Map;',
  );

  static final _component26 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component26()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject> component26() {
    return _component26(
            reference.pointer, _id_component26 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject>>(
            const jni$_.JMapType<jni$_.JObject, jni$_.JObject>(
                jni$_.JObjectType(), jni$_.JObjectType()));
  }

  static final _id_component27 = _class.instanceMethodId(
    r'component27',
    r'()Ljava/util/Map;',
  );

  static final _component27 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> component27()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> component27() {
    return _component27(
            reference.pointer, _id_component27 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JList<jni$_.JObject?>>(
                jni$_.JLongType(),
                jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType())));
  }

  static final _id_component28 = _class.instanceMethodId(
    r'component28',
    r'()Ljava/util/Map;',
  );

  static final _component28 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> component28()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>
      component28() {
    return _component28(
            reference.pointer, _id_component28 as jni$_.JMethodIDPtr)
        .object<
            jni$_.JMap<jni$_.JLong,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(const jni$_
            .JMapType<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            jni$_.JLongType(),
            jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(ZJJD[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)LJniAllTypes;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllTypes copy(boolean z, long j, long j1, double d, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends JniAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<JniAnEnum, ? extends JniAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes copy(
    bool z,
    int j,
    int j1,
    double d,
    jni$_.JByteArray bs,
    jni$_.JIntArray is$,
    jni$_.JLongArray js,
    jni$_.JDoubleArray ds,
    JniAnEnum jniAnEnum,
    JniAnotherEnum jniAnotherEnum,
    jni$_.JString string,
    jni$_.JObject object,
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JList<jni$_.JString> list1,
    jni$_.JList<jni$_.JLong> list2,
    jni$_.JList<jni$_.JDouble> list3,
    jni$_.JList<jni$_.JBoolean> list4,
    jni$_.JList<JniAnEnum> list5,
    jni$_.JList<jni$_.JObject> list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>> list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?> map,
    jni$_.JMap<jni$_.JString, jni$_.JString> map1,
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map2,
    jni$_.JMap<JniAnEnum, JniAnEnum> map3,
    jni$_.JMap<jni$_.JObject, jni$_.JObject> map4,
    jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> map5,
    jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> map6,
  ) {
    final _$bs = bs.reference;
    final _$is$ = is$.reference;
    final _$js = js.reference;
    final _$ds = ds.reference;
    final _$jniAnEnum = jniAnEnum.reference;
    final _$jniAnotherEnum = jniAnotherEnum.reference;
    final _$string = string.reference;
    final _$object = object.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$list2 = list2.reference;
    final _$list3 = list3.reference;
    final _$list4 = list4.reference;
    final _$list5 = list5.reference;
    final _$list6 = list6.reference;
    final _$list7 = list7.reference;
    final _$list8 = list8.reference;
    final _$map = map.reference;
    final _$map1 = map1.reference;
    final _$map2 = map2.reference;
    final _$map3 = map3.reference;
    final _$map4 = map4.reference;
    final _$map5 = map5.reference;
    final _$map6 = map6.reference;
    return _copy(
            reference.pointer,
            _id_copy as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            j,
            j1,
            d,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer)
        .object<JniAllTypes>(const $JniAllTypes$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $JniAllTypes$NullableType extends jni$_.JObjType<JniAllTypes?> {
  @jni$_.internal
  const $JniAllTypes$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllTypes;';

  @jni$_.internal
  @core$_.override
  JniAllTypes? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : JniAllTypes.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllTypes?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllTypes$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllTypes$NullableType) &&
        other is $JniAllTypes$NullableType;
  }
}

final class $JniAllTypes$Type extends jni$_.JObjType<JniAllTypes> {
  @jni$_.internal
  const $JniAllTypes$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllTypes;';

  @jni$_.internal
  @core$_.override
  JniAllTypes fromReference(jni$_.JReference reference) =>
      JniAllTypes.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllTypes?> get nullableType =>
      const $JniAllTypes$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllTypes$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllTypes$Type) &&
        other is $JniAllTypes$Type;
  }
}

/// from: `JniAllNullableTypes$Companion`
class JniAllNullableTypes$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllNullableTypes$Companion> $type;

  @jni$_.internal
  JniAllNullableTypes$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAllNullableTypes$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAllNullableTypes$Companion$NullableType();
  static const type = $JniAllNullableTypes$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LJniAllNullableTypes;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllNullableTypes fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypes$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllNullableTypes$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniAllNullableTypes$Companion$NullableType
    extends jni$_.JObjType<JniAllNullableTypes$Companion?> {
  @jni$_.internal
  const $JniAllNullableTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypes$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypes$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllNullableTypes$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypes$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllNullableTypes$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllNullableTypes$Companion$NullableType) &&
        other is $JniAllNullableTypes$Companion$NullableType;
  }
}

final class $JniAllNullableTypes$Companion$Type
    extends jni$_.JObjType<JniAllNullableTypes$Companion> {
  @jni$_.internal
  const $JniAllNullableTypes$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypes$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypes$Companion fromReference(jni$_.JReference reference) =>
      JniAllNullableTypes$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypes$Companion?> get nullableType =>
      const $JniAllNullableTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllNullableTypes$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllNullableTypes$Companion$Type) &&
        other is $JniAllNullableTypes$Companion$Type;
  }
}

/// from: `JniAllNullableTypes`
class JniAllNullableTypes extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllNullableTypes> $type;

  @jni$_.internal
  JniAllNullableTypes.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAllNullableTypes');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAllNullableTypes$NullableType();
  static const type = $JniAllNullableTypes$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniAllNullableTypes$Companion;',
  );

  /// from: `static public final JniAllNullableTypes$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAllNullableTypes$Companion get Companion =>
      _id_Companion.get(_class, const $JniAllNullableTypes$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;LJniAllNullableTypes;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, JniAllNullableTypes jniAllNullableTypes, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends JniAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.List<JniAllNullableTypes> list9, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<JniAnEnum, ? extends JniAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6, java.util.Map<java.lang.Long, JniAllNullableTypes> map7)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    JniAnEnum? jniAnEnum,
    JniAnotherEnum? jniAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    JniAllNullableTypes? jniAllNullableTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<JniAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JList<JniAllNullableTypes?>? list9,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map7,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$list9 = list9?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$map7 = map7?.reference ?? jni$_.jNullReference;
    return JniAllNullableTypes.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$jniAllNullableTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$list9.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer,
            _$map7.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;LJniAllNullableTypes;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, JniAllNullableTypes jniAllNullableTypes, java.util.List list, java.util.List list1, java.util.List list2, java.util.List list3, java.util.List list4, java.util.List list5, java.util.List list6, java.util.List list7, java.util.List list8, java.util.List list9, java.util.Map map, java.util.Map map1, java.util.Map map2, java.util.Map map3, java.util.Map map4, java.util.Map map5, java.util.Map map6, java.util.Map map7, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypes.new$1(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    JniAnEnum? jniAnEnum,
    JniAnotherEnum? jniAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    JniAllNullableTypes? jniAllNullableTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    jni$_.JList<jni$_.JObject?>? list2,
    jni$_.JList<jni$_.JObject?>? list3,
    jni$_.JList<jni$_.JObject?>? list4,
    jni$_.JList<jni$_.JObject?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JObject?>? list7,
    jni$_.JList<jni$_.JObject?>? list8,
    jni$_.JList<jni$_.JObject?>? list9,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map1,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map2,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map5,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map6,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map7,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$list9 = list9?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$map7 = map7?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllNullableTypes.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$jniAllNullableTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$list9.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer,
            _$map7.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getANullableBool = _class.instanceMethodId(
    r'getANullableBool',
    r'()Ljava/lang/Boolean;',
  );

  static final _getANullableBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Boolean getANullableBool()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? getANullableBool() {
    return _getANullableBool(
            reference.pointer, _id_getANullableBool as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_getANullableInt = _class.instanceMethodId(
    r'getANullableInt',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long getANullableInt()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt() {
    return _getANullableInt(
            reference.pointer, _id_getANullableInt as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_getANullableInt64 = _class.instanceMethodId(
    r'getANullableInt64',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt64 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long getANullableInt64()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt64() {
    return _getANullableInt64(
            reference.pointer, _id_getANullableInt64 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_getANullableDouble = _class.instanceMethodId(
    r'getANullableDouble',
    r'()Ljava/lang/Double;',
  );

  static final _getANullableDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Double getANullableDouble()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getANullableDouble() {
    return _getANullableDouble(
            reference.pointer, _id_getANullableDouble as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_getANullableByteArray = _class.instanceMethodId(
    r'getANullableByteArray',
    r'()[B',
  );

  static final _getANullableByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] getANullableByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getANullableByteArray() {
    return _getANullableByteArray(
            reference.pointer, _id_getANullableByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_getANullable4ByteArray = _class.instanceMethodId(
    r'getANullable4ByteArray',
    r'()[I',
  );

  static final _getANullable4ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] getANullable4ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? getANullable4ByteArray() {
    return _getANullable4ByteArray(
            reference.pointer, _id_getANullable4ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_getANullable8ByteArray = _class.instanceMethodId(
    r'getANullable8ByteArray',
    r'()[J',
  );

  static final _getANullable8ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] getANullable8ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? getANullable8ByteArray() {
    return _getANullable8ByteArray(
            reference.pointer, _id_getANullable8ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_getANullableFloatArray = _class.instanceMethodId(
    r'getANullableFloatArray',
    r'()[D',
  );

  static final _getANullableFloatArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] getANullableFloatArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? getANullableFloatArray() {
    return _getANullableFloatArray(
            reference.pointer, _id_getANullableFloatArray as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_getANullableEnum = _class.instanceMethodId(
    r'getANullableEnum',
    r'()LJniAnEnum;',
  );

  static final _getANullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnEnum getANullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? getANullableEnum() {
    return _getANullableEnum(
            reference.pointer, _id_getANullableEnum as jni$_.JMethodIDPtr)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_getAnotherNullableEnum = _class.instanceMethodId(
    r'getAnotherNullableEnum',
    r'()LJniAnotherEnum;',
  );

  static final _getAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnotherEnum getAnotherNullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? getAnotherNullableEnum() {
    return _getAnotherNullableEnum(
            reference.pointer, _id_getAnotherNullableEnum as jni$_.JMethodIDPtr)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_getANullableString = _class.instanceMethodId(
    r'getANullableString',
    r'()Ljava/lang/String;',
  );

  static final _getANullableString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getANullableString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getANullableString() {
    return _getANullableString(
            reference.pointer, _id_getANullableString as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getANullableObject = _class.instanceMethodId(
    r'getANullableObject',
    r'()Ljava/lang/Object;',
  );

  static final _getANullableObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object getANullableObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getANullableObject() {
    return _getANullableObject(
            reference.pointer, _id_getANullableObject as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getAllNullableTypes = _class.instanceMethodId(
    r'getAllNullableTypes',
    r'()LJniAllNullableTypes;',
  );

  static final _getAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllNullableTypes getAllNullableTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes? getAllNullableTypes() {
    return _getAllNullableTypes(
            reference.pointer, _id_getAllNullableTypes as jni$_.JMethodIDPtr)
        .object<JniAllNullableTypes?>(
            const $JniAllNullableTypes$NullableType());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getList() {
    return _getList(reference.pointer, _id_getList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getStringList() {
    return _getStringList(
            reference.pointer, _id_getStringList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? getIntList() {
    return _getIntList(reference.pointer, _id_getIntList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong?>?>(
            const jni$_.JListNullableType<jni$_.JLong?>(
                jni$_.JLongNullableType()));
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? getDoubleList() {
    return _getDoubleList(
            reference.pointer, _id_getDoubleList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble?>?>(
            const jni$_.JListNullableType<jni$_.JDouble?>(
                jni$_.JDoubleNullableType()));
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? getBoolList() {
    return _getBoolList(
            reference.pointer, _id_getBoolList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean?>?>(
            const jni$_.JListNullableType<jni$_.JBoolean?>(
                jni$_.JBooleanNullableType()));
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? getEnumList() {
    return _getEnumList(
            reference.pointer, _id_getEnumList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_getObjectList = _class.instanceMethodId(
    r'getObjectList',
    r'()Ljava/util/List;',
  );

  static final _getObjectList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getObjectList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getObjectList() {
    return _getObjectList(
            reference.pointer, _id_getObjectList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getListList = _class.instanceMethodId(
    r'getListList',
    r'()Ljava/util/List;',
  );

  static final _getListList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> getListList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? getListList() {
    return _getListList(
            reference.pointer, _id_getListList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_.JListNullableType<jni$_.JList<jni$_.JObject?>?>(
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_getMapList = _class.instanceMethodId(
    r'getMapList',
    r'()Ljava/util/List;',
  );

  static final _getMapList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> getMapList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? getMapList() {
    return _getMapList(reference.pointer, _id_getMapList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_
                .JListNullableType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_getRecursiveClassList = _class.instanceMethodId(
    r'getRecursiveClassList',
    r'()Ljava/util/List;',
  );

  static final _getRecursiveClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAllNullableTypes> getRecursiveClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?>? getRecursiveClassList() {
    return _getRecursiveClassList(
            reference.pointer, _id_getRecursiveClassList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAllNullableTypes?>?>(
            const jni$_.JListNullableType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? getMap() {
    return _getMap(reference.pointer, _id_getMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? getStringMap() {
    return _getStringMap(
            reference.pointer, _id_getStringMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_getIntMap = _class.instanceMethodId(
    r'getIntMap',
    r'()Ljava/util/Map;',
  );

  static final _getIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> getIntMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? getIntMap() {
    return _getIntMap(reference.pointer, _id_getIntMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_getEnumMap = _class.instanceMethodId(
    r'getEnumMap',
    r'()Ljava/util/Map;',
  );

  static final _getEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<JniAnEnum, JniAnEnum> getEnumMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? getEnumMap() {
    return _getEnumMap(reference.pointer, _id_getEnumMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_getObjectMap = _class.instanceMethodId(
    r'getObjectMap',
    r'()Ljava/util/Map;',
  );

  static final _getObjectMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getObjectMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? getObjectMap() {
    return _getObjectMap(
            reference.pointer, _id_getObjectMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_getListMap = _class.instanceMethodId(
    r'getListMap',
    r'()Ljava/util/Map;',
  );

  static final _getListMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> getListMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? getListMap() {
    return _getListMap(reference.pointer, _id_getListMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_
                .JMapNullableType<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_getMapMap = _class.instanceMethodId(
    r'getMapMap',
    r'()Ljava/util/Map;',
  );

  static final _getMapMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> getMapMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
      getMapMap() {
    return _getMapMap(reference.pointer, _id_getMapMap as jni$_.JMethodIDPtr)
        .object<
                jni$_.JMap<jni$_.JLong?,
                    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?,
                    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_getRecursiveClassMap = _class.instanceMethodId(
    r'getRecursiveClassMap',
    r'()Ljava/util/Map;',
  );

  static final _getRecursiveClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, JniAllNullableTypes> getRecursiveClassMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? getRecursiveClassMap() {
    return _getRecursiveClassMap(
            reference.pointer, _id_getRecursiveClassMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/Boolean;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Boolean component1()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()Ljava/lang/Long;',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long component2()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()Ljava/lang/Long;',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long component3()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/lang/Double;',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Double component4()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()[B',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] component5()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()[I',
  );

  static final _component6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] component6()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? component6() {
    return _component6(reference.pointer, _id_component6 as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()[J',
  );

  static final _component7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] component7()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? component7() {
    return _component7(reference.pointer, _id_component7 as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_component8 = _class.instanceMethodId(
    r'component8',
    r'()[D',
  );

  static final _component8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] component8()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? component8() {
    return _component8(reference.pointer, _id_component8 as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()LJniAnEnum;',
  );

  static final _component9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnEnum component9()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? component9() {
    return _component9(reference.pointer, _id_component9 as jni$_.JMethodIDPtr)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()LJniAnotherEnum;',
  );

  static final _component10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnotherEnum component10()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? component10() {
    return _component10(
            reference.pointer, _id_component10 as jni$_.JMethodIDPtr)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/lang/String;',
  );

  static final _component11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component11()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? component11() {
    return _component11(
            reference.pointer, _id_component11 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/lang/Object;',
  );

  static final _component12 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object component12()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? component12() {
    return _component12(
            reference.pointer, _id_component12 as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()LJniAllNullableTypes;',
  );

  static final _component13 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllNullableTypes component13()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes? component13() {
    return _component13(
            reference.pointer, _id_component13 as jni$_.JMethodIDPtr)
        .object<JniAllNullableTypes?>(
            const $JniAllNullableTypes$NullableType());
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component14()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component14() {
    return _component14(
            reference.pointer, _id_component14 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/List;',
  );

  static final _component15 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> component15()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? component15() {
    return _component15(
            reference.pointer, _id_component15 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/List;',
  );

  static final _component16 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> component16()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? component16() {
    return _component16(
            reference.pointer, _id_component16 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong?>?>(
            const jni$_.JListNullableType<jni$_.JLong?>(
                jni$_.JLongNullableType()));
  }

  static final _id_component17 = _class.instanceMethodId(
    r'component17',
    r'()Ljava/util/List;',
  );

  static final _component17 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> component17()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? component17() {
    return _component17(
            reference.pointer, _id_component17 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble?>?>(
            const jni$_.JListNullableType<jni$_.JDouble?>(
                jni$_.JDoubleNullableType()));
  }

  static final _id_component18 = _class.instanceMethodId(
    r'component18',
    r'()Ljava/util/List;',
  );

  static final _component18 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> component18()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? component18() {
    return _component18(
            reference.pointer, _id_component18 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean?>?>(
            const jni$_.JListNullableType<jni$_.JBoolean?>(
                jni$_.JBooleanNullableType()));
  }

  static final _id_component19 = _class.instanceMethodId(
    r'component19',
    r'()Ljava/util/List;',
  );

  static final _component19 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAnEnum> component19()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? component19() {
    return _component19(
            reference.pointer, _id_component19 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_component20 = _class.instanceMethodId(
    r'component20',
    r'()Ljava/util/List;',
  );

  static final _component20 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component20()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component20() {
    return _component20(
            reference.pointer, _id_component20 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_component21 = _class.instanceMethodId(
    r'component21',
    r'()Ljava/util/List;',
  );

  static final _component21 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> component21()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? component21() {
    return _component21(
            reference.pointer, _id_component21 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_.JListNullableType<jni$_.JList<jni$_.JObject?>?>(
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_component22 = _class.instanceMethodId(
    r'component22',
    r'()Ljava/util/List;',
  );

  static final _component22 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> component22()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? component22() {
    return _component22(
            reference.pointer, _id_component22 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_
                .JListNullableType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_component23 = _class.instanceMethodId(
    r'component23',
    r'()Ljava/util/List;',
  );

  static final _component23 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAllNullableTypes> component23()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypes?>? component23() {
    return _component23(
            reference.pointer, _id_component23 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAllNullableTypes?>?>(
            const jni$_.JListNullableType<JniAllNullableTypes?>(
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_component24 = _class.instanceMethodId(
    r'component24',
    r'()Ljava/util/Map;',
  );

  static final _component24 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component24()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? component24() {
    return _component24(
            reference.pointer, _id_component24 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_component25 = _class.instanceMethodId(
    r'component25',
    r'()Ljava/util/Map;',
  );

  static final _component25 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> component25()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? component25() {
    return _component25(
            reference.pointer, _id_component25 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_component26 = _class.instanceMethodId(
    r'component26',
    r'()Ljava/util/Map;',
  );

  static final _component26 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> component26()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? component26() {
    return _component26(
            reference.pointer, _id_component26 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_component27 = _class.instanceMethodId(
    r'component27',
    r'()Ljava/util/Map;',
  );

  static final _component27 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<JniAnEnum, JniAnEnum> component27()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? component27() {
    return _component27(
            reference.pointer, _id_component27 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_component28 = _class.instanceMethodId(
    r'component28',
    r'()Ljava/util/Map;',
  );

  static final _component28 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component28()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? component28() {
    return _component28(
            reference.pointer, _id_component28 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_component29 = _class.instanceMethodId(
    r'component29',
    r'()Ljava/util/Map;',
  );

  static final _component29 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> component29()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? component29() {
    return _component29(
            reference.pointer, _id_component29 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_
                .JMapNullableType<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_component30 = _class.instanceMethodId(
    r'component30',
    r'()Ljava/util/Map;',
  );

  static final _component30 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> component30()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
      component30() {
    return _component30(reference.pointer, _id_component30 as jni$_.JMethodIDPtr)
        .object<
            jni$_.JMap<jni$_.JLong?,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(const jni$_
            .JMapNullableType<jni$_.JLong?,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            jni$_.JLongNullableType(),
            jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_component31 = _class.instanceMethodId(
    r'component31',
    r'()Ljava/util/Map;',
  );

  static final _component31 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, JniAllNullableTypes> component31()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? component31() {
    return _component31(
            reference.pointer, _id_component31 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, JniAllNullableTypes?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypes$NullableType()));
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;LJniAllNullableTypes;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)LJniAllNullableTypes;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllNullableTypes copy(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, JniAllNullableTypes jniAllNullableTypes, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends JniAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.List<JniAllNullableTypes> list9, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<JniAnEnum, ? extends JniAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6, java.util.Map<java.lang.Long, JniAllNullableTypes> map7)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes copy(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    JniAnEnum? jniAnEnum,
    JniAnotherEnum? jniAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    JniAllNullableTypes? jniAllNullableTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<JniAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JList<JniAllNullableTypes?>? list9,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypes?>? map7,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$list9 = list9?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$map7 = map7?.reference ?? jni$_.jNullReference;
    return _copy(
            reference.pointer,
            _id_copy as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$jniAllNullableTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$list9.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer,
            _$map7.pointer)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypes.new$2() {
    return JniAllNullableTypes.fromReference(
        _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $JniAllNullableTypes$NullableType
    extends jni$_.JObjType<JniAllNullableTypes?> {
  @jni$_.internal
  const $JniAllNullableTypes$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypes;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypes? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllNullableTypes.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypes?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllNullableTypes$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllNullableTypes$NullableType) &&
        other is $JniAllNullableTypes$NullableType;
  }
}

final class $JniAllNullableTypes$Type
    extends jni$_.JObjType<JniAllNullableTypes> {
  @jni$_.internal
  const $JniAllNullableTypes$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypes;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypes fromReference(jni$_.JReference reference) =>
      JniAllNullableTypes.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypes?> get nullableType =>
      const $JniAllNullableTypes$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllNullableTypes$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllNullableTypes$Type) &&
        other is $JniAllNullableTypes$Type;
  }
}

/// from: `JniAllNullableTypesWithoutRecursion$Companion`
class JniAllNullableTypesWithoutRecursion$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllNullableTypesWithoutRecursion$Companion> $type;

  @jni$_.internal
  JniAllNullableTypesWithoutRecursion$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'JniAllNullableTypesWithoutRecursion$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $JniAllNullableTypesWithoutRecursion$Companion$NullableType();
  static const type = $JniAllNullableTypesWithoutRecursion$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllNullableTypesWithoutRecursion fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<JniAllNullableTypesWithoutRecursion>(
            const $JniAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypesWithoutRecursion$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllNullableTypesWithoutRecursion$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniAllNullableTypesWithoutRecursion$Companion$NullableType
    extends jni$_.JObjType<JniAllNullableTypesWithoutRecursion$Companion?> {
  @jni$_.internal
  const $JniAllNullableTypesWithoutRecursion$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypesWithoutRecursion$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypesWithoutRecursion$Companion? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllNullableTypesWithoutRecursion$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypesWithoutRecursion$Companion?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($JniAllNullableTypesWithoutRecursion$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JniAllNullableTypesWithoutRecursion$Companion$NullableType) &&
        other is $JniAllNullableTypesWithoutRecursion$Companion$NullableType;
  }
}

final class $JniAllNullableTypesWithoutRecursion$Companion$Type
    extends jni$_.JObjType<JniAllNullableTypesWithoutRecursion$Companion> {
  @jni$_.internal
  const $JniAllNullableTypesWithoutRecursion$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypesWithoutRecursion$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypesWithoutRecursion$Companion fromReference(
          jni$_.JReference reference) =>
      JniAllNullableTypesWithoutRecursion$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypesWithoutRecursion$Companion?>
      get nullableType =>
          const $JniAllNullableTypesWithoutRecursion$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($JniAllNullableTypesWithoutRecursion$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JniAllNullableTypesWithoutRecursion$Companion$Type) &&
        other is $JniAllNullableTypesWithoutRecursion$Companion$Type;
  }
}

/// from: `JniAllNullableTypesWithoutRecursion`
class JniAllNullableTypesWithoutRecursion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllNullableTypesWithoutRecursion> $type;

  @jni$_.internal
  JniAllNullableTypesWithoutRecursion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'JniAllNullableTypesWithoutRecursion');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $JniAllNullableTypesWithoutRecursion$NullableType();
  static const type = $JniAllNullableTypesWithoutRecursion$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniAllNullableTypesWithoutRecursion$Companion;',
  );

  /// from: `static public final JniAllNullableTypesWithoutRecursion$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAllNullableTypesWithoutRecursion$Companion get Companion =>
      _id_Companion.get(
          _class, const $JniAllNullableTypesWithoutRecursion$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends JniAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<JniAnEnum, ? extends JniAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    JniAnEnum? jniAnEnum,
    JniAnotherEnum? jniAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<JniAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    return JniAllNullableTypesWithoutRecursion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List list, java.util.List list1, java.util.List list2, java.util.List list3, java.util.List list4, java.util.List list5, java.util.List list6, java.util.List list7, java.util.List list8, java.util.Map map, java.util.Map map1, java.util.Map map2, java.util.Map map3, java.util.Map map4, java.util.Map map5, java.util.Map map6, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypesWithoutRecursion.new$1(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    JniAnEnum? jniAnEnum,
    JniAnotherEnum? jniAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    jni$_.JList<jni$_.JObject?>? list2,
    jni$_.JList<jni$_.JObject?>? list3,
    jni$_.JList<jni$_.JObject?>? list4,
    jni$_.JList<jni$_.JObject?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JObject?>? list7,
    jni$_.JList<jni$_.JObject?>? list8,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map1,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map2,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map5,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map6,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllNullableTypesWithoutRecursion.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getANullableBool = _class.instanceMethodId(
    r'getANullableBool',
    r'()Ljava/lang/Boolean;',
  );

  static final _getANullableBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Boolean getANullableBool()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? getANullableBool() {
    return _getANullableBool(
            reference.pointer, _id_getANullableBool as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_getANullableInt = _class.instanceMethodId(
    r'getANullableInt',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long getANullableInt()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt() {
    return _getANullableInt(
            reference.pointer, _id_getANullableInt as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_getANullableInt64 = _class.instanceMethodId(
    r'getANullableInt64',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt64 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long getANullableInt64()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt64() {
    return _getANullableInt64(
            reference.pointer, _id_getANullableInt64 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_getANullableDouble = _class.instanceMethodId(
    r'getANullableDouble',
    r'()Ljava/lang/Double;',
  );

  static final _getANullableDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Double getANullableDouble()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getANullableDouble() {
    return _getANullableDouble(
            reference.pointer, _id_getANullableDouble as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_getANullableByteArray = _class.instanceMethodId(
    r'getANullableByteArray',
    r'()[B',
  );

  static final _getANullableByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] getANullableByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getANullableByteArray() {
    return _getANullableByteArray(
            reference.pointer, _id_getANullableByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_getANullable4ByteArray = _class.instanceMethodId(
    r'getANullable4ByteArray',
    r'()[I',
  );

  static final _getANullable4ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] getANullable4ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? getANullable4ByteArray() {
    return _getANullable4ByteArray(
            reference.pointer, _id_getANullable4ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_getANullable8ByteArray = _class.instanceMethodId(
    r'getANullable8ByteArray',
    r'()[J',
  );

  static final _getANullable8ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] getANullable8ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? getANullable8ByteArray() {
    return _getANullable8ByteArray(
            reference.pointer, _id_getANullable8ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_getANullableFloatArray = _class.instanceMethodId(
    r'getANullableFloatArray',
    r'()[D',
  );

  static final _getANullableFloatArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] getANullableFloatArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? getANullableFloatArray() {
    return _getANullableFloatArray(
            reference.pointer, _id_getANullableFloatArray as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_getANullableEnum = _class.instanceMethodId(
    r'getANullableEnum',
    r'()LJniAnEnum;',
  );

  static final _getANullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnEnum getANullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? getANullableEnum() {
    return _getANullableEnum(
            reference.pointer, _id_getANullableEnum as jni$_.JMethodIDPtr)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_getAnotherNullableEnum = _class.instanceMethodId(
    r'getAnotherNullableEnum',
    r'()LJniAnotherEnum;',
  );

  static final _getAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnotherEnum getAnotherNullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? getAnotherNullableEnum() {
    return _getAnotherNullableEnum(
            reference.pointer, _id_getAnotherNullableEnum as jni$_.JMethodIDPtr)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_getANullableString = _class.instanceMethodId(
    r'getANullableString',
    r'()Ljava/lang/String;',
  );

  static final _getANullableString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getANullableString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getANullableString() {
    return _getANullableString(
            reference.pointer, _id_getANullableString as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getANullableObject = _class.instanceMethodId(
    r'getANullableObject',
    r'()Ljava/lang/Object;',
  );

  static final _getANullableObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object getANullableObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getANullableObject() {
    return _getANullableObject(
            reference.pointer, _id_getANullableObject as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getList() {
    return _getList(reference.pointer, _id_getList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getStringList() {
    return _getStringList(
            reference.pointer, _id_getStringList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? getIntList() {
    return _getIntList(reference.pointer, _id_getIntList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong?>?>(
            const jni$_.JListNullableType<jni$_.JLong?>(
                jni$_.JLongNullableType()));
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? getDoubleList() {
    return _getDoubleList(
            reference.pointer, _id_getDoubleList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble?>?>(
            const jni$_.JListNullableType<jni$_.JDouble?>(
                jni$_.JDoubleNullableType()));
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? getBoolList() {
    return _getBoolList(
            reference.pointer, _id_getBoolList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean?>?>(
            const jni$_.JListNullableType<jni$_.JBoolean?>(
                jni$_.JBooleanNullableType()));
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? getEnumList() {
    return _getEnumList(
            reference.pointer, _id_getEnumList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_getObjectList = _class.instanceMethodId(
    r'getObjectList',
    r'()Ljava/util/List;',
  );

  static final _getObjectList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getObjectList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getObjectList() {
    return _getObjectList(
            reference.pointer, _id_getObjectList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getListList = _class.instanceMethodId(
    r'getListList',
    r'()Ljava/util/List;',
  );

  static final _getListList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> getListList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? getListList() {
    return _getListList(
            reference.pointer, _id_getListList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_.JListNullableType<jni$_.JList<jni$_.JObject?>?>(
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_getMapList = _class.instanceMethodId(
    r'getMapList',
    r'()Ljava/util/List;',
  );

  static final _getMapList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> getMapList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? getMapList() {
    return _getMapList(reference.pointer, _id_getMapList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_
                .JListNullableType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? getMap() {
    return _getMap(reference.pointer, _id_getMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? getStringMap() {
    return _getStringMap(
            reference.pointer, _id_getStringMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_getIntMap = _class.instanceMethodId(
    r'getIntMap',
    r'()Ljava/util/Map;',
  );

  static final _getIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> getIntMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? getIntMap() {
    return _getIntMap(reference.pointer, _id_getIntMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_getEnumMap = _class.instanceMethodId(
    r'getEnumMap',
    r'()Ljava/util/Map;',
  );

  static final _getEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<JniAnEnum, JniAnEnum> getEnumMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? getEnumMap() {
    return _getEnumMap(reference.pointer, _id_getEnumMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_getObjectMap = _class.instanceMethodId(
    r'getObjectMap',
    r'()Ljava/util/Map;',
  );

  static final _getObjectMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getObjectMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? getObjectMap() {
    return _getObjectMap(
            reference.pointer, _id_getObjectMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_getListMap = _class.instanceMethodId(
    r'getListMap',
    r'()Ljava/util/Map;',
  );

  static final _getListMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> getListMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? getListMap() {
    return _getListMap(reference.pointer, _id_getListMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_
                .JMapNullableType<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_getMapMap = _class.instanceMethodId(
    r'getMapMap',
    r'()Ljava/util/Map;',
  );

  static final _getMapMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> getMapMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
      getMapMap() {
    return _getMapMap(reference.pointer, _id_getMapMap as jni$_.JMethodIDPtr)
        .object<
                jni$_.JMap<jni$_.JLong?,
                    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?,
                    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/Boolean;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Boolean component1()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()Ljava/lang/Long;',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long component2()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()Ljava/lang/Long;',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long component3()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/lang/Double;',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Double component4()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()[B',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] component5()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()[I',
  );

  static final _component6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] component6()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? component6() {
    return _component6(reference.pointer, _id_component6 as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()[J',
  );

  static final _component7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] component7()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? component7() {
    return _component7(reference.pointer, _id_component7 as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_component8 = _class.instanceMethodId(
    r'component8',
    r'()[D',
  );

  static final _component8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] component8()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? component8() {
    return _component8(reference.pointer, _id_component8 as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()LJniAnEnum;',
  );

  static final _component9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnEnum component9()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? component9() {
    return _component9(reference.pointer, _id_component9 as jni$_.JMethodIDPtr)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()LJniAnotherEnum;',
  );

  static final _component10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAnotherEnum component10()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? component10() {
    return _component10(
            reference.pointer, _id_component10 as jni$_.JMethodIDPtr)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/lang/String;',
  );

  static final _component11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component11()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? component11() {
    return _component11(
            reference.pointer, _id_component11 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/lang/Object;',
  );

  static final _component12 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object component12()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? component12() {
    return _component12(
            reference.pointer, _id_component12 as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()Ljava/util/List;',
  );

  static final _component13 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component13()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component13() {
    return _component13(
            reference.pointer, _id_component13 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> component14()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? component14() {
    return _component14(
            reference.pointer, _id_component14 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/List;',
  );

  static final _component15 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> component15()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? component15() {
    return _component15(
            reference.pointer, _id_component15 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong?>?>(
            const jni$_.JListNullableType<jni$_.JLong?>(
                jni$_.JLongNullableType()));
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/List;',
  );

  static final _component16 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> component16()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? component16() {
    return _component16(
            reference.pointer, _id_component16 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble?>?>(
            const jni$_.JListNullableType<jni$_.JDouble?>(
                jni$_.JDoubleNullableType()));
  }

  static final _id_component17 = _class.instanceMethodId(
    r'component17',
    r'()Ljava/util/List;',
  );

  static final _component17 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> component17()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? component17() {
    return _component17(
            reference.pointer, _id_component17 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean?>?>(
            const jni$_.JListNullableType<jni$_.JBoolean?>(
                jni$_.JBooleanNullableType()));
  }

  static final _id_component18 = _class.instanceMethodId(
    r'component18',
    r'()Ljava/util/List;',
  );

  static final _component18 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAnEnum> component18()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAnEnum?>? component18() {
    return _component18(
            reference.pointer, _id_component18 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAnEnum?>?>(
            const jni$_.JListNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_component19 = _class.instanceMethodId(
    r'component19',
    r'()Ljava/util/List;',
  );

  static final _component19 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component19()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component19() {
    return _component19(
            reference.pointer, _id_component19 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_component20 = _class.instanceMethodId(
    r'component20',
    r'()Ljava/util/List;',
  );

  static final _component20 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> component20()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? component20() {
    return _component20(
            reference.pointer, _id_component20 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_.JListNullableType<jni$_.JList<jni$_.JObject?>?>(
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_component21 = _class.instanceMethodId(
    r'component21',
    r'()Ljava/util/List;',
  );

  static final _component21 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> component21()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? component21() {
    return _component21(
            reference.pointer, _id_component21 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_
                .JListNullableType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_component22 = _class.instanceMethodId(
    r'component22',
    r'()Ljava/util/Map;',
  );

  static final _component22 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component22()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? component22() {
    return _component22(
            reference.pointer, _id_component22 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_component23 = _class.instanceMethodId(
    r'component23',
    r'()Ljava/util/Map;',
  );

  static final _component23 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> component23()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? component23() {
    return _component23(
            reference.pointer, _id_component23 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_component24 = _class.instanceMethodId(
    r'component24',
    r'()Ljava/util/Map;',
  );

  static final _component24 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> component24()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? component24() {
    return _component24(
            reference.pointer, _id_component24 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_component25 = _class.instanceMethodId(
    r'component25',
    r'()Ljava/util/Map;',
  );

  static final _component25 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<JniAnEnum, JniAnEnum> component25()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<JniAnEnum?, JniAnEnum?>? component25() {
    return _component25(
            reference.pointer, _id_component25 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<JniAnEnum?, JniAnEnum?>?>(
            const jni$_.JMapNullableType<JniAnEnum?, JniAnEnum?>(
                $JniAnEnum$NullableType(), $JniAnEnum$NullableType()));
  }

  static final _id_component26 = _class.instanceMethodId(
    r'component26',
    r'()Ljava/util/Map;',
  );

  static final _component26 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component26()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? component26() {
    return _component26(
            reference.pointer, _id_component26 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_component27 = _class.instanceMethodId(
    r'component27',
    r'()Ljava/util/Map;',
  );

  static final _component27 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> component27()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? component27() {
    return _component27(
            reference.pointer, _id_component27 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_
                .JMapNullableType<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_component28 = _class.instanceMethodId(
    r'component28',
    r'()Ljava/util/Map;',
  );

  static final _component28 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> component28()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
      component28() {
    return _component28(reference.pointer, _id_component28 as jni$_.JMethodIDPtr)
        .object<
            jni$_.JMap<jni$_.JLong?,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(const jni$_
            .JMapNullableType<jni$_.JLong?,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            jni$_.JLongNullableType(),
            jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLJniAnEnum;LJniAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)LJniAllNullableTypesWithoutRecursion;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllNullableTypesWithoutRecursion copy(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, JniAnEnum jniAnEnum, JniAnotherEnum jniAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends JniAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<JniAnEnum, ? extends JniAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion copy(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    JniAnEnum? jniAnEnum,
    JniAnotherEnum? jniAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<JniAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<JniAnEnum?, JniAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$jniAnEnum = jniAnEnum?.reference ?? jni$_.jNullReference;
    final _$jniAnotherEnum = jniAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    return _copy(
            reference.pointer,
            _id_copy as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$jniAnEnum.pointer,
            _$jniAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer)
        .object<JniAllNullableTypesWithoutRecursion>(
            const $JniAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllNullableTypesWithoutRecursion.new$2() {
    return JniAllNullableTypesWithoutRecursion.fromReference(
        _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $JniAllNullableTypesWithoutRecursion$NullableType
    extends jni$_.JObjType<JniAllNullableTypesWithoutRecursion?> {
  @jni$_.internal
  const $JniAllNullableTypesWithoutRecursion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypesWithoutRecursion;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypesWithoutRecursion? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllNullableTypesWithoutRecursion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypesWithoutRecursion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($JniAllNullableTypesWithoutRecursion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JniAllNullableTypesWithoutRecursion$NullableType) &&
        other is $JniAllNullableTypesWithoutRecursion$NullableType;
  }
}

final class $JniAllNullableTypesWithoutRecursion$Type
    extends jni$_.JObjType<JniAllNullableTypesWithoutRecursion> {
  @jni$_.internal
  const $JniAllNullableTypesWithoutRecursion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllNullableTypesWithoutRecursion;';

  @jni$_.internal
  @core$_.override
  JniAllNullableTypesWithoutRecursion fromReference(
          jni$_.JReference reference) =>
      JniAllNullableTypesWithoutRecursion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllNullableTypesWithoutRecursion?> get nullableType =>
      const $JniAllNullableTypesWithoutRecursion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllNullableTypesWithoutRecursion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllNullableTypesWithoutRecursion$Type) &&
        other is $JniAllNullableTypesWithoutRecursion$Type;
  }
}

/// from: `JniAllClassesWrapper$Companion`
class JniAllClassesWrapper$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllClassesWrapper$Companion> $type;

  @jni$_.internal
  JniAllClassesWrapper$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAllClassesWrapper$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAllClassesWrapper$Companion$NullableType();
  static const type = $JniAllClassesWrapper$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LJniAllClassesWrapper;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllClassesWrapper fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllClassesWrapper fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<JniAllClassesWrapper>(const $JniAllClassesWrapper$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllClassesWrapper$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllClassesWrapper$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniAllClassesWrapper$Companion$NullableType
    extends jni$_.JObjType<JniAllClassesWrapper$Companion?> {
  @jni$_.internal
  const $JniAllClassesWrapper$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllClassesWrapper$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllClassesWrapper$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllClassesWrapper$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllClassesWrapper$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllClassesWrapper$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($JniAllClassesWrapper$Companion$NullableType) &&
        other is $JniAllClassesWrapper$Companion$NullableType;
  }
}

final class $JniAllClassesWrapper$Companion$Type
    extends jni$_.JObjType<JniAllClassesWrapper$Companion> {
  @jni$_.internal
  const $JniAllClassesWrapper$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllClassesWrapper$Companion;';

  @jni$_.internal
  @core$_.override
  JniAllClassesWrapper$Companion fromReference(jni$_.JReference reference) =>
      JniAllClassesWrapper$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllClassesWrapper$Companion?> get nullableType =>
      const $JniAllClassesWrapper$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllClassesWrapper$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllClassesWrapper$Companion$Type) &&
        other is $JniAllClassesWrapper$Companion$Type;
  }
}

/// from: `JniAllClassesWrapper`
class JniAllClassesWrapper extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAllClassesWrapper> $type;

  @jni$_.internal
  JniAllClassesWrapper.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAllClassesWrapper');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAllClassesWrapper$NullableType();
  static const type = $JniAllClassesWrapper$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniAllClassesWrapper$Companion;',
  );

  /// from: `static public final JniAllClassesWrapper$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAllClassesWrapper$Companion get Companion =>
      _id_Companion.get(_class, const $JniAllClassesWrapper$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(LJniAllNullableTypes;LJniAllNullableTypesWithoutRecursion;LJniAllTypes;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(JniAllNullableTypes jniAllNullableTypes, JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion, JniAllTypes jniAllTypes, java.util.List<JniAllTypes> list, java.util.List<JniAllNullableTypesWithoutRecursion> list1, java.util.Map<java.lang.Long, JniAllTypes> map, java.util.Map<java.lang.Long, JniAllNullableTypesWithoutRecursion> map1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllClassesWrapper(
    JniAllNullableTypes jniAllNullableTypes,
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
    JniAllTypes? jniAllTypes,
    jni$_.JList<JniAllTypes?> list,
    jni$_.JList<JniAllNullableTypesWithoutRecursion?>? list1,
    jni$_.JMap<jni$_.JLong?, JniAllTypes?> map,
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypesWithoutRecursion?>? map1,
  ) {
    final _$jniAllNullableTypes = jniAllNullableTypes.reference;
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$jniAllTypes = jniAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list.reference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$map = map.reference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    return JniAllClassesWrapper.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer,
            _$jniAllNullableTypesWithoutRecursion.pointer,
            _$jniAllTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$map.pointer,
            _$map1.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(LJniAllNullableTypes;LJniAllNullableTypesWithoutRecursion;LJniAllTypes;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(JniAllNullableTypes jniAllNullableTypes, JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion, JniAllTypes jniAllTypes, java.util.List list, java.util.List list1, java.util.Map map, java.util.Map map1, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAllClassesWrapper.new$1(
    JniAllNullableTypes? jniAllNullableTypes,
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
    JniAllTypes? jniAllTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map1,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$jniAllNullableTypes =
        jniAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$jniAllTypes = jniAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAllClassesWrapper.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer,
            _$jniAllNullableTypesWithoutRecursion.pointer,
            _$jniAllTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$map.pointer,
            _$map1.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getAllNullableTypes = _class.instanceMethodId(
    r'getAllNullableTypes',
    r'()LJniAllNullableTypes;',
  );

  static final _getAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllNullableTypes getAllNullableTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes getAllNullableTypes() {
    return _getAllNullableTypes(
            reference.pointer, _id_getAllNullableTypes as jni$_.JMethodIDPtr)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_getAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'getAllNullableTypesWithoutRecursion',
    r'()LJniAllNullableTypesWithoutRecursion;',
  );

  static final _getAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public final JniAllNullableTypesWithoutRecursion getAllNullableTypesWithoutRecursion()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion? getAllNullableTypesWithoutRecursion() {
    return _getAllNullableTypesWithoutRecursion(reference.pointer,
            _id_getAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr)
        .object<JniAllNullableTypesWithoutRecursion?>(
            const $JniAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_getAllTypes = _class.instanceMethodId(
    r'getAllTypes',
    r'()LJniAllTypes;',
  );

  static final _getAllTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllTypes getAllTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes? getAllTypes() {
    return _getAllTypes(
            reference.pointer, _id_getAllTypes as jni$_.JMethodIDPtr)
        .object<JniAllTypes?>(const $JniAllTypes$NullableType());
  }

  static final _id_getClassList = _class.instanceMethodId(
    r'getClassList',
    r'()Ljava/util/List;',
  );

  static final _getClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAllTypes> getClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllTypes?> getClassList() {
    return _getClassList(
            reference.pointer, _id_getClassList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAllTypes?>>(
            const jni$_.JListType<JniAllTypes?>($JniAllTypes$NullableType()));
  }

  static final _id_getNullableClassList = _class.instanceMethodId(
    r'getNullableClassList',
    r'()Ljava/util/List;',
  );

  static final _getNullableClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAllNullableTypesWithoutRecursion> getNullableClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypesWithoutRecursion?>? getNullableClassList() {
    return _getNullableClassList(
            reference.pointer, _id_getNullableClassList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAllNullableTypesWithoutRecursion?>?>(
            const jni$_.JListNullableType<JniAllNullableTypesWithoutRecursion?>(
                $JniAllNullableTypesWithoutRecursion$NullableType()));
  }

  static final _id_getClassMap = _class.instanceMethodId(
    r'getClassMap',
    r'()Ljava/util/Map;',
  );

  static final _getClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, JniAllTypes> getClassMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllTypes?> getClassMap() {
    return _getClassMap(
            reference.pointer, _id_getClassMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, JniAllTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, JniAllTypes?>(
                jni$_.JLongNullableType(), $JniAllTypes$NullableType()));
  }

  static final _id_getNullableClassMap = _class.instanceMethodId(
    r'getNullableClassMap',
    r'()Ljava/util/Map;',
  );

  static final _getNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, JniAllNullableTypesWithoutRecursion> getNullableClassMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypesWithoutRecursion?>?
      getNullableClassMap() {
    return _getNullableClassMap(
            reference.pointer, _id_getNullableClassMap as jni$_.JMethodIDPtr)
        .object<
                jni$_
                .JMap<jni$_.JLong?, JniAllNullableTypesWithoutRecursion?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?,
                    JniAllNullableTypesWithoutRecursion?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypesWithoutRecursion$NullableType()));
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()LJniAllNullableTypes;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllNullableTypes component1()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypes component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<JniAllNullableTypes>(const $JniAllNullableTypes$Type());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()LJniAllNullableTypesWithoutRecursion;',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllNullableTypesWithoutRecursion component2()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllNullableTypesWithoutRecursion? component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .object<JniAllNullableTypesWithoutRecursion?>(
            const $JniAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()LJniAllTypes;',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final JniAllTypes component3()`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllTypes? component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .object<JniAllTypes?>(const $JniAllTypes$NullableType());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/util/List;',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAllTypes> component4()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllTypes?> component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAllTypes?>>(
            const jni$_.JListType<JniAllTypes?>($JniAllTypes$NullableType()));
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()Ljava/util/List;',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<JniAllNullableTypesWithoutRecursion> component5()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<JniAllNullableTypesWithoutRecursion?>? component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<JniAllNullableTypesWithoutRecursion?>?>(
            const jni$_.JListNullableType<JniAllNullableTypesWithoutRecursion?>(
                $JniAllNullableTypesWithoutRecursion$NullableType()));
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()Ljava/util/Map;',
  );

  static final _component6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, JniAllTypes> component6()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllTypes?> component6() {
    return _component6(reference.pointer, _id_component6 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, JniAllTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, JniAllTypes?>(
                jni$_.JLongNullableType(), $JniAllTypes$NullableType()));
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()Ljava/util/Map;',
  );

  static final _component7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, JniAllNullableTypesWithoutRecursion> component7()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, JniAllNullableTypesWithoutRecursion?>? component7() {
    return _component7(reference.pointer, _id_component7 as jni$_.JMethodIDPtr)
        .object<
                jni$_
                .JMap<jni$_.JLong?, JniAllNullableTypesWithoutRecursion?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?,
                    JniAllNullableTypesWithoutRecursion?>(
                jni$_.JLongNullableType(),
                $JniAllNullableTypesWithoutRecursion$NullableType()));
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(LJniAllNullableTypes;LJniAllNullableTypesWithoutRecursion;LJniAllTypes;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;)LJniAllClassesWrapper;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final JniAllClassesWrapper copy(JniAllNullableTypes jniAllNullableTypes, JniAllNullableTypesWithoutRecursion jniAllNullableTypesWithoutRecursion, JniAllTypes jniAllTypes, java.util.List<JniAllTypes> list, java.util.List<JniAllNullableTypesWithoutRecursion> list1, java.util.Map<java.lang.Long, JniAllTypes> map, java.util.Map<java.lang.Long, JniAllNullableTypesWithoutRecursion> map1)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAllClassesWrapper copy(
    JniAllNullableTypes jniAllNullableTypes,
    JniAllNullableTypesWithoutRecursion? jniAllNullableTypesWithoutRecursion,
    JniAllTypes? jniAllTypes,
    jni$_.JList<JniAllTypes?> list,
    jni$_.JList<JniAllNullableTypesWithoutRecursion?>? list1,
    jni$_.JMap<jni$_.JLong?, JniAllTypes?> map,
    jni$_.JMap<jni$_.JLong?, JniAllNullableTypesWithoutRecursion?>? map1,
  ) {
    final _$jniAllNullableTypes = jniAllNullableTypes.reference;
    final _$jniAllNullableTypesWithoutRecursion =
        jniAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$jniAllTypes = jniAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list.reference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$map = map.reference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    return _copy(
            reference.pointer,
            _id_copy as jni$_.JMethodIDPtr,
            _$jniAllNullableTypes.pointer,
            _$jniAllNullableTypesWithoutRecursion.pointer,
            _$jniAllTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$map.pointer,
            _$map1.pointer)
        .object<JniAllClassesWrapper>(const $JniAllClassesWrapper$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $JniAllClassesWrapper$NullableType
    extends jni$_.JObjType<JniAllClassesWrapper?> {
  @jni$_.internal
  const $JniAllClassesWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllClassesWrapper;';

  @jni$_.internal
  @core$_.override
  JniAllClassesWrapper? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAllClassesWrapper.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllClassesWrapper?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllClassesWrapper$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllClassesWrapper$NullableType) &&
        other is $JniAllClassesWrapper$NullableType;
  }
}

final class $JniAllClassesWrapper$Type
    extends jni$_.JObjType<JniAllClassesWrapper> {
  @jni$_.internal
  const $JniAllClassesWrapper$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAllClassesWrapper;';

  @jni$_.internal
  @core$_.override
  JniAllClassesWrapper fromReference(jni$_.JReference reference) =>
      JniAllClassesWrapper.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAllClassesWrapper?> get nullableType =>
      const $JniAllClassesWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAllClassesWrapper$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAllClassesWrapper$Type) &&
        other is $JniAllClassesWrapper$Type;
  }
}

/// from: `JniAnEnum$Companion`
class JniAnEnum$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAnEnum$Companion> $type;

  @jni$_.internal
  JniAnEnum$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAnEnum$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAnEnum$Companion$NullableType();
  static const type = $JniAnEnum$Companion$Type();
  static final _id_ofRaw = _class.instanceMethodId(
    r'ofRaw',
    r'(I)LJniAnEnum;',
  );

  static final _ofRaw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final JniAnEnum ofRaw(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnEnum? ofRaw(
    int i,
  ) {
    return _ofRaw(reference.pointer, _id_ofRaw as jni$_.JMethodIDPtr, i)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAnEnum$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAnEnum$Companion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniAnEnum$Companion$NullableType
    extends jni$_.JObjType<JniAnEnum$Companion?> {
  @jni$_.internal
  const $JniAnEnum$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnEnum$Companion;';

  @jni$_.internal
  @core$_.override
  JniAnEnum$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAnEnum$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnEnum$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnEnum$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnEnum$Companion$NullableType) &&
        other is $JniAnEnum$Companion$NullableType;
  }
}

final class $JniAnEnum$Companion$Type
    extends jni$_.JObjType<JniAnEnum$Companion> {
  @jni$_.internal
  const $JniAnEnum$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnEnum$Companion;';

  @jni$_.internal
  @core$_.override
  JniAnEnum$Companion fromReference(jni$_.JReference reference) =>
      JniAnEnum$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnEnum$Companion?> get nullableType =>
      const $JniAnEnum$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnEnum$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnEnum$Companion$Type) &&
        other is $JniAnEnum$Companion$Type;
  }
}

/// from: `JniAnEnum`
class JniAnEnum extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAnEnum> $type;

  @jni$_.internal
  JniAnEnum.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAnEnum');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAnEnum$NullableType();
  static const type = $JniAnEnum$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniAnEnum$Companion;',
  );

  /// from: `static public final JniAnEnum$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum$Companion get Companion =>
      _id_Companion.get(_class, const $JniAnEnum$Companion$Type());

  static final _id_ONE = _class.staticFieldId(
    r'ONE',
    r'LJniAnEnum;',
  );

  /// from: `static public final JniAnEnum ONE`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum get ONE => _id_ONE.get(_class, const $JniAnEnum$Type());

  static final _id_TWO = _class.staticFieldId(
    r'TWO',
    r'LJniAnEnum;',
  );

  /// from: `static public final JniAnEnum TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum get TWO => _id_TWO.get(_class, const $JniAnEnum$Type());

  static final _id_THREE = _class.staticFieldId(
    r'THREE',
    r'LJniAnEnum;',
  );

  /// from: `static public final JniAnEnum THREE`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum get THREE => _id_THREE.get(_class, const $JniAnEnum$Type());

  static final _id_FORTY_TWO = _class.staticFieldId(
    r'FORTY_TWO',
    r'LJniAnEnum;',
  );

  /// from: `static public final JniAnEnum FORTY_TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum get FORTY_TWO =>
      _id_FORTY_TWO.get(_class, const $JniAnEnum$Type());

  static final _id_FOUR_HUNDRED_TWENTY_TWO = _class.staticFieldId(
    r'FOUR_HUNDRED_TWENTY_TWO',
    r'LJniAnEnum;',
  );

  /// from: `static public final JniAnEnum FOUR_HUNDRED_TWENTY_TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum get FOUR_HUNDRED_TWENTY_TWO =>
      _id_FOUR_HUNDRED_TWENTY_TWO.get(_class, const $JniAnEnum$Type());

  static final _id_getRaw = _class.instanceMethodId(
    r'getRaw',
    r'()I',
  );

  static final _getRaw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int getRaw()`
  int getRaw() {
    return _getRaw(reference.pointer, _id_getRaw as jni$_.JMethodIDPtr).integer;
  }

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[LJniAnEnum;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public JniAnEnum[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<JniAnEnum?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<JniAnEnum?>?>(
            const jni$_.JArrayNullableType<JniAnEnum?>(
                $JniAnEnum$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)LJniAnEnum;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public JniAnEnum valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnEnum? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<JniAnEnum?>(const $JniAnEnum$NullableType());
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public kotlin.enums.EnumEntries<JniAnEnum> getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
            _class.reference.pointer, _id_getEntries as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $JniAnEnum$NullableType extends jni$_.JObjType<JniAnEnum?> {
  @jni$_.internal
  const $JniAnEnum$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnEnum;';

  @jni$_.internal
  @core$_.override
  JniAnEnum? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : JniAnEnum.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnEnum?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnEnum$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnEnum$NullableType) &&
        other is $JniAnEnum$NullableType;
  }
}

final class $JniAnEnum$Type extends jni$_.JObjType<JniAnEnum> {
  @jni$_.internal
  const $JniAnEnum$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnEnum;';

  @jni$_.internal
  @core$_.override
  JniAnEnum fromReference(jni$_.JReference reference) =>
      JniAnEnum.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnEnum?> get nullableType =>
      const $JniAnEnum$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnEnum$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnEnum$Type) && other is $JniAnEnum$Type;
  }
}

/// from: `JniAnotherEnum$Companion`
class JniAnotherEnum$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAnotherEnum$Companion> $type;

  @jni$_.internal
  JniAnotherEnum$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAnotherEnum$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAnotherEnum$Companion$NullableType();
  static const type = $JniAnotherEnum$Companion$Type();
  static final _id_ofRaw = _class.instanceMethodId(
    r'ofRaw',
    r'(I)LJniAnotherEnum;',
  );

  static final _ofRaw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final JniAnotherEnum ofRaw(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  JniAnotherEnum? ofRaw(
    int i,
  ) {
    return _ofRaw(reference.pointer, _id_ofRaw as jni$_.JMethodIDPtr, i)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory JniAnotherEnum$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return JniAnotherEnum$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $JniAnotherEnum$Companion$NullableType
    extends jni$_.JObjType<JniAnotherEnum$Companion?> {
  @jni$_.internal
  const $JniAnotherEnum$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnotherEnum$Companion;';

  @jni$_.internal
  @core$_.override
  JniAnotherEnum$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JniAnotherEnum$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnotherEnum$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnotherEnum$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnotherEnum$Companion$NullableType) &&
        other is $JniAnotherEnum$Companion$NullableType;
  }
}

final class $JniAnotherEnum$Companion$Type
    extends jni$_.JObjType<JniAnotherEnum$Companion> {
  @jni$_.internal
  const $JniAnotherEnum$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnotherEnum$Companion;';

  @jni$_.internal
  @core$_.override
  JniAnotherEnum$Companion fromReference(jni$_.JReference reference) =>
      JniAnotherEnum$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnotherEnum$Companion?> get nullableType =>
      const $JniAnotherEnum$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnotherEnum$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnotherEnum$Companion$Type) &&
        other is $JniAnotherEnum$Companion$Type;
  }
}

/// from: `JniAnotherEnum`
class JniAnotherEnum extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JniAnotherEnum> $type;

  @jni$_.internal
  JniAnotherEnum.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'JniAnotherEnum');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JniAnotherEnum$NullableType();
  static const type = $JniAnotherEnum$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LJniAnotherEnum$Companion;',
  );

  /// from: `static public final JniAnotherEnum$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnotherEnum$Companion get Companion =>
      _id_Companion.get(_class, const $JniAnotherEnum$Companion$Type());

  static final _id_JUST_IN_CASE = _class.staticFieldId(
    r'JUST_IN_CASE',
    r'LJniAnotherEnum;',
  );

  /// from: `static public final JniAnotherEnum JUST_IN_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnotherEnum get JUST_IN_CASE =>
      _id_JUST_IN_CASE.get(_class, const $JniAnotherEnum$Type());

  static final _id_getRaw = _class.instanceMethodId(
    r'getRaw',
    r'()I',
  );

  static final _getRaw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int getRaw()`
  int getRaw() {
    return _getRaw(reference.pointer, _id_getRaw as jni$_.JMethodIDPtr).integer;
  }

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[LJniAnotherEnum;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public JniAnotherEnum[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<JniAnotherEnum?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<JniAnotherEnum?>?>(
            const jni$_.JArrayNullableType<JniAnotherEnum?>(
                $JniAnotherEnum$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)LJniAnotherEnum;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public JniAnotherEnum valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static JniAnotherEnum? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<JniAnotherEnum?>(const $JniAnotherEnum$NullableType());
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public kotlin.enums.EnumEntries<JniAnotherEnum> getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
            _class.reference.pointer, _id_getEntries as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $JniAnotherEnum$NullableType
    extends jni$_.JObjType<JniAnotherEnum?> {
  @jni$_.internal
  const $JniAnotherEnum$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnotherEnum;';

  @jni$_.internal
  @core$_.override
  JniAnotherEnum? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : JniAnotherEnum.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnotherEnum?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnotherEnum$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnotherEnum$NullableType) &&
        other is $JniAnotherEnum$NullableType;
  }
}

final class $JniAnotherEnum$Type extends jni$_.JObjType<JniAnotherEnum> {
  @jni$_.internal
  const $JniAnotherEnum$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LJniAnotherEnum;';

  @jni$_.internal
  @core$_.override
  JniAnotherEnum fromReference(jni$_.JReference reference) =>
      JniAnotherEnum.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JniAnotherEnum?> get nullableType =>
      const $JniAnotherEnum$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JniAnotherEnum$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JniAnotherEnum$Type) &&
        other is $JniAnotherEnum$Type;
  }
}
