// AUTO GENERATED BY JNIGEN 0.15.1. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `NIHostIntegrationCoreApi`
class NIHostIntegrationCoreApi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIHostIntegrationCoreApi> $type;

  @jni$_.internal
  NIHostIntegrationCoreApi.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIHostIntegrationCoreApi');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIHostIntegrationCoreApi?> nullableType =
      $NIHostIntegrationCoreApi$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIHostIntegrationCoreApi> type =
      $NIHostIntegrationCoreApi$Type$();
  static final _id_noop = _class.instanceMethodId(r'noop', r'()V');

  static final _noop =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun noop(): kotlin.Unit`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }

  static final _id_echoAllTypes = _class.instanceMethodId(
    r'echoAllTypes',
    r'(LNIAllTypes;)LNIAllTypes;',
  );

  static final _echoAllTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAllTypes(everything: NIAllTypes): NIAllTypes`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes echoAllTypes(NIAllTypes nIAllTypes) {
    final _$nIAllTypes = nIAllTypes.reference;
    return _echoAllTypes(
      reference.pointer,
      _id_echoAllTypes as jni$_.JMethodIDPtr,
      _$nIAllTypes.pointer,
    ).object<NIAllTypes>(const $NIAllTypes$Type$());
  }

  static final _id_throwError = _class.instanceMethodId(
    r'throwError',
    r'()Ljava/lang/Object;',
  );

  static final _throwError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun throwError(): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwError() {
    return _throwError(
      reference.pointer,
      _id_throwError as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_throwErrorFromVoid = _class.instanceMethodId(
    r'throwErrorFromVoid',
    r'()V',
  );

  static final _throwErrorFromVoid =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun throwErrorFromVoid(): kotlin.Unit`
  void throwErrorFromVoid() {
    _throwErrorFromVoid(
      reference.pointer,
      _id_throwErrorFromVoid as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_throwFlutterError = _class.instanceMethodId(
    r'throwFlutterError',
    r'()Ljava/lang/Object;',
  );

  static final _throwFlutterError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun throwFlutterError(): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwFlutterError() {
    return _throwFlutterError(
      reference.pointer,
      _id_throwFlutterError as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_echoInt = _class.instanceMethodId(r'echoInt', r'(J)J');

  static final _echoInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public fun echoInt(anInt: kotlin.Long): kotlin.Long`
  int echoInt(int j) {
    return _echoInt(
      reference.pointer,
      _id_echoInt as jni$_.JMethodIDPtr,
      j,
    ).long;
  }

  static final _id_echoDouble = _class.instanceMethodId(r'echoDouble', r'(D)D');

  static final _echoDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public fun echoDouble(aDouble: kotlin.Double): kotlin.Double`
  double echoDouble(double d) {
    return _echoDouble(
      reference.pointer,
      _id_echoDouble as jni$_.JMethodIDPtr,
      d,
    ).doubleFloat;
  }

  static final _id_echoBool = _class.instanceMethodId(r'echoBool', r'(Z)Z');

  static final _echoBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public fun echoBool(aBool: kotlin.Boolean): kotlin.Boolean`
  core$_.bool echoBool(core$_.bool z) {
    return _echoBool(
      reference.pointer,
      _id_echoBool as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_echoString = _class.instanceMethodId(
    r'echoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoString(aString: kotlin.String): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoString(jni$_.JString string) {
    final _$string = string.reference;
    return _echoString(
      reference.pointer,
      _id_echoString as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_echoUint8List = _class.instanceMethodId(
    r'echoUint8List',
    r'([B)[B',
  );

  static final _echoUint8List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoUint8List(aUint8List: kotlin.ByteArray): kotlin.ByteArray`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray echoUint8List(jni$_.JByteArray bs) {
    final _$bs = bs.reference;
    return _echoUint8List(
      reference.pointer,
      _id_echoUint8List as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).object<jni$_.JByteArray>(const jni$_.$JByteArray$Type$());
  }

  static final _id_echoInt32List = _class.instanceMethodId(
    r'echoInt32List',
    r'([I)[I',
  );

  static final _echoInt32List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoInt32List(aInt32List: kotlin.IntArray): kotlin.IntArray`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray echoInt32List(jni$_.JIntArray is$) {
    final _$is$ = is$.reference;
    return _echoInt32List(
      reference.pointer,
      _id_echoInt32List as jni$_.JMethodIDPtr,
      _$is$.pointer,
    ).object<jni$_.JIntArray>(const jni$_.$JIntArray$Type$());
  }

  static final _id_echoInt64List = _class.instanceMethodId(
    r'echoInt64List',
    r'([J)[J',
  );

  static final _echoInt64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoInt64List(aInt64List: kotlin.LongArray): kotlin.LongArray`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray echoInt64List(jni$_.JLongArray js) {
    final _$js = js.reference;
    return _echoInt64List(
      reference.pointer,
      _id_echoInt64List as jni$_.JMethodIDPtr,
      _$js.pointer,
    ).object<jni$_.JLongArray>(const jni$_.$JLongArray$Type$());
  }

  static final _id_echoFloat64List = _class.instanceMethodId(
    r'echoFloat64List',
    r'([D)[D',
  );

  static final _echoFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoFloat64List(aFloat64List: kotlin.DoubleArray): kotlin.DoubleArray`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray echoFloat64List(jni$_.JDoubleArray ds) {
    final _$ds = ds.reference;
    return _echoFloat64List(
      reference.pointer,
      _id_echoFloat64List as jni$_.JMethodIDPtr,
      _$ds.pointer,
    ).object<jni$_.JDoubleArray>(const jni$_.$JDoubleArray$Type$());
  }

  static final _id_echoObject = _class.instanceMethodId(
    r'echoObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoObject(anObject: kotlin.Any): kotlin.Any`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject echoObject(jni$_.JObject object) {
    final _$object = object.reference;
    return _echoObject(
      reference.pointer,
      _id_echoObject as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_echoList = _class.instanceMethodId(
    r'echoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoList(list: kotlin.collections.List<kotlin.Any?>): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> echoList(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _echoList(
      reference.pointer,
      _id_echoList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_echoStringList = _class.instanceMethodId(
    r'echoStringList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoStringList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoStringList(stringList: kotlin.collections.List<kotlin.String?>): kotlin.collections.List<kotlin.String?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> echoStringList(jni$_.JList<jni$_.JString?> list) {
    final _$list = list.reference;
    return _echoStringList(
      reference.pointer,
      _id_echoStringList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JString?>>(
      const jni$_.$JList$Type$<jni$_.JString?>(jni$_.$JString$NullableType$()),
    );
  }

  static final _id_echoIntList = _class.instanceMethodId(
    r'echoIntList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoIntList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoIntList(intList: kotlin.collections.List<kotlin.Long?>): kotlin.collections.List<kotlin.Long?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?> echoIntList(jni$_.JList<jni$_.JLong?> list) {
    final _$list = list.reference;
    return _echoIntList(
      reference.pointer,
      _id_echoIntList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JLong?>>(
      const jni$_.$JList$Type$<jni$_.JLong?>(jni$_.$JLong$NullableType$()),
    );
  }

  static final _id_echoDoubleList = _class.instanceMethodId(
    r'echoDoubleList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoDoubleList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoDoubleList(doubleList: kotlin.collections.List<kotlin.Double?>): kotlin.collections.List<kotlin.Double?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?> echoDoubleList(jni$_.JList<jni$_.JDouble?> list) {
    final _$list = list.reference;
    return _echoDoubleList(
      reference.pointer,
      _id_echoDoubleList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JDouble?>>(
      const jni$_.$JList$Type$<jni$_.JDouble?>(jni$_.$JDouble$NullableType$()),
    );
  }

  static final _id_echoBoolList = _class.instanceMethodId(
    r'echoBoolList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoBoolList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoBoolList(boolList: kotlin.collections.List<kotlin.Boolean?>): kotlin.collections.List<kotlin.Boolean?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?> echoBoolList(jni$_.JList<jni$_.JBoolean?> list) {
    final _$list = list.reference;
    return _echoBoolList(
      reference.pointer,
      _id_echoBoolList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JBoolean?>>(
      const jni$_.$JList$Type$<jni$_.JBoolean?>(
        jni$_.$JBoolean$NullableType$(),
      ),
    );
  }

  static final _id_echoEnumList = _class.instanceMethodId(
    r'echoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoEnumList(enumList: kotlin.collections.List<NIAnEnum?>): kotlin.collections.List<NIAnEnum?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?> echoEnumList(jni$_.JList<NIAnEnum?> list) {
    final _$list = list.reference;
    return _echoEnumList(
      reference.pointer,
      _id_echoEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum?>>(
      const jni$_.$JList$Type$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_echoClassList = _class.instanceMethodId(
    r'echoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoClassList(classList: kotlin.collections.List<NIAllNullableTypes?>): kotlin.collections.List<NIAllNullableTypes?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?> echoClassList(
    jni$_.JList<NIAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _echoClassList(
      reference.pointer,
      _id_echoClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypes?>>(
      const jni$_.$JList$Type$<NIAllNullableTypes?>(
        $NIAllNullableTypes$NullableType$(),
      ),
    );
  }

  static final _id_echoNonNullEnumList = _class.instanceMethodId(
    r'echoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullEnumList(enumList: kotlin.collections.List<NIAnEnum>): kotlin.collections.List<NIAnEnum>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> echoNonNullEnumList(jni$_.JList<NIAnEnum> list) {
    final _$list = list.reference;
    return _echoNonNullEnumList(
      reference.pointer,
      _id_echoNonNullEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum>>(
      const jni$_.$JList$Type$<NIAnEnum>($NIAnEnum$Type$()),
    );
  }

  static final _id_echoNonNullClassList = _class.instanceMethodId(
    r'echoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullClassList(classList: kotlin.collections.List<NIAllNullableTypes>): kotlin.collections.List<NIAllNullableTypes>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes> echoNonNullClassList(
    jni$_.JList<NIAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullClassList(
      reference.pointer,
      _id_echoNonNullClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypes>>(
      const jni$_.$JList$Type$<NIAllNullableTypes>($NIAllNullableTypes$Type$()),
    );
  }

  static final _id_echoMap = _class.instanceMethodId(
    r'echoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoMap(map: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _echoMap(
      reference.pointer,
      _id_echoMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
      const jni$_.$JMap$Type$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_echoStringMap = _class.instanceMethodId(
    r'echoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoStringMap(stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>): kotlin.collections.Map<kotlin.String?, kotlin.String?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _echoStringMap(
      reference.pointer,
      _id_echoStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
      const jni$_.$JMap$Type$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_echoIntMap = _class.instanceMethodId(
    r'echoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoIntMap(intMap: kotlin.collections.Map<kotlin.Long?, kotlin.Long?>): kotlin.collections.Map<kotlin.Long?, kotlin.Long?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _echoIntMap(
      reference.pointer,
      _id_echoIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
      const jni$_.$JMap$Type$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_echoEnumMap = _class.instanceMethodId(
    r'echoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoEnumMap(enumMap: kotlin.collections.Map<NIAnEnum?, NIAnEnum?>): kotlin.collections.Map<NIAnEnum?, NIAnEnum?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?> echoEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _echoEnumMap(
      reference.pointer,
      _id_echoEnumMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<NIAnEnum?, NIAnEnum?>>(
      const jni$_.$JMap$Type$<NIAnEnum?, NIAnEnum?>(
        $NIAnEnum$NullableType$(),
        $NIAnEnum$NullableType$(),
      ),
    );
  }

  static final _id_echoClassMap = _class.instanceMethodId(
    r'echoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoClassMap(classMap: kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>): kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> echoClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _echoClassMap(
      reference.pointer,
      _id_echoClassMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>(
      const jni$_.$JMap$Type$<jni$_.JLong?, NIAllNullableTypes?>(
        jni$_.$JLong$NullableType$(),
        $NIAllNullableTypes$NullableType$(),
      ),
    );
  }

  static final _id_echoNonNullStringMap = _class.instanceMethodId(
    r'echoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullStringMap(stringMap: kotlin.collections.Map<kotlin.String, kotlin.String>): kotlin.collections.Map<kotlin.String, kotlin.String>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullStringMap(
      reference.pointer,
      _id_echoNonNullStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
      const jni$_.$JMap$Type$<jni$_.JString, jni$_.JString>(
        jni$_.$JString$Type$(),
        jni$_.$JString$Type$(),
      ),
    );
  }

  static final _id_echoNonNullIntMap = _class.instanceMethodId(
    r'echoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullIntMap(intMap: kotlin.collections.Map<kotlin.Long, kotlin.Long>): kotlin.collections.Map<kotlin.Long, kotlin.Long>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullIntMap(
      reference.pointer,
      _id_echoNonNullIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
      const jni$_.$JMap$Type$<jni$_.JLong, jni$_.JLong>(
        jni$_.$JLong$Type$(),
        jni$_.$JLong$Type$(),
      ),
    );
  }

  static final _id_echoNonNullEnumMap = _class.instanceMethodId(
    r'echoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullEnumMap(enumMap: kotlin.collections.Map<NIAnEnum, NIAnEnum>): kotlin.collections.Map<NIAnEnum, NIAnEnum>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum> echoNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullEnumMap(
      reference.pointer,
      _id_echoNonNullEnumMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<NIAnEnum, NIAnEnum>>(
      const jni$_.$JMap$Type$<NIAnEnum, NIAnEnum>(
        $NIAnEnum$Type$(),
        $NIAnEnum$Type$(),
      ),
    );
  }

  static final _id_echoNonNullClassMap = _class.instanceMethodId(
    r'echoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullClassMap(classMap: kotlin.collections.Map<kotlin.Long, NIAllNullableTypes>): kotlin.collections.Map<kotlin.Long, NIAllNullableTypes>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes> echoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullClassMap(
      reference.pointer,
      _id_echoNonNullClassMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>>(
      const jni$_.$JMap$Type$<jni$_.JLong, NIAllNullableTypes>(
        jni$_.$JLong$Type$(),
        $NIAllNullableTypes$Type$(),
      ),
    );
  }

  static final _id_echoClassWrapper = _class.instanceMethodId(
    r'echoClassWrapper',
    r'(LNIAllClassesWrapper;)LNIAllClassesWrapper;',
  );

  static final _echoClassWrapper =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoClassWrapper(wrapper: NIAllClassesWrapper): NIAllClassesWrapper`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper echoClassWrapper(
    NIAllClassesWrapper nIAllClassesWrapper,
  ) {
    final _$nIAllClassesWrapper = nIAllClassesWrapper.reference;
    return _echoClassWrapper(
      reference.pointer,
      _id_echoClassWrapper as jni$_.JMethodIDPtr,
      _$nIAllClassesWrapper.pointer,
    ).object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type$());
  }

  static final _id_echoEnum = _class.instanceMethodId(
    r'echoEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoEnum(anEnum: NIAnEnum): NIAnEnum`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum echoEnum(NIAnEnum nIAnEnum) {
    final _$nIAnEnum = nIAnEnum.reference;
    return _echoEnum(
      reference.pointer,
      _id_echoEnum as jni$_.JMethodIDPtr,
      _$nIAnEnum.pointer,
    ).object<NIAnEnum>(const $NIAnEnum$Type$());
  }

  static final _id_echoAnotherEnum = _class.instanceMethodId(
    r'echoAnotherEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoAnotherEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAnotherEnum(anotherEnum: NIAnotherEnum): NIAnotherEnum`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum echoAnotherEnum(NIAnotherEnum nIAnotherEnum) {
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    return _echoAnotherEnum(
      reference.pointer,
      _id_echoAnotherEnum as jni$_.JMethodIDPtr,
      _$nIAnotherEnum.pointer,
    ).object<NIAnotherEnum>(const $NIAnotherEnum$Type$());
  }

  static final _id_echoAllNullableTypes = _class.instanceMethodId(
    r'echoAllNullableTypes',
    r'(LNIAllNullableTypes;)LNIAllNullableTypes;',
  );

  static final _echoAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAllNullableTypes(everything: NIAllNullableTypes?): NIAllNullableTypes?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes? echoAllNullableTypes(
    NIAllNullableTypes? nIAllNullableTypes,
  ) {
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypes(
      reference.pointer,
      _id_echoAllNullableTypes as jni$_.JMethodIDPtr,
      _$nIAllNullableTypes.pointer,
    ).object<NIAllNullableTypes?>(const $NIAllNullableTypes$NullableType$());
  }

  static final _id_echoAllNullableTypesWithoutRecursion = _class.instanceMethodId(
    r'echoAllNullableTypesWithoutRecursion',
    r'(LNIAllNullableTypesWithoutRecursion;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _echoAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAllNullableTypesWithoutRecursion(everything: NIAllNullableTypesWithoutRecursion?): NIAllNullableTypesWithoutRecursion?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion? echoAllNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
  ) {
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypesWithoutRecursion(
      reference.pointer,
      _id_echoAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
      _$nIAllNullableTypesWithoutRecursion.pointer,
    ).object<NIAllNullableTypesWithoutRecursion?>(
      const $NIAllNullableTypesWithoutRecursion$NullableType$(),
    );
  }

  static final _id_extractNestedNullableString = _class.instanceMethodId(
    r'extractNestedNullableString',
    r'(LNIAllClassesWrapper;)Ljava/lang/String;',
  );

  static final _extractNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun extractNestedNullableString(wrapper: NIAllClassesWrapper): kotlin.String?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? extractNestedNullableString(
    NIAllClassesWrapper nIAllClassesWrapper,
  ) {
    final _$nIAllClassesWrapper = nIAllClassesWrapper.reference;
    return _extractNestedNullableString(
      reference.pointer,
      _id_extractNestedNullableString as jni$_.JMethodIDPtr,
      _$nIAllClassesWrapper.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_createNestedNullableString = _class.instanceMethodId(
    r'createNestedNullableString',
    r'(Ljava/lang/String;)LNIAllClassesWrapper;',
  );

  static final _createNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun createNestedNullableString(nullableString: kotlin.String?): NIAllClassesWrapper`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper createNestedNullableString(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createNestedNullableString(
      reference.pointer,
      _id_createNestedNullableString as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type$());
  }

  static final _id_sendMultipleNullableTypes = _class.instanceMethodId(
    r'sendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypes;',
  );

  static final _sendMultipleNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun sendMultipleNullableTypes(aNullableBool: kotlin.Boolean?, aNullableInt: kotlin.Long?, aNullableString: kotlin.String?): NIAllNullableTypes`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes sendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypes(
      reference.pointer,
      _id_sendMultipleNullableTypes as jni$_.JMethodIDPtr,
      _$boolean.pointer,
      _$long.pointer,
      _$string.pointer,
    ).object<NIAllNullableTypes>(const $NIAllNullableTypes$Type$());
  }

  static final _id_sendMultipleNullableTypesWithoutRecursion = _class
      .instanceMethodId(
        r'sendMultipleNullableTypesWithoutRecursion',
        r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypesWithoutRecursion;',
      );

  static final _sendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun sendMultipleNullableTypesWithoutRecursion(aNullableBool: kotlin.Boolean?, aNullableInt: kotlin.Long?, aNullableString: kotlin.String?): NIAllNullableTypesWithoutRecursion`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypesWithoutRecursion(
      reference.pointer,
      _id_sendMultipleNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
      _$boolean.pointer,
      _$long.pointer,
      _$string.pointer,
    ).object<NIAllNullableTypesWithoutRecursion>(
      const $NIAllNullableTypesWithoutRecursion$Type$(),
    );
  }

  static final _id_echoNullableInt = _class.instanceMethodId(
    r'echoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoNullableInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableInt(aNullableInt: kotlin.Long?): kotlin.Long?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoNullableInt(jni$_.JLong? long) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoNullableInt(
      reference.pointer,
      _id_echoNullableInt as jni$_.JMethodIDPtr,
      _$long.pointer,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_echoNullableDouble = _class.instanceMethodId(
    r'echoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _echoNullableDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableDouble(aNullableDouble: kotlin.Double?): kotlin.Double?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? echoNullableDouble(jni$_.JDouble? double) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _echoNullableDouble(
      reference.pointer,
      _id_echoNullableDouble as jni$_.JMethodIDPtr,
      _$double.pointer,
    ).object<jni$_.JDouble?>(const jni$_.$JDouble$NullableType$());
  }

  static final _id_echoNullableBool = _class.instanceMethodId(
    r'echoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _echoNullableBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableBool(aNullableBool: kotlin.Boolean?): kotlin.Boolean?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? echoNullableBool(jni$_.JBoolean? boolean) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _echoNullableBool(
      reference.pointer,
      _id_echoNullableBool as jni$_.JMethodIDPtr,
      _$boolean.pointer,
    ).object<jni$_.JBoolean?>(const jni$_.$JBoolean$NullableType$());
  }

  static final _id_echoNullableString = _class.instanceMethodId(
    r'echoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableString(aNullableString: kotlin.String?): kotlin.String?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNullableString(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNullableString(
      reference.pointer,
      _id_echoNullableString as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_echoNullableUint8List = _class.instanceMethodId(
    r'echoNullableUint8List',
    r'([B)[B',
  );

  static final _echoNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableUint8List(aNullableUint8List: kotlin.ByteArray?): kotlin.ByteArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? echoNullableUint8List(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _echoNullableUint8List(
      reference.pointer,
      _id_echoNullableUint8List as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).object<jni$_.JByteArray?>(const jni$_.$JByteArray$NullableType$());
  }

  static final _id_echoNullableInt32List = _class.instanceMethodId(
    r'echoNullableInt32List',
    r'([I)[I',
  );

  static final _echoNullableInt32List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableInt32List(aNullableInt32List: kotlin.IntArray?): kotlin.IntArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? echoNullableInt32List(jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _echoNullableInt32List(
      reference.pointer,
      _id_echoNullableInt32List as jni$_.JMethodIDPtr,
      _$is$.pointer,
    ).object<jni$_.JIntArray?>(const jni$_.$JIntArray$NullableType$());
  }

  static final _id_echoNullableInt64List = _class.instanceMethodId(
    r'echoNullableInt64List',
    r'([J)[J',
  );

  static final _echoNullableInt64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableInt64List(aNullableInt64List: kotlin.LongArray?): kotlin.LongArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? echoNullableInt64List(jni$_.JLongArray? js) {
    final _$js = js?.reference ?? jni$_.jNullReference;
    return _echoNullableInt64List(
      reference.pointer,
      _id_echoNullableInt64List as jni$_.JMethodIDPtr,
      _$js.pointer,
    ).object<jni$_.JLongArray?>(const jni$_.$JLongArray$NullableType$());
  }

  static final _id_echoNullableFloat64List = _class.instanceMethodId(
    r'echoNullableFloat64List',
    r'([D)[D',
  );

  static final _echoNullableFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableFloat64List(aNullableFloat64List: kotlin.DoubleArray?): kotlin.DoubleArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? echoNullableFloat64List(jni$_.JDoubleArray? ds) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    return _echoNullableFloat64List(
      reference.pointer,
      _id_echoNullableFloat64List as jni$_.JMethodIDPtr,
      _$ds.pointer,
    ).object<jni$_.JDoubleArray?>(const jni$_.$JDoubleArray$NullableType$());
  }

  static final _id_echoNullableObject = _class.instanceMethodId(
    r'echoNullableObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoNullableObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableObject(aNullableObject: kotlin.Any?): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? echoNullableObject(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _echoNullableObject(
      reference.pointer,
      _id_echoNullableObject as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_echoNullableList = _class.instanceMethodId(
    r'echoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableList(aNullableList: kotlin.collections.List<kotlin.Any?>?): kotlin.collections.List<kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? echoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableList(
      reference.pointer,
      _id_echoNullableList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableEnumList = _class.instanceMethodId(
    r'echoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableEnumList(enumList: kotlin.collections.List<NIAnEnum?>?): kotlin.collections.List<NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? echoNullableEnumList(jni$_.JList<NIAnEnum?>? list) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumList(
      reference.pointer,
      _id_echoNullableEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum?>?>(
      const jni$_.$JList$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_echoNullableClassList = _class.instanceMethodId(
    r'echoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableClassList(classList: kotlin.collections.List<NIAllNullableTypes?>?): kotlin.collections.List<NIAllNullableTypes?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?>? echoNullableClassList(
    jni$_.JList<NIAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableClassList(
      reference.pointer,
      _id_echoNullableClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypes?>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypes?>(
        $NIAllNullableTypes$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableNonNullEnumList = _class.instanceMethodId(
    r'echoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullEnumList(enumList: kotlin.collections.List<NIAnEnum>?): kotlin.collections.List<NIAnEnum>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum>? echoNullableNonNullEnumList(
    jni$_.JList<NIAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumList(
      reference.pointer,
      _id_echoNullableNonNullEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum>?>(
      const jni$_.$JList$NullableType$<NIAnEnum>($NIAnEnum$Type$()),
    );
  }

  static final _id_echoNullableNonNullClassList = _class.instanceMethodId(
    r'echoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullClassList(classList: kotlin.collections.List<NIAllNullableTypes>?): kotlin.collections.List<NIAllNullableTypes>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes>? echoNullableNonNullClassList(
    jni$_.JList<NIAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassList(
      reference.pointer,
      _id_echoNullableNonNullClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypes>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypes>(
        $NIAllNullableTypes$Type$(),
      ),
    );
  }

  static final _id_echoNullableMap = _class.instanceMethodId(
    r'echoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableMap(map: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableMap(
      reference.pointer,
      _id_echoNullableMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableStringMap = _class.instanceMethodId(
    r'echoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableStringMap(stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>?): kotlin.collections.Map<kotlin.String?, kotlin.String?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableStringMap(
      reference.pointer,
      _id_echoNullableStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableIntMap = _class.instanceMethodId(
    r'echoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableIntMap(intMap: kotlin.collections.Map<kotlin.Long?, kotlin.Long?>?): kotlin.collections.Map<kotlin.Long?, kotlin.Long?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableIntMap(
      reference.pointer,
      _id_echoNullableIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableEnumMap = _class.instanceMethodId(
    r'echoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableEnumMap(enumMap: kotlin.collections.Map<NIAnEnum?, NIAnEnum?>?): kotlin.collections.Map<NIAnEnum?, NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? echoNullableEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumMap(
      reference.pointer,
      _id_echoNullableEnumMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
      const jni$_.$JMap$NullableType$<NIAnEnum?, NIAnEnum?>(
        $NIAnEnum$NullableType$(),
        $NIAnEnum$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableClassMap = _class.instanceMethodId(
    r'echoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableClassMap(classMap: kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>?): kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? echoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableClassMap(
      reference.pointer,
      _id_echoNullableClassMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, NIAllNullableTypes?>(
        jni$_.$JLong$NullableType$(),
        $NIAllNullableTypes$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableNonNullStringMap = _class.instanceMethodId(
    r'echoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullStringMap(stringMap: kotlin.collections.Map<kotlin.String, kotlin.String>?): kotlin.collections.Map<kotlin.String, kotlin.String>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullStringMap(
      reference.pointer,
      _id_echoNullableNonNullStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString, jni$_.JString>(
        jni$_.$JString$Type$(),
        jni$_.$JString$Type$(),
      ),
    );
  }

  static final _id_echoNullableNonNullIntMap = _class.instanceMethodId(
    r'echoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullIntMap(intMap: kotlin.collections.Map<kotlin.Long, kotlin.Long>?): kotlin.collections.Map<kotlin.Long, kotlin.Long>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullIntMap(
      reference.pointer,
      _id_echoNullableNonNullIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong, jni$_.JLong>(
        jni$_.$JLong$Type$(),
        jni$_.$JLong$Type$(),
      ),
    );
  }

  static final _id_echoNullableNonNullEnumMap = _class.instanceMethodId(
    r'echoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullEnumMap(enumMap: kotlin.collections.Map<NIAnEnum, NIAnEnum>?): kotlin.collections.Map<NIAnEnum, NIAnEnum>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum>? echoNullableNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumMap(
      reference.pointer,
      _id_echoNullableNonNullEnumMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<NIAnEnum, NIAnEnum>?>(
      const jni$_.$JMap$NullableType$<NIAnEnum, NIAnEnum>(
        $NIAnEnum$Type$(),
        $NIAnEnum$Type$(),
      ),
    );
  }

  static final _id_echoNullableNonNullClassMap = _class.instanceMethodId(
    r'echoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullClassMap(classMap: kotlin.collections.Map<kotlin.Long, NIAllNullableTypes>?): kotlin.collections.Map<kotlin.Long, NIAllNullableTypes>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? echoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassMap(
      reference.pointer,
      _id_echoNullableNonNullClassMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong, NIAllNullableTypes>(
        jni$_.$JLong$Type$(),
        $NIAllNullableTypes$Type$(),
      ),
    );
  }

  static final _id_echoNullableEnum = _class.instanceMethodId(
    r'echoNullableEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableEnum(anEnum: NIAnEnum?): NIAnEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? echoNullableEnum(NIAnEnum? nIAnEnum) {
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    return _echoNullableEnum(
      reference.pointer,
      _id_echoNullableEnum as jni$_.JMethodIDPtr,
      _$nIAnEnum.pointer,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_echoAnotherNullableEnum = _class.instanceMethodId(
    r'echoAnotherNullableEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoAnotherNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAnotherNullableEnum(anotherEnum: NIAnotherEnum?): NIAnotherEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? echoAnotherNullableEnum(NIAnotherEnum? nIAnotherEnum) {
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    return _echoAnotherNullableEnum(
      reference.pointer,
      _id_echoAnotherNullableEnum as jni$_.JMethodIDPtr,
      _$nIAnotherEnum.pointer,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }

  static final _id_noopAsync = _class.instanceMethodId(
    r'noopAsync',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _noopAsync =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun noopAsync(): kotlin.Unit`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> noopAsync() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _noopAsync(
      reference.pointer,
      _id_noopAsync as jni$_.JMethodIDPtr,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.$JObject$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt = _class.instanceMethodId(
    r'echoAsyncInt',
    r'(JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncInt(anInt: kotlin.Long): kotlin.Long`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong> echoAsyncInt(int j) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncInt(
      reference.pointer,
      _id_echoAsyncInt as jni$_.JMethodIDPtr,
      j,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLong>(
      const jni$_.$JLong$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncDouble = _class.instanceMethodId(
    r'echoAsyncDouble',
    r'(DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncDouble(aDouble: kotlin.Double): kotlin.Double`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble> echoAsyncDouble(double d) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncDouble(
      reference.pointer,
      _id_echoAsyncDouble as jni$_.JMethodIDPtr,
      d,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDouble>(
      const jni$_.$JDouble$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncBool = _class.instanceMethodId(
    r'echoAsyncBool',
    r'(ZLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncBool(aBool: kotlin.Boolean): kotlin.Boolean`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean> echoAsyncBool(core$_.bool z) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncBool(
      reference.pointer,
      _id_echoAsyncBool as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JBoolean>(
      const jni$_.$JBoolean$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncString = _class.instanceMethodId(
    r'echoAsyncString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncString(aString: kotlin.String): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echoAsyncString(jni$_.JString string) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echoAsyncString(
      reference.pointer,
      _id_echoAsyncString as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.$JString$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncUint8List = _class.instanceMethodId(
    r'echoAsyncUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncUint8List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncUint8List(aUint8List: kotlin.ByteArray): kotlin.ByteArray`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray> echoAsyncUint8List(
    jni$_.JByteArray bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs.reference;
    final $r = _echoAsyncUint8List(
      reference.pointer,
      _id_echoAsyncUint8List as jni$_.JMethodIDPtr,
      _$bs.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JByteArray>(
      const jni$_.$JByteArray$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt32List = _class.instanceMethodId(
    r'echoAsyncInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt32List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncInt32List(aInt32List: kotlin.IntArray): kotlin.IntArray`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray> echoAsyncInt32List(jni$_.JIntArray is$) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$.reference;
    final $r = _echoAsyncInt32List(
      reference.pointer,
      _id_echoAsyncInt32List as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JIntArray>(
      const jni$_.$JIntArray$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt64List = _class.instanceMethodId(
    r'echoAsyncInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncInt64List(aInt64List: kotlin.LongArray): kotlin.LongArray`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray> echoAsyncInt64List(
    jni$_.JLongArray js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js.reference;
    final $r = _echoAsyncInt64List(
      reference.pointer,
      _id_echoAsyncInt64List as jni$_.JMethodIDPtr,
      _$js.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLongArray>(
      const jni$_.$JLongArray$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncFloat64List = _class.instanceMethodId(
    r'echoAsyncFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncFloat64List(aFloat64List: kotlin.DoubleArray): kotlin.DoubleArray`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray> echoAsyncFloat64List(
    jni$_.JDoubleArray ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds.reference;
    final $r = _echoAsyncFloat64List(
      reference.pointer,
      _id_echoAsyncFloat64List as jni$_.JMethodIDPtr,
      _$ds.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDoubleArray>(
      const jni$_.$JDoubleArray$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncObject = _class.instanceMethodId(
    r'echoAsyncObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncObject(anObject: kotlin.Any): kotlin.Any`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> echoAsyncObject(jni$_.JObject object) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object.reference;
    final $r = _echoAsyncObject(
      reference.pointer,
      _id_echoAsyncObject as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.$JObject$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncList = _class.instanceMethodId(
    r'echoAsyncList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncList(list: kotlin.collections.List<kotlin.Any?>): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>> echoAsyncList(
    jni$_.JList<jni$_.JObject?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncList(
      reference.pointer,
      _id_echoAsyncList as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumList = _class.instanceMethodId(
    r'echoAsyncEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncEnumList(enumList: kotlin.collections.List<NIAnEnum?>): kotlin.collections.List<NIAnEnum?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAnEnum?>> echoAsyncEnumList(
    jni$_.JList<NIAnEnum?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncEnumList(
      reference.pointer,
      _id_echoAsyncEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<NIAnEnum?>>(
      const jni$_.$JList$Type$<NIAnEnum?>($NIAnEnum$NullableType$()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassList = _class.instanceMethodId(
    r'echoAsyncClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncClassList(classList: kotlin.collections.List<NIAllNullableTypes?>): kotlin.collections.List<NIAllNullableTypes?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAllNullableTypes?>> echoAsyncClassList(
    jni$_.JList<NIAllNullableTypes?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncClassList(
      reference.pointer,
      _id_echoAsyncClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<NIAllNullableTypes?>>(
      const jni$_.$JList$Type$<NIAllNullableTypes?>(
        $NIAllNullableTypes$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncMap = _class.instanceMethodId(
    r'echoAsyncMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncMap(map: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> echoAsyncMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncMap(
      reference.pointer,
      _id_echoAsyncMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
      const jni$_.$JMap$Type$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncStringMap = _class.instanceMethodId(
    r'echoAsyncStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncStringMap(stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>): kotlin.collections.Map<kotlin.String?, kotlin.String?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>> echoAsyncStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncStringMap(
      reference.pointer,
      _id_echoAsyncStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
      const jni$_.$JMap$Type$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncIntMap = _class.instanceMethodId(
    r'echoAsyncIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncIntMap(intMap: kotlin.collections.Map<kotlin.Long?, kotlin.Long?>): kotlin.collections.Map<kotlin.Long?, kotlin.Long?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>> echoAsyncIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncIntMap(
      reference.pointer,
      _id_echoAsyncIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
      const jni$_.$JMap$Type$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumMap = _class.instanceMethodId(
    r'echoAsyncEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncEnumMap(enumMap: kotlin.collections.Map<NIAnEnum?, NIAnEnum?>): kotlin.collections.Map<NIAnEnum?, NIAnEnum?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<NIAnEnum?, NIAnEnum?>> echoAsyncEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncEnumMap(
      reference.pointer,
      _id_echoAsyncEnumMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<NIAnEnum?, NIAnEnum?>>(
      const jni$_.$JMap$Type$<NIAnEnum?, NIAnEnum?>(
        $NIAnEnum$NullableType$(),
        $NIAnEnum$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassMap = _class.instanceMethodId(
    r'echoAsyncClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncClassMap(classMap: kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>): kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>
  echoAsyncClassMap(jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncClassMap(
      reference.pointer,
      _id_echoAsyncClassMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>(
      const jni$_.$JMap$Type$<jni$_.JLong?, NIAllNullableTypes?>(
        jni$_.$JLong$NullableType$(),
        $NIAllNullableTypes$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnum = _class.instanceMethodId(
    r'echoAsyncEnum',
    r'(LNIAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncEnum(anEnum: NIAnEnum): NIAnEnum`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnEnum> echoAsyncEnum(NIAnEnum nIAnEnum) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnEnum = nIAnEnum.reference;
    final $r = _echoAsyncEnum(
      reference.pointer,
      _id_echoAsyncEnum as jni$_.JMethodIDPtr,
      _$nIAnEnum.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<NIAnEnum>(const $NIAnEnum$Type$(), releaseOriginal: true);
  }

  static final _id_echoAnotherAsyncEnum = _class.instanceMethodId(
    r'echoAnotherAsyncEnum',
    r'(LNIAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAnotherAsyncEnum(anotherEnum: NIAnotherEnum): NIAnotherEnum`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnotherEnum> echoAnotherAsyncEnum(
    NIAnotherEnum nIAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    final $r = _echoAnotherAsyncEnum(
      reference.pointer,
      _id_echoAnotherAsyncEnum as jni$_.JMethodIDPtr,
      _$nIAnotherEnum.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<NIAnotherEnum>(
      const $NIAnotherEnum$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncError = _class.instanceMethodId(
    r'throwAsyncError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun throwAsyncError(): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncError(
      reference.pointer,
      _id_throwAsyncError as jni$_.JMethodIDPtr,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.$JObject$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncErrorFromVoid = _class.instanceMethodId(
    r'throwAsyncErrorFromVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncErrorFromVoid =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun throwAsyncErrorFromVoid(): kotlin.Unit`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> throwAsyncErrorFromVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncErrorFromVoid(
      reference.pointer,
      _id_throwAsyncErrorFromVoid as jni$_.JMethodIDPtr,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.$JObject$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncFlutterError = _class.instanceMethodId(
    r'throwAsyncFlutterError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncFlutterError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun throwAsyncFlutterError(): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncFlutterError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncFlutterError(
      reference.pointer,
      _id_throwAsyncFlutterError as jni$_.JMethodIDPtr,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.$JObject$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNIAllTypes = _class.instanceMethodId(
    r'echoAsyncNIAllTypes',
    r'(LNIAllTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNIAllTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNIAllTypes(everything: NIAllTypes): NIAllTypes`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAllTypes> echoAsyncNIAllTypes(NIAllTypes nIAllTypes) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAllTypes = nIAllTypes.reference;
    final $r = _echoAsyncNIAllTypes(
      reference.pointer,
      _id_echoAsyncNIAllTypes as jni$_.JMethodIDPtr,
      _$nIAllTypes.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<NIAllTypes>(const $NIAllTypes$Type$(), releaseOriginal: true);
  }

  static final _id_echoAsyncNullableNIAllNullableTypes = _class.instanceMethodId(
    r'echoAsyncNullableNIAllNullableTypes',
    r'(LNIAllNullableTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableNIAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableNIAllNullableTypes(everything: NIAllNullableTypes?): NIAllNullableTypes?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAllNullableTypes?> echoAsyncNullableNIAllNullableTypes(
    NIAllNullableTypes? nIAllNullableTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableNIAllNullableTypes(
      reference.pointer,
      _id_echoAsyncNullableNIAllNullableTypes as jni$_.JMethodIDPtr,
      _$nIAllNullableTypes.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAllNullableTypes?>(
      const $NIAllNullableTypes$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableNIAllNullableTypesWithoutRecursion = _class
      .instanceMethodId(
        r'echoAsyncNullableNIAllNullableTypesWithoutRecursion',
        r'(LNIAllNullableTypesWithoutRecursion;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
      );

  static final _echoAsyncNullableNIAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableNIAllNullableTypesWithoutRecursion(everything: NIAllNullableTypesWithoutRecursion?): NIAllNullableTypesWithoutRecursion?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAllNullableTypesWithoutRecursion?>
  echoAsyncNullableNIAllNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableNIAllNullableTypesWithoutRecursion(
      reference.pointer,
      _id_echoAsyncNullableNIAllNullableTypesWithoutRecursion
          as jni$_.JMethodIDPtr,
      _$nIAllNullableTypesWithoutRecursion.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAllNullableTypesWithoutRecursion?>(
      const $NIAllNullableTypesWithoutRecursion$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt = _class.instanceMethodId(
    r'echoAsyncNullableInt',
    r'(Ljava/lang/Long;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableInt(anInt: kotlin.Long?): kotlin.Long?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong?> echoAsyncNullableInt(jni$_.JLong? long) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$long = long?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt(
      reference.pointer,
      _id_echoAsyncNullableInt as jni$_.JMethodIDPtr,
      _$long.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLong?>(
      const jni$_.$JLong$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableDouble = _class.instanceMethodId(
    r'echoAsyncNullableDouble',
    r'(Ljava/lang/Double;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableDouble(aDouble: kotlin.Double?): kotlin.Double?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble?> echoAsyncNullableDouble(
    jni$_.JDouble? double,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$double = double?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableDouble(
      reference.pointer,
      _id_echoAsyncNullableDouble as jni$_.JMethodIDPtr,
      _$double.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDouble?>(
      const jni$_.$JDouble$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableBool = _class.instanceMethodId(
    r'echoAsyncNullableBool',
    r'(Ljava/lang/Boolean;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableBool(aBool: kotlin.Boolean?): kotlin.Boolean?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean?> echoAsyncNullableBool(
    jni$_.JBoolean? boolean,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableBool(
      reference.pointer,
      _id_echoAsyncNullableBool as jni$_.JMethodIDPtr,
      _$boolean.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JBoolean?>(
      const jni$_.$JBoolean$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableString = _class.instanceMethodId(
    r'echoAsyncNullableString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableString(aString: kotlin.String?): kotlin.String?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString?> echoAsyncNullableString(
    jni$_.JString? string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableString(
      reference.pointer,
      _id_echoAsyncNullableString as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JString?>(
      const jni$_.$JString$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableUint8List = _class.instanceMethodId(
    r'echoAsyncNullableUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableUint8List(aUint8List: kotlin.ByteArray?): kotlin.ByteArray?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray?> echoAsyncNullableUint8List(
    jni$_.JByteArray? bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableUint8List(
      reference.pointer,
      _id_echoAsyncNullableUint8List as jni$_.JMethodIDPtr,
      _$bs.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JByteArray?>(
      const jni$_.$JByteArray$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt32List = _class.instanceMethodId(
    r'echoAsyncNullableInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt32List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableInt32List(aInt32List: kotlin.IntArray?): kotlin.IntArray?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray?> echoAsyncNullableInt32List(
    jni$_.JIntArray? is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt32List(
      reference.pointer,
      _id_echoAsyncNullableInt32List as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JIntArray?>(
      const jni$_.$JIntArray$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt64List = _class.instanceMethodId(
    r'echoAsyncNullableInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableInt64List(aInt64List: kotlin.LongArray?): kotlin.LongArray?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray?> echoAsyncNullableInt64List(
    jni$_.JLongArray? js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt64List(
      reference.pointer,
      _id_echoAsyncNullableInt64List as jni$_.JMethodIDPtr,
      _$js.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLongArray?>(
      const jni$_.$JLongArray$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableFloat64List = _class.instanceMethodId(
    r'echoAsyncNullableFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableFloat64List(aFloat64List: kotlin.DoubleArray?): kotlin.DoubleArray?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray?> echoAsyncNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableFloat64List(
      reference.pointer,
      _id_echoAsyncNullableFloat64List as jni$_.JMethodIDPtr,
      _$ds.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDoubleArray?>(
      const jni$_.$JDoubleArray$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableObject = _class.instanceMethodId(
    r'echoAsyncNullableObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableObject(anObject: kotlin.Any?): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> echoAsyncNullableObject(
    jni$_.JObject? object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableObject(
      reference.pointer,
      _id_echoAsyncNullableObject as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.$JObject$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableList = _class.instanceMethodId(
    r'echoAsyncNullableList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableList(list: kotlin.collections.List<kotlin.Any?>?): kotlin.collections.List<kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>?> echoAsyncNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableList(
      reference.pointer,
      _id_echoAsyncNullableList as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumList = _class.instanceMethodId(
    r'echoAsyncNullableEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableEnumList(enumList: kotlin.collections.List<NIAnEnum?>?): kotlin.collections.List<NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAnEnum?>?> echoAsyncNullableEnumList(
    jni$_.JList<NIAnEnum?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumList(
      reference.pointer,
      _id_echoAsyncNullableEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<NIAnEnum?>?>(
      const jni$_.$JList$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassList = _class.instanceMethodId(
    r'echoAsyncNullableClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableClassList(classList: kotlin.collections.List<NIAllNullableTypes?>?): kotlin.collections.List<NIAllNullableTypes?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAllNullableTypes?>?> echoAsyncNullableClassList(
    jni$_.JList<NIAllNullableTypes?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassList(
      reference.pointer,
      _id_echoAsyncNullableClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<NIAllNullableTypes?>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypes?>(
        $NIAllNullableTypes$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableMap = _class.instanceMethodId(
    r'echoAsyncNullableMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableMap(map: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>
  echoAsyncNullableMap(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableMap(
      reference.pointer,
      _id_echoAsyncNullableMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableStringMap = _class.instanceMethodId(
    r'echoAsyncNullableStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableStringMap(stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>?): kotlin.collections.Map<kotlin.String?, kotlin.String?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>
  echoAsyncNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableStringMap(
      reference.pointer,
      _id_echoAsyncNullableStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableIntMap = _class.instanceMethodId(
    r'echoAsyncNullableIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableIntMap(intMap: kotlin.collections.Map<kotlin.Long?, kotlin.Long?>?): kotlin.collections.Map<kotlin.Long?, kotlin.Long?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>
  echoAsyncNullableIntMap(jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableIntMap(
      reference.pointer,
      _id_echoAsyncNullableIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumMap = _class.instanceMethodId(
    r'echoAsyncNullableEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableEnumMap(enumMap: kotlin.collections.Map<NIAnEnum?, NIAnEnum?>?): kotlin.collections.Map<NIAnEnum?, NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<NIAnEnum?, NIAnEnum?>?> echoAsyncNullableEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumMap(
      reference.pointer,
      _id_echoAsyncNullableEnumMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
      const jni$_.$JMap$NullableType$<NIAnEnum?, NIAnEnum?>(
        $NIAnEnum$NullableType$(),
        $NIAnEnum$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassMap = _class.instanceMethodId(
    r'echoAsyncNullableClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableClassMap(classMap: kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>?): kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>
  echoAsyncNullableClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassMap(
      reference.pointer,
      _id_echoAsyncNullableClassMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, NIAllNullableTypes?>(
        jni$_.$JLong$NullableType$(),
        $NIAllNullableTypes$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnum = _class.instanceMethodId(
    r'echoAsyncNullableEnum',
    r'(LNIAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableEnum(anEnum: NIAnEnum?): NIAnEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnEnum?> echoAsyncNullableEnum(NIAnEnum? nIAnEnum) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnum(
      reference.pointer,
      _id_echoAsyncNullableEnum as jni$_.JMethodIDPtr,
      _$nIAnEnum.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAnEnum?>(
      const $NIAnEnum$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncNullableEnum = _class.instanceMethodId(
    r'echoAnotherAsyncNullableEnum',
    r'(LNIAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAnotherAsyncNullableEnum(anotherEnum: NIAnotherEnum?): NIAnotherEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnotherEnum?> echoAnotherAsyncNullableEnum(
    NIAnotherEnum? nIAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAnotherAsyncNullableEnum(
      reference.pointer,
      _id_echoAnotherAsyncNullableEnum as jni$_.JMethodIDPtr,
      _$nIAnotherEnum.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAnotherEnum?>(
      const $NIAnotherEnum$NullableType$(),
      releaseOriginal: true,
    );
  }
}

final class $NIHostIntegrationCoreApi$NullableType$
    extends jni$_.JType<NIHostIntegrationCoreApi?> {
  @jni$_.internal
  const $NIHostIntegrationCoreApi$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  NIHostIntegrationCoreApi? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : NIHostIntegrationCoreApi.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIHostIntegrationCoreApi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIHostIntegrationCoreApi$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIHostIntegrationCoreApi$NullableType$) &&
        other is $NIHostIntegrationCoreApi$NullableType$;
  }
}

final class $NIHostIntegrationCoreApi$Type$
    extends jni$_.JType<NIHostIntegrationCoreApi> {
  @jni$_.internal
  const $NIHostIntegrationCoreApi$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  NIHostIntegrationCoreApi fromReference(jni$_.JReference reference) =>
      NIHostIntegrationCoreApi.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIHostIntegrationCoreApi?> get nullableType =>
      const $NIHostIntegrationCoreApi$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIHostIntegrationCoreApi$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIHostIntegrationCoreApi$Type$) &&
        other is $NIHostIntegrationCoreApi$Type$;
  }
}

/// from: `NIHostIntegrationCoreApiRegistrar`
class NIHostIntegrationCoreApiRegistrar extends NIHostIntegrationCoreApi {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIHostIntegrationCoreApiRegistrar> $type;

  @jni$_.internal
  NIHostIntegrationCoreApiRegistrar.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'NIHostIntegrationCoreApiRegistrar',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIHostIntegrationCoreApiRegistrar?> nullableType =
      $NIHostIntegrationCoreApiRegistrar$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIHostIntegrationCoreApiRegistrar> type =
      $NIHostIntegrationCoreApiRegistrar$Type$();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIHostIntegrationCoreApiRegistrar() {
    return NIHostIntegrationCoreApiRegistrar.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_getApi = _class.instanceMethodId(
    r'getApi',
    r'()LNIHostIntegrationCoreApi;',
  );

  static final _getApi =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIHostIntegrationCoreApi getApi()`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostIntegrationCoreApi? getApi() {
    return _getApi(
      reference.pointer,
      _id_getApi as jni$_.JMethodIDPtr,
    ).object<NIHostIntegrationCoreApi?>(
      const $NIHostIntegrationCoreApi$NullableType$(),
    );
  }

  static final _id_setApi = _class.instanceMethodId(
    r'setApi',
    r'(LNIHostIntegrationCoreApi;)V',
  );

  static final _setApi =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void setApi(NIHostIntegrationCoreApi nIHostIntegrationCoreApi)`
  void setApi(NIHostIntegrationCoreApi? nIHostIntegrationCoreApi) {
    final _$nIHostIntegrationCoreApi =
        nIHostIntegrationCoreApi?.reference ?? jni$_.jNullReference;
    _setApi(
      reference.pointer,
      _id_setApi as jni$_.JMethodIDPtr,
      _$nIHostIntegrationCoreApi.pointer,
    ).check();
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(LNIHostIntegrationCoreApi;Ljava/lang/String;)LNIHostIntegrationCoreApiRegistrar;',
  );

  static final _register =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun register(api: NIHostIntegrationCoreApi, name: kotlin.String): NIHostIntegrationCoreApiRegistrar`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostIntegrationCoreApiRegistrar register(
    NIHostIntegrationCoreApi nIHostIntegrationCoreApi,
    jni$_.JString string,
  ) {
    final _$nIHostIntegrationCoreApi = nIHostIntegrationCoreApi.reference;
    final _$string = string.reference;
    return _register(
      reference.pointer,
      _id_register as jni$_.JMethodIDPtr,
      _$nIHostIntegrationCoreApi.pointer,
      _$string.pointer,
    ).object<NIHostIntegrationCoreApiRegistrar>(
      const $NIHostIntegrationCoreApiRegistrar$Type$(),
    );
  }

  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Ljava/lang/String;)LNIHostIntegrationCoreApiRegistrar;',
  );

  static final _getInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun getInstance(name: kotlin.String): NIHostIntegrationCoreApiRegistrar?`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostIntegrationCoreApiRegistrar? getInstance(jni$_.JString string) {
    final _$string = string.reference;
    return _getInstance(
      reference.pointer,
      _id_getInstance as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<NIHostIntegrationCoreApiRegistrar?>(
      const $NIHostIntegrationCoreApiRegistrar$NullableType$(),
    );
  }

  static final _id_noop = _class.instanceMethodId(r'noop', r'()V');

  static final _noop =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun noop(): kotlin.Unit`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }

  static final _id_echoAllTypes = _class.instanceMethodId(
    r'echoAllTypes',
    r'(LNIAllTypes;)LNIAllTypes;',
  );

  static final _echoAllTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAllTypes(everything: NIAllTypes): NIAllTypes`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes echoAllTypes(NIAllTypes nIAllTypes) {
    final _$nIAllTypes = nIAllTypes.reference;
    return _echoAllTypes(
      reference.pointer,
      _id_echoAllTypes as jni$_.JMethodIDPtr,
      _$nIAllTypes.pointer,
    ).object<NIAllTypes>(const $NIAllTypes$Type$());
  }

  static final _id_throwError = _class.instanceMethodId(
    r'throwError',
    r'()Ljava/lang/Object;',
  );

  static final _throwError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun throwError(): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwError() {
    return _throwError(
      reference.pointer,
      _id_throwError as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_throwErrorFromVoid = _class.instanceMethodId(
    r'throwErrorFromVoid',
    r'()V',
  );

  static final _throwErrorFromVoid =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun throwErrorFromVoid(): kotlin.Unit`
  void throwErrorFromVoid() {
    _throwErrorFromVoid(
      reference.pointer,
      _id_throwErrorFromVoid as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_throwFlutterError = _class.instanceMethodId(
    r'throwFlutterError',
    r'()Ljava/lang/Object;',
  );

  static final _throwFlutterError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun throwFlutterError(): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwFlutterError() {
    return _throwFlutterError(
      reference.pointer,
      _id_throwFlutterError as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_echoInt = _class.instanceMethodId(r'echoInt', r'(J)J');

  static final _echoInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public fun echoInt(anInt: kotlin.Long): kotlin.Long`
  int echoInt(int j) {
    return _echoInt(
      reference.pointer,
      _id_echoInt as jni$_.JMethodIDPtr,
      j,
    ).long;
  }

  static final _id_echoDouble = _class.instanceMethodId(r'echoDouble', r'(D)D');

  static final _echoDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public fun echoDouble(aDouble: kotlin.Double): kotlin.Double`
  double echoDouble(double d) {
    return _echoDouble(
      reference.pointer,
      _id_echoDouble as jni$_.JMethodIDPtr,
      d,
    ).doubleFloat;
  }

  static final _id_echoBool = _class.instanceMethodId(r'echoBool', r'(Z)Z');

  static final _echoBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public fun echoBool(aBool: kotlin.Boolean): kotlin.Boolean`
  core$_.bool echoBool(core$_.bool z) {
    return _echoBool(
      reference.pointer,
      _id_echoBool as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_echoString = _class.instanceMethodId(
    r'echoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoString(aString: kotlin.String): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoString(jni$_.JString string) {
    final _$string = string.reference;
    return _echoString(
      reference.pointer,
      _id_echoString as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_echoUint8List = _class.instanceMethodId(
    r'echoUint8List',
    r'([B)[B',
  );

  static final _echoUint8List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoUint8List(aUint8List: kotlin.ByteArray): kotlin.ByteArray`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray echoUint8List(jni$_.JByteArray bs) {
    final _$bs = bs.reference;
    return _echoUint8List(
      reference.pointer,
      _id_echoUint8List as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).object<jni$_.JByteArray>(const jni$_.$JByteArray$Type$());
  }

  static final _id_echoInt32List = _class.instanceMethodId(
    r'echoInt32List',
    r'([I)[I',
  );

  static final _echoInt32List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoInt32List(aInt32List: kotlin.IntArray): kotlin.IntArray`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray echoInt32List(jni$_.JIntArray is$) {
    final _$is$ = is$.reference;
    return _echoInt32List(
      reference.pointer,
      _id_echoInt32List as jni$_.JMethodIDPtr,
      _$is$.pointer,
    ).object<jni$_.JIntArray>(const jni$_.$JIntArray$Type$());
  }

  static final _id_echoInt64List = _class.instanceMethodId(
    r'echoInt64List',
    r'([J)[J',
  );

  static final _echoInt64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoInt64List(aInt64List: kotlin.LongArray): kotlin.LongArray`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray echoInt64List(jni$_.JLongArray js) {
    final _$js = js.reference;
    return _echoInt64List(
      reference.pointer,
      _id_echoInt64List as jni$_.JMethodIDPtr,
      _$js.pointer,
    ).object<jni$_.JLongArray>(const jni$_.$JLongArray$Type$());
  }

  static final _id_echoFloat64List = _class.instanceMethodId(
    r'echoFloat64List',
    r'([D)[D',
  );

  static final _echoFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoFloat64List(aFloat64List: kotlin.DoubleArray): kotlin.DoubleArray`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray echoFloat64List(jni$_.JDoubleArray ds) {
    final _$ds = ds.reference;
    return _echoFloat64List(
      reference.pointer,
      _id_echoFloat64List as jni$_.JMethodIDPtr,
      _$ds.pointer,
    ).object<jni$_.JDoubleArray>(const jni$_.$JDoubleArray$Type$());
  }

  static final _id_echoObject = _class.instanceMethodId(
    r'echoObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoObject(anObject: kotlin.Any): kotlin.Any`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject echoObject(jni$_.JObject object) {
    final _$object = object.reference;
    return _echoObject(
      reference.pointer,
      _id_echoObject as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_echoList = _class.instanceMethodId(
    r'echoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoList(list: kotlin.collections.List<kotlin.Any?>): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> echoList(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _echoList(
      reference.pointer,
      _id_echoList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_echoStringList = _class.instanceMethodId(
    r'echoStringList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoStringList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoStringList(stringList: kotlin.collections.List<kotlin.String?>): kotlin.collections.List<kotlin.String?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> echoStringList(jni$_.JList<jni$_.JString?> list) {
    final _$list = list.reference;
    return _echoStringList(
      reference.pointer,
      _id_echoStringList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JString?>>(
      const jni$_.$JList$Type$<jni$_.JString?>(jni$_.$JString$NullableType$()),
    );
  }

  static final _id_echoIntList = _class.instanceMethodId(
    r'echoIntList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoIntList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoIntList(intList: kotlin.collections.List<kotlin.Long?>): kotlin.collections.List<kotlin.Long?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?> echoIntList(jni$_.JList<jni$_.JLong?> list) {
    final _$list = list.reference;
    return _echoIntList(
      reference.pointer,
      _id_echoIntList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JLong?>>(
      const jni$_.$JList$Type$<jni$_.JLong?>(jni$_.$JLong$NullableType$()),
    );
  }

  static final _id_echoDoubleList = _class.instanceMethodId(
    r'echoDoubleList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoDoubleList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoDoubleList(doubleList: kotlin.collections.List<kotlin.Double?>): kotlin.collections.List<kotlin.Double?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?> echoDoubleList(jni$_.JList<jni$_.JDouble?> list) {
    final _$list = list.reference;
    return _echoDoubleList(
      reference.pointer,
      _id_echoDoubleList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JDouble?>>(
      const jni$_.$JList$Type$<jni$_.JDouble?>(jni$_.$JDouble$NullableType$()),
    );
  }

  static final _id_echoBoolList = _class.instanceMethodId(
    r'echoBoolList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoBoolList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoBoolList(boolList: kotlin.collections.List<kotlin.Boolean?>): kotlin.collections.List<kotlin.Boolean?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?> echoBoolList(jni$_.JList<jni$_.JBoolean?> list) {
    final _$list = list.reference;
    return _echoBoolList(
      reference.pointer,
      _id_echoBoolList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JBoolean?>>(
      const jni$_.$JList$Type$<jni$_.JBoolean?>(
        jni$_.$JBoolean$NullableType$(),
      ),
    );
  }

  static final _id_echoEnumList = _class.instanceMethodId(
    r'echoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoEnumList(enumList: kotlin.collections.List<NIAnEnum?>): kotlin.collections.List<NIAnEnum?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?> echoEnumList(jni$_.JList<NIAnEnum?> list) {
    final _$list = list.reference;
    return _echoEnumList(
      reference.pointer,
      _id_echoEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum?>>(
      const jni$_.$JList$Type$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_echoClassList = _class.instanceMethodId(
    r'echoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoClassList(classList: kotlin.collections.List<NIAllNullableTypes?>): kotlin.collections.List<NIAllNullableTypes?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?> echoClassList(
    jni$_.JList<NIAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _echoClassList(
      reference.pointer,
      _id_echoClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypes?>>(
      const jni$_.$JList$Type$<NIAllNullableTypes?>(
        $NIAllNullableTypes$NullableType$(),
      ),
    );
  }

  static final _id_echoNonNullEnumList = _class.instanceMethodId(
    r'echoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullEnumList(enumList: kotlin.collections.List<NIAnEnum>): kotlin.collections.List<NIAnEnum>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> echoNonNullEnumList(jni$_.JList<NIAnEnum> list) {
    final _$list = list.reference;
    return _echoNonNullEnumList(
      reference.pointer,
      _id_echoNonNullEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum>>(
      const jni$_.$JList$Type$<NIAnEnum>($NIAnEnum$Type$()),
    );
  }

  static final _id_echoNonNullClassList = _class.instanceMethodId(
    r'echoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullClassList(classList: kotlin.collections.List<NIAllNullableTypes>): kotlin.collections.List<NIAllNullableTypes>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes> echoNonNullClassList(
    jni$_.JList<NIAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullClassList(
      reference.pointer,
      _id_echoNonNullClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypes>>(
      const jni$_.$JList$Type$<NIAllNullableTypes>($NIAllNullableTypes$Type$()),
    );
  }

  static final _id_echoMap = _class.instanceMethodId(
    r'echoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoMap(map: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _echoMap(
      reference.pointer,
      _id_echoMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
      const jni$_.$JMap$Type$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_echoStringMap = _class.instanceMethodId(
    r'echoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoStringMap(stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>): kotlin.collections.Map<kotlin.String?, kotlin.String?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _echoStringMap(
      reference.pointer,
      _id_echoStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
      const jni$_.$JMap$Type$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_echoIntMap = _class.instanceMethodId(
    r'echoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoIntMap(intMap: kotlin.collections.Map<kotlin.Long?, kotlin.Long?>): kotlin.collections.Map<kotlin.Long?, kotlin.Long?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _echoIntMap(
      reference.pointer,
      _id_echoIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
      const jni$_.$JMap$Type$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_echoEnumMap = _class.instanceMethodId(
    r'echoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoEnumMap(enumMap: kotlin.collections.Map<NIAnEnum?, NIAnEnum?>): kotlin.collections.Map<NIAnEnum?, NIAnEnum?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?> echoEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _echoEnumMap(
      reference.pointer,
      _id_echoEnumMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<NIAnEnum?, NIAnEnum?>>(
      const jni$_.$JMap$Type$<NIAnEnum?, NIAnEnum?>(
        $NIAnEnum$NullableType$(),
        $NIAnEnum$NullableType$(),
      ),
    );
  }

  static final _id_echoClassMap = _class.instanceMethodId(
    r'echoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoClassMap(classMap: kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>): kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> echoClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _echoClassMap(
      reference.pointer,
      _id_echoClassMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>(
      const jni$_.$JMap$Type$<jni$_.JLong?, NIAllNullableTypes?>(
        jni$_.$JLong$NullableType$(),
        $NIAllNullableTypes$NullableType$(),
      ),
    );
  }

  static final _id_echoNonNullStringMap = _class.instanceMethodId(
    r'echoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullStringMap(stringMap: kotlin.collections.Map<kotlin.String, kotlin.String>): kotlin.collections.Map<kotlin.String, kotlin.String>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullStringMap(
      reference.pointer,
      _id_echoNonNullStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
      const jni$_.$JMap$Type$<jni$_.JString, jni$_.JString>(
        jni$_.$JString$Type$(),
        jni$_.$JString$Type$(),
      ),
    );
  }

  static final _id_echoNonNullIntMap = _class.instanceMethodId(
    r'echoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullIntMap(intMap: kotlin.collections.Map<kotlin.Long, kotlin.Long>): kotlin.collections.Map<kotlin.Long, kotlin.Long>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullIntMap(
      reference.pointer,
      _id_echoNonNullIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
      const jni$_.$JMap$Type$<jni$_.JLong, jni$_.JLong>(
        jni$_.$JLong$Type$(),
        jni$_.$JLong$Type$(),
      ),
    );
  }

  static final _id_echoNonNullEnumMap = _class.instanceMethodId(
    r'echoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullEnumMap(enumMap: kotlin.collections.Map<NIAnEnum, NIAnEnum>): kotlin.collections.Map<NIAnEnum, NIAnEnum>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum> echoNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullEnumMap(
      reference.pointer,
      _id_echoNonNullEnumMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<NIAnEnum, NIAnEnum>>(
      const jni$_.$JMap$Type$<NIAnEnum, NIAnEnum>(
        $NIAnEnum$Type$(),
        $NIAnEnum$Type$(),
      ),
    );
  }

  static final _id_echoNonNullClassMap = _class.instanceMethodId(
    r'echoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullClassMap(classMap: kotlin.collections.Map<kotlin.Long, NIAllNullableTypes>): kotlin.collections.Map<kotlin.Long, NIAllNullableTypes>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes> echoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullClassMap(
      reference.pointer,
      _id_echoNonNullClassMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>>(
      const jni$_.$JMap$Type$<jni$_.JLong, NIAllNullableTypes>(
        jni$_.$JLong$Type$(),
        $NIAllNullableTypes$Type$(),
      ),
    );
  }

  static final _id_echoClassWrapper = _class.instanceMethodId(
    r'echoClassWrapper',
    r'(LNIAllClassesWrapper;)LNIAllClassesWrapper;',
  );

  static final _echoClassWrapper =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoClassWrapper(wrapper: NIAllClassesWrapper): NIAllClassesWrapper`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper echoClassWrapper(
    NIAllClassesWrapper nIAllClassesWrapper,
  ) {
    final _$nIAllClassesWrapper = nIAllClassesWrapper.reference;
    return _echoClassWrapper(
      reference.pointer,
      _id_echoClassWrapper as jni$_.JMethodIDPtr,
      _$nIAllClassesWrapper.pointer,
    ).object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type$());
  }

  static final _id_echoEnum = _class.instanceMethodId(
    r'echoEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoEnum(anEnum: NIAnEnum): NIAnEnum`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum echoEnum(NIAnEnum nIAnEnum) {
    final _$nIAnEnum = nIAnEnum.reference;
    return _echoEnum(
      reference.pointer,
      _id_echoEnum as jni$_.JMethodIDPtr,
      _$nIAnEnum.pointer,
    ).object<NIAnEnum>(const $NIAnEnum$Type$());
  }

  static final _id_echoAnotherEnum = _class.instanceMethodId(
    r'echoAnotherEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoAnotherEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAnotherEnum(anotherEnum: NIAnotherEnum): NIAnotherEnum`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum echoAnotherEnum(NIAnotherEnum nIAnotherEnum) {
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    return _echoAnotherEnum(
      reference.pointer,
      _id_echoAnotherEnum as jni$_.JMethodIDPtr,
      _$nIAnotherEnum.pointer,
    ).object<NIAnotherEnum>(const $NIAnotherEnum$Type$());
  }

  static final _id_echoAllNullableTypes = _class.instanceMethodId(
    r'echoAllNullableTypes',
    r'(LNIAllNullableTypes;)LNIAllNullableTypes;',
  );

  static final _echoAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAllNullableTypes(everything: NIAllNullableTypes?): NIAllNullableTypes?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes? echoAllNullableTypes(
    NIAllNullableTypes? nIAllNullableTypes,
  ) {
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypes(
      reference.pointer,
      _id_echoAllNullableTypes as jni$_.JMethodIDPtr,
      _$nIAllNullableTypes.pointer,
    ).object<NIAllNullableTypes?>(const $NIAllNullableTypes$NullableType$());
  }

  static final _id_echoAllNullableTypesWithoutRecursion = _class.instanceMethodId(
    r'echoAllNullableTypesWithoutRecursion',
    r'(LNIAllNullableTypesWithoutRecursion;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _echoAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAllNullableTypesWithoutRecursion(everything: NIAllNullableTypesWithoutRecursion?): NIAllNullableTypesWithoutRecursion?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion? echoAllNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
  ) {
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypesWithoutRecursion(
      reference.pointer,
      _id_echoAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
      _$nIAllNullableTypesWithoutRecursion.pointer,
    ).object<NIAllNullableTypesWithoutRecursion?>(
      const $NIAllNullableTypesWithoutRecursion$NullableType$(),
    );
  }

  static final _id_extractNestedNullableString = _class.instanceMethodId(
    r'extractNestedNullableString',
    r'(LNIAllClassesWrapper;)Ljava/lang/String;',
  );

  static final _extractNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun extractNestedNullableString(wrapper: NIAllClassesWrapper): kotlin.String?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? extractNestedNullableString(
    NIAllClassesWrapper nIAllClassesWrapper,
  ) {
    final _$nIAllClassesWrapper = nIAllClassesWrapper.reference;
    return _extractNestedNullableString(
      reference.pointer,
      _id_extractNestedNullableString as jni$_.JMethodIDPtr,
      _$nIAllClassesWrapper.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_createNestedNullableString = _class.instanceMethodId(
    r'createNestedNullableString',
    r'(Ljava/lang/String;)LNIAllClassesWrapper;',
  );

  static final _createNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun createNestedNullableString(nullableString: kotlin.String?): NIAllClassesWrapper`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper createNestedNullableString(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createNestedNullableString(
      reference.pointer,
      _id_createNestedNullableString as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type$());
  }

  static final _id_sendMultipleNullableTypes = _class.instanceMethodId(
    r'sendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypes;',
  );

  static final _sendMultipleNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun sendMultipleNullableTypes(aNullableBool: kotlin.Boolean?, aNullableInt: kotlin.Long?, aNullableString: kotlin.String?): NIAllNullableTypes`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes sendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypes(
      reference.pointer,
      _id_sendMultipleNullableTypes as jni$_.JMethodIDPtr,
      _$boolean.pointer,
      _$long.pointer,
      _$string.pointer,
    ).object<NIAllNullableTypes>(const $NIAllNullableTypes$Type$());
  }

  static final _id_sendMultipleNullableTypesWithoutRecursion = _class
      .instanceMethodId(
        r'sendMultipleNullableTypesWithoutRecursion',
        r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypesWithoutRecursion;',
      );

  static final _sendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun sendMultipleNullableTypesWithoutRecursion(aNullableBool: kotlin.Boolean?, aNullableInt: kotlin.Long?, aNullableString: kotlin.String?): NIAllNullableTypesWithoutRecursion`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypesWithoutRecursion(
      reference.pointer,
      _id_sendMultipleNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
      _$boolean.pointer,
      _$long.pointer,
      _$string.pointer,
    ).object<NIAllNullableTypesWithoutRecursion>(
      const $NIAllNullableTypesWithoutRecursion$Type$(),
    );
  }

  static final _id_echoNullableInt = _class.instanceMethodId(
    r'echoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoNullableInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableInt(aNullableInt: kotlin.Long?): kotlin.Long?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoNullableInt(jni$_.JLong? long) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoNullableInt(
      reference.pointer,
      _id_echoNullableInt as jni$_.JMethodIDPtr,
      _$long.pointer,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_echoNullableDouble = _class.instanceMethodId(
    r'echoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _echoNullableDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableDouble(aNullableDouble: kotlin.Double?): kotlin.Double?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? echoNullableDouble(jni$_.JDouble? double) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _echoNullableDouble(
      reference.pointer,
      _id_echoNullableDouble as jni$_.JMethodIDPtr,
      _$double.pointer,
    ).object<jni$_.JDouble?>(const jni$_.$JDouble$NullableType$());
  }

  static final _id_echoNullableBool = _class.instanceMethodId(
    r'echoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _echoNullableBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableBool(aNullableBool: kotlin.Boolean?): kotlin.Boolean?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? echoNullableBool(jni$_.JBoolean? boolean) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _echoNullableBool(
      reference.pointer,
      _id_echoNullableBool as jni$_.JMethodIDPtr,
      _$boolean.pointer,
    ).object<jni$_.JBoolean?>(const jni$_.$JBoolean$NullableType$());
  }

  static final _id_echoNullableString = _class.instanceMethodId(
    r'echoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableString(aNullableString: kotlin.String?): kotlin.String?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNullableString(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNullableString(
      reference.pointer,
      _id_echoNullableString as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_echoNullableUint8List = _class.instanceMethodId(
    r'echoNullableUint8List',
    r'([B)[B',
  );

  static final _echoNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableUint8List(aNullableUint8List: kotlin.ByteArray?): kotlin.ByteArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? echoNullableUint8List(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _echoNullableUint8List(
      reference.pointer,
      _id_echoNullableUint8List as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).object<jni$_.JByteArray?>(const jni$_.$JByteArray$NullableType$());
  }

  static final _id_echoNullableInt32List = _class.instanceMethodId(
    r'echoNullableInt32List',
    r'([I)[I',
  );

  static final _echoNullableInt32List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableInt32List(aNullableInt32List: kotlin.IntArray?): kotlin.IntArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? echoNullableInt32List(jni$_.JIntArray? is$) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _echoNullableInt32List(
      reference.pointer,
      _id_echoNullableInt32List as jni$_.JMethodIDPtr,
      _$is$.pointer,
    ).object<jni$_.JIntArray?>(const jni$_.$JIntArray$NullableType$());
  }

  static final _id_echoNullableInt64List = _class.instanceMethodId(
    r'echoNullableInt64List',
    r'([J)[J',
  );

  static final _echoNullableInt64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableInt64List(aNullableInt64List: kotlin.LongArray?): kotlin.LongArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? echoNullableInt64List(jni$_.JLongArray? js) {
    final _$js = js?.reference ?? jni$_.jNullReference;
    return _echoNullableInt64List(
      reference.pointer,
      _id_echoNullableInt64List as jni$_.JMethodIDPtr,
      _$js.pointer,
    ).object<jni$_.JLongArray?>(const jni$_.$JLongArray$NullableType$());
  }

  static final _id_echoNullableFloat64List = _class.instanceMethodId(
    r'echoNullableFloat64List',
    r'([D)[D',
  );

  static final _echoNullableFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableFloat64List(aNullableFloat64List: kotlin.DoubleArray?): kotlin.DoubleArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? echoNullableFloat64List(jni$_.JDoubleArray? ds) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    return _echoNullableFloat64List(
      reference.pointer,
      _id_echoNullableFloat64List as jni$_.JMethodIDPtr,
      _$ds.pointer,
    ).object<jni$_.JDoubleArray?>(const jni$_.$JDoubleArray$NullableType$());
  }

  static final _id_echoNullableObject = _class.instanceMethodId(
    r'echoNullableObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoNullableObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableObject(aNullableObject: kotlin.Any?): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? echoNullableObject(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _echoNullableObject(
      reference.pointer,
      _id_echoNullableObject as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_echoNullableList = _class.instanceMethodId(
    r'echoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableList(aNullableList: kotlin.collections.List<kotlin.Any?>?): kotlin.collections.List<kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? echoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableList(
      reference.pointer,
      _id_echoNullableList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableEnumList = _class.instanceMethodId(
    r'echoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableEnumList(enumList: kotlin.collections.List<NIAnEnum?>?): kotlin.collections.List<NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? echoNullableEnumList(jni$_.JList<NIAnEnum?>? list) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumList(
      reference.pointer,
      _id_echoNullableEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum?>?>(
      const jni$_.$JList$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_echoNullableClassList = _class.instanceMethodId(
    r'echoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableClassList(classList: kotlin.collections.List<NIAllNullableTypes?>?): kotlin.collections.List<NIAllNullableTypes?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?>? echoNullableClassList(
    jni$_.JList<NIAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableClassList(
      reference.pointer,
      _id_echoNullableClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypes?>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypes?>(
        $NIAllNullableTypes$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableNonNullEnumList = _class.instanceMethodId(
    r'echoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullEnumList(enumList: kotlin.collections.List<NIAnEnum>?): kotlin.collections.List<NIAnEnum>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum>? echoNullableNonNullEnumList(
    jni$_.JList<NIAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumList(
      reference.pointer,
      _id_echoNullableNonNullEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum>?>(
      const jni$_.$JList$NullableType$<NIAnEnum>($NIAnEnum$Type$()),
    );
  }

  static final _id_echoNullableNonNullClassList = _class.instanceMethodId(
    r'echoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullClassList(classList: kotlin.collections.List<NIAllNullableTypes>?): kotlin.collections.List<NIAllNullableTypes>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes>? echoNullableNonNullClassList(
    jni$_.JList<NIAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassList(
      reference.pointer,
      _id_echoNullableNonNullClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypes>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypes>(
        $NIAllNullableTypes$Type$(),
      ),
    );
  }

  static final _id_echoNullableMap = _class.instanceMethodId(
    r'echoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableMap(map: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableMap(
      reference.pointer,
      _id_echoNullableMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableStringMap = _class.instanceMethodId(
    r'echoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableStringMap(stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>?): kotlin.collections.Map<kotlin.String?, kotlin.String?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableStringMap(
      reference.pointer,
      _id_echoNullableStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableIntMap = _class.instanceMethodId(
    r'echoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableIntMap(intMap: kotlin.collections.Map<kotlin.Long?, kotlin.Long?>?): kotlin.collections.Map<kotlin.Long?, kotlin.Long?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableIntMap(
      reference.pointer,
      _id_echoNullableIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableEnumMap = _class.instanceMethodId(
    r'echoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableEnumMap(enumMap: kotlin.collections.Map<NIAnEnum?, NIAnEnum?>?): kotlin.collections.Map<NIAnEnum?, NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? echoNullableEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumMap(
      reference.pointer,
      _id_echoNullableEnumMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
      const jni$_.$JMap$NullableType$<NIAnEnum?, NIAnEnum?>(
        $NIAnEnum$NullableType$(),
        $NIAnEnum$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableClassMap = _class.instanceMethodId(
    r'echoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableClassMap(classMap: kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>?): kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? echoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableClassMap(
      reference.pointer,
      _id_echoNullableClassMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, NIAllNullableTypes?>(
        jni$_.$JLong$NullableType$(),
        $NIAllNullableTypes$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableNonNullStringMap = _class.instanceMethodId(
    r'echoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullStringMap(stringMap: kotlin.collections.Map<kotlin.String, kotlin.String>?): kotlin.collections.Map<kotlin.String, kotlin.String>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullStringMap(
      reference.pointer,
      _id_echoNullableNonNullStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString, jni$_.JString>(
        jni$_.$JString$Type$(),
        jni$_.$JString$Type$(),
      ),
    );
  }

  static final _id_echoNullableNonNullIntMap = _class.instanceMethodId(
    r'echoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullIntMap(intMap: kotlin.collections.Map<kotlin.Long, kotlin.Long>?): kotlin.collections.Map<kotlin.Long, kotlin.Long>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullIntMap(
      reference.pointer,
      _id_echoNullableNonNullIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong, jni$_.JLong>(
        jni$_.$JLong$Type$(),
        jni$_.$JLong$Type$(),
      ),
    );
  }

  static final _id_echoNullableNonNullEnumMap = _class.instanceMethodId(
    r'echoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullEnumMap(enumMap: kotlin.collections.Map<NIAnEnum, NIAnEnum>?): kotlin.collections.Map<NIAnEnum, NIAnEnum>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum>? echoNullableNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumMap(
      reference.pointer,
      _id_echoNullableNonNullEnumMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<NIAnEnum, NIAnEnum>?>(
      const jni$_.$JMap$NullableType$<NIAnEnum, NIAnEnum>(
        $NIAnEnum$Type$(),
        $NIAnEnum$Type$(),
      ),
    );
  }

  static final _id_echoNullableNonNullClassMap = _class.instanceMethodId(
    r'echoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullClassMap(classMap: kotlin.collections.Map<kotlin.Long, NIAllNullableTypes>?): kotlin.collections.Map<kotlin.Long, NIAllNullableTypes>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? echoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassMap(
      reference.pointer,
      _id_echoNullableNonNullClassMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong, NIAllNullableTypes>(
        jni$_.$JLong$Type$(),
        $NIAllNullableTypes$Type$(),
      ),
    );
  }

  static final _id_echoNullableEnum = _class.instanceMethodId(
    r'echoNullableEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableEnum(anEnum: NIAnEnum?): NIAnEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? echoNullableEnum(NIAnEnum? nIAnEnum) {
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    return _echoNullableEnum(
      reference.pointer,
      _id_echoNullableEnum as jni$_.JMethodIDPtr,
      _$nIAnEnum.pointer,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_echoAnotherNullableEnum = _class.instanceMethodId(
    r'echoAnotherNullableEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoAnotherNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAnotherNullableEnum(anotherEnum: NIAnotherEnum?): NIAnotherEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? echoAnotherNullableEnum(NIAnotherEnum? nIAnotherEnum) {
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    return _echoAnotherNullableEnum(
      reference.pointer,
      _id_echoAnotherNullableEnum as jni$_.JMethodIDPtr,
      _$nIAnotherEnum.pointer,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }

  static final _id_noopAsync = _class.instanceMethodId(
    r'noopAsync',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _noopAsync =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun noopAsync(): kotlin.Unit`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> noopAsync() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _noopAsync(
      reference.pointer,
      _id_noopAsync as jni$_.JMethodIDPtr,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.$JObject$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt = _class.instanceMethodId(
    r'echoAsyncInt',
    r'(JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncInt(anInt: kotlin.Long): kotlin.Long`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong> echoAsyncInt(int j) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncInt(
      reference.pointer,
      _id_echoAsyncInt as jni$_.JMethodIDPtr,
      j,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLong>(
      const jni$_.$JLong$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncDouble = _class.instanceMethodId(
    r'echoAsyncDouble',
    r'(DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncDouble(aDouble: kotlin.Double): kotlin.Double`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble> echoAsyncDouble(double d) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncDouble(
      reference.pointer,
      _id_echoAsyncDouble as jni$_.JMethodIDPtr,
      d,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDouble>(
      const jni$_.$JDouble$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncBool = _class.instanceMethodId(
    r'echoAsyncBool',
    r'(ZLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncBool(aBool: kotlin.Boolean): kotlin.Boolean`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean> echoAsyncBool(core$_.bool z) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncBool(
      reference.pointer,
      _id_echoAsyncBool as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JBoolean>(
      const jni$_.$JBoolean$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncString = _class.instanceMethodId(
    r'echoAsyncString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncString(aString: kotlin.String): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echoAsyncString(jni$_.JString string) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echoAsyncString(
      reference.pointer,
      _id_echoAsyncString as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.$JString$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncUint8List = _class.instanceMethodId(
    r'echoAsyncUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncUint8List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncUint8List(aUint8List: kotlin.ByteArray): kotlin.ByteArray`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray> echoAsyncUint8List(
    jni$_.JByteArray bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs.reference;
    final $r = _echoAsyncUint8List(
      reference.pointer,
      _id_echoAsyncUint8List as jni$_.JMethodIDPtr,
      _$bs.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JByteArray>(
      const jni$_.$JByteArray$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt32List = _class.instanceMethodId(
    r'echoAsyncInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt32List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncInt32List(aInt32List: kotlin.IntArray): kotlin.IntArray`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray> echoAsyncInt32List(jni$_.JIntArray is$) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$.reference;
    final $r = _echoAsyncInt32List(
      reference.pointer,
      _id_echoAsyncInt32List as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JIntArray>(
      const jni$_.$JIntArray$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt64List = _class.instanceMethodId(
    r'echoAsyncInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncInt64List(aInt64List: kotlin.LongArray): kotlin.LongArray`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray> echoAsyncInt64List(
    jni$_.JLongArray js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js.reference;
    final $r = _echoAsyncInt64List(
      reference.pointer,
      _id_echoAsyncInt64List as jni$_.JMethodIDPtr,
      _$js.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLongArray>(
      const jni$_.$JLongArray$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncFloat64List = _class.instanceMethodId(
    r'echoAsyncFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncFloat64List(aFloat64List: kotlin.DoubleArray): kotlin.DoubleArray`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray> echoAsyncFloat64List(
    jni$_.JDoubleArray ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds.reference;
    final $r = _echoAsyncFloat64List(
      reference.pointer,
      _id_echoAsyncFloat64List as jni$_.JMethodIDPtr,
      _$ds.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDoubleArray>(
      const jni$_.$JDoubleArray$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncObject = _class.instanceMethodId(
    r'echoAsyncObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncObject(anObject: kotlin.Any): kotlin.Any`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> echoAsyncObject(jni$_.JObject object) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object.reference;
    final $r = _echoAsyncObject(
      reference.pointer,
      _id_echoAsyncObject as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.$JObject$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncList = _class.instanceMethodId(
    r'echoAsyncList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncList(list: kotlin.collections.List<kotlin.Any?>): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>> echoAsyncList(
    jni$_.JList<jni$_.JObject?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncList(
      reference.pointer,
      _id_echoAsyncList as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumList = _class.instanceMethodId(
    r'echoAsyncEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncEnumList(enumList: kotlin.collections.List<NIAnEnum?>): kotlin.collections.List<NIAnEnum?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAnEnum?>> echoAsyncEnumList(
    jni$_.JList<NIAnEnum?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncEnumList(
      reference.pointer,
      _id_echoAsyncEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<NIAnEnum?>>(
      const jni$_.$JList$Type$<NIAnEnum?>($NIAnEnum$NullableType$()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassList = _class.instanceMethodId(
    r'echoAsyncClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncClassList(classList: kotlin.collections.List<NIAllNullableTypes?>): kotlin.collections.List<NIAllNullableTypes?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAllNullableTypes?>> echoAsyncClassList(
    jni$_.JList<NIAllNullableTypes?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncClassList(
      reference.pointer,
      _id_echoAsyncClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<NIAllNullableTypes?>>(
      const jni$_.$JList$Type$<NIAllNullableTypes?>(
        $NIAllNullableTypes$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncMap = _class.instanceMethodId(
    r'echoAsyncMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncMap(map: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> echoAsyncMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncMap(
      reference.pointer,
      _id_echoAsyncMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
      const jni$_.$JMap$Type$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncStringMap = _class.instanceMethodId(
    r'echoAsyncStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncStringMap(stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>): kotlin.collections.Map<kotlin.String?, kotlin.String?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>> echoAsyncStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncStringMap(
      reference.pointer,
      _id_echoAsyncStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
      const jni$_.$JMap$Type$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncIntMap = _class.instanceMethodId(
    r'echoAsyncIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncIntMap(intMap: kotlin.collections.Map<kotlin.Long?, kotlin.Long?>): kotlin.collections.Map<kotlin.Long?, kotlin.Long?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>> echoAsyncIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncIntMap(
      reference.pointer,
      _id_echoAsyncIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
      const jni$_.$JMap$Type$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumMap = _class.instanceMethodId(
    r'echoAsyncEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncEnumMap(enumMap: kotlin.collections.Map<NIAnEnum?, NIAnEnum?>): kotlin.collections.Map<NIAnEnum?, NIAnEnum?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<NIAnEnum?, NIAnEnum?>> echoAsyncEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncEnumMap(
      reference.pointer,
      _id_echoAsyncEnumMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<NIAnEnum?, NIAnEnum?>>(
      const jni$_.$JMap$Type$<NIAnEnum?, NIAnEnum?>(
        $NIAnEnum$NullableType$(),
        $NIAnEnum$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassMap = _class.instanceMethodId(
    r'echoAsyncClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncClassMap(classMap: kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>): kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>
  echoAsyncClassMap(jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncClassMap(
      reference.pointer,
      _id_echoAsyncClassMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>(
      const jni$_.$JMap$Type$<jni$_.JLong?, NIAllNullableTypes?>(
        jni$_.$JLong$NullableType$(),
        $NIAllNullableTypes$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnum = _class.instanceMethodId(
    r'echoAsyncEnum',
    r'(LNIAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncEnum(anEnum: NIAnEnum): NIAnEnum`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnEnum> echoAsyncEnum(NIAnEnum nIAnEnum) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnEnum = nIAnEnum.reference;
    final $r = _echoAsyncEnum(
      reference.pointer,
      _id_echoAsyncEnum as jni$_.JMethodIDPtr,
      _$nIAnEnum.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<NIAnEnum>(const $NIAnEnum$Type$(), releaseOriginal: true);
  }

  static final _id_echoAnotherAsyncEnum = _class.instanceMethodId(
    r'echoAnotherAsyncEnum',
    r'(LNIAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAnotherAsyncEnum(anotherEnum: NIAnotherEnum): NIAnotherEnum`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnotherEnum> echoAnotherAsyncEnum(
    NIAnotherEnum nIAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    final $r = _echoAnotherAsyncEnum(
      reference.pointer,
      _id_echoAnotherAsyncEnum as jni$_.JMethodIDPtr,
      _$nIAnotherEnum.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<NIAnotherEnum>(
      const $NIAnotherEnum$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncError = _class.instanceMethodId(
    r'throwAsyncError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun throwAsyncError(): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncError(
      reference.pointer,
      _id_throwAsyncError as jni$_.JMethodIDPtr,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.$JObject$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncErrorFromVoid = _class.instanceMethodId(
    r'throwAsyncErrorFromVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncErrorFromVoid =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun throwAsyncErrorFromVoid(): kotlin.Unit`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> throwAsyncErrorFromVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncErrorFromVoid(
      reference.pointer,
      _id_throwAsyncErrorFromVoid as jni$_.JMethodIDPtr,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.$JObject$Type$(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncFlutterError = _class.instanceMethodId(
    r'throwAsyncFlutterError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncFlutterError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun throwAsyncFlutterError(): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncFlutterError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncFlutterError(
      reference.pointer,
      _id_throwAsyncFlutterError as jni$_.JMethodIDPtr,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.$JObject$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNIAllTypes = _class.instanceMethodId(
    r'echoAsyncNIAllTypes',
    r'(LNIAllTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNIAllTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNIAllTypes(everything: NIAllTypes): NIAllTypes`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAllTypes> echoAsyncNIAllTypes(NIAllTypes nIAllTypes) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAllTypes = nIAllTypes.reference;
    final $r = _echoAsyncNIAllTypes(
      reference.pointer,
      _id_echoAsyncNIAllTypes as jni$_.JMethodIDPtr,
      _$nIAllTypes.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
    _$continuation.release();
    jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
        jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
      );
      if ($o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<NIAllTypes>(const $NIAllTypes$Type$(), releaseOriginal: true);
  }

  static final _id_echoAsyncNullableNIAllNullableTypes = _class.instanceMethodId(
    r'echoAsyncNullableNIAllNullableTypes',
    r'(LNIAllNullableTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableNIAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableNIAllNullableTypes(everything: NIAllNullableTypes?): NIAllNullableTypes?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAllNullableTypes?> echoAsyncNullableNIAllNullableTypes(
    NIAllNullableTypes? nIAllNullableTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableNIAllNullableTypes(
      reference.pointer,
      _id_echoAsyncNullableNIAllNullableTypes as jni$_.JMethodIDPtr,
      _$nIAllNullableTypes.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAllNullableTypes?>(
      const $NIAllNullableTypes$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableNIAllNullableTypesWithoutRecursion = _class
      .instanceMethodId(
        r'echoAsyncNullableNIAllNullableTypesWithoutRecursion',
        r'(LNIAllNullableTypesWithoutRecursion;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
      );

  static final _echoAsyncNullableNIAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableNIAllNullableTypesWithoutRecursion(everything: NIAllNullableTypesWithoutRecursion?): NIAllNullableTypesWithoutRecursion?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAllNullableTypesWithoutRecursion?>
  echoAsyncNullableNIAllNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableNIAllNullableTypesWithoutRecursion(
      reference.pointer,
      _id_echoAsyncNullableNIAllNullableTypesWithoutRecursion
          as jni$_.JMethodIDPtr,
      _$nIAllNullableTypesWithoutRecursion.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAllNullableTypesWithoutRecursion?>(
      const $NIAllNullableTypesWithoutRecursion$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt = _class.instanceMethodId(
    r'echoAsyncNullableInt',
    r'(Ljava/lang/Long;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableInt(anInt: kotlin.Long?): kotlin.Long?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong?> echoAsyncNullableInt(jni$_.JLong? long) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$long = long?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt(
      reference.pointer,
      _id_echoAsyncNullableInt as jni$_.JMethodIDPtr,
      _$long.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLong?>(
      const jni$_.$JLong$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableDouble = _class.instanceMethodId(
    r'echoAsyncNullableDouble',
    r'(Ljava/lang/Double;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableDouble(aDouble: kotlin.Double?): kotlin.Double?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble?> echoAsyncNullableDouble(
    jni$_.JDouble? double,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$double = double?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableDouble(
      reference.pointer,
      _id_echoAsyncNullableDouble as jni$_.JMethodIDPtr,
      _$double.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDouble?>(
      const jni$_.$JDouble$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableBool = _class.instanceMethodId(
    r'echoAsyncNullableBool',
    r'(Ljava/lang/Boolean;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableBool(aBool: kotlin.Boolean?): kotlin.Boolean?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean?> echoAsyncNullableBool(
    jni$_.JBoolean? boolean,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableBool(
      reference.pointer,
      _id_echoAsyncNullableBool as jni$_.JMethodIDPtr,
      _$boolean.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JBoolean?>(
      const jni$_.$JBoolean$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableString = _class.instanceMethodId(
    r'echoAsyncNullableString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableString(aString: kotlin.String?): kotlin.String?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString?> echoAsyncNullableString(
    jni$_.JString? string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableString(
      reference.pointer,
      _id_echoAsyncNullableString as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JString?>(
      const jni$_.$JString$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableUint8List = _class.instanceMethodId(
    r'echoAsyncNullableUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableUint8List(aUint8List: kotlin.ByteArray?): kotlin.ByteArray?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray?> echoAsyncNullableUint8List(
    jni$_.JByteArray? bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableUint8List(
      reference.pointer,
      _id_echoAsyncNullableUint8List as jni$_.JMethodIDPtr,
      _$bs.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JByteArray?>(
      const jni$_.$JByteArray$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt32List = _class.instanceMethodId(
    r'echoAsyncNullableInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt32List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableInt32List(aInt32List: kotlin.IntArray?): kotlin.IntArray?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray?> echoAsyncNullableInt32List(
    jni$_.JIntArray? is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt32List(
      reference.pointer,
      _id_echoAsyncNullableInt32List as jni$_.JMethodIDPtr,
      _$is$.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JIntArray?>(
      const jni$_.$JIntArray$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt64List = _class.instanceMethodId(
    r'echoAsyncNullableInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableInt64List(aInt64List: kotlin.LongArray?): kotlin.LongArray?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray?> echoAsyncNullableInt64List(
    jni$_.JLongArray? js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt64List(
      reference.pointer,
      _id_echoAsyncNullableInt64List as jni$_.JMethodIDPtr,
      _$js.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLongArray?>(
      const jni$_.$JLongArray$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableFloat64List = _class.instanceMethodId(
    r'echoAsyncNullableFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableFloat64List(aFloat64List: kotlin.DoubleArray?): kotlin.DoubleArray?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray?> echoAsyncNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableFloat64List(
      reference.pointer,
      _id_echoAsyncNullableFloat64List as jni$_.JMethodIDPtr,
      _$ds.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDoubleArray?>(
      const jni$_.$JDoubleArray$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableObject = _class.instanceMethodId(
    r'echoAsyncNullableObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableObject(anObject: kotlin.Any?): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> echoAsyncNullableObject(
    jni$_.JObject? object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableObject(
      reference.pointer,
      _id_echoAsyncNullableObject as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.$JObject$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableList = _class.instanceMethodId(
    r'echoAsyncNullableList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableList(list: kotlin.collections.List<kotlin.Any?>?): kotlin.collections.List<kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>?> echoAsyncNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableList(
      reference.pointer,
      _id_echoAsyncNullableList as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumList = _class.instanceMethodId(
    r'echoAsyncNullableEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableEnumList(enumList: kotlin.collections.List<NIAnEnum?>?): kotlin.collections.List<NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAnEnum?>?> echoAsyncNullableEnumList(
    jni$_.JList<NIAnEnum?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumList(
      reference.pointer,
      _id_echoAsyncNullableEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<NIAnEnum?>?>(
      const jni$_.$JList$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassList = _class.instanceMethodId(
    r'echoAsyncNullableClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableClassList(classList: kotlin.collections.List<NIAllNullableTypes?>?): kotlin.collections.List<NIAllNullableTypes?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAllNullableTypes?>?> echoAsyncNullableClassList(
    jni$_.JList<NIAllNullableTypes?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassList(
      reference.pointer,
      _id_echoAsyncNullableClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<NIAllNullableTypes?>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypes?>(
        $NIAllNullableTypes$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableMap = _class.instanceMethodId(
    r'echoAsyncNullableMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableMap(map: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>
  echoAsyncNullableMap(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableMap(
      reference.pointer,
      _id_echoAsyncNullableMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableStringMap = _class.instanceMethodId(
    r'echoAsyncNullableStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableStringMap(stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>?): kotlin.collections.Map<kotlin.String?, kotlin.String?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>
  echoAsyncNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableStringMap(
      reference.pointer,
      _id_echoAsyncNullableStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableIntMap = _class.instanceMethodId(
    r'echoAsyncNullableIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableIntMap(intMap: kotlin.collections.Map<kotlin.Long?, kotlin.Long?>?): kotlin.collections.Map<kotlin.Long?, kotlin.Long?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>
  echoAsyncNullableIntMap(jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableIntMap(
      reference.pointer,
      _id_echoAsyncNullableIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumMap = _class.instanceMethodId(
    r'echoAsyncNullableEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableEnumMap(enumMap: kotlin.collections.Map<NIAnEnum?, NIAnEnum?>?): kotlin.collections.Map<NIAnEnum?, NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<NIAnEnum?, NIAnEnum?>?> echoAsyncNullableEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumMap(
      reference.pointer,
      _id_echoAsyncNullableEnumMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
      const jni$_.$JMap$NullableType$<NIAnEnum?, NIAnEnum?>(
        $NIAnEnum$NullableType$(),
        $NIAnEnum$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassMap = _class.instanceMethodId(
    r'echoAsyncNullableClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableClassMap(classMap: kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>?): kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>
  echoAsyncNullableClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassMap(
      reference.pointer,
      _id_echoAsyncNullableClassMap as jni$_.JMethodIDPtr,
      _$map.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, NIAllNullableTypes?>(
        jni$_.$JLong$NullableType$(),
        $NIAllNullableTypes$NullableType$(),
      ),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnum = _class.instanceMethodId(
    r'echoAsyncNullableEnum',
    r'(LNIAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAsyncNullableEnum(anEnum: NIAnEnum?): NIAnEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnEnum?> echoAsyncNullableEnum(NIAnEnum? nIAnEnum) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnum(
      reference.pointer,
      _id_echoAsyncNullableEnum as jni$_.JMethodIDPtr,
      _$nIAnEnum.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAnEnum?>(
      const $NIAnEnum$NullableType$(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncNullableEnum = _class.instanceMethodId(
    r'echoAnotherAsyncNullableEnum',
    r'(LNIAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public suspend fun echoAnotherAsyncNullableEnum(anotherEnum: NIAnotherEnum?): NIAnotherEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnotherEnum?> echoAnotherAsyncNullableEnum(
    NIAnotherEnum? nIAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAnotherAsyncNullableEnum(
      reference.pointer,
      _id_echoAnotherAsyncNullableEnum as jni$_.JMethodIDPtr,
      _$nIAnotherEnum.pointer,
      _$continuation.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
    _$continuation.release();
    jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)),
            );
      if ($o != null && $o.isInstanceOf(jni$_.result$Class)) {
        $o = jni$_.resultValueField.get($o, const jni$_.$JObject$Type$());
      } else if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e = jni$_.failureExceptionField.get(
          $o,
          const jni$_.$JObject$Type$(),
        );
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAnotherEnum?>(
      const $NIAnotherEnum$NullableType$(),
      releaseOriginal: true,
    );
  }
}

final class $NIHostIntegrationCoreApiRegistrar$NullableType$
    extends jni$_.JType<NIHostIntegrationCoreApiRegistrar?> {
  @jni$_.internal
  const $NIHostIntegrationCoreApiRegistrar$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  NIHostIntegrationCoreApiRegistrar? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : NIHostIntegrationCoreApiRegistrar.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const $NIHostIntegrationCoreApi$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIHostIntegrationCoreApiRegistrar?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode =>
      ($NIHostIntegrationCoreApiRegistrar$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIHostIntegrationCoreApiRegistrar$NullableType$) &&
        other is $NIHostIntegrationCoreApiRegistrar$NullableType$;
  }
}

final class $NIHostIntegrationCoreApiRegistrar$Type$
    extends jni$_.JType<NIHostIntegrationCoreApiRegistrar> {
  @jni$_.internal
  const $NIHostIntegrationCoreApiRegistrar$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  NIHostIntegrationCoreApiRegistrar fromReference(jni$_.JReference reference) =>
      NIHostIntegrationCoreApiRegistrar.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const $NIHostIntegrationCoreApi$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIHostIntegrationCoreApiRegistrar?> get nullableType =>
      const $NIHostIntegrationCoreApiRegistrar$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($NIHostIntegrationCoreApiRegistrar$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIHostIntegrationCoreApiRegistrar$Type$) &&
        other is $NIHostIntegrationCoreApiRegistrar$Type$;
  }
}

/// from: `NIUnusedClass$Companion`
class NIUnusedClass$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIUnusedClass$Companion> $type;

  @jni$_.internal
  NIUnusedClass$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIUnusedClass$Companion');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIUnusedClass$Companion?> nullableType =
      $NIUnusedClass$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIUnusedClass$Companion> type =
      $NIUnusedClass$Companion$Type$();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LNIUnusedClass;',
  );

  static final _fromList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun fromList(pigeonVar_list: kotlin.collections.List<kotlin.Any?>): NIUnusedClass`
  /// The returned object must be released after use, by calling the [release] method.
  NIUnusedClass fromList(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _fromList(
      reference.pointer,
      _id_fromList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<NIUnusedClass>(const $NIUnusedClass$Type$());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIUnusedClass$Companion(jni$_.JObject? defaultConstructorMarker) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIUnusedClass$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $NIUnusedClass$Companion$NullableType$
    extends jni$_.JType<NIUnusedClass$Companion?> {
  @jni$_.internal
  const $NIUnusedClass$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIUnusedClass$Companion;';

  @jni$_.internal
  @core$_.override
  NIUnusedClass$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : NIUnusedClass$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIUnusedClass$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIUnusedClass$Companion$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIUnusedClass$Companion$NullableType$) &&
        other is $NIUnusedClass$Companion$NullableType$;
  }
}

final class $NIUnusedClass$Companion$Type$
    extends jni$_.JType<NIUnusedClass$Companion> {
  @jni$_.internal
  const $NIUnusedClass$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIUnusedClass$Companion;';

  @jni$_.internal
  @core$_.override
  NIUnusedClass$Companion fromReference(jni$_.JReference reference) =>
      NIUnusedClass$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIUnusedClass$Companion?> get nullableType =>
      const $NIUnusedClass$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIUnusedClass$Companion$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIUnusedClass$Companion$Type$) &&
        other is $NIUnusedClass$Companion$Type$;
  }
}

/// from: `NIUnusedClass`
class NIUnusedClass extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIUnusedClass> $type;

  @jni$_.internal
  NIUnusedClass.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIUnusedClass');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIUnusedClass?> nullableType =
      $NIUnusedClass$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIUnusedClass> type = $NIUnusedClass$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIUnusedClass$Companion;',
  );

  /// from: `static public final NIUnusedClass$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIUnusedClass$Companion get Companion =>
      _id_Companion.get(_class, const $NIUnusedClass$Companion$Type$());

  static final _id_new$ = _class.constructorId(r'(Ljava/lang/Object;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIUnusedClass(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return NIUnusedClass.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$object.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Object;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(java.lang.Object object, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIUnusedClass.new$1(
    jni$_.JObject? object,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIUnusedClass.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$object.pointer,
        i,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }

  static final _id_getAField = _class.instanceMethodId(
    r'getAField',
    r'()Ljava/lang/Object;',
  );

  static final _getAField =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object getAField()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getAField() {
    return _getAField(
      reference.pointer,
      _id_getAField as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toList(): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(
      reference.pointer,
      _id_toList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public operator fun equals(other: kotlin.Any?): kotlin.Boolean`
  core$_.bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun hashCode(): kotlin.Int`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/Object;',
  );

  static final _component1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component1(): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? component1() {
    return _component1(
      reference.pointer,
      _id_component1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/Object;)LNIUnusedClass;',
  );

  static final _copy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun copy(aField: kotlin.Any?): NIUnusedClass`
  /// The returned object must be released after use, by calling the [release] method.
  NIUnusedClass copy(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _copy(
      reference.pointer,
      _id_copy as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<NIUnusedClass>(const $NIUnusedClass$Type$());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toString(): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_new$2 = _class.constructorId(r'()V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIUnusedClass.new$2() {
    return NIUnusedClass.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }
}

final class $NIUnusedClass$NullableType$ extends jni$_.JType<NIUnusedClass?> {
  @jni$_.internal
  const $NIUnusedClass$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIUnusedClass;';

  @jni$_.internal
  @core$_.override
  NIUnusedClass? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIUnusedClass.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIUnusedClass?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIUnusedClass$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIUnusedClass$NullableType$) &&
        other is $NIUnusedClass$NullableType$;
  }
}

final class $NIUnusedClass$Type$ extends jni$_.JType<NIUnusedClass> {
  @jni$_.internal
  const $NIUnusedClass$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIUnusedClass;';

  @jni$_.internal
  @core$_.override
  NIUnusedClass fromReference(jni$_.JReference reference) =>
      NIUnusedClass.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIUnusedClass?> get nullableType =>
      const $NIUnusedClass$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIUnusedClass$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIUnusedClass$Type$) &&
        other is $NIUnusedClass$Type$;
  }
}

/// from: `NIAllTypes$Companion`
class NIAllTypes$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllTypes$Companion> $type;

  @jni$_.internal
  NIAllTypes$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllTypes$Companion');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllTypes$Companion?> nullableType =
      $NIAllTypes$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllTypes$Companion> type =
      $NIAllTypes$Companion$Type$();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LNIAllTypes;',
  );

  static final _fromList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun fromList(pigeonVar_list: kotlin.collections.List<kotlin.Any?>): NIAllTypes`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes fromList(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _fromList(
      reference.pointer,
      _id_fromList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<NIAllTypes>(const $NIAllTypes$Type$());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllTypes$Companion(jni$_.JObject? defaultConstructorMarker) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllTypes$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $NIAllTypes$Companion$NullableType$
    extends jni$_.JType<NIAllTypes$Companion?> {
  @jni$_.internal
  const $NIAllTypes$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllTypes$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllTypes$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIAllTypes$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllTypes$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllTypes$Companion$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAllTypes$Companion$NullableType$) &&
        other is $NIAllTypes$Companion$NullableType$;
  }
}

final class $NIAllTypes$Companion$Type$
    extends jni$_.JType<NIAllTypes$Companion> {
  @jni$_.internal
  const $NIAllTypes$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllTypes$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllTypes$Companion fromReference(jni$_.JReference reference) =>
      NIAllTypes$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllTypes$Companion?> get nullableType =>
      const $NIAllTypes$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllTypes$Companion$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAllTypes$Companion$Type$) &&
        other is $NIAllTypes$Companion$Type$;
  }
}

/// from: `NIAllTypes`
class NIAllTypes extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllTypes> $type;

  @jni$_.internal
  NIAllTypes.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllTypes');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllTypes?> nullableType =
      $NIAllTypes$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllTypes> type = $NIAllTypes$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAllTypes$Companion;',
  );

  /// from: `static public final NIAllTypes$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAllTypes$Companion get Companion =>
      _id_Companion.get(_class, const $NIAllTypes$Companion$Type$());

  static final _id_new$ = _class.constructorId(
    r'(ZJJD[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int64,
                    jni$_.Int64,
                    jni$_.Double,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(boolean z, long j, long j1, double d, byte[] bs, int[] is, long[] js, double[] ds, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends NIAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<NIAnEnum, ? extends NIAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllTypes(
    core$_.bool z,
    int j,
    int j1,
    double d,
    jni$_.JByteArray bs,
    jni$_.JIntArray is$,
    jni$_.JLongArray js,
    jni$_.JDoubleArray ds,
    NIAnEnum nIAnEnum,
    NIAnotherEnum nIAnotherEnum,
    jni$_.JString string,
    jni$_.JObject object,
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JList<jni$_.JString> list1,
    jni$_.JList<jni$_.JLong> list2,
    jni$_.JList<jni$_.JDouble> list3,
    jni$_.JList<jni$_.JBoolean> list4,
    jni$_.JList<NIAnEnum> list5,
    jni$_.JList<jni$_.JObject> list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>> list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?> map,
    jni$_.JMap<jni$_.JString, jni$_.JString> map1,
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map2,
    jni$_.JMap<NIAnEnum, NIAnEnum> map3,
    jni$_.JMap<jni$_.JObject, jni$_.JObject> map4,
    jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> map5,
    jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> map6,
  ) {
    final _$bs = bs.reference;
    final _$is$ = is$.reference;
    final _$js = js.reference;
    final _$ds = ds.reference;
    final _$nIAnEnum = nIAnEnum.reference;
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    final _$string = string.reference;
    final _$object = object.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$list2 = list2.reference;
    final _$list3 = list3.reference;
    final _$list4 = list4.reference;
    final _$list5 = list5.reference;
    final _$list6 = list6.reference;
    final _$list7 = list7.reference;
    final _$list8 = list8.reference;
    final _$map = map.reference;
    final _$map1 = map1.reference;
    final _$map2 = map2.reference;
    final _$map3 = map3.reference;
    final _$map4 = map4.reference;
    final _$map5 = map5.reference;
    final _$map6 = map6.reference;
    return NIAllTypes.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        z ? 1 : 0,
        j,
        j1,
        d,
        _$bs.pointer,
        _$is$.pointer,
        _$js.pointer,
        _$ds.pointer,
        _$nIAnEnum.pointer,
        _$nIAnotherEnum.pointer,
        _$string.pointer,
        _$object.pointer,
        _$list.pointer,
        _$list1.pointer,
        _$list2.pointer,
        _$list3.pointer,
        _$list4.pointer,
        _$list5.pointer,
        _$list6.pointer,
        _$list7.pointer,
        _$list8.pointer,
        _$map.pointer,
        _$map1.pointer,
        _$map2.pointer,
        _$map3.pointer,
        _$map4.pointer,
        _$map5.pointer,
        _$map6.pointer,
      ).reference,
    );
  }

  static final _id_getABool = _class.instanceMethodId(r'getABool', r'()Z');

  static final _getABool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean getABool()`
  core$_.bool getABool() {
    return _getABool(
      reference.pointer,
      _id_getABool as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getAnInt = _class.instanceMethodId(r'getAnInt', r'()J');

  static final _getAnInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long getAnInt()`
  int getAnInt() {
    return _getAnInt(
      reference.pointer,
      _id_getAnInt as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getAnInt64 = _class.instanceMethodId(r'getAnInt64', r'()J');

  static final _getAnInt64 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long getAnInt64()`
  int getAnInt64() {
    return _getAnInt64(
      reference.pointer,
      _id_getAnInt64 as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getADouble = _class.instanceMethodId(r'getADouble', r'()D');

  static final _getADouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final double getADouble()`
  double getADouble() {
    return _getADouble(
      reference.pointer,
      _id_getADouble as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_getAByteArray = _class.instanceMethodId(
    r'getAByteArray',
    r'()[B',
  );

  static final _getAByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final byte[] getAByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray getAByteArray() {
    return _getAByteArray(
      reference.pointer,
      _id_getAByteArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray>(const jni$_.$JByteArray$Type$());
  }

  static final _id_getA4ByteArray = _class.instanceMethodId(
    r'getA4ByteArray',
    r'()[I',
  );

  static final _getA4ByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int[] getA4ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray getA4ByteArray() {
    return _getA4ByteArray(
      reference.pointer,
      _id_getA4ByteArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JIntArray>(const jni$_.$JIntArray$Type$());
  }

  static final _id_getA8ByteArray = _class.instanceMethodId(
    r'getA8ByteArray',
    r'()[J',
  );

  static final _getA8ByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long[] getA8ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray getA8ByteArray() {
    return _getA8ByteArray(
      reference.pointer,
      _id_getA8ByteArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JLongArray>(const jni$_.$JLongArray$Type$());
  }

  static final _id_getAFloatArray = _class.instanceMethodId(
    r'getAFloatArray',
    r'()[D',
  );

  static final _getAFloatArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final double[] getAFloatArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray getAFloatArray() {
    return _getAFloatArray(
      reference.pointer,
      _id_getAFloatArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JDoubleArray>(const jni$_.$JDoubleArray$Type$());
  }

  static final _id_getAnEnum = _class.instanceMethodId(
    r'getAnEnum',
    r'()LNIAnEnum;',
  );

  static final _getAnEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAnEnum getAnEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum getAnEnum() {
    return _getAnEnum(
      reference.pointer,
      _id_getAnEnum as jni$_.JMethodIDPtr,
    ).object<NIAnEnum>(const $NIAnEnum$Type$());
  }

  static final _id_getAnotherEnum = _class.instanceMethodId(
    r'getAnotherEnum',
    r'()LNIAnotherEnum;',
  );

  static final _getAnotherEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAnotherEnum getAnotherEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum getAnotherEnum() {
    return _getAnotherEnum(
      reference.pointer,
      _id_getAnotherEnum as jni$_.JMethodIDPtr,
    ).object<NIAnotherEnum>(const $NIAnotherEnum$Type$());
  }

  static final _id_getAString = _class.instanceMethodId(
    r'getAString',
    r'()Ljava/lang/String;',
  );

  static final _getAString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getAString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getAString() {
    return _getAString(
      reference.pointer,
      _id_getAString as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getAnObject = _class.instanceMethodId(
    r'getAnObject',
    r'()Ljava/lang/Object;',
  );

  static final _getAnObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object getAnObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getAnObject() {
    return _getAnObject(
      reference.pointer,
      _id_getAnObject as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getList() {
    return _getList(
      reference.pointer,
      _id_getList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString> getStringList() {
    return _getStringList(
      reference.pointer,
      _id_getStringList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString>>(
      const jni$_.$JList$Type$<jni$_.JString>(jni$_.$JString$Type$()),
    );
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong> getIntList() {
    return _getIntList(
      reference.pointer,
      _id_getIntList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JLong>>(
      const jni$_.$JList$Type$<jni$_.JLong>(jni$_.$JLong$Type$()),
    );
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble> getDoubleList() {
    return _getDoubleList(
      reference.pointer,
      _id_getDoubleList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JDouble>>(
      const jni$_.$JList$Type$<jni$_.JDouble>(jni$_.$JDouble$Type$()),
    );
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean> getBoolList() {
    return _getBoolList(
      reference.pointer,
      _id_getBoolList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JBoolean>>(
      const jni$_.$JList$Type$<jni$_.JBoolean>(jni$_.$JBoolean$Type$()),
    );
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<NIAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> getEnumList() {
    return _getEnumList(
      reference.pointer,
      _id_getEnumList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAnEnum>>(
      const jni$_.$JList$Type$<NIAnEnum>($NIAnEnum$Type$()),
    );
  }

  static final _id_getObjectList = _class.instanceMethodId(
    r'getObjectList',
    r'()Ljava/util/List;',
  );

  static final _getObjectList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Object> getObjectList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject> getObjectList() {
    return _getObjectList(
      reference.pointer,
      _id_getObjectList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject>>(
      const jni$_.$JList$Type$<jni$_.JObject>(jni$_.$JObject$Type$()),
    );
  }

  static final _id_getListList = _class.instanceMethodId(
    r'getListList',
    r'()Ljava/util/List;',
  );

  static final _getListList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> getListList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>> getListList() {
    return _getListList(
      reference.pointer,
      _id_getListList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JList<jni$_.JObject?>>>(
      const jni$_.$JList$Type$<jni$_.JList<jni$_.JObject?>>(
        jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
      ),
    );
  }

  static final _id_getMapList = _class.instanceMethodId(
    r'getMapList',
    r'()Ljava/util/List;',
  );

  static final _getMapList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> getMapList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> getMapList() {
    return _getMapList(
      reference.pointer,
      _id_getMapList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(
      const jni$_.$JList$Type$<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
        jni$_.$JMap$Type$<jni$_.JObject?, jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?> getMap() {
    return _getMap(
      reference.pointer,
      _id_getMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>>(
      const jni$_.$JMap$Type$<jni$_.JObject, jni$_.JObject?>(
        jni$_.$JObject$Type$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> getStringMap() {
    return _getStringMap(
      reference.pointer,
      _id_getStringMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
      const jni$_.$JMap$Type$<jni$_.JString, jni$_.JString>(
        jni$_.$JString$Type$(),
        jni$_.$JString$Type$(),
      ),
    );
  }

  static final _id_getIntMap = _class.instanceMethodId(
    r'getIntMap',
    r'()Ljava/util/Map;',
  );

  static final _getIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> getIntMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> getIntMap() {
    return _getIntMap(
      reference.pointer,
      _id_getIntMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
      const jni$_.$JMap$Type$<jni$_.JLong, jni$_.JLong>(
        jni$_.$JLong$Type$(),
        jni$_.$JLong$Type$(),
      ),
    );
  }

  static final _id_getEnumMap = _class.instanceMethodId(
    r'getEnumMap',
    r'()Ljava/util/Map;',
  );

  static final _getEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<NIAnEnum, NIAnEnum> getEnumMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum> getEnumMap() {
    return _getEnumMap(
      reference.pointer,
      _id_getEnumMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<NIAnEnum, NIAnEnum>>(
      const jni$_.$JMap$Type$<NIAnEnum, NIAnEnum>(
        $NIAnEnum$Type$(),
        $NIAnEnum$Type$(),
      ),
    );
  }

  static final _id_getObjectMap = _class.instanceMethodId(
    r'getObjectMap',
    r'()Ljava/util/Map;',
  );

  static final _getObjectMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getObjectMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject> getObjectMap() {
    return _getObjectMap(
      reference.pointer,
      _id_getObjectMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject, jni$_.JObject>>(
      const jni$_.$JMap$Type$<jni$_.JObject, jni$_.JObject>(
        jni$_.$JObject$Type$(),
        jni$_.$JObject$Type$(),
      ),
    );
  }

  static final _id_getListMap = _class.instanceMethodId(
    r'getListMap',
    r'()Ljava/util/Map;',
  );

  static final _getListMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> getListMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> getListMap() {
    return _getListMap(
      reference.pointer,
      _id_getListMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>>>(
      const jni$_.$JMap$Type$<jni$_.JLong, jni$_.JList<jni$_.JObject?>>(
        jni$_.$JLong$Type$(),
        jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
      ),
    );
  }

  static final _id_getMapMap = _class.instanceMethodId(
    r'getMapMap',
    r'()Ljava/util/Map;',
  );

  static final _getMapMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> getMapMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>
  getMapMap() {
    return _getMapMap(
      reference.pointer,
      _id_getMapMap as jni$_.JMethodIDPtr,
    ).object<
      jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>
    >(
      const jni$_.$JMap$Type$<
        jni$_.JLong,
        jni$_.JMap<jni$_.JObject?, jni$_.JObject?>
      >(
        jni$_.$JLong$Type$(),
        jni$_.$JMap$Type$<jni$_.JObject?, jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toList(): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(
      reference.pointer,
      _id_toList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public operator fun equals(other: kotlin.Any?): kotlin.Boolean`
  core$_.bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun hashCode(): kotlin.Int`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_component1 = _class.instanceMethodId(r'component1', r'()Z');

  static final _component1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component1(): kotlin.Boolean`
  core$_.bool component1() {
    return _component1(
      reference.pointer,
      _id_component1 as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_component2 = _class.instanceMethodId(r'component2', r'()J');

  static final _component2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component2(): kotlin.Long`
  int component2() {
    return _component2(
      reference.pointer,
      _id_component2 as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_component3 = _class.instanceMethodId(r'component3', r'()J');

  static final _component3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component3(): kotlin.Long`
  int component3() {
    return _component3(
      reference.pointer,
      _id_component3 as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_component4 = _class.instanceMethodId(r'component4', r'()D');

  static final _component4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component4(): kotlin.Double`
  double component4() {
    return _component4(
      reference.pointer,
      _id_component4 as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_component5 = _class.instanceMethodId(r'component5', r'()[B');

  static final _component5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component5(): kotlin.ByteArray`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray component5() {
    return _component5(
      reference.pointer,
      _id_component5 as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray>(const jni$_.$JByteArray$Type$());
  }

  static final _id_component6 = _class.instanceMethodId(r'component6', r'()[I');

  static final _component6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component6(): kotlin.IntArray`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray component6() {
    return _component6(
      reference.pointer,
      _id_component6 as jni$_.JMethodIDPtr,
    ).object<jni$_.JIntArray>(const jni$_.$JIntArray$Type$());
  }

  static final _id_component7 = _class.instanceMethodId(r'component7', r'()[J');

  static final _component7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component7(): kotlin.LongArray`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray component7() {
    return _component7(
      reference.pointer,
      _id_component7 as jni$_.JMethodIDPtr,
    ).object<jni$_.JLongArray>(const jni$_.$JLongArray$Type$());
  }

  static final _id_component8 = _class.instanceMethodId(r'component8', r'()[D');

  static final _component8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component8(): kotlin.DoubleArray`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray component8() {
    return _component8(
      reference.pointer,
      _id_component8 as jni$_.JMethodIDPtr,
    ).object<jni$_.JDoubleArray>(const jni$_.$JDoubleArray$Type$());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()LNIAnEnum;',
  );

  static final _component9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component9(): NIAnEnum`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum component9() {
    return _component9(
      reference.pointer,
      _id_component9 as jni$_.JMethodIDPtr,
    ).object<NIAnEnum>(const $NIAnEnum$Type$());
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()LNIAnotherEnum;',
  );

  static final _component10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component10(): NIAnotherEnum`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum component10() {
    return _component10(
      reference.pointer,
      _id_component10 as jni$_.JMethodIDPtr,
    ).object<NIAnotherEnum>(const $NIAnotherEnum$Type$());
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/lang/String;',
  );

  static final _component11 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component11(): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString component11() {
    return _component11(
      reference.pointer,
      _id_component11 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/lang/Object;',
  );

  static final _component12 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component12(): kotlin.Any`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject component12() {
    return _component12(
      reference.pointer,
      _id_component12 as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()Ljava/util/List;',
  );

  static final _component13 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component13(): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> component13() {
    return _component13(
      reference.pointer,
      _id_component13 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component14(): kotlin.collections.List<kotlin.String>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString> component14() {
    return _component14(
      reference.pointer,
      _id_component14 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString>>(
      const jni$_.$JList$Type$<jni$_.JString>(jni$_.$JString$Type$()),
    );
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/List;',
  );

  static final _component15 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component15(): kotlin.collections.List<kotlin.Long>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong> component15() {
    return _component15(
      reference.pointer,
      _id_component15 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JLong>>(
      const jni$_.$JList$Type$<jni$_.JLong>(jni$_.$JLong$Type$()),
    );
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/List;',
  );

  static final _component16 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component16(): kotlin.collections.List<kotlin.Double>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble> component16() {
    return _component16(
      reference.pointer,
      _id_component16 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JDouble>>(
      const jni$_.$JList$Type$<jni$_.JDouble>(jni$_.$JDouble$Type$()),
    );
  }

  static final _id_component17 = _class.instanceMethodId(
    r'component17',
    r'()Ljava/util/List;',
  );

  static final _component17 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component17(): kotlin.collections.List<kotlin.Boolean>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean> component17() {
    return _component17(
      reference.pointer,
      _id_component17 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JBoolean>>(
      const jni$_.$JList$Type$<jni$_.JBoolean>(jni$_.$JBoolean$Type$()),
    );
  }

  static final _id_component18 = _class.instanceMethodId(
    r'component18',
    r'()Ljava/util/List;',
  );

  static final _component18 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component18(): kotlin.collections.List<NIAnEnum>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> component18() {
    return _component18(
      reference.pointer,
      _id_component18 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAnEnum>>(
      const jni$_.$JList$Type$<NIAnEnum>($NIAnEnum$Type$()),
    );
  }

  static final _id_component19 = _class.instanceMethodId(
    r'component19',
    r'()Ljava/util/List;',
  );

  static final _component19 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component19(): kotlin.collections.List<kotlin.Any>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject> component19() {
    return _component19(
      reference.pointer,
      _id_component19 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject>>(
      const jni$_.$JList$Type$<jni$_.JObject>(jni$_.$JObject$Type$()),
    );
  }

  static final _id_component20 = _class.instanceMethodId(
    r'component20',
    r'()Ljava/util/List;',
  );

  static final _component20 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component20(): kotlin.collections.List<kotlin.collections.List<kotlin.Any?>>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>> component20() {
    return _component20(
      reference.pointer,
      _id_component20 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JList<jni$_.JObject?>>>(
      const jni$_.$JList$Type$<jni$_.JList<jni$_.JObject?>>(
        jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
      ),
    );
  }

  static final _id_component21 = _class.instanceMethodId(
    r'component21',
    r'()Ljava/util/List;',
  );

  static final _component21 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component21(): kotlin.collections.List<kotlin.collections.Map<kotlin.Any?, kotlin.Any?>>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> component21() {
    return _component21(
      reference.pointer,
      _id_component21 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(
      const jni$_.$JList$Type$<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
        jni$_.$JMap$Type$<jni$_.JObject?, jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_component22 = _class.instanceMethodId(
    r'component22',
    r'()Ljava/util/Map;',
  );

  static final _component22 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component22(): kotlin.collections.Map<kotlin.Any, kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?> component22() {
    return _component22(
      reference.pointer,
      _id_component22 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>>(
      const jni$_.$JMap$Type$<jni$_.JObject, jni$_.JObject?>(
        jni$_.$JObject$Type$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_component23 = _class.instanceMethodId(
    r'component23',
    r'()Ljava/util/Map;',
  );

  static final _component23 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component23(): kotlin.collections.Map<kotlin.String, kotlin.String>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> component23() {
    return _component23(
      reference.pointer,
      _id_component23 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
      const jni$_.$JMap$Type$<jni$_.JString, jni$_.JString>(
        jni$_.$JString$Type$(),
        jni$_.$JString$Type$(),
      ),
    );
  }

  static final _id_component24 = _class.instanceMethodId(
    r'component24',
    r'()Ljava/util/Map;',
  );

  static final _component24 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component24(): kotlin.collections.Map<kotlin.Long, kotlin.Long>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> component24() {
    return _component24(
      reference.pointer,
      _id_component24 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
      const jni$_.$JMap$Type$<jni$_.JLong, jni$_.JLong>(
        jni$_.$JLong$Type$(),
        jni$_.$JLong$Type$(),
      ),
    );
  }

  static final _id_component25 = _class.instanceMethodId(
    r'component25',
    r'()Ljava/util/Map;',
  );

  static final _component25 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component25(): kotlin.collections.Map<NIAnEnum, NIAnEnum>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum> component25() {
    return _component25(
      reference.pointer,
      _id_component25 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<NIAnEnum, NIAnEnum>>(
      const jni$_.$JMap$Type$<NIAnEnum, NIAnEnum>(
        $NIAnEnum$Type$(),
        $NIAnEnum$Type$(),
      ),
    );
  }

  static final _id_component26 = _class.instanceMethodId(
    r'component26',
    r'()Ljava/util/Map;',
  );

  static final _component26 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component26(): kotlin.collections.Map<kotlin.Any, kotlin.Any>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject> component26() {
    return _component26(
      reference.pointer,
      _id_component26 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject, jni$_.JObject>>(
      const jni$_.$JMap$Type$<jni$_.JObject, jni$_.JObject>(
        jni$_.$JObject$Type$(),
        jni$_.$JObject$Type$(),
      ),
    );
  }

  static final _id_component27 = _class.instanceMethodId(
    r'component27',
    r'()Ljava/util/Map;',
  );

  static final _component27 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component27(): kotlin.collections.Map<kotlin.Long, kotlin.collections.List<kotlin.Any?>>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> component27() {
    return _component27(
      reference.pointer,
      _id_component27 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>>>(
      const jni$_.$JMap$Type$<jni$_.JLong, jni$_.JList<jni$_.JObject?>>(
        jni$_.$JLong$Type$(),
        jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
      ),
    );
  }

  static final _id_component28 = _class.instanceMethodId(
    r'component28',
    r'()Ljava/util/Map;',
  );

  static final _component28 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component28(): kotlin.collections.Map<kotlin.Long, kotlin.collections.Map<kotlin.Any?, kotlin.Any?>>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>
  component28() {
    return _component28(
      reference.pointer,
      _id_component28 as jni$_.JMethodIDPtr,
    ).object<
      jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>
    >(
      const jni$_.$JMap$Type$<
        jni$_.JLong,
        jni$_.JMap<jni$_.JObject?, jni$_.JObject?>
      >(
        jni$_.$JLong$Type$(),
        jni$_.$JMap$Type$<jni$_.JObject?, jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(ZJJD[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)LNIAllTypes;',
  );

  static final _copy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int64,
                    jni$_.Int64,
                    jni$_.Double,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun copy(aBool: kotlin.Boolean, anInt: kotlin.Long, anInt64: kotlin.Long, aDouble: kotlin.Double, aByteArray: kotlin.ByteArray, a4ByteArray: kotlin.IntArray, a8ByteArray: kotlin.LongArray, aFloatArray: kotlin.DoubleArray, anEnum: NIAnEnum, anotherEnum: NIAnotherEnum, aString: kotlin.String, anObject: kotlin.Any, list: kotlin.collections.List<kotlin.Any?>, stringList: kotlin.collections.List<kotlin.String>, intList: kotlin.collections.List<kotlin.Long>, doubleList: kotlin.collections.List<kotlin.Double>, boolList: kotlin.collections.List<kotlin.Boolean>, enumList: kotlin.collections.List<NIAnEnum>, objectList: kotlin.collections.List<kotlin.Any>, listList: kotlin.collections.List<kotlin.collections.List<kotlin.Any?>>, mapList: kotlin.collections.List<kotlin.collections.Map<kotlin.Any?, kotlin.Any?>>, map: kotlin.collections.Map<kotlin.Any, kotlin.Any?>, stringMap: kotlin.collections.Map<kotlin.String, kotlin.String>, intMap: kotlin.collections.Map<kotlin.Long, kotlin.Long>, enumMap: kotlin.collections.Map<NIAnEnum, NIAnEnum>, objectMap: kotlin.collections.Map<kotlin.Any, kotlin.Any>, listMap: kotlin.collections.Map<kotlin.Long, kotlin.collections.List<kotlin.Any?>>, mapMap: kotlin.collections.Map<kotlin.Long, kotlin.collections.Map<kotlin.Any?, kotlin.Any?>>): NIAllTypes`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes copy(
    core$_.bool z,
    int j,
    int j1,
    double d,
    jni$_.JByteArray bs,
    jni$_.JIntArray is$,
    jni$_.JLongArray js,
    jni$_.JDoubleArray ds,
    NIAnEnum nIAnEnum,
    NIAnotherEnum nIAnotherEnum,
    jni$_.JString string,
    jni$_.JObject object,
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JList<jni$_.JString> list1,
    jni$_.JList<jni$_.JLong> list2,
    jni$_.JList<jni$_.JDouble> list3,
    jni$_.JList<jni$_.JBoolean> list4,
    jni$_.JList<NIAnEnum> list5,
    jni$_.JList<jni$_.JObject> list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>> list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?> map,
    jni$_.JMap<jni$_.JString, jni$_.JString> map1,
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map2,
    jni$_.JMap<NIAnEnum, NIAnEnum> map3,
    jni$_.JMap<jni$_.JObject, jni$_.JObject> map4,
    jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> map5,
    jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> map6,
  ) {
    final _$bs = bs.reference;
    final _$is$ = is$.reference;
    final _$js = js.reference;
    final _$ds = ds.reference;
    final _$nIAnEnum = nIAnEnum.reference;
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    final _$string = string.reference;
    final _$object = object.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$list2 = list2.reference;
    final _$list3 = list3.reference;
    final _$list4 = list4.reference;
    final _$list5 = list5.reference;
    final _$list6 = list6.reference;
    final _$list7 = list7.reference;
    final _$list8 = list8.reference;
    final _$map = map.reference;
    final _$map1 = map1.reference;
    final _$map2 = map2.reference;
    final _$map3 = map3.reference;
    final _$map4 = map4.reference;
    final _$map5 = map5.reference;
    final _$map6 = map6.reference;
    return _copy(
      reference.pointer,
      _id_copy as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      j,
      j1,
      d,
      _$bs.pointer,
      _$is$.pointer,
      _$js.pointer,
      _$ds.pointer,
      _$nIAnEnum.pointer,
      _$nIAnotherEnum.pointer,
      _$string.pointer,
      _$object.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$list2.pointer,
      _$list3.pointer,
      _$list4.pointer,
      _$list5.pointer,
      _$list6.pointer,
      _$list7.pointer,
      _$list8.pointer,
      _$map.pointer,
      _$map1.pointer,
      _$map2.pointer,
      _$map3.pointer,
      _$map4.pointer,
      _$map5.pointer,
      _$map6.pointer,
    ).object<NIAllTypes>(const $NIAllTypes$Type$());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toString(): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }
}

final class $NIAllTypes$NullableType$ extends jni$_.JType<NIAllTypes?> {
  @jni$_.internal
  const $NIAllTypes$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllTypes;';

  @jni$_.internal
  @core$_.override
  NIAllTypes? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIAllTypes.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllTypes?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllTypes$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAllTypes$NullableType$) &&
        other is $NIAllTypes$NullableType$;
  }
}

final class $NIAllTypes$Type$ extends jni$_.JType<NIAllTypes> {
  @jni$_.internal
  const $NIAllTypes$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllTypes;';

  @jni$_.internal
  @core$_.override
  NIAllTypes fromReference(jni$_.JReference reference) =>
      NIAllTypes.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllTypes?> get nullableType =>
      const $NIAllTypes$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllTypes$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAllTypes$Type$) &&
        other is $NIAllTypes$Type$;
  }
}

/// from: `NIAllNullableTypes$Companion`
class NIAllNullableTypes$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllNullableTypes$Companion> $type;

  @jni$_.internal
  NIAllNullableTypes$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllNullableTypes$Companion');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllNullableTypes$Companion?> nullableType =
      $NIAllNullableTypes$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllNullableTypes$Companion> type =
      $NIAllNullableTypes$Companion$Type$();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LNIAllNullableTypes;',
  );

  static final _fromList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun fromList(pigeonVar_list: kotlin.collections.List<kotlin.Any?>): NIAllNullableTypes`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes fromList(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _fromList(
      reference.pointer,
      _id_fromList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<NIAllNullableTypes>(const $NIAllNullableTypes$Type$());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypes$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypes$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $NIAllNullableTypes$Companion$NullableType$
    extends jni$_.JType<NIAllNullableTypes$Companion?> {
  @jni$_.internal
  const $NIAllNullableTypes$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypes$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypes$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : NIAllNullableTypes$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllNullableTypes$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllNullableTypes$Companion$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAllNullableTypes$Companion$NullableType$) &&
        other is $NIAllNullableTypes$Companion$NullableType$;
  }
}

final class $NIAllNullableTypes$Companion$Type$
    extends jni$_.JType<NIAllNullableTypes$Companion> {
  @jni$_.internal
  const $NIAllNullableTypes$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypes$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypes$Companion fromReference(jni$_.JReference reference) =>
      NIAllNullableTypes$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllNullableTypes$Companion?> get nullableType =>
      const $NIAllNullableTypes$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllNullableTypes$Companion$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAllNullableTypes$Companion$Type$) &&
        other is $NIAllNullableTypes$Companion$Type$;
  }
}

/// from: `NIAllNullableTypes`
class NIAllNullableTypes extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllNullableTypes> $type;

  @jni$_.internal
  NIAllNullableTypes.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllNullableTypes');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllNullableTypes?> nullableType =
      $NIAllNullableTypes$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllNullableTypes> type =
      $NIAllNullableTypes$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAllNullableTypes$Companion;',
  );

  /// from: `static public final NIAllNullableTypes$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAllNullableTypes$Companion get Companion =>
      _id_Companion.get(_class, const $NIAllNullableTypes$Companion$Type$());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;LNIAllNullableTypes;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, NIAllNullableTypes nIAllNullableTypes, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends NIAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.List<NIAllNullableTypes> list9, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<NIAnEnum, ? extends NIAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6, java.util.Map<java.lang.Long, NIAllNullableTypes> map7)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    NIAllNullableTypes? nIAllNullableTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<NIAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JList<NIAllNullableTypes?>? list9,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map7,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$list9 = list9?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$map7 = map7?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypes.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$boolean.pointer,
        _$long.pointer,
        _$long1.pointer,
        _$double.pointer,
        _$bs.pointer,
        _$is$.pointer,
        _$js.pointer,
        _$ds.pointer,
        _$nIAnEnum.pointer,
        _$nIAnotherEnum.pointer,
        _$string.pointer,
        _$object.pointer,
        _$nIAllNullableTypes.pointer,
        _$list.pointer,
        _$list1.pointer,
        _$list2.pointer,
        _$list3.pointer,
        _$list4.pointer,
        _$list5.pointer,
        _$list6.pointer,
        _$list7.pointer,
        _$list8.pointer,
        _$list9.pointer,
        _$map.pointer,
        _$map1.pointer,
        _$map2.pointer,
        _$map3.pointer,
        _$map4.pointer,
        _$map5.pointer,
        _$map6.pointer,
        _$map7.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;LNIAllNullableTypes;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, NIAllNullableTypes nIAllNullableTypes, java.util.List list, java.util.List list1, java.util.List list2, java.util.List list3, java.util.List list4, java.util.List list5, java.util.List list6, java.util.List list7, java.util.List list8, java.util.List list9, java.util.Map map, java.util.Map map1, java.util.Map map2, java.util.Map map3, java.util.Map map4, java.util.Map map5, java.util.Map map6, java.util.Map map7, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypes.new$1(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    NIAllNullableTypes? nIAllNullableTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    jni$_.JList<jni$_.JObject?>? list2,
    jni$_.JList<jni$_.JObject?>? list3,
    jni$_.JList<jni$_.JObject?>? list4,
    jni$_.JList<jni$_.JObject?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JObject?>? list7,
    jni$_.JList<jni$_.JObject?>? list8,
    jni$_.JList<jni$_.JObject?>? list9,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map1,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map2,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map5,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map6,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map7,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$list9 = list9?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$map7 = map7?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypes.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$boolean.pointer,
        _$long.pointer,
        _$long1.pointer,
        _$double.pointer,
        _$bs.pointer,
        _$is$.pointer,
        _$js.pointer,
        _$ds.pointer,
        _$nIAnEnum.pointer,
        _$nIAnotherEnum.pointer,
        _$string.pointer,
        _$object.pointer,
        _$nIAllNullableTypes.pointer,
        _$list.pointer,
        _$list1.pointer,
        _$list2.pointer,
        _$list3.pointer,
        _$list4.pointer,
        _$list5.pointer,
        _$list6.pointer,
        _$list7.pointer,
        _$list8.pointer,
        _$list9.pointer,
        _$map.pointer,
        _$map1.pointer,
        _$map2.pointer,
        _$map3.pointer,
        _$map4.pointer,
        _$map5.pointer,
        _$map6.pointer,
        _$map7.pointer,
        i,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }

  static final _id_getANullableBool = _class.instanceMethodId(
    r'getANullableBool',
    r'()Ljava/lang/Boolean;',
  );

  static final _getANullableBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Boolean getANullableBool()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? getANullableBool() {
    return _getANullableBool(
      reference.pointer,
      _id_getANullableBool as jni$_.JMethodIDPtr,
    ).object<jni$_.JBoolean?>(const jni$_.$JBoolean$NullableType$());
  }

  static final _id_getANullableInt = _class.instanceMethodId(
    r'getANullableInt',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Long getANullableInt()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt() {
    return _getANullableInt(
      reference.pointer,
      _id_getANullableInt as jni$_.JMethodIDPtr,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_getANullableInt64 = _class.instanceMethodId(
    r'getANullableInt64',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt64 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Long getANullableInt64()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt64() {
    return _getANullableInt64(
      reference.pointer,
      _id_getANullableInt64 as jni$_.JMethodIDPtr,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_getANullableDouble = _class.instanceMethodId(
    r'getANullableDouble',
    r'()Ljava/lang/Double;',
  );

  static final _getANullableDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Double getANullableDouble()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getANullableDouble() {
    return _getANullableDouble(
      reference.pointer,
      _id_getANullableDouble as jni$_.JMethodIDPtr,
    ).object<jni$_.JDouble?>(const jni$_.$JDouble$NullableType$());
  }

  static final _id_getANullableByteArray = _class.instanceMethodId(
    r'getANullableByteArray',
    r'()[B',
  );

  static final _getANullableByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final byte[] getANullableByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getANullableByteArray() {
    return _getANullableByteArray(
      reference.pointer,
      _id_getANullableByteArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray?>(const jni$_.$JByteArray$NullableType$());
  }

  static final _id_getANullable4ByteArray = _class.instanceMethodId(
    r'getANullable4ByteArray',
    r'()[I',
  );

  static final _getANullable4ByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int[] getANullable4ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? getANullable4ByteArray() {
    return _getANullable4ByteArray(
      reference.pointer,
      _id_getANullable4ByteArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JIntArray?>(const jni$_.$JIntArray$NullableType$());
  }

  static final _id_getANullable8ByteArray = _class.instanceMethodId(
    r'getANullable8ByteArray',
    r'()[J',
  );

  static final _getANullable8ByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long[] getANullable8ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? getANullable8ByteArray() {
    return _getANullable8ByteArray(
      reference.pointer,
      _id_getANullable8ByteArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JLongArray?>(const jni$_.$JLongArray$NullableType$());
  }

  static final _id_getANullableFloatArray = _class.instanceMethodId(
    r'getANullableFloatArray',
    r'()[D',
  );

  static final _getANullableFloatArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final double[] getANullableFloatArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? getANullableFloatArray() {
    return _getANullableFloatArray(
      reference.pointer,
      _id_getANullableFloatArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JDoubleArray?>(const jni$_.$JDoubleArray$NullableType$());
  }

  static final _id_getANullableEnum = _class.instanceMethodId(
    r'getANullableEnum',
    r'()LNIAnEnum;',
  );

  static final _getANullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAnEnum getANullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? getANullableEnum() {
    return _getANullableEnum(
      reference.pointer,
      _id_getANullableEnum as jni$_.JMethodIDPtr,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_getAnotherNullableEnum = _class.instanceMethodId(
    r'getAnotherNullableEnum',
    r'()LNIAnotherEnum;',
  );

  static final _getAnotherNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAnotherEnum getAnotherNullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? getAnotherNullableEnum() {
    return _getAnotherNullableEnum(
      reference.pointer,
      _id_getAnotherNullableEnum as jni$_.JMethodIDPtr,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }

  static final _id_getANullableString = _class.instanceMethodId(
    r'getANullableString',
    r'()Ljava/lang/String;',
  );

  static final _getANullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getANullableString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getANullableString() {
    return _getANullableString(
      reference.pointer,
      _id_getANullableString as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getANullableObject = _class.instanceMethodId(
    r'getANullableObject',
    r'()Ljava/lang/Object;',
  );

  static final _getANullableObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object getANullableObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getANullableObject() {
    return _getANullableObject(
      reference.pointer,
      _id_getANullableObject as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getAllNullableTypes = _class.instanceMethodId(
    r'getAllNullableTypes',
    r'()LNIAllNullableTypes;',
  );

  static final _getAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAllNullableTypes getAllNullableTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes? getAllNullableTypes() {
    return _getAllNullableTypes(
      reference.pointer,
      _id_getAllNullableTypes as jni$_.JMethodIDPtr,
    ).object<NIAllNullableTypes?>(const $NIAllNullableTypes$NullableType$());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getList() {
    return _getList(
      reference.pointer,
      _id_getList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getStringList() {
    return _getStringList(
      reference.pointer,
      _id_getStringList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString?>?>(
      const jni$_.$JList$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? getIntList() {
    return _getIntList(
      reference.pointer,
      _id_getIntList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JLong?>?>(
      const jni$_.$JList$NullableType$<jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? getDoubleList() {
    return _getDoubleList(
      reference.pointer,
      _id_getDoubleList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JDouble?>?>(
      const jni$_.$JList$NullableType$<jni$_.JDouble?>(
        jni$_.$JDouble$NullableType$(),
      ),
    );
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? getBoolList() {
    return _getBoolList(
      reference.pointer,
      _id_getBoolList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JBoolean?>?>(
      const jni$_.$JList$NullableType$<jni$_.JBoolean?>(
        jni$_.$JBoolean$NullableType$(),
      ),
    );
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<NIAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? getEnumList() {
    return _getEnumList(
      reference.pointer,
      _id_getEnumList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAnEnum?>?>(
      const jni$_.$JList$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_getObjectList = _class.instanceMethodId(
    r'getObjectList',
    r'()Ljava/util/List;',
  );

  static final _getObjectList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Object> getObjectList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getObjectList() {
    return _getObjectList(
      reference.pointer,
      _id_getObjectList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getListList = _class.instanceMethodId(
    r'getListList',
    r'()Ljava/util/List;',
  );

  static final _getListList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> getListList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? getListList() {
    return _getListList(
      reference.pointer,
      _id_getListList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
      const jni$_.$JList$NullableType$<jni$_.JList<jni$_.JObject?>?>(
        jni$_.$JList$NullableType$<jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_getMapList = _class.instanceMethodId(
    r'getMapList',
    r'()Ljava/util/List;',
  );

  static final _getMapList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> getMapList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? getMapList() {
    return _getMapList(
      reference.pointer,
      _id_getMapList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
      const jni$_.$JList$NullableType$<
        jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?
      >(
        jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_getRecursiveClassList = _class.instanceMethodId(
    r'getRecursiveClassList',
    r'()Ljava/util/List;',
  );

  static final _getRecursiveClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<NIAllNullableTypes> getRecursiveClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?>? getRecursiveClassList() {
    return _getRecursiveClassList(
      reference.pointer,
      _id_getRecursiveClassList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAllNullableTypes?>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypes?>(
        $NIAllNullableTypes$NullableType$(),
      ),
    );
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? getMap() {
    return _getMap(
      reference.pointer,
      _id_getMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject, jni$_.JObject?>(
        jni$_.$JObject$Type$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? getStringMap() {
    return _getStringMap(
      reference.pointer,
      _id_getStringMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_getIntMap = _class.instanceMethodId(
    r'getIntMap',
    r'()Ljava/util/Map;',
  );

  static final _getIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> getIntMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? getIntMap() {
    return _getIntMap(
      reference.pointer,
      _id_getIntMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_getEnumMap = _class.instanceMethodId(
    r'getEnumMap',
    r'()Ljava/util/Map;',
  );

  static final _getEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<NIAnEnum, NIAnEnum> getEnumMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? getEnumMap() {
    return _getEnumMap(
      reference.pointer,
      _id_getEnumMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
      const jni$_.$JMap$NullableType$<NIAnEnum?, NIAnEnum?>(
        $NIAnEnum$NullableType$(),
        $NIAnEnum$NullableType$(),
      ),
    );
  }

  static final _id_getObjectMap = _class.instanceMethodId(
    r'getObjectMap',
    r'()Ljava/util/Map;',
  );

  static final _getObjectMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getObjectMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? getObjectMap() {
    return _getObjectMap(
      reference.pointer,
      _id_getObjectMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getListMap = _class.instanceMethodId(
    r'getListMap',
    r'()Ljava/util/Map;',
  );

  static final _getListMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> getListMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? getListMap() {
    return _getListMap(
      reference.pointer,
      _id_getListMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
      const jni$_.$JMap$NullableType$<
        jni$_.JLong?,
        jni$_.JList<jni$_.JObject?>?
      >(
        jni$_.$JLong$NullableType$(),
        jni$_.$JList$NullableType$<jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_getMapMap = _class.instanceMethodId(
    r'getMapMap',
    r'()Ljava/util/Map;',
  );

  static final _getMapMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> getMapMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
  getMapMap() {
    return _getMapMap(
      reference.pointer,
      _id_getMapMap as jni$_.JMethodIDPtr,
    ).object<
      jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
    >(
      const jni$_.$JMap$NullableType$<
        jni$_.JLong?,
        jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?
      >(
        jni$_.$JLong$NullableType$(),
        jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_getRecursiveClassMap = _class.instanceMethodId(
    r'getRecursiveClassMap',
    r'()Ljava/util/Map;',
  );

  static final _getRecursiveClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Long, NIAllNullableTypes> getRecursiveClassMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? getRecursiveClassMap() {
    return _getRecursiveClassMap(
      reference.pointer,
      _id_getRecursiveClassMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, NIAllNullableTypes?>(
        jni$_.$JLong$NullableType$(),
        $NIAllNullableTypes$NullableType$(),
      ),
    );
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toList(): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(
      reference.pointer,
      _id_toList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public operator fun equals(other: kotlin.Any?): kotlin.Boolean`
  core$_.bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun hashCode(): kotlin.Int`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/Boolean;',
  );

  static final _component1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component1(): kotlin.Boolean?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? component1() {
    return _component1(
      reference.pointer,
      _id_component1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JBoolean?>(const jni$_.$JBoolean$NullableType$());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()Ljava/lang/Long;',
  );

  static final _component2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component2(): kotlin.Long?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component2() {
    return _component2(
      reference.pointer,
      _id_component2 as jni$_.JMethodIDPtr,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()Ljava/lang/Long;',
  );

  static final _component3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component3(): kotlin.Long?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component3() {
    return _component3(
      reference.pointer,
      _id_component3 as jni$_.JMethodIDPtr,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/lang/Double;',
  );

  static final _component4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component4(): kotlin.Double?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? component4() {
    return _component4(
      reference.pointer,
      _id_component4 as jni$_.JMethodIDPtr,
    ).object<jni$_.JDouble?>(const jni$_.$JDouble$NullableType$());
  }

  static final _id_component5 = _class.instanceMethodId(r'component5', r'()[B');

  static final _component5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component5(): kotlin.ByteArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? component5() {
    return _component5(
      reference.pointer,
      _id_component5 as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray?>(const jni$_.$JByteArray$NullableType$());
  }

  static final _id_component6 = _class.instanceMethodId(r'component6', r'()[I');

  static final _component6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component6(): kotlin.IntArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? component6() {
    return _component6(
      reference.pointer,
      _id_component6 as jni$_.JMethodIDPtr,
    ).object<jni$_.JIntArray?>(const jni$_.$JIntArray$NullableType$());
  }

  static final _id_component7 = _class.instanceMethodId(r'component7', r'()[J');

  static final _component7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component7(): kotlin.LongArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? component7() {
    return _component7(
      reference.pointer,
      _id_component7 as jni$_.JMethodIDPtr,
    ).object<jni$_.JLongArray?>(const jni$_.$JLongArray$NullableType$());
  }

  static final _id_component8 = _class.instanceMethodId(r'component8', r'()[D');

  static final _component8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component8(): kotlin.DoubleArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? component8() {
    return _component8(
      reference.pointer,
      _id_component8 as jni$_.JMethodIDPtr,
    ).object<jni$_.JDoubleArray?>(const jni$_.$JDoubleArray$NullableType$());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()LNIAnEnum;',
  );

  static final _component9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component9(): NIAnEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? component9() {
    return _component9(
      reference.pointer,
      _id_component9 as jni$_.JMethodIDPtr,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()LNIAnotherEnum;',
  );

  static final _component10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component10(): NIAnotherEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? component10() {
    return _component10(
      reference.pointer,
      _id_component10 as jni$_.JMethodIDPtr,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/lang/String;',
  );

  static final _component11 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component11(): kotlin.String?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? component11() {
    return _component11(
      reference.pointer,
      _id_component11 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/lang/Object;',
  );

  static final _component12 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component12(): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? component12() {
    return _component12(
      reference.pointer,
      _id_component12 as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()LNIAllNullableTypes;',
  );

  static final _component13 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component13(): NIAllNullableTypes?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes? component13() {
    return _component13(
      reference.pointer,
      _id_component13 as jni$_.JMethodIDPtr,
    ).object<NIAllNullableTypes?>(const $NIAllNullableTypes$NullableType$());
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component14(): kotlin.collections.List<kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component14() {
    return _component14(
      reference.pointer,
      _id_component14 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/List;',
  );

  static final _component15 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component15(): kotlin.collections.List<kotlin.String?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? component15() {
    return _component15(
      reference.pointer,
      _id_component15 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString?>?>(
      const jni$_.$JList$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/List;',
  );

  static final _component16 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component16(): kotlin.collections.List<kotlin.Long?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? component16() {
    return _component16(
      reference.pointer,
      _id_component16 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JLong?>?>(
      const jni$_.$JList$NullableType$<jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_component17 = _class.instanceMethodId(
    r'component17',
    r'()Ljava/util/List;',
  );

  static final _component17 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component17(): kotlin.collections.List<kotlin.Double?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? component17() {
    return _component17(
      reference.pointer,
      _id_component17 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JDouble?>?>(
      const jni$_.$JList$NullableType$<jni$_.JDouble?>(
        jni$_.$JDouble$NullableType$(),
      ),
    );
  }

  static final _id_component18 = _class.instanceMethodId(
    r'component18',
    r'()Ljava/util/List;',
  );

  static final _component18 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component18(): kotlin.collections.List<kotlin.Boolean?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? component18() {
    return _component18(
      reference.pointer,
      _id_component18 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JBoolean?>?>(
      const jni$_.$JList$NullableType$<jni$_.JBoolean?>(
        jni$_.$JBoolean$NullableType$(),
      ),
    );
  }

  static final _id_component19 = _class.instanceMethodId(
    r'component19',
    r'()Ljava/util/List;',
  );

  static final _component19 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component19(): kotlin.collections.List<NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? component19() {
    return _component19(
      reference.pointer,
      _id_component19 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAnEnum?>?>(
      const jni$_.$JList$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_component20 = _class.instanceMethodId(
    r'component20',
    r'()Ljava/util/List;',
  );

  static final _component20 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component20(): kotlin.collections.List<kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component20() {
    return _component20(
      reference.pointer,
      _id_component20 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_component21 = _class.instanceMethodId(
    r'component21',
    r'()Ljava/util/List;',
  );

  static final _component21 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component21(): kotlin.collections.List<kotlin.collections.List<kotlin.Any?>?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? component21() {
    return _component21(
      reference.pointer,
      _id_component21 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
      const jni$_.$JList$NullableType$<jni$_.JList<jni$_.JObject?>?>(
        jni$_.$JList$NullableType$<jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_component22 = _class.instanceMethodId(
    r'component22',
    r'()Ljava/util/List;',
  );

  static final _component22 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component22(): kotlin.collections.List<kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? component22() {
    return _component22(
      reference.pointer,
      _id_component22 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
      const jni$_.$JList$NullableType$<
        jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?
      >(
        jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_component23 = _class.instanceMethodId(
    r'component23',
    r'()Ljava/util/List;',
  );

  static final _component23 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component23(): kotlin.collections.List<NIAllNullableTypes?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?>? component23() {
    return _component23(
      reference.pointer,
      _id_component23 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAllNullableTypes?>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypes?>(
        $NIAllNullableTypes$NullableType$(),
      ),
    );
  }

  static final _id_component24 = _class.instanceMethodId(
    r'component24',
    r'()Ljava/util/Map;',
  );

  static final _component24 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component24(): kotlin.collections.Map<kotlin.Any, kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? component24() {
    return _component24(
      reference.pointer,
      _id_component24 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject, jni$_.JObject?>(
        jni$_.$JObject$Type$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_component25 = _class.instanceMethodId(
    r'component25',
    r'()Ljava/util/Map;',
  );

  static final _component25 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component25(): kotlin.collections.Map<kotlin.String?, kotlin.String?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? component25() {
    return _component25(
      reference.pointer,
      _id_component25 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_component26 = _class.instanceMethodId(
    r'component26',
    r'()Ljava/util/Map;',
  );

  static final _component26 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component26(): kotlin.collections.Map<kotlin.Long?, kotlin.Long?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? component26() {
    return _component26(
      reference.pointer,
      _id_component26 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_component27 = _class.instanceMethodId(
    r'component27',
    r'()Ljava/util/Map;',
  );

  static final _component27 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component27(): kotlin.collections.Map<NIAnEnum?, NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? component27() {
    return _component27(
      reference.pointer,
      _id_component27 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
      const jni$_.$JMap$NullableType$<NIAnEnum?, NIAnEnum?>(
        $NIAnEnum$NullableType$(),
        $NIAnEnum$NullableType$(),
      ),
    );
  }

  static final _id_component28 = _class.instanceMethodId(
    r'component28',
    r'()Ljava/util/Map;',
  );

  static final _component28 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component28(): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? component28() {
    return _component28(
      reference.pointer,
      _id_component28 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_component29 = _class.instanceMethodId(
    r'component29',
    r'()Ljava/util/Map;',
  );

  static final _component29 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component29(): kotlin.collections.Map<kotlin.Long?, kotlin.collections.List<kotlin.Any?>?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? component29() {
    return _component29(
      reference.pointer,
      _id_component29 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
      const jni$_.$JMap$NullableType$<
        jni$_.JLong?,
        jni$_.JList<jni$_.JObject?>?
      >(
        jni$_.$JLong$NullableType$(),
        jni$_.$JList$NullableType$<jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_component30 = _class.instanceMethodId(
    r'component30',
    r'()Ljava/util/Map;',
  );

  static final _component30 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component30(): kotlin.collections.Map<kotlin.Long?, kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
  component30() {
    return _component30(
      reference.pointer,
      _id_component30 as jni$_.JMethodIDPtr,
    ).object<
      jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
    >(
      const jni$_.$JMap$NullableType$<
        jni$_.JLong?,
        jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?
      >(
        jni$_.$JLong$NullableType$(),
        jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_component31 = _class.instanceMethodId(
    r'component31',
    r'()Ljava/util/Map;',
  );

  static final _component31 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component31(): kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? component31() {
    return _component31(
      reference.pointer,
      _id_component31 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, NIAllNullableTypes?>(
        jni$_.$JLong$NullableType$(),
        $NIAllNullableTypes$NullableType$(),
      ),
    );
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;LNIAllNullableTypes;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)LNIAllNullableTypes;',
  );

  static final _copy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun copy(aNullableBool: kotlin.Boolean?, aNullableInt: kotlin.Long?, aNullableInt64: kotlin.Long?, aNullableDouble: kotlin.Double?, aNullableByteArray: kotlin.ByteArray?, aNullable4ByteArray: kotlin.IntArray?, aNullable8ByteArray: kotlin.LongArray?, aNullableFloatArray: kotlin.DoubleArray?, aNullableEnum: NIAnEnum?, anotherNullableEnum: NIAnotherEnum?, aNullableString: kotlin.String?, aNullableObject: kotlin.Any?, allNullableTypes: NIAllNullableTypes?, list: kotlin.collections.List<kotlin.Any?>?, stringList: kotlin.collections.List<kotlin.String?>?, intList: kotlin.collections.List<kotlin.Long?>?, doubleList: kotlin.collections.List<kotlin.Double?>?, boolList: kotlin.collections.List<kotlin.Boolean?>?, enumList: kotlin.collections.List<NIAnEnum?>?, objectList: kotlin.collections.List<kotlin.Any?>?, listList: kotlin.collections.List<kotlin.collections.List<kotlin.Any?>?>?, mapList: kotlin.collections.List<kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?>?, recursiveClassList: kotlin.collections.List<NIAllNullableTypes?>?, map: kotlin.collections.Map<kotlin.Any, kotlin.Any?>?, stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>?, intMap: kotlin.collections.Map<kotlin.Long?, kotlin.Long?>?, enumMap: kotlin.collections.Map<NIAnEnum?, NIAnEnum?>?, objectMap: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?, listMap: kotlin.collections.Map<kotlin.Long?, kotlin.collections.List<kotlin.Any?>?>?, mapMap: kotlin.collections.Map<kotlin.Long?, kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?>?, recursiveClassMap: kotlin.collections.Map<kotlin.Long?, NIAllNullableTypes?>?): NIAllNullableTypes`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes copy(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    NIAllNullableTypes? nIAllNullableTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<NIAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JList<NIAllNullableTypes?>? list9,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map7,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$list9 = list9?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$map7 = map7?.reference ?? jni$_.jNullReference;
    return _copy(
      reference.pointer,
      _id_copy as jni$_.JMethodIDPtr,
      _$boolean.pointer,
      _$long.pointer,
      _$long1.pointer,
      _$double.pointer,
      _$bs.pointer,
      _$is$.pointer,
      _$js.pointer,
      _$ds.pointer,
      _$nIAnEnum.pointer,
      _$nIAnotherEnum.pointer,
      _$string.pointer,
      _$object.pointer,
      _$nIAllNullableTypes.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$list2.pointer,
      _$list3.pointer,
      _$list4.pointer,
      _$list5.pointer,
      _$list6.pointer,
      _$list7.pointer,
      _$list8.pointer,
      _$list9.pointer,
      _$map.pointer,
      _$map1.pointer,
      _$map2.pointer,
      _$map3.pointer,
      _$map4.pointer,
      _$map5.pointer,
      _$map6.pointer,
      _$map7.pointer,
    ).object<NIAllNullableTypes>(const $NIAllNullableTypes$Type$());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toString(): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_new$2 = _class.constructorId(r'()V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypes.new$2() {
    return NIAllNullableTypes.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }
}

final class $NIAllNullableTypes$NullableType$
    extends jni$_.JType<NIAllNullableTypes?> {
  @jni$_.internal
  const $NIAllNullableTypes$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypes;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypes? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIAllNullableTypes.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllNullableTypes?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllNullableTypes$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAllNullableTypes$NullableType$) &&
        other is $NIAllNullableTypes$NullableType$;
  }
}

final class $NIAllNullableTypes$Type$ extends jni$_.JType<NIAllNullableTypes> {
  @jni$_.internal
  const $NIAllNullableTypes$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypes;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypes fromReference(jni$_.JReference reference) =>
      NIAllNullableTypes.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllNullableTypes?> get nullableType =>
      const $NIAllNullableTypes$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllNullableTypes$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAllNullableTypes$Type$) &&
        other is $NIAllNullableTypes$Type$;
  }
}

/// from: `NIAllNullableTypesWithoutRecursion$Companion`
class NIAllNullableTypesWithoutRecursion$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion> $type;

  @jni$_.internal
  NIAllNullableTypesWithoutRecursion$Companion.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'NIAllNullableTypesWithoutRecursion$Companion',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion?>
  nullableType = $NIAllNullableTypesWithoutRecursion$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion> type =
      $NIAllNullableTypesWithoutRecursion$Companion$Type$();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _fromList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun fromList(pigeonVar_list: kotlin.collections.List<kotlin.Any?>): NIAllNullableTypesWithoutRecursion`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(
      reference.pointer,
      _id_fromList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<NIAllNullableTypesWithoutRecursion>(
      const $NIAllNullableTypesWithoutRecursion$Type$(),
    );
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypesWithoutRecursion$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypesWithoutRecursion$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $NIAllNullableTypesWithoutRecursion$Companion$NullableType$
    extends jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion?> {
  @jni$_.internal
  const $NIAllNullableTypesWithoutRecursion$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypesWithoutRecursion$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypesWithoutRecursion$Companion? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : NIAllNullableTypesWithoutRecursion$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($NIAllNullableTypesWithoutRecursion$Companion$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIAllNullableTypesWithoutRecursion$Companion$NullableType$) &&
        other is $NIAllNullableTypesWithoutRecursion$Companion$NullableType$;
  }
}

final class $NIAllNullableTypesWithoutRecursion$Companion$Type$
    extends jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion> {
  @jni$_.internal
  const $NIAllNullableTypesWithoutRecursion$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypesWithoutRecursion$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypesWithoutRecursion$Companion fromReference(
    jni$_.JReference reference,
  ) => NIAllNullableTypesWithoutRecursion$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion?> get nullableType =>
      const $NIAllNullableTypesWithoutRecursion$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($NIAllNullableTypesWithoutRecursion$Companion$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIAllNullableTypesWithoutRecursion$Companion$Type$) &&
        other is $NIAllNullableTypesWithoutRecursion$Companion$Type$;
  }
}

/// from: `NIAllNullableTypesWithoutRecursion`
class NIAllNullableTypesWithoutRecursion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllNullableTypesWithoutRecursion> $type;

  @jni$_.internal
  NIAllNullableTypesWithoutRecursion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'NIAllNullableTypesWithoutRecursion',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllNullableTypesWithoutRecursion?> nullableType =
      $NIAllNullableTypesWithoutRecursion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllNullableTypesWithoutRecursion> type =
      $NIAllNullableTypesWithoutRecursion$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAllNullableTypesWithoutRecursion$Companion;',
  );

  /// from: `static public final NIAllNullableTypesWithoutRecursion$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAllNullableTypesWithoutRecursion$Companion get Companion =>
      _id_Companion.get(
        _class,
        const $NIAllNullableTypesWithoutRecursion$Companion$Type$(),
      );

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends NIAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<NIAnEnum, ? extends NIAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<NIAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypesWithoutRecursion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$boolean.pointer,
        _$long.pointer,
        _$long1.pointer,
        _$double.pointer,
        _$bs.pointer,
        _$is$.pointer,
        _$js.pointer,
        _$ds.pointer,
        _$nIAnEnum.pointer,
        _$nIAnotherEnum.pointer,
        _$string.pointer,
        _$object.pointer,
        _$list.pointer,
        _$list1.pointer,
        _$list2.pointer,
        _$list3.pointer,
        _$list4.pointer,
        _$list5.pointer,
        _$list6.pointer,
        _$list7.pointer,
        _$list8.pointer,
        _$map.pointer,
        _$map1.pointer,
        _$map2.pointer,
        _$map3.pointer,
        _$map4.pointer,
        _$map5.pointer,
        _$map6.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List list, java.util.List list1, java.util.List list2, java.util.List list3, java.util.List list4, java.util.List list5, java.util.List list6, java.util.List list7, java.util.List list8, java.util.Map map, java.util.Map map1, java.util.Map map2, java.util.Map map3, java.util.Map map4, java.util.Map map5, java.util.Map map6, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypesWithoutRecursion.new$1(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    jni$_.JList<jni$_.JObject?>? list2,
    jni$_.JList<jni$_.JObject?>? list3,
    jni$_.JList<jni$_.JObject?>? list4,
    jni$_.JList<jni$_.JObject?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JObject?>? list7,
    jni$_.JList<jni$_.JObject?>? list8,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map1,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map2,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map5,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map6,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypesWithoutRecursion.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$boolean.pointer,
        _$long.pointer,
        _$long1.pointer,
        _$double.pointer,
        _$bs.pointer,
        _$is$.pointer,
        _$js.pointer,
        _$ds.pointer,
        _$nIAnEnum.pointer,
        _$nIAnotherEnum.pointer,
        _$string.pointer,
        _$object.pointer,
        _$list.pointer,
        _$list1.pointer,
        _$list2.pointer,
        _$list3.pointer,
        _$list4.pointer,
        _$list5.pointer,
        _$list6.pointer,
        _$list7.pointer,
        _$list8.pointer,
        _$map.pointer,
        _$map1.pointer,
        _$map2.pointer,
        _$map3.pointer,
        _$map4.pointer,
        _$map5.pointer,
        _$map6.pointer,
        i,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }

  static final _id_getANullableBool = _class.instanceMethodId(
    r'getANullableBool',
    r'()Ljava/lang/Boolean;',
  );

  static final _getANullableBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Boolean getANullableBool()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? getANullableBool() {
    return _getANullableBool(
      reference.pointer,
      _id_getANullableBool as jni$_.JMethodIDPtr,
    ).object<jni$_.JBoolean?>(const jni$_.$JBoolean$NullableType$());
  }

  static final _id_getANullableInt = _class.instanceMethodId(
    r'getANullableInt',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Long getANullableInt()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt() {
    return _getANullableInt(
      reference.pointer,
      _id_getANullableInt as jni$_.JMethodIDPtr,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_getANullableInt64 = _class.instanceMethodId(
    r'getANullableInt64',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt64 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Long getANullableInt64()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt64() {
    return _getANullableInt64(
      reference.pointer,
      _id_getANullableInt64 as jni$_.JMethodIDPtr,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_getANullableDouble = _class.instanceMethodId(
    r'getANullableDouble',
    r'()Ljava/lang/Double;',
  );

  static final _getANullableDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Double getANullableDouble()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getANullableDouble() {
    return _getANullableDouble(
      reference.pointer,
      _id_getANullableDouble as jni$_.JMethodIDPtr,
    ).object<jni$_.JDouble?>(const jni$_.$JDouble$NullableType$());
  }

  static final _id_getANullableByteArray = _class.instanceMethodId(
    r'getANullableByteArray',
    r'()[B',
  );

  static final _getANullableByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final byte[] getANullableByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getANullableByteArray() {
    return _getANullableByteArray(
      reference.pointer,
      _id_getANullableByteArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray?>(const jni$_.$JByteArray$NullableType$());
  }

  static final _id_getANullable4ByteArray = _class.instanceMethodId(
    r'getANullable4ByteArray',
    r'()[I',
  );

  static final _getANullable4ByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int[] getANullable4ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? getANullable4ByteArray() {
    return _getANullable4ByteArray(
      reference.pointer,
      _id_getANullable4ByteArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JIntArray?>(const jni$_.$JIntArray$NullableType$());
  }

  static final _id_getANullable8ByteArray = _class.instanceMethodId(
    r'getANullable8ByteArray',
    r'()[J',
  );

  static final _getANullable8ByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long[] getANullable8ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? getANullable8ByteArray() {
    return _getANullable8ByteArray(
      reference.pointer,
      _id_getANullable8ByteArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JLongArray?>(const jni$_.$JLongArray$NullableType$());
  }

  static final _id_getANullableFloatArray = _class.instanceMethodId(
    r'getANullableFloatArray',
    r'()[D',
  );

  static final _getANullableFloatArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final double[] getANullableFloatArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? getANullableFloatArray() {
    return _getANullableFloatArray(
      reference.pointer,
      _id_getANullableFloatArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JDoubleArray?>(const jni$_.$JDoubleArray$NullableType$());
  }

  static final _id_getANullableEnum = _class.instanceMethodId(
    r'getANullableEnum',
    r'()LNIAnEnum;',
  );

  static final _getANullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAnEnum getANullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? getANullableEnum() {
    return _getANullableEnum(
      reference.pointer,
      _id_getANullableEnum as jni$_.JMethodIDPtr,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_getAnotherNullableEnum = _class.instanceMethodId(
    r'getAnotherNullableEnum',
    r'()LNIAnotherEnum;',
  );

  static final _getAnotherNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAnotherEnum getAnotherNullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? getAnotherNullableEnum() {
    return _getAnotherNullableEnum(
      reference.pointer,
      _id_getAnotherNullableEnum as jni$_.JMethodIDPtr,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }

  static final _id_getANullableString = _class.instanceMethodId(
    r'getANullableString',
    r'()Ljava/lang/String;',
  );

  static final _getANullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getANullableString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getANullableString() {
    return _getANullableString(
      reference.pointer,
      _id_getANullableString as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getANullableObject = _class.instanceMethodId(
    r'getANullableObject',
    r'()Ljava/lang/Object;',
  );

  static final _getANullableObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object getANullableObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getANullableObject() {
    return _getANullableObject(
      reference.pointer,
      _id_getANullableObject as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getList() {
    return _getList(
      reference.pointer,
      _id_getList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getStringList() {
    return _getStringList(
      reference.pointer,
      _id_getStringList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString?>?>(
      const jni$_.$JList$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? getIntList() {
    return _getIntList(
      reference.pointer,
      _id_getIntList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JLong?>?>(
      const jni$_.$JList$NullableType$<jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? getDoubleList() {
    return _getDoubleList(
      reference.pointer,
      _id_getDoubleList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JDouble?>?>(
      const jni$_.$JList$NullableType$<jni$_.JDouble?>(
        jni$_.$JDouble$NullableType$(),
      ),
    );
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? getBoolList() {
    return _getBoolList(
      reference.pointer,
      _id_getBoolList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JBoolean?>?>(
      const jni$_.$JList$NullableType$<jni$_.JBoolean?>(
        jni$_.$JBoolean$NullableType$(),
      ),
    );
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<NIAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? getEnumList() {
    return _getEnumList(
      reference.pointer,
      _id_getEnumList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAnEnum?>?>(
      const jni$_.$JList$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_getObjectList = _class.instanceMethodId(
    r'getObjectList',
    r'()Ljava/util/List;',
  );

  static final _getObjectList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Object> getObjectList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getObjectList() {
    return _getObjectList(
      reference.pointer,
      _id_getObjectList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getListList = _class.instanceMethodId(
    r'getListList',
    r'()Ljava/util/List;',
  );

  static final _getListList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> getListList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? getListList() {
    return _getListList(
      reference.pointer,
      _id_getListList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
      const jni$_.$JList$NullableType$<jni$_.JList<jni$_.JObject?>?>(
        jni$_.$JList$NullableType$<jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_getMapList = _class.instanceMethodId(
    r'getMapList',
    r'()Ljava/util/List;',
  );

  static final _getMapList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> getMapList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? getMapList() {
    return _getMapList(
      reference.pointer,
      _id_getMapList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
      const jni$_.$JList$NullableType$<
        jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?
      >(
        jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? getMap() {
    return _getMap(
      reference.pointer,
      _id_getMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject, jni$_.JObject?>(
        jni$_.$JObject$Type$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? getStringMap() {
    return _getStringMap(
      reference.pointer,
      _id_getStringMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_getIntMap = _class.instanceMethodId(
    r'getIntMap',
    r'()Ljava/util/Map;',
  );

  static final _getIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> getIntMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? getIntMap() {
    return _getIntMap(
      reference.pointer,
      _id_getIntMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_getEnumMap = _class.instanceMethodId(
    r'getEnumMap',
    r'()Ljava/util/Map;',
  );

  static final _getEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<NIAnEnum, NIAnEnum> getEnumMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? getEnumMap() {
    return _getEnumMap(
      reference.pointer,
      _id_getEnumMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
      const jni$_.$JMap$NullableType$<NIAnEnum?, NIAnEnum?>(
        $NIAnEnum$NullableType$(),
        $NIAnEnum$NullableType$(),
      ),
    );
  }

  static final _id_getObjectMap = _class.instanceMethodId(
    r'getObjectMap',
    r'()Ljava/util/Map;',
  );

  static final _getObjectMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getObjectMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? getObjectMap() {
    return _getObjectMap(
      reference.pointer,
      _id_getObjectMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getListMap = _class.instanceMethodId(
    r'getListMap',
    r'()Ljava/util/Map;',
  );

  static final _getListMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> getListMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? getListMap() {
    return _getListMap(
      reference.pointer,
      _id_getListMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
      const jni$_.$JMap$NullableType$<
        jni$_.JLong?,
        jni$_.JList<jni$_.JObject?>?
      >(
        jni$_.$JLong$NullableType$(),
        jni$_.$JList$NullableType$<jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_getMapMap = _class.instanceMethodId(
    r'getMapMap',
    r'()Ljava/util/Map;',
  );

  static final _getMapMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> getMapMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
  getMapMap() {
    return _getMapMap(
      reference.pointer,
      _id_getMapMap as jni$_.JMethodIDPtr,
    ).object<
      jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
    >(
      const jni$_.$JMap$NullableType$<
        jni$_.JLong?,
        jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?
      >(
        jni$_.$JLong$NullableType$(),
        jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toList(): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(
      reference.pointer,
      _id_toList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public operator fun equals(other: kotlin.Any?): kotlin.Boolean`
  core$_.bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun hashCode(): kotlin.Int`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/Boolean;',
  );

  static final _component1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component1(): kotlin.Boolean?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? component1() {
    return _component1(
      reference.pointer,
      _id_component1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JBoolean?>(const jni$_.$JBoolean$NullableType$());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()Ljava/lang/Long;',
  );

  static final _component2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component2(): kotlin.Long?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component2() {
    return _component2(
      reference.pointer,
      _id_component2 as jni$_.JMethodIDPtr,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()Ljava/lang/Long;',
  );

  static final _component3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component3(): kotlin.Long?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component3() {
    return _component3(
      reference.pointer,
      _id_component3 as jni$_.JMethodIDPtr,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/lang/Double;',
  );

  static final _component4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component4(): kotlin.Double?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? component4() {
    return _component4(
      reference.pointer,
      _id_component4 as jni$_.JMethodIDPtr,
    ).object<jni$_.JDouble?>(const jni$_.$JDouble$NullableType$());
  }

  static final _id_component5 = _class.instanceMethodId(r'component5', r'()[B');

  static final _component5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component5(): kotlin.ByteArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? component5() {
    return _component5(
      reference.pointer,
      _id_component5 as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray?>(const jni$_.$JByteArray$NullableType$());
  }

  static final _id_component6 = _class.instanceMethodId(r'component6', r'()[I');

  static final _component6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component6(): kotlin.IntArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? component6() {
    return _component6(
      reference.pointer,
      _id_component6 as jni$_.JMethodIDPtr,
    ).object<jni$_.JIntArray?>(const jni$_.$JIntArray$NullableType$());
  }

  static final _id_component7 = _class.instanceMethodId(r'component7', r'()[J');

  static final _component7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component7(): kotlin.LongArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? component7() {
    return _component7(
      reference.pointer,
      _id_component7 as jni$_.JMethodIDPtr,
    ).object<jni$_.JLongArray?>(const jni$_.$JLongArray$NullableType$());
  }

  static final _id_component8 = _class.instanceMethodId(r'component8', r'()[D');

  static final _component8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component8(): kotlin.DoubleArray?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? component8() {
    return _component8(
      reference.pointer,
      _id_component8 as jni$_.JMethodIDPtr,
    ).object<jni$_.JDoubleArray?>(const jni$_.$JDoubleArray$NullableType$());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()LNIAnEnum;',
  );

  static final _component9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component9(): NIAnEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? component9() {
    return _component9(
      reference.pointer,
      _id_component9 as jni$_.JMethodIDPtr,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()LNIAnotherEnum;',
  );

  static final _component10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component10(): NIAnotherEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? component10() {
    return _component10(
      reference.pointer,
      _id_component10 as jni$_.JMethodIDPtr,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/lang/String;',
  );

  static final _component11 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component11(): kotlin.String?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? component11() {
    return _component11(
      reference.pointer,
      _id_component11 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/lang/Object;',
  );

  static final _component12 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component12(): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? component12() {
    return _component12(
      reference.pointer,
      _id_component12 as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()Ljava/util/List;',
  );

  static final _component13 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component13(): kotlin.collections.List<kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component13() {
    return _component13(
      reference.pointer,
      _id_component13 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component14(): kotlin.collections.List<kotlin.String?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? component14() {
    return _component14(
      reference.pointer,
      _id_component14 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString?>?>(
      const jni$_.$JList$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/List;',
  );

  static final _component15 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component15(): kotlin.collections.List<kotlin.Long?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? component15() {
    return _component15(
      reference.pointer,
      _id_component15 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JLong?>?>(
      const jni$_.$JList$NullableType$<jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/List;',
  );

  static final _component16 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component16(): kotlin.collections.List<kotlin.Double?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? component16() {
    return _component16(
      reference.pointer,
      _id_component16 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JDouble?>?>(
      const jni$_.$JList$NullableType$<jni$_.JDouble?>(
        jni$_.$JDouble$NullableType$(),
      ),
    );
  }

  static final _id_component17 = _class.instanceMethodId(
    r'component17',
    r'()Ljava/util/List;',
  );

  static final _component17 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component17(): kotlin.collections.List<kotlin.Boolean?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? component17() {
    return _component17(
      reference.pointer,
      _id_component17 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JBoolean?>?>(
      const jni$_.$JList$NullableType$<jni$_.JBoolean?>(
        jni$_.$JBoolean$NullableType$(),
      ),
    );
  }

  static final _id_component18 = _class.instanceMethodId(
    r'component18',
    r'()Ljava/util/List;',
  );

  static final _component18 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component18(): kotlin.collections.List<NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? component18() {
    return _component18(
      reference.pointer,
      _id_component18 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAnEnum?>?>(
      const jni$_.$JList$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_component19 = _class.instanceMethodId(
    r'component19',
    r'()Ljava/util/List;',
  );

  static final _component19 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component19(): kotlin.collections.List<kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component19() {
    return _component19(
      reference.pointer,
      _id_component19 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_component20 = _class.instanceMethodId(
    r'component20',
    r'()Ljava/util/List;',
  );

  static final _component20 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component20(): kotlin.collections.List<kotlin.collections.List<kotlin.Any?>?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? component20() {
    return _component20(
      reference.pointer,
      _id_component20 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
      const jni$_.$JList$NullableType$<jni$_.JList<jni$_.JObject?>?>(
        jni$_.$JList$NullableType$<jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_component21 = _class.instanceMethodId(
    r'component21',
    r'()Ljava/util/List;',
  );

  static final _component21 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component21(): kotlin.collections.List<kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? component21() {
    return _component21(
      reference.pointer,
      _id_component21 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
      const jni$_.$JList$NullableType$<
        jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?
      >(
        jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_component22 = _class.instanceMethodId(
    r'component22',
    r'()Ljava/util/Map;',
  );

  static final _component22 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component22(): kotlin.collections.Map<kotlin.Any, kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? component22() {
    return _component22(
      reference.pointer,
      _id_component22 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject, jni$_.JObject?>(
        jni$_.$JObject$Type$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_component23 = _class.instanceMethodId(
    r'component23',
    r'()Ljava/util/Map;',
  );

  static final _component23 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component23(): kotlin.collections.Map<kotlin.String?, kotlin.String?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? component23() {
    return _component23(
      reference.pointer,
      _id_component23 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_component24 = _class.instanceMethodId(
    r'component24',
    r'()Ljava/util/Map;',
  );

  static final _component24 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component24(): kotlin.collections.Map<kotlin.Long?, kotlin.Long?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? component24() {
    return _component24(
      reference.pointer,
      _id_component24 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_component25 = _class.instanceMethodId(
    r'component25',
    r'()Ljava/util/Map;',
  );

  static final _component25 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component25(): kotlin.collections.Map<NIAnEnum?, NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? component25() {
    return _component25(
      reference.pointer,
      _id_component25 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
      const jni$_.$JMap$NullableType$<NIAnEnum?, NIAnEnum?>(
        $NIAnEnum$NullableType$(),
        $NIAnEnum$NullableType$(),
      ),
    );
  }

  static final _id_component26 = _class.instanceMethodId(
    r'component26',
    r'()Ljava/util/Map;',
  );

  static final _component26 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component26(): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? component26() {
    return _component26(
      reference.pointer,
      _id_component26 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_component27 = _class.instanceMethodId(
    r'component27',
    r'()Ljava/util/Map;',
  );

  static final _component27 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component27(): kotlin.collections.Map<kotlin.Long?, kotlin.collections.List<kotlin.Any?>?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? component27() {
    return _component27(
      reference.pointer,
      _id_component27 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
      const jni$_.$JMap$NullableType$<
        jni$_.JLong?,
        jni$_.JList<jni$_.JObject?>?
      >(
        jni$_.$JLong$NullableType$(),
        jni$_.$JList$NullableType$<jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_component28 = _class.instanceMethodId(
    r'component28',
    r'()Ljava/util/Map;',
  );

  static final _component28 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component28(): kotlin.collections.Map<kotlin.Long?, kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
  component28() {
    return _component28(
      reference.pointer,
      _id_component28 as jni$_.JMethodIDPtr,
    ).object<
      jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
    >(
      const jni$_.$JMap$NullableType$<
        jni$_.JLong?,
        jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?
      >(
        jni$_.$JLong$NullableType$(),
        jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
          jni$_.$JObject$NullableType$(),
          jni$_.$JObject$NullableType$(),
        ),
      ),
    );
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _copy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun copy(aNullableBool: kotlin.Boolean?, aNullableInt: kotlin.Long?, aNullableInt64: kotlin.Long?, aNullableDouble: kotlin.Double?, aNullableByteArray: kotlin.ByteArray?, aNullable4ByteArray: kotlin.IntArray?, aNullable8ByteArray: kotlin.LongArray?, aNullableFloatArray: kotlin.DoubleArray?, aNullableEnum: NIAnEnum?, anotherNullableEnum: NIAnotherEnum?, aNullableString: kotlin.String?, aNullableObject: kotlin.Any?, list: kotlin.collections.List<kotlin.Any?>?, stringList: kotlin.collections.List<kotlin.String?>?, intList: kotlin.collections.List<kotlin.Long?>?, doubleList: kotlin.collections.List<kotlin.Double?>?, boolList: kotlin.collections.List<kotlin.Boolean?>?, enumList: kotlin.collections.List<NIAnEnum?>?, objectList: kotlin.collections.List<kotlin.Any?>?, listList: kotlin.collections.List<kotlin.collections.List<kotlin.Any?>?>?, mapList: kotlin.collections.List<kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?>?, map: kotlin.collections.Map<kotlin.Any, kotlin.Any?>?, stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>?, intMap: kotlin.collections.Map<kotlin.Long?, kotlin.Long?>?, enumMap: kotlin.collections.Map<NIAnEnum?, NIAnEnum?>?, objectMap: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?, listMap: kotlin.collections.Map<kotlin.Long?, kotlin.collections.List<kotlin.Any?>?>?, mapMap: kotlin.collections.Map<kotlin.Long?, kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?>?): NIAllNullableTypesWithoutRecursion`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion copy(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<NIAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    return _copy(
      reference.pointer,
      _id_copy as jni$_.JMethodIDPtr,
      _$boolean.pointer,
      _$long.pointer,
      _$long1.pointer,
      _$double.pointer,
      _$bs.pointer,
      _$is$.pointer,
      _$js.pointer,
      _$ds.pointer,
      _$nIAnEnum.pointer,
      _$nIAnotherEnum.pointer,
      _$string.pointer,
      _$object.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$list2.pointer,
      _$list3.pointer,
      _$list4.pointer,
      _$list5.pointer,
      _$list6.pointer,
      _$list7.pointer,
      _$list8.pointer,
      _$map.pointer,
      _$map1.pointer,
      _$map2.pointer,
      _$map3.pointer,
      _$map4.pointer,
      _$map5.pointer,
      _$map6.pointer,
    ).object<NIAllNullableTypesWithoutRecursion>(
      const $NIAllNullableTypesWithoutRecursion$Type$(),
    );
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toString(): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_new$2 = _class.constructorId(r'()V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypesWithoutRecursion.new$2() {
    return NIAllNullableTypesWithoutRecursion.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }
}

final class $NIAllNullableTypesWithoutRecursion$NullableType$
    extends jni$_.JType<NIAllNullableTypesWithoutRecursion?> {
  @jni$_.internal
  const $NIAllNullableTypesWithoutRecursion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypesWithoutRecursion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypesWithoutRecursion? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : NIAllNullableTypesWithoutRecursion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllNullableTypesWithoutRecursion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($NIAllNullableTypesWithoutRecursion$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIAllNullableTypesWithoutRecursion$NullableType$) &&
        other is $NIAllNullableTypesWithoutRecursion$NullableType$;
  }
}

final class $NIAllNullableTypesWithoutRecursion$Type$
    extends jni$_.JType<NIAllNullableTypesWithoutRecursion> {
  @jni$_.internal
  const $NIAllNullableTypesWithoutRecursion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypesWithoutRecursion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypesWithoutRecursion fromReference(
    jni$_.JReference reference,
  ) => NIAllNullableTypesWithoutRecursion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllNullableTypesWithoutRecursion?> get nullableType =>
      const $NIAllNullableTypesWithoutRecursion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllNullableTypesWithoutRecursion$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAllNullableTypesWithoutRecursion$Type$) &&
        other is $NIAllNullableTypesWithoutRecursion$Type$;
  }
}

/// from: `NIAllClassesWrapper$Companion`
class NIAllClassesWrapper$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllClassesWrapper$Companion> $type;

  @jni$_.internal
  NIAllClassesWrapper$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllClassesWrapper$Companion');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllClassesWrapper$Companion?> nullableType =
      $NIAllClassesWrapper$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllClassesWrapper$Companion> type =
      $NIAllClassesWrapper$Companion$Type$();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LNIAllClassesWrapper;',
  );

  static final _fromList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun fromList(pigeonVar_list: kotlin.collections.List<kotlin.Any?>): NIAllClassesWrapper`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper fromList(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _fromList(
      reference.pointer,
      _id_fromList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type$());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllClassesWrapper$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllClassesWrapper$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $NIAllClassesWrapper$Companion$NullableType$
    extends jni$_.JType<NIAllClassesWrapper$Companion?> {
  @jni$_.internal
  const $NIAllClassesWrapper$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllClassesWrapper$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllClassesWrapper$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : NIAllClassesWrapper$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllClassesWrapper$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllClassesWrapper$Companion$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIAllClassesWrapper$Companion$NullableType$) &&
        other is $NIAllClassesWrapper$Companion$NullableType$;
  }
}

final class $NIAllClassesWrapper$Companion$Type$
    extends jni$_.JType<NIAllClassesWrapper$Companion> {
  @jni$_.internal
  const $NIAllClassesWrapper$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllClassesWrapper$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllClassesWrapper$Companion fromReference(jni$_.JReference reference) =>
      NIAllClassesWrapper$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllClassesWrapper$Companion?> get nullableType =>
      const $NIAllClassesWrapper$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllClassesWrapper$Companion$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAllClassesWrapper$Companion$Type$) &&
        other is $NIAllClassesWrapper$Companion$Type$;
  }
}

/// from: `NIAllClassesWrapper`
class NIAllClassesWrapper extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllClassesWrapper> $type;

  @jni$_.internal
  NIAllClassesWrapper.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllClassesWrapper');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllClassesWrapper?> nullableType =
      $NIAllClassesWrapper$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllClassesWrapper> type =
      $NIAllClassesWrapper$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAllClassesWrapper$Companion;',
  );

  /// from: `static public final NIAllClassesWrapper$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAllClassesWrapper$Companion get Companion =>
      _id_Companion.get(_class, const $NIAllClassesWrapper$Companion$Type$());

  static final _id_new$ = _class.constructorId(
    r'(LNIAllNullableTypes;LNIAllNullableTypesWithoutRecursion;LNIAllTypes;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(NIAllNullableTypes nIAllNullableTypes, NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion, NIAllTypes nIAllTypes, java.util.List<NIAllTypes> list, java.util.List<NIAllNullableTypesWithoutRecursion> list1, java.util.Map<java.lang.Long, NIAllTypes> map, java.util.Map<java.lang.Long, NIAllNullableTypesWithoutRecursion> map1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllClassesWrapper(
    NIAllNullableTypes nIAllNullableTypes,
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
    NIAllTypes? nIAllTypes,
    jni$_.JList<NIAllTypes?> list,
    jni$_.JList<NIAllNullableTypesWithoutRecursion?>? list1,
    jni$_.JMap<jni$_.JLong?, NIAllTypes?> map,
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypesWithoutRecursion?>? map1,
  ) {
    final _$nIAllNullableTypes = nIAllNullableTypes.reference;
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$nIAllTypes = nIAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list.reference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$map = map.reference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    return NIAllClassesWrapper.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$nIAllNullableTypes.pointer,
        _$nIAllNullableTypesWithoutRecursion.pointer,
        _$nIAllTypes.pointer,
        _$list.pointer,
        _$list1.pointer,
        _$map.pointer,
        _$map1.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(LNIAllNullableTypes;LNIAllNullableTypesWithoutRecursion;LNIAllTypes;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(NIAllNullableTypes nIAllNullableTypes, NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion, NIAllTypes nIAllTypes, java.util.List list, java.util.List list1, java.util.Map map, java.util.Map map1, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllClassesWrapper.new$1(
    NIAllNullableTypes? nIAllNullableTypes,
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
    NIAllTypes? nIAllTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map1,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$nIAllTypes = nIAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllClassesWrapper.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$nIAllNullableTypes.pointer,
        _$nIAllNullableTypesWithoutRecursion.pointer,
        _$nIAllTypes.pointer,
        _$list.pointer,
        _$list1.pointer,
        _$map.pointer,
        _$map1.pointer,
        i,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }

  static final _id_getAllNullableTypes = _class.instanceMethodId(
    r'getAllNullableTypes',
    r'()LNIAllNullableTypes;',
  );

  static final _getAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAllNullableTypes getAllNullableTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes getAllNullableTypes() {
    return _getAllNullableTypes(
      reference.pointer,
      _id_getAllNullableTypes as jni$_.JMethodIDPtr,
    ).object<NIAllNullableTypes>(const $NIAllNullableTypes$Type$());
  }

  static final _id_getAllNullableTypesWithoutRecursion = _class
      .instanceMethodId(
        r'getAllNullableTypesWithoutRecursion',
        r'()LNIAllNullableTypesWithoutRecursion;',
      );

  static final _getAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAllNullableTypesWithoutRecursion getAllNullableTypesWithoutRecursion()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion? getAllNullableTypesWithoutRecursion() {
    return _getAllNullableTypesWithoutRecursion(
      reference.pointer,
      _id_getAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
    ).object<NIAllNullableTypesWithoutRecursion?>(
      const $NIAllNullableTypesWithoutRecursion$NullableType$(),
    );
  }

  static final _id_getAllTypes = _class.instanceMethodId(
    r'getAllTypes',
    r'()LNIAllTypes;',
  );

  static final _getAllTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAllTypes getAllTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes? getAllTypes() {
    return _getAllTypes(
      reference.pointer,
      _id_getAllTypes as jni$_.JMethodIDPtr,
    ).object<NIAllTypes?>(const $NIAllTypes$NullableType$());
  }

  static final _id_getClassList = _class.instanceMethodId(
    r'getClassList',
    r'()Ljava/util/List;',
  );

  static final _getClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<NIAllTypes> getClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllTypes?> getClassList() {
    return _getClassList(
      reference.pointer,
      _id_getClassList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAllTypes?>>(
      const jni$_.$JList$Type$<NIAllTypes?>($NIAllTypes$NullableType$()),
    );
  }

  static final _id_getNullableClassList = _class.instanceMethodId(
    r'getNullableClassList',
    r'()Ljava/util/List;',
  );

  static final _getNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<NIAllNullableTypesWithoutRecursion> getNullableClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypesWithoutRecursion?>? getNullableClassList() {
    return _getNullableClassList(
      reference.pointer,
      _id_getNullableClassList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAllNullableTypesWithoutRecursion?>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypesWithoutRecursion?>(
        $NIAllNullableTypesWithoutRecursion$NullableType$(),
      ),
    );
  }

  static final _id_getClassMap = _class.instanceMethodId(
    r'getClassMap',
    r'()Ljava/util/Map;',
  );

  static final _getClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Long, NIAllTypes> getClassMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllTypes?> getClassMap() {
    return _getClassMap(
      reference.pointer,
      _id_getClassMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, NIAllTypes?>>(
      const jni$_.$JMap$Type$<jni$_.JLong?, NIAllTypes?>(
        jni$_.$JLong$NullableType$(),
        $NIAllTypes$NullableType$(),
      ),
    );
  }

  static final _id_getNullableClassMap = _class.instanceMethodId(
    r'getNullableClassMap',
    r'()Ljava/util/Map;',
  );

  static final _getNullableClassMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Long, NIAllNullableTypesWithoutRecursion> getNullableClassMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypesWithoutRecursion?>?
  getNullableClassMap() {
    return _getNullableClassMap(
      reference.pointer,
      _id_getNullableClassMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypesWithoutRecursion?>?>(
      const jni$_.$JMap$NullableType$<
        jni$_.JLong?,
        NIAllNullableTypesWithoutRecursion?
      >(
        jni$_.$JLong$NullableType$(),
        $NIAllNullableTypesWithoutRecursion$NullableType$(),
      ),
    );
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toList(): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(
      reference.pointer,
      _id_toList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public operator fun equals(other: kotlin.Any?): kotlin.Boolean`
  core$_.bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun hashCode(): kotlin.Int`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()LNIAllNullableTypes;',
  );

  static final _component1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component1(): NIAllNullableTypes`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes component1() {
    return _component1(
      reference.pointer,
      _id_component1 as jni$_.JMethodIDPtr,
    ).object<NIAllNullableTypes>(const $NIAllNullableTypes$Type$());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()LNIAllNullableTypesWithoutRecursion;',
  );

  static final _component2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component2(): NIAllNullableTypesWithoutRecursion?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion? component2() {
    return _component2(
      reference.pointer,
      _id_component2 as jni$_.JMethodIDPtr,
    ).object<NIAllNullableTypesWithoutRecursion?>(
      const $NIAllNullableTypesWithoutRecursion$NullableType$(),
    );
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()LNIAllTypes;',
  );

  static final _component3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component3(): NIAllTypes?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes? component3() {
    return _component3(
      reference.pointer,
      _id_component3 as jni$_.JMethodIDPtr,
    ).object<NIAllTypes?>(const $NIAllTypes$NullableType$());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/util/List;',
  );

  static final _component4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component4(): kotlin.collections.List<NIAllTypes?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllTypes?> component4() {
    return _component4(
      reference.pointer,
      _id_component4 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAllTypes?>>(
      const jni$_.$JList$Type$<NIAllTypes?>($NIAllTypes$NullableType$()),
    );
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()Ljava/util/List;',
  );

  static final _component5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component5(): kotlin.collections.List<NIAllNullableTypesWithoutRecursion?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypesWithoutRecursion?>? component5() {
    return _component5(
      reference.pointer,
      _id_component5 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAllNullableTypesWithoutRecursion?>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypesWithoutRecursion?>(
        $NIAllNullableTypesWithoutRecursion$NullableType$(),
      ),
    );
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()Ljava/util/Map;',
  );

  static final _component6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component6(): kotlin.collections.Map<kotlin.Long?, NIAllTypes?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllTypes?> component6() {
    return _component6(
      reference.pointer,
      _id_component6 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, NIAllTypes?>>(
      const jni$_.$JMap$Type$<jni$_.JLong?, NIAllTypes?>(
        jni$_.$JLong$NullableType$(),
        $NIAllTypes$NullableType$(),
      ),
    );
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()Ljava/util/Map;',
  );

  static final _component7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component7(): kotlin.collections.Map<kotlin.Long?, NIAllNullableTypesWithoutRecursion?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypesWithoutRecursion?>? component7() {
    return _component7(
      reference.pointer,
      _id_component7 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypesWithoutRecursion?>?>(
      const jni$_.$JMap$NullableType$<
        jni$_.JLong?,
        NIAllNullableTypesWithoutRecursion?
      >(
        jni$_.$JLong$NullableType$(),
        $NIAllNullableTypesWithoutRecursion$NullableType$(),
      ),
    );
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(LNIAllNullableTypes;LNIAllNullableTypesWithoutRecursion;LNIAllTypes;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;)LNIAllClassesWrapper;',
  );

  static final _copy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun copy(allNullableTypes: NIAllNullableTypes, allNullableTypesWithoutRecursion: NIAllNullableTypesWithoutRecursion?, allTypes: NIAllTypes?, classList: kotlin.collections.List<NIAllTypes?>, nullableClassList: kotlin.collections.List<NIAllNullableTypesWithoutRecursion?>?, classMap: kotlin.collections.Map<kotlin.Long?, NIAllTypes?>, nullableClassMap: kotlin.collections.Map<kotlin.Long?, NIAllNullableTypesWithoutRecursion?>?): NIAllClassesWrapper`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper copy(
    NIAllNullableTypes nIAllNullableTypes,
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
    NIAllTypes? nIAllTypes,
    jni$_.JList<NIAllTypes?> list,
    jni$_.JList<NIAllNullableTypesWithoutRecursion?>? list1,
    jni$_.JMap<jni$_.JLong?, NIAllTypes?> map,
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypesWithoutRecursion?>? map1,
  ) {
    final _$nIAllNullableTypes = nIAllNullableTypes.reference;
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$nIAllTypes = nIAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list.reference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$map = map.reference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    return _copy(
      reference.pointer,
      _id_copy as jni$_.JMethodIDPtr,
      _$nIAllNullableTypes.pointer,
      _$nIAllNullableTypesWithoutRecursion.pointer,
      _$nIAllTypes.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$map.pointer,
      _$map1.pointer,
    ).object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type$());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toString(): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }
}

final class $NIAllClassesWrapper$NullableType$
    extends jni$_.JType<NIAllClassesWrapper?> {
  @jni$_.internal
  const $NIAllClassesWrapper$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllClassesWrapper;';

  @jni$_.internal
  @core$_.override
  NIAllClassesWrapper? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIAllClassesWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllClassesWrapper?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllClassesWrapper$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAllClassesWrapper$NullableType$) &&
        other is $NIAllClassesWrapper$NullableType$;
  }
}

final class $NIAllClassesWrapper$Type$
    extends jni$_.JType<NIAllClassesWrapper> {
  @jni$_.internal
  const $NIAllClassesWrapper$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllClassesWrapper;';

  @jni$_.internal
  @core$_.override
  NIAllClassesWrapper fromReference(jni$_.JReference reference) =>
      NIAllClassesWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllClassesWrapper?> get nullableType =>
      const $NIAllClassesWrapper$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllClassesWrapper$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAllClassesWrapper$Type$) &&
        other is $NIAllClassesWrapper$Type$;
  }
}

/// from: `NIAnEnum$Companion`
class NIAnEnum$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAnEnum$Companion> $type;

  @jni$_.internal
  NIAnEnum$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAnEnum$Companion');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnEnum$Companion?> nullableType =
      $NIAnEnum$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnEnum$Companion> type =
      $NIAnEnum$Companion$Type$();
  static final _id_ofRaw = _class.instanceMethodId(r'ofRaw', r'(I)LNIAnEnum;');

  static final _ofRaw =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public fun ofRaw(raw: kotlin.Int): NIAnEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? ofRaw(int i) {
    return _ofRaw(
      reference.pointer,
      _id_ofRaw as jni$_.JMethodIDPtr,
      i,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAnEnum$Companion(jni$_.JObject? defaultConstructorMarker) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAnEnum$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $NIAnEnum$Companion$NullableType$
    extends jni$_.JType<NIAnEnum$Companion?> {
  @jni$_.internal
  const $NIAnEnum$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnEnum$Companion;';

  @jni$_.internal
  @core$_.override
  NIAnEnum$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIAnEnum$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnEnum$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnEnum$Companion$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAnEnum$Companion$NullableType$) &&
        other is $NIAnEnum$Companion$NullableType$;
  }
}

final class $NIAnEnum$Companion$Type$ extends jni$_.JType<NIAnEnum$Companion> {
  @jni$_.internal
  const $NIAnEnum$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnEnum$Companion;';

  @jni$_.internal
  @core$_.override
  NIAnEnum$Companion fromReference(jni$_.JReference reference) =>
      NIAnEnum$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnEnum$Companion?> get nullableType =>
      const $NIAnEnum$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnEnum$Companion$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAnEnum$Companion$Type$) &&
        other is $NIAnEnum$Companion$Type$;
  }
}

/// from: `NIAnEnum`
class NIAnEnum extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAnEnum> $type;

  @jni$_.internal
  NIAnEnum.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAnEnum');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnEnum?> nullableType = $NIAnEnum$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnEnum> type = $NIAnEnum$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAnEnum$Companion;',
  );

  /// from: `static public final NIAnEnum$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum$Companion get Companion =>
      _id_Companion.get(_class, const $NIAnEnum$Companion$Type$());

  static final _id_ONE = _class.staticFieldId(r'ONE', r'LNIAnEnum;');

  /// from: `static public final NIAnEnum ONE`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get ONE => _id_ONE.get(_class, const $NIAnEnum$Type$());

  static final _id_TWO = _class.staticFieldId(r'TWO', r'LNIAnEnum;');

  /// from: `static public final NIAnEnum TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get TWO => _id_TWO.get(_class, const $NIAnEnum$Type$());

  static final _id_THREE = _class.staticFieldId(r'THREE', r'LNIAnEnum;');

  /// from: `static public final NIAnEnum THREE`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get THREE => _id_THREE.get(_class, const $NIAnEnum$Type$());

  static final _id_FORTY_TWO = _class.staticFieldId(
    r'FORTY_TWO',
    r'LNIAnEnum;',
  );

  /// from: `static public final NIAnEnum FORTY_TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get FORTY_TWO =>
      _id_FORTY_TWO.get(_class, const $NIAnEnum$Type$());

  static final _id_FOUR_HUNDRED_TWENTY_TWO = _class.staticFieldId(
    r'FOUR_HUNDRED_TWENTY_TWO',
    r'LNIAnEnum;',
  );

  /// from: `static public final NIAnEnum FOUR_HUNDRED_TWENTY_TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get FOUR_HUNDRED_TWENTY_TWO =>
      _id_FOUR_HUNDRED_TWENTY_TWO.get(_class, const $NIAnEnum$Type$());

  static final _id_getRaw = _class.instanceMethodId(r'getRaw', r'()I');

  static final _getRaw =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int getRaw()`
  int getRaw() {
    return _getRaw(reference.pointer, _id_getRaw as jni$_.JMethodIDPtr).integer;
  }

  static final _id_values = _class.staticMethodId(r'values', r'()[LNIAnEnum;');

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public NIAnEnum[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<NIAnEnum?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<NIAnEnum?>?>(
      const jni$_.$JArray$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)LNIAnEnum;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public NIAnEnum valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public kotlin.enums.EnumEntries<NIAnEnum> getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
      _class.reference.pointer,
      _id_getEntries as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }
}

final class $NIAnEnum$NullableType$ extends jni$_.JType<NIAnEnum?> {
  @jni$_.internal
  const $NIAnEnum$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnEnum;';

  @jni$_.internal
  @core$_.override
  NIAnEnum? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIAnEnum.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnEnum?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnEnum$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAnEnum$NullableType$) &&
        other is $NIAnEnum$NullableType$;
  }
}

final class $NIAnEnum$Type$ extends jni$_.JType<NIAnEnum> {
  @jni$_.internal
  const $NIAnEnum$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnEnum;';

  @jni$_.internal
  @core$_.override
  NIAnEnum fromReference(jni$_.JReference reference) =>
      NIAnEnum.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnEnum?> get nullableType => const $NIAnEnum$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnEnum$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAnEnum$Type$) && other is $NIAnEnum$Type$;
  }
}

/// from: `NIAnotherEnum$Companion`
class NIAnotherEnum$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAnotherEnum$Companion> $type;

  @jni$_.internal
  NIAnotherEnum$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAnotherEnum$Companion');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnotherEnum$Companion?> nullableType =
      $NIAnotherEnum$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnotherEnum$Companion> type =
      $NIAnotherEnum$Companion$Type$();
  static final _id_ofRaw = _class.instanceMethodId(
    r'ofRaw',
    r'(I)LNIAnotherEnum;',
  );

  static final _ofRaw =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public fun ofRaw(raw: kotlin.Int): NIAnotherEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? ofRaw(int i) {
    return _ofRaw(
      reference.pointer,
      _id_ofRaw as jni$_.JMethodIDPtr,
      i,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAnotherEnum$Companion(jni$_.JObject? defaultConstructorMarker) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAnotherEnum$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $NIAnotherEnum$Companion$NullableType$
    extends jni$_.JType<NIAnotherEnum$Companion?> {
  @jni$_.internal
  const $NIAnotherEnum$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnotherEnum$Companion;';

  @jni$_.internal
  @core$_.override
  NIAnotherEnum$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : NIAnotherEnum$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnotherEnum$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnotherEnum$Companion$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAnotherEnum$Companion$NullableType$) &&
        other is $NIAnotherEnum$Companion$NullableType$;
  }
}

final class $NIAnotherEnum$Companion$Type$
    extends jni$_.JType<NIAnotherEnum$Companion> {
  @jni$_.internal
  const $NIAnotherEnum$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnotherEnum$Companion;';

  @jni$_.internal
  @core$_.override
  NIAnotherEnum$Companion fromReference(jni$_.JReference reference) =>
      NIAnotherEnum$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnotherEnum$Companion?> get nullableType =>
      const $NIAnotherEnum$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnotherEnum$Companion$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAnotherEnum$Companion$Type$) &&
        other is $NIAnotherEnum$Companion$Type$;
  }
}

/// from: `NIAnotherEnum`
class NIAnotherEnum extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAnotherEnum> $type;

  @jni$_.internal
  NIAnotherEnum.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAnotherEnum');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnotherEnum?> nullableType =
      $NIAnotherEnum$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnotherEnum> type = $NIAnotherEnum$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAnotherEnum$Companion;',
  );

  /// from: `static public final NIAnotherEnum$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnotherEnum$Companion get Companion =>
      _id_Companion.get(_class, const $NIAnotherEnum$Companion$Type$());

  static final _id_JUST_IN_CASE = _class.staticFieldId(
    r'JUST_IN_CASE',
    r'LNIAnotherEnum;',
  );

  /// from: `static public final NIAnotherEnum JUST_IN_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnotherEnum get JUST_IN_CASE =>
      _id_JUST_IN_CASE.get(_class, const $NIAnotherEnum$Type$());

  static final _id_getRaw = _class.instanceMethodId(r'getRaw', r'()I');

  static final _getRaw =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int getRaw()`
  int getRaw() {
    return _getRaw(reference.pointer, _id_getRaw as jni$_.JMethodIDPtr).integer;
  }

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[LNIAnotherEnum;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public NIAnotherEnum[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<NIAnotherEnum?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<NIAnotherEnum?>?>(
      const jni$_.$JArray$NullableType$<NIAnotherEnum?>(
        $NIAnotherEnum$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)LNIAnotherEnum;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public NIAnotherEnum valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnotherEnum? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public kotlin.enums.EnumEntries<NIAnotherEnum> getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
      _class.reference.pointer,
      _id_getEntries as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }
}

final class $NIAnotherEnum$NullableType$ extends jni$_.JType<NIAnotherEnum?> {
  @jni$_.internal
  const $NIAnotherEnum$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnotherEnum;';

  @jni$_.internal
  @core$_.override
  NIAnotherEnum? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIAnotherEnum.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnotherEnum?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnotherEnum$NullableType$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAnotherEnum$NullableType$) &&
        other is $NIAnotherEnum$NullableType$;
  }
}

final class $NIAnotherEnum$Type$ extends jni$_.JType<NIAnotherEnum> {
  @jni$_.internal
  const $NIAnotherEnum$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnotherEnum;';

  @jni$_.internal
  @core$_.override
  NIAnotherEnum fromReference(jni$_.JReference reference) =>
      NIAnotherEnum.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnotherEnum?> get nullableType =>
      const $NIAnotherEnum$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnotherEnum$Type$).hashCode;

  @core$_.override
  core$_.bool operator ==(Object other) {
    return other.runtimeType == ($NIAnotherEnum$Type$) &&
        other is $NIAnotherEnum$Type$;
  }
}
