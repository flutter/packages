// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `NIHostIntegrationCoreApi`
class NIHostIntegrationCoreApi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIHostIntegrationCoreApi> $type;

  @jni$_.internal
  NIHostIntegrationCoreApi.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIHostIntegrationCoreApi');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIHostIntegrationCoreApi$NullableType();
  static const type = $NIHostIntegrationCoreApi$Type();
  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }

  static final _id_echoAllTypes = _class.instanceMethodId(
    r'echoAllTypes',
    r'(LNIAllTypes;)LNIAllTypes;',
  );

  static final _echoAllTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllTypes echoAllTypes(NIAllTypes nIAllTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes echoAllTypes(
    NIAllTypes nIAllTypes,
  ) {
    final _$nIAllTypes = nIAllTypes.reference;
    return _echoAllTypes(reference.pointer,
            _id_echoAllTypes as jni$_.JMethodIDPtr, _$nIAllTypes.pointer)
        .object<NIAllTypes>(const $NIAllTypes$Type());
  }

  static final _id_throwError = _class.instanceMethodId(
    r'throwError',
    r'()Ljava/lang/Object;',
  );

  static final _throwError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.Object throwError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwError() {
    return _throwError(reference.pointer, _id_throwError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_throwErrorFromVoid = _class.instanceMethodId(
    r'throwErrorFromVoid',
    r'()V',
  );

  static final _throwErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void throwErrorFromVoid()`
  void throwErrorFromVoid() {
    _throwErrorFromVoid(
            reference.pointer, _id_throwErrorFromVoid as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_throwFlutterError = _class.instanceMethodId(
    r'throwFlutterError',
    r'()Ljava/lang/Object;',
  );

  static final _throwFlutterError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.Object throwFlutterError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwFlutterError() {
    return _throwFlutterError(
            reference.pointer, _id_throwFlutterError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_echoInt = _class.instanceMethodId(
    r'echoInt',
    r'(J)J',
  );

  static final _echoInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract long echoInt(long j)`
  int echoInt(
    int j,
  ) {
    return _echoInt(reference.pointer, _id_echoInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoDouble = _class.instanceMethodId(
    r'echoDouble',
    r'(D)D',
  );

  static final _echoDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public abstract double echoDouble(double d)`
  double echoDouble(
    double d,
  ) {
    return _echoDouble(
            reference.pointer, _id_echoDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoBool = _class.instanceMethodId(
    r'echoBool',
    r'(Z)Z',
  );

  static final _echoBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract boolean echoBool(boolean z)`
  bool echoBool(
    bool z,
  ) {
    return _echoBool(
            reference.pointer, _id_echoBool as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_echoString = _class.instanceMethodId(
    r'echoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoString(reference.pointer, _id_echoString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoUint8List = _class.instanceMethodId(
    r'echoUint8List',
    r'([B)[B',
  );

  static final _echoUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] echoUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray echoUint8List(
    jni$_.JByteArray bs,
  ) {
    final _$bs = bs.reference;
    return _echoUint8List(reference.pointer,
            _id_echoUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_echoInt32List = _class.instanceMethodId(
    r'echoInt32List',
    r'([I)[I',
  );

  static final _echoInt32List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract int[] echoInt32List(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray echoInt32List(
    jni$_.JIntArray is$,
  ) {
    final _$is$ = is$.reference;
    return _echoInt32List(reference.pointer,
            _id_echoInt32List as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<jni$_.JIntArray>(const jni$_.JIntArrayType());
  }

  static final _id_echoInt64List = _class.instanceMethodId(
    r'echoInt64List',
    r'([J)[J',
  );

  static final _echoInt64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract long[] echoInt64List(long[] js)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray echoInt64List(
    jni$_.JLongArray js,
  ) {
    final _$js = js.reference;
    return _echoInt64List(reference.pointer,
            _id_echoInt64List as jni$_.JMethodIDPtr, _$js.pointer)
        .object<jni$_.JLongArray>(const jni$_.JLongArrayType());
  }

  static final _id_echoFloat64List = _class.instanceMethodId(
    r'echoFloat64List',
    r'([D)[D',
  );

  static final _echoFloat64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract double[] echoFloat64List(double[] ds)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray echoFloat64List(
    jni$_.JDoubleArray ds,
  ) {
    final _$ds = ds.reference;
    return _echoFloat64List(reference.pointer,
            _id_echoFloat64List as jni$_.JMethodIDPtr, _$ds.pointer)
        .object<jni$_.JDoubleArray>(const jni$_.JDoubleArrayType());
  }

  static final _id_echoObject = _class.instanceMethodId(
    r'echoObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoObject = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoObject(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject echoObject(
    jni$_.JObject object,
  ) {
    final _$object = object.reference;
    return _echoObject(reference.pointer, _id_echoObject as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_echoList = _class.instanceMethodId(
    r'echoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> echoList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> echoList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _echoList(reference.pointer, _id_echoList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_echoEnumList = _class.instanceMethodId(
    r'echoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAnEnum> echoEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?> echoEnumList(
    jni$_.JList<NIAnEnum?> list,
  ) {
    final _$list = list.reference;
    return _echoEnumList(reference.pointer,
            _id_echoEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAnEnum?>>(
            const jni$_.JListType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_echoClassList = _class.instanceMethodId(
    r'echoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAllNullableTypes> echoClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?> echoClassList(
    jni$_.JList<NIAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _echoClassList(reference.pointer,
            _id_echoClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes?>>(
            const jni$_.JListType<NIAllNullableTypes?>(
                $NIAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullEnumList = _class.instanceMethodId(
    r'echoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAnEnum> echoNonNullEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> echoNonNullEnumList(
    jni$_.JList<NIAnEnum> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullEnumList(reference.pointer,
            _id_echoNonNullEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAnEnum>>(
            const jni$_.JListType<NIAnEnum>($NIAnEnum$Type()));
  }

  static final _id_echoNonNullClassList = _class.instanceMethodId(
    r'echoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAllNullableTypes> echoNonNullClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes> echoNonNullClassList(
    jni$_.JList<NIAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullClassList(reference.pointer,
            _id_echoNonNullClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes>>(
            const jni$_.JListType<NIAllNullableTypes>(
                $NIAllNullableTypes$Type()));
  }

  static final _id_echoMap = _class.instanceMethodId(
    r'echoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> echoMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _echoMap(
            reference.pointer, _id_echoMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoStringMap = _class.instanceMethodId(
    r'echoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _echoStringMap(reference.pointer,
            _id_echoStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoIntMap = _class.instanceMethodId(
    r'echoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _echoIntMap(reference.pointer, _id_echoIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
            const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoEnumMap = _class.instanceMethodId(
    r'echoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<NIAnEnum, NIAnEnum> echoEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?> echoEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _echoEnumMap(reference.pointer,
            _id_echoEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>>(
            const jni$_.JMapType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_echoClassMap = _class.instanceMethodId(
    r'echoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, NIAllNullableTypes> echoClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> echoClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _echoClassMap(reference.pointer,
            _id_echoClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, NIAllNullableTypes?>(
                jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullStringMap = _class.instanceMethodId(
    r'echoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullStringMap(reference.pointer,
            _id_echoNonNullStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNonNullIntMap = _class.instanceMethodId(
    r'echoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullIntMap(reference.pointer,
            _id_echoNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNonNullEnumMap = _class.instanceMethodId(
    r'echoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<NIAnEnum, NIAnEnum> echoNonNullEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum> echoNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullEnumMap(reference.pointer,
            _id_echoNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum, NIAnEnum>>(
            const jni$_.JMapType<NIAnEnum, NIAnEnum>(
                $NIAnEnum$Type(), $NIAnEnum$Type()));
  }

  static final _id_echoNonNullClassMap = _class.instanceMethodId(
    r'echoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, NIAllNullableTypes> echoNonNullClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes> echoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullClassMap(reference.pointer,
            _id_echoNonNullClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>>(
            const jni$_.JMapType<jni$_.JLong, NIAllNullableTypes>(
                jni$_.JLongType(), $NIAllNullableTypes$Type()));
  }

  static final _id_echoClassWrapper = _class.instanceMethodId(
    r'echoClassWrapper',
    r'(LNIAllClassesWrapper;)LNIAllClassesWrapper;',
  );

  static final _echoClassWrapper = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllClassesWrapper echoClassWrapper(NIAllClassesWrapper nIAllClassesWrapper)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper echoClassWrapper(
    NIAllClassesWrapper nIAllClassesWrapper,
  ) {
    final _$nIAllClassesWrapper = nIAllClassesWrapper.reference;
    return _echoClassWrapper(
            reference.pointer,
            _id_echoClassWrapper as jni$_.JMethodIDPtr,
            _$nIAllClassesWrapper.pointer)
        .object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type());
  }

  static final _id_echoEnum = _class.instanceMethodId(
    r'echoEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAnEnum echoEnum(NIAnEnum nIAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum echoEnum(
    NIAnEnum nIAnEnum,
  ) {
    final _$nIAnEnum = nIAnEnum.reference;
    return _echoEnum(reference.pointer, _id_echoEnum as jni$_.JMethodIDPtr,
            _$nIAnEnum.pointer)
        .object<NIAnEnum>(const $NIAnEnum$Type());
  }

  static final _id_echoAnotherEnum = _class.instanceMethodId(
    r'echoAnotherEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoAnotherEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAnotherEnum echoAnotherEnum(NIAnotherEnum nIAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum echoAnotherEnum(
    NIAnotherEnum nIAnotherEnum,
  ) {
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    return _echoAnotherEnum(reference.pointer,
            _id_echoAnotherEnum as jni$_.JMethodIDPtr, _$nIAnotherEnum.pointer)
        .object<NIAnotherEnum>(const $NIAnotherEnum$Type());
  }

  static final _id_echoNamedDefaultString = _class.instanceMethodId(
    r'echoNamedDefaultString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNamedDefaultString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoNamedDefaultString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoNamedDefaultString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoNamedDefaultString(reference.pointer,
            _id_echoNamedDefaultString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoOptionalDefaultDouble = _class.instanceMethodId(
    r'echoOptionalDefaultDouble',
    r'(D)D',
  );

  static final _echoOptionalDefaultDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public abstract double echoOptionalDefaultDouble(double d)`
  double echoOptionalDefaultDouble(
    double d,
  ) {
    return _echoOptionalDefaultDouble(reference.pointer,
            _id_echoOptionalDefaultDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoRequiredInt = _class.instanceMethodId(
    r'echoRequiredInt',
    r'(J)J',
  );

  static final _echoRequiredInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract long echoRequiredInt(long j)`
  int echoRequiredInt(
    int j,
  ) {
    return _echoRequiredInt(
            reference.pointer, _id_echoRequiredInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoAllNullableTypes = _class.instanceMethodId(
    r'echoAllNullableTypes',
    r'(LNIAllNullableTypes;)LNIAllNullableTypes;',
  );

  static final _echoAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllNullableTypes echoAllNullableTypes(NIAllNullableTypes nIAllNullableTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes? echoAllNullableTypes(
    NIAllNullableTypes? nIAllNullableTypes,
  ) {
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypes(
            reference.pointer,
            _id_echoAllNullableTypes as jni$_.JMethodIDPtr,
            _$nIAllNullableTypes.pointer)
        .object<NIAllNullableTypes?>(const $NIAllNullableTypes$NullableType());
  }

  static final _id_echoAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoAllNullableTypesWithoutRecursion',
    r'(LNIAllNullableTypesWithoutRecursion;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _echoAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllNullableTypesWithoutRecursion echoAllNullableTypesWithoutRecursion(NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion? echoAllNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
  ) {
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$nIAllNullableTypesWithoutRecursion.pointer)
        .object<NIAllNullableTypesWithoutRecursion?>(
            const $NIAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_extractNestedNullableString = _class.instanceMethodId(
    r'extractNestedNullableString',
    r'(LNIAllClassesWrapper;)Ljava/lang/String;',
  );

  static final _extractNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String extractNestedNullableString(NIAllClassesWrapper nIAllClassesWrapper)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? extractNestedNullableString(
    NIAllClassesWrapper nIAllClassesWrapper,
  ) {
    final _$nIAllClassesWrapper = nIAllClassesWrapper.reference;
    return _extractNestedNullableString(
            reference.pointer,
            _id_extractNestedNullableString as jni$_.JMethodIDPtr,
            _$nIAllClassesWrapper.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_createNestedNullableString = _class.instanceMethodId(
    r'createNestedNullableString',
    r'(Ljava/lang/String;)LNIAllClassesWrapper;',
  );

  static final _createNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllClassesWrapper createNestedNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper createNestedNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createNestedNullableString(
            reference.pointer,
            _id_createNestedNullableString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type());
  }

  static final _id_sendMultipleNullableTypes = _class.instanceMethodId(
    r'sendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypes;',
  );

  static final _sendMultipleNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllNullableTypes sendMultipleNullableTypes(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes sendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypes(
            reference.pointer,
            _id_sendMultipleNullableTypes as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<NIAllNullableTypes>(const $NIAllNullableTypes$Type());
  }

  static final _id_sendMultipleNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'sendMultipleNullableTypesWithoutRecursion',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _sendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypesWithoutRecursion(
            reference.pointer,
            _id_sendMultipleNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<NIAllNullableTypesWithoutRecursion>(
            const $NIAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_echoNullableInt = _class.instanceMethodId(
    r'echoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Long echoNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoNullableInt(reference.pointer,
            _id_echoNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNullableDouble = _class.instanceMethodId(
    r'echoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _echoNullableDouble = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Double echoNullableDouble(java.lang.Double double)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? echoNullableDouble(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _echoNullableDouble(reference.pointer,
            _id_echoNullableDouble as jni$_.JMethodIDPtr, _$double.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_echoNullableBool = _class.instanceMethodId(
    r'echoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _echoNullableBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Boolean echoNullableBool(java.lang.Boolean boolean)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? echoNullableBool(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _echoNullableBool(reference.pointer,
            _id_echoNullableBool as jni$_.JMethodIDPtr, _$boolean.pointer)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_echoNullableString = _class.instanceMethodId(
    r'echoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNullableString(reference.pointer,
            _id_echoNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_echoNullableUint8List = _class.instanceMethodId(
    r'echoNullableUint8List',
    r'([B)[B',
  );

  static final _echoNullableUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] echoNullableUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? echoNullableUint8List(
    jni$_.JByteArray? bs,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _echoNullableUint8List(reference.pointer,
            _id_echoNullableUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_echoNullableInt32List = _class.instanceMethodId(
    r'echoNullableInt32List',
    r'([I)[I',
  );

  static final _echoNullableInt32List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract int[] echoNullableInt32List(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? echoNullableInt32List(
    jni$_.JIntArray? is$,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _echoNullableInt32List(reference.pointer,
            _id_echoNullableInt32List as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_echoNullableInt64List = _class.instanceMethodId(
    r'echoNullableInt64List',
    r'([J)[J',
  );

  static final _echoNullableInt64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract long[] echoNullableInt64List(long[] js)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? echoNullableInt64List(
    jni$_.JLongArray? js,
  ) {
    final _$js = js?.reference ?? jni$_.jNullReference;
    return _echoNullableInt64List(reference.pointer,
            _id_echoNullableInt64List as jni$_.JMethodIDPtr, _$js.pointer)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_echoNullableFloat64List = _class.instanceMethodId(
    r'echoNullableFloat64List',
    r'([D)[D',
  );

  static final _echoNullableFloat64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract double[] echoNullableFloat64List(double[] ds)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? echoNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    return _echoNullableFloat64List(reference.pointer,
            _id_echoNullableFloat64List as jni$_.JMethodIDPtr, _$ds.pointer)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_echoNullableObject = _class.instanceMethodId(
    r'echoNullableObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoNullableObject = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoNullableObject(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? echoNullableObject(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _echoNullableObject(reference.pointer,
            _id_echoNullableObject as jni$_.JMethodIDPtr, _$object.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_echoNullableList = _class.instanceMethodId(
    r'echoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> echoNullableList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? echoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableList(reference.pointer,
            _id_echoNullableList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableEnumList = _class.instanceMethodId(
    r'echoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAnEnum> echoNullableEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? echoNullableEnumList(
    jni$_.JList<NIAnEnum?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumList(reference.pointer,
            _id_echoNullableEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAnEnum?>?>(
            const jni$_.JListNullableType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_echoNullableClassList = _class.instanceMethodId(
    r'echoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAllNullableTypes> echoNullableClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?>? echoNullableClassList(
    jni$_.JList<NIAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableClassList(reference.pointer,
            _id_echoNullableClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes?>?>(
            const jni$_.JListNullableType<NIAllNullableTypes?>(
                $NIAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullEnumList = _class.instanceMethodId(
    r'echoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAnEnum> echoNullableNonNullEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum>? echoNullableNonNullEnumList(
    jni$_.JList<NIAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumList(
            reference.pointer,
            _id_echoNullableNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAnEnum>?>(
            const jni$_.JListNullableType<NIAnEnum>($NIAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassList = _class.instanceMethodId(
    r'echoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAllNullableTypes> echoNullableNonNullClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes>? echoNullableNonNullClassList(
    jni$_.JList<NIAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassList(
            reference.pointer,
            _id_echoNullableNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes>?>(
            const jni$_.JListNullableType<NIAllNullableTypes>(
                $NIAllNullableTypes$Type()));
  }

  static final _id_echoNullableMap = _class.instanceMethodId(
    r'echoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> echoNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableMap(reference.pointer,
            _id_echoNullableMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableStringMap = _class.instanceMethodId(
    r'echoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableStringMap(reference.pointer,
            _id_echoNullableStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoNullableIntMap = _class.instanceMethodId(
    r'echoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableIntMap(reference.pointer,
            _id_echoNullableIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoNullableEnumMap = _class.instanceMethodId(
    r'echoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<NIAnEnum, NIAnEnum> echoNullableEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? echoNullableEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumMap(reference.pointer,
            _id_echoNullableEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
            const jni$_.JMapNullableType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_echoNullableClassMap = _class.instanceMethodId(
    r'echoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, NIAllNullableTypes> echoNullableClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? echoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableClassMap(reference.pointer,
            _id_echoNullableClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, NIAllNullableTypes?>(
                jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullStringMap = _class.instanceMethodId(
    r'echoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNullableNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullStringMap(
            reference.pointer,
            _id_echoNullableNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNullableNonNullIntMap = _class.instanceMethodId(
    r'echoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNullableNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullIntMap(reference.pointer,
            _id_echoNullableNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
            const jni$_.JMapNullableType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNullableNonNullEnumMap = _class.instanceMethodId(
    r'echoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<NIAnEnum, NIAnEnum> echoNullableNonNullEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum>? echoNullableNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumMap(reference.pointer,
            _id_echoNullableNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum, NIAnEnum>?>(
            const jni$_.JMapNullableType<NIAnEnum, NIAnEnum>(
                $NIAnEnum$Type(), $NIAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassMap = _class.instanceMethodId(
    r'echoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, NIAllNullableTypes> echoNullableNonNullClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? echoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassMap(
            reference.pointer,
            _id_echoNullableNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>?>(
            const jni$_.JMapNullableType<jni$_.JLong, NIAllNullableTypes>(
                jni$_.JLongType(), $NIAllNullableTypes$Type()));
  }

  static final _id_echoNullableEnum = _class.instanceMethodId(
    r'echoNullableEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAnEnum echoNullableEnum(NIAnEnum nIAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? echoNullableEnum(
    NIAnEnum? nIAnEnum,
  ) {
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    return _echoNullableEnum(reference.pointer,
            _id_echoNullableEnum as jni$_.JMethodIDPtr, _$nIAnEnum.pointer)
        .object<NIAnEnum?>(const $NIAnEnum$NullableType());
  }

  static final _id_echoAnotherNullableEnum = _class.instanceMethodId(
    r'echoAnotherNullableEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAnotherEnum echoAnotherNullableEnum(NIAnotherEnum nIAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? echoAnotherNullableEnum(
    NIAnotherEnum? nIAnotherEnum,
  ) {
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    return _echoAnotherNullableEnum(
            reference.pointer,
            _id_echoAnotherNullableEnum as jni$_.JMethodIDPtr,
            _$nIAnotherEnum.pointer)
        .object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType());
  }

  static final _id_echoOptionalNullableInt = _class.instanceMethodId(
    r'echoOptionalNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoOptionalNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Long echoOptionalNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoOptionalNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoOptionalNullableInt(reference.pointer,
            _id_echoOptionalNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNamedNullableString = _class.instanceMethodId(
    r'echoNamedNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNamedNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoNamedNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNamedNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNamedNullableString(reference.pointer,
            _id_echoNamedNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_noopAsync = _class.instanceMethodId(
    r'noopAsync',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _noopAsync = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object noopAsync(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> noopAsync() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _noopAsync(reference.pointer,
            _id_noopAsync as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt = _class.instanceMethodId(
    r'echoAsyncInt',
    r'(JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncInt(long j, kotlin.coroutines.Continuation<? super java.lang.Long> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong> echoAsyncInt(
    int j,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncInt(reference.pointer,
            _id_echoAsyncInt as jni$_.JMethodIDPtr, j, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLong>(
      const jni$_.JLongType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncDouble = _class.instanceMethodId(
    r'echoAsyncDouble',
    r'(DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, double, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncDouble(double d, kotlin.coroutines.Continuation<? super java.lang.Double> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble> echoAsyncDouble(
    double d,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncDouble(
            reference.pointer,
            _id_echoAsyncDouble as jni$_.JMethodIDPtr,
            d,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDouble>(
      const jni$_.JDoubleType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncBool = _class.instanceMethodId(
    r'echoAsyncBool',
    r'(ZLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncBool(boolean z, kotlin.coroutines.Continuation<? super java.lang.Boolean> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean> echoAsyncBool(
    bool z,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncBool(
            reference.pointer,
            _id_echoAsyncBool as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JBoolean>(
      const jni$_.JBooleanType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncString = _class.instanceMethodId(
    r'echoAsyncString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncString(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echoAsyncString(
    jni$_.JString string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echoAsyncString(
            reference.pointer,
            _id_echoAsyncString as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.JStringType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncUint8List = _class.instanceMethodId(
    r'echoAsyncUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncUint8List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncUint8List(byte[] bs, kotlin.coroutines.Continuation<? super byte[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray> echoAsyncUint8List(
    jni$_.JByteArray bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs.reference;
    final $r = _echoAsyncUint8List(
            reference.pointer,
            _id_echoAsyncUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JByteArray>(
      const jni$_.JByteArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt32List = _class.instanceMethodId(
    r'echoAsyncInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt32List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncInt32List(int[] is, kotlin.coroutines.Continuation<? super int[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray> echoAsyncInt32List(
    jni$_.JIntArray is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$.reference;
    final $r = _echoAsyncInt32List(
            reference.pointer,
            _id_echoAsyncInt32List as jni$_.JMethodIDPtr,
            _$is$.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JIntArray>(
      const jni$_.JIntArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt64List = _class.instanceMethodId(
    r'echoAsyncInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt64List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncInt64List(long[] js, kotlin.coroutines.Continuation<? super long[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray> echoAsyncInt64List(
    jni$_.JLongArray js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js.reference;
    final $r = _echoAsyncInt64List(
            reference.pointer,
            _id_echoAsyncInt64List as jni$_.JMethodIDPtr,
            _$js.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLongArray>(
      const jni$_.JLongArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncFloat64List = _class.instanceMethodId(
    r'echoAsyncFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncFloat64List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncFloat64List(double[] ds, kotlin.coroutines.Continuation<? super double[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray> echoAsyncFloat64List(
    jni$_.JDoubleArray ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds.reference;
    final $r = _echoAsyncFloat64List(
            reference.pointer,
            _id_echoAsyncFloat64List as jni$_.JMethodIDPtr,
            _$ds.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDoubleArray>(
      const jni$_.JDoubleArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncObject = _class.instanceMethodId(
    r'echoAsyncObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncObject(java.lang.Object object, kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> echoAsyncObject(
    jni$_.JObject object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object.reference;
    final $r = _echoAsyncObject(
            reference.pointer,
            _id_echoAsyncObject as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncList = _class.instanceMethodId(
    r'echoAsyncList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncList(java.util.List<? extends java.lang.Object> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>> echoAsyncList(
    jni$_.JList<jni$_.JObject?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncList(
            reference.pointer,
            _id_echoAsyncList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumList = _class.instanceMethodId(
    r'echoAsyncEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncEnumList(java.util.List<? extends NIAnEnum> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAnEnum?>> echoAsyncEnumList(
    jni$_.JList<NIAnEnum?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncEnumList(
            reference.pointer,
            _id_echoAsyncEnumList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<NIAnEnum?>>(
      const jni$_.JListType<NIAnEnum?>($NIAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassList = _class.instanceMethodId(
    r'echoAsyncClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncClassList(java.util.List<NIAllNullableTypes> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAllNullableTypes?>> echoAsyncClassList(
    jni$_.JList<NIAllNullableTypes?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncClassList(
            reference.pointer,
            _id_echoAsyncClassList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<NIAllNullableTypes?>>(
      const jni$_.JListType<NIAllNullableTypes?>(
          $NIAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncMap = _class.instanceMethodId(
    r'echoAsyncMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> echoAsyncMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncMap(
            reference.pointer,
            _id_echoAsyncMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
      const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
          jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncStringMap = _class.instanceMethodId(
    r'echoAsyncStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncStringMap(java.util.Map<java.lang.String, java.lang.String> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>> echoAsyncStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncStringMap(
            reference.pointer,
            _id_echoAsyncStringMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
      const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(), jni$_.JStringNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncIntMap = _class.instanceMethodId(
    r'echoAsyncIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncIntMap(java.util.Map<java.lang.Long, java.lang.Long> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>> echoAsyncIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncIntMap(
            reference.pointer,
            _id_echoAsyncIntMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
      const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
          jni$_.JLongNullableType(), jni$_.JLongNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumMap = _class.instanceMethodId(
    r'echoAsyncEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<NIAnEnum?, NIAnEnum?>> echoAsyncEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncEnumMap(
            reference.pointer,
            _id_echoAsyncEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<NIAnEnum?, NIAnEnum?>>(
      const jni$_.JMapType<NIAnEnum?, NIAnEnum?>(
          $NIAnEnum$NullableType(), $NIAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassMap = _class.instanceMethodId(
    r'echoAsyncClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>
      echoAsyncClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncClassMap(
            reference.pointer,
            _id_echoAsyncClassMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>(
      const jni$_.JMapType<jni$_.JLong?, NIAllNullableTypes?>(
          jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnum = _class.instanceMethodId(
    r'echoAsyncEnum',
    r'(LNIAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncEnum(NIAnEnum nIAnEnum, kotlin.coroutines.Continuation<? super NIAnEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnEnum> echoAsyncEnum(
    NIAnEnum nIAnEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnEnum = nIAnEnum.reference;
    final $r = _echoAsyncEnum(
            reference.pointer,
            _id_echoAsyncEnum as jni$_.JMethodIDPtr,
            _$nIAnEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<NIAnEnum>(
      const $NIAnEnum$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncEnum = _class.instanceMethodId(
    r'echoAnotherAsyncEnum',
    r'(LNIAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAnotherAsyncEnum(NIAnotherEnum nIAnotherEnum, kotlin.coroutines.Continuation<? super NIAnotherEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnotherEnum> echoAnotherAsyncEnum(
    NIAnotherEnum nIAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    final $r = _echoAnotherAsyncEnum(
            reference.pointer,
            _id_echoAnotherAsyncEnum as jni$_.JMethodIDPtr,
            _$nIAnotherEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<NIAnotherEnum>(
      const $NIAnotherEnum$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncError = _class.instanceMethodId(
    r'throwAsyncError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object throwAsyncError(kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncError(reference.pointer,
            _id_throwAsyncError as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncErrorFromVoid = _class.instanceMethodId(
    r'throwAsyncErrorFromVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object throwAsyncErrorFromVoid(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> throwAsyncErrorFromVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncErrorFromVoid(
            reference.pointer,
            _id_throwAsyncErrorFromVoid as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncFlutterError = _class.instanceMethodId(
    r'throwAsyncFlutterError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncFlutterError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object throwAsyncFlutterError(kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncFlutterError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncFlutterError(
            reference.pointer,
            _id_throwAsyncFlutterError as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNIAllTypes = _class.instanceMethodId(
    r'echoAsyncNIAllTypes',
    r'(LNIAllTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNIAllTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNIAllTypes(NIAllTypes nIAllTypes, kotlin.coroutines.Continuation<? super NIAllTypes> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAllTypes> echoAsyncNIAllTypes(
    NIAllTypes nIAllTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAllTypes = nIAllTypes.reference;
    final $r = _echoAsyncNIAllTypes(
            reference.pointer,
            _id_echoAsyncNIAllTypes as jni$_.JMethodIDPtr,
            _$nIAllTypes.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<NIAllTypes>(
      const $NIAllTypes$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableNIAllNullableTypes =
      _class.instanceMethodId(
    r'echoAsyncNullableNIAllNullableTypes',
    r'(LNIAllNullableTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableNIAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableNIAllNullableTypes(NIAllNullableTypes nIAllNullableTypes, kotlin.coroutines.Continuation<? super NIAllNullableTypes> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAllNullableTypes?> echoAsyncNullableNIAllNullableTypes(
    NIAllNullableTypes? nIAllNullableTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableNIAllNullableTypes(
            reference.pointer,
            _id_echoAsyncNullableNIAllNullableTypes as jni$_.JMethodIDPtr,
            _$nIAllNullableTypes.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAllNullableTypes?>(
      const $NIAllNullableTypes$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableNIAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoAsyncNullableNIAllNullableTypesWithoutRecursion',
    r'(LNIAllNullableTypesWithoutRecursion;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableNIAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableNIAllNullableTypesWithoutRecursion(NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion, kotlin.coroutines.Continuation<? super NIAllNullableTypesWithoutRecursion> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAllNullableTypesWithoutRecursion?>
      echoAsyncNullableNIAllNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableNIAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoAsyncNullableNIAllNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$nIAllNullableTypesWithoutRecursion.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAllNullableTypesWithoutRecursion?>(
      const $NIAllNullableTypesWithoutRecursion$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt = _class.instanceMethodId(
    r'echoAsyncNullableInt',
    r'(Ljava/lang/Long;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableInt(java.lang.Long long, kotlin.coroutines.Continuation<? super java.lang.Long> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong?> echoAsyncNullableInt(
    jni$_.JLong? long,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$long = long?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt(
            reference.pointer,
            _id_echoAsyncNullableInt as jni$_.JMethodIDPtr,
            _$long.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLong?>(
      const jni$_.JLongNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableDouble = _class.instanceMethodId(
    r'echoAsyncNullableDouble',
    r'(Ljava/lang/Double;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableDouble(java.lang.Double double, kotlin.coroutines.Continuation<? super java.lang.Double> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble?> echoAsyncNullableDouble(
    jni$_.JDouble? double,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$double = double?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableDouble(
            reference.pointer,
            _id_echoAsyncNullableDouble as jni$_.JMethodIDPtr,
            _$double.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDouble?>(
      const jni$_.JDoubleNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableBool = _class.instanceMethodId(
    r'echoAsyncNullableBool',
    r'(Ljava/lang/Boolean;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableBool(java.lang.Boolean boolean, kotlin.coroutines.Continuation<? super java.lang.Boolean> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean?> echoAsyncNullableBool(
    jni$_.JBoolean? boolean,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableBool(
            reference.pointer,
            _id_echoAsyncNullableBool as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JBoolean?>(
      const jni$_.JBooleanNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableString = _class.instanceMethodId(
    r'echoAsyncNullableString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableString(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString?> echoAsyncNullableString(
    jni$_.JString? string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableString(
            reference.pointer,
            _id_echoAsyncNullableString as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JString?>(
      const jni$_.JStringNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableUint8List = _class.instanceMethodId(
    r'echoAsyncNullableUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableUint8List(byte[] bs, kotlin.coroutines.Continuation<? super byte[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray?> echoAsyncNullableUint8List(
    jni$_.JByteArray? bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableUint8List(
            reference.pointer,
            _id_echoAsyncNullableUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JByteArray?>(
      const jni$_.JByteArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt32List = _class.instanceMethodId(
    r'echoAsyncNullableInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt32List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableInt32List(int[] is, kotlin.coroutines.Continuation<? super int[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray?> echoAsyncNullableInt32List(
    jni$_.JIntArray? is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt32List(
            reference.pointer,
            _id_echoAsyncNullableInt32List as jni$_.JMethodIDPtr,
            _$is$.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JIntArray?>(
      const jni$_.JIntArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt64List = _class.instanceMethodId(
    r'echoAsyncNullableInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt64List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableInt64List(long[] js, kotlin.coroutines.Continuation<? super long[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray?> echoAsyncNullableInt64List(
    jni$_.JLongArray? js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt64List(
            reference.pointer,
            _id_echoAsyncNullableInt64List as jni$_.JMethodIDPtr,
            _$js.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLongArray?>(
      const jni$_.JLongArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableFloat64List = _class.instanceMethodId(
    r'echoAsyncNullableFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableFloat64List(double[] ds, kotlin.coroutines.Continuation<? super double[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray?> echoAsyncNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableFloat64List(
            reference.pointer,
            _id_echoAsyncNullableFloat64List as jni$_.JMethodIDPtr,
            _$ds.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDoubleArray?>(
      const jni$_.JDoubleArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableObject = _class.instanceMethodId(
    r'echoAsyncNullableObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableObject(java.lang.Object object, kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> echoAsyncNullableObject(
    jni$_.JObject? object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableObject(
            reference.pointer,
            _id_echoAsyncNullableObject as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableList = _class.instanceMethodId(
    r'echoAsyncNullableList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableList(java.util.List<? extends java.lang.Object> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>?> echoAsyncNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableList(
            reference.pointer,
            _id_echoAsyncNullableList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.JListNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumList = _class.instanceMethodId(
    r'echoAsyncNullableEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableEnumList(java.util.List<? extends NIAnEnum> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAnEnum?>?> echoAsyncNullableEnumList(
    jni$_.JList<NIAnEnum?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumList(
            reference.pointer,
            _id_echoAsyncNullableEnumList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<NIAnEnum?>?>(
      const jni$_.JListNullableType<NIAnEnum?>($NIAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassList = _class.instanceMethodId(
    r'echoAsyncNullableClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableClassList(java.util.List<NIAllNullableTypes> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAllNullableTypes?>?> echoAsyncNullableClassList(
    jni$_.JList<NIAllNullableTypes?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassList(
            reference.pointer,
            _id_echoAsyncNullableClassList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<NIAllNullableTypes?>?>(
      const jni$_.JListNullableType<NIAllNullableTypes?>(
          $NIAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableMap = _class.instanceMethodId(
    r'echoAsyncNullableMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>
      echoAsyncNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableMap(
            reference.pointer,
            _id_echoAsyncNullableMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
          jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableStringMap = _class.instanceMethodId(
    r'echoAsyncNullableStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>
      echoAsyncNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableStringMap(
            reference.pointer,
            _id_echoAsyncNullableStringMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(), jni$_.JStringNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableIntMap = _class.instanceMethodId(
    r'echoAsyncNullableIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>
      echoAsyncNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableIntMap(
            reference.pointer,
            _id_echoAsyncNullableIntMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
          jni$_.JLongNullableType(), jni$_.JLongNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumMap = _class.instanceMethodId(
    r'echoAsyncNullableEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<NIAnEnum?, NIAnEnum?>?> echoAsyncNullableEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumMap(
            reference.pointer,
            _id_echoAsyncNullableEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
      const jni$_.JMapNullableType<NIAnEnum?, NIAnEnum?>(
          $NIAnEnum$NullableType(), $NIAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassMap = _class.instanceMethodId(
    r'echoAsyncNullableClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>
      echoAsyncNullableClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassMap(
            reference.pointer,
            _id_echoAsyncNullableClassMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
      const jni$_.JMapNullableType<jni$_.JLong?, NIAllNullableTypes?>(
          jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnum = _class.instanceMethodId(
    r'echoAsyncNullableEnum',
    r'(LNIAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAsyncNullableEnum(NIAnEnum nIAnEnum, kotlin.coroutines.Continuation<? super NIAnEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnEnum?> echoAsyncNullableEnum(
    NIAnEnum? nIAnEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnum(
            reference.pointer,
            _id_echoAsyncNullableEnum as jni$_.JMethodIDPtr,
            _$nIAnEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAnEnum?>(
      const $NIAnEnum$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncNullableEnum = _class.instanceMethodId(
    r'echoAnotherAsyncNullableEnum',
    r'(LNIAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echoAnotherAsyncNullableEnum(NIAnotherEnum nIAnotherEnum, kotlin.coroutines.Continuation<? super NIAnotherEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnotherEnum?> echoAnotherAsyncNullableEnum(
    NIAnotherEnum? nIAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAnotherAsyncNullableEnum(
            reference.pointer,
            _id_echoAnotherAsyncNullableEnum as jni$_.JMethodIDPtr,
            _$nIAnotherEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAnotherEnum?>(
      const $NIAnotherEnum$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_callFlutterNoop = _class.instanceMethodId(
    r'callFlutterNoop',
    r'()V',
  );

  static final _callFlutterNoop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void callFlutterNoop()`
  void callFlutterNoop() {
    _callFlutterNoop(
            reference.pointer, _id_callFlutterNoop as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_callFlutterThrowError = _class.instanceMethodId(
    r'callFlutterThrowError',
    r'()Ljava/lang/Object;',
  );

  static final _callFlutterThrowError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.Object callFlutterThrowError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? callFlutterThrowError() {
    return _callFlutterThrowError(
            reference.pointer, _id_callFlutterThrowError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_callFlutterThrowErrorFromVoid = _class.instanceMethodId(
    r'callFlutterThrowErrorFromVoid',
    r'()V',
  );

  static final _callFlutterThrowErrorFromVoid =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public abstract void callFlutterThrowErrorFromVoid()`
  void callFlutterThrowErrorFromVoid() {
    _callFlutterThrowErrorFromVoid(reference.pointer,
            _id_callFlutterThrowErrorFromVoid as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_callFlutterEchoNIAllTypes = _class.instanceMethodId(
    r'callFlutterEchoNIAllTypes',
    r'(LNIAllTypes;)LNIAllTypes;',
  );

  static final _callFlutterEchoNIAllTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllTypes callFlutterEchoNIAllTypes(NIAllTypes nIAllTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes callFlutterEchoNIAllTypes(
    NIAllTypes nIAllTypes,
  ) {
    final _$nIAllTypes = nIAllTypes.reference;
    return _callFlutterEchoNIAllTypes(
            reference.pointer,
            _id_callFlutterEchoNIAllTypes as jni$_.JMethodIDPtr,
            _$nIAllTypes.pointer)
        .object<NIAllTypes>(const $NIAllTypes$Type());
  }

  static final _id_callFlutterEchoNIAllNullableTypes = _class.instanceMethodId(
    r'callFlutterEchoNIAllNullableTypes',
    r'(LNIAllNullableTypes;)LNIAllNullableTypes;',
  );

  static final _callFlutterEchoNIAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllNullableTypes callFlutterEchoNIAllNullableTypes(NIAllNullableTypes nIAllNullableTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes? callFlutterEchoNIAllNullableTypes(
    NIAllNullableTypes? nIAllNullableTypes,
  ) {
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNIAllNullableTypes(
            reference.pointer,
            _id_callFlutterEchoNIAllNullableTypes as jni$_.JMethodIDPtr,
            _$nIAllNullableTypes.pointer)
        .object<NIAllNullableTypes?>(const $NIAllNullableTypes$NullableType());
  }

  static final _id_callFlutterSendMultipleNullableTypes =
      _class.instanceMethodId(
    r'callFlutterSendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypes;',
  );

  static final _callFlutterSendMultipleNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllNullableTypes callFlutterSendMultipleNullableTypes(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes callFlutterSendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _callFlutterSendMultipleNullableTypes(
            reference.pointer,
            _id_callFlutterSendMultipleNullableTypes as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<NIAllNullableTypes>(const $NIAllNullableTypes$Type());
  }

  static final _id_callFlutterEchoNIAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'callFlutterEchoNIAllNullableTypesWithoutRecursion',
    r'(LNIAllNullableTypesWithoutRecursion;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _callFlutterEchoNIAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllNullableTypesWithoutRecursion callFlutterEchoNIAllNullableTypesWithoutRecursion(NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion?
      callFlutterEchoNIAllNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
  ) {
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNIAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_callFlutterEchoNIAllNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$nIAllNullableTypesWithoutRecursion.pointer)
        .object<NIAllNullableTypesWithoutRecursion?>(
            const $NIAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_callFlutterSendMultipleNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'callFlutterSendMultipleNullableTypesWithoutRecursion',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _callFlutterSendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllNullableTypesWithoutRecursion callFlutterSendMultipleNullableTypesWithoutRecursion(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion
      callFlutterSendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _callFlutterSendMultipleNullableTypesWithoutRecursion(
            reference.pointer,
            _id_callFlutterSendMultipleNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<NIAllNullableTypesWithoutRecursion>(
            const $NIAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_callFlutterEchoBool = _class.instanceMethodId(
    r'callFlutterEchoBool',
    r'(Z)Z',
  );

  static final _callFlutterEchoBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract boolean callFlutterEchoBool(boolean z)`
  bool callFlutterEchoBool(
    bool z,
  ) {
    return _callFlutterEchoBool(reference.pointer,
            _id_callFlutterEchoBool as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_callFlutterEchoInt = _class.instanceMethodId(
    r'callFlutterEchoInt',
    r'(J)J',
  );

  static final _callFlutterEchoInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract long callFlutterEchoInt(long j)`
  int callFlutterEchoInt(
    int j,
  ) {
    return _callFlutterEchoInt(
            reference.pointer, _id_callFlutterEchoInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_callFlutterEchoDouble = _class.instanceMethodId(
    r'callFlutterEchoDouble',
    r'(D)D',
  );

  static final _callFlutterEchoDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public abstract double callFlutterEchoDouble(double d)`
  double callFlutterEchoDouble(
    double d,
  ) {
    return _callFlutterEchoDouble(reference.pointer,
            _id_callFlutterEchoDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_callFlutterEchoString = _class.instanceMethodId(
    r'callFlutterEchoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _callFlutterEchoString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String callFlutterEchoString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString callFlutterEchoString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _callFlutterEchoString(reference.pointer,
            _id_callFlutterEchoString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_callFlutterEchoUint8List = _class.instanceMethodId(
    r'callFlutterEchoUint8List',
    r'([B)[B',
  );

  static final _callFlutterEchoUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] callFlutterEchoUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray callFlutterEchoUint8List(
    jni$_.JByteArray bs,
  ) {
    final _$bs = bs.reference;
    return _callFlutterEchoUint8List(reference.pointer,
            _id_callFlutterEchoUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_callFlutterEchoList = _class.instanceMethodId(
    r'callFlutterEchoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> callFlutterEchoList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> callFlutterEchoList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoList(reference.pointer,
            _id_callFlutterEchoList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoEnumList = _class.instanceMethodId(
    r'callFlutterEchoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAnEnum> callFlutterEchoEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?> callFlutterEchoEnumList(
    jni$_.JList<NIAnEnum?> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoEnumList(reference.pointer,
            _id_callFlutterEchoEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAnEnum?>>(
            const jni$_.JListType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoClassList = _class.instanceMethodId(
    r'callFlutterEchoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAllNullableTypes> callFlutterEchoClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?> callFlutterEchoClassList(
    jni$_.JList<NIAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoClassList(reference.pointer,
            _id_callFlutterEchoClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes?>>(
            const jni$_.JListType<NIAllNullableTypes?>(
                $NIAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNonNullEnumList = _class.instanceMethodId(
    r'callFlutterEchoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAnEnum> callFlutterEchoNonNullEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> callFlutterEchoNonNullEnumList(
    jni$_.JList<NIAnEnum> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoNonNullEnumList(
            reference.pointer,
            _id_callFlutterEchoNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAnEnum>>(
            const jni$_.JListType<NIAnEnum>($NIAnEnum$Type()));
  }

  static final _id_callFlutterEchoNonNullClassList = _class.instanceMethodId(
    r'callFlutterEchoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAllNullableTypes> callFlutterEchoNonNullClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes> callFlutterEchoNonNullClassList(
    jni$_.JList<NIAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoNonNullClassList(
            reference.pointer,
            _id_callFlutterEchoNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes>>(
            const jni$_.JListType<NIAllNullableTypes>(
                $NIAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoMap = _class.instanceMethodId(
    r'callFlutterEchoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> callFlutterEchoMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> callFlutterEchoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoMap(reference.pointer,
            _id_callFlutterEchoMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoStringMap = _class.instanceMethodId(
    r'callFlutterEchoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> callFlutterEchoStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> callFlutterEchoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoStringMap(reference.pointer,
            _id_callFlutterEchoStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_callFlutterEchoIntMap = _class.instanceMethodId(
    r'callFlutterEchoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> callFlutterEchoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoIntMap(reference.pointer,
            _id_callFlutterEchoIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
            const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_callFlutterEchoEnumMap = _class.instanceMethodId(
    r'callFlutterEchoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<NIAnEnum, NIAnEnum> callFlutterEchoEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?> callFlutterEchoEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoEnumMap(reference.pointer,
            _id_callFlutterEchoEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>>(
            const jni$_.JMapType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoClassMap = _class.instanceMethodId(
    r'callFlutterEchoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, NIAllNullableTypes> callFlutterEchoClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> callFlutterEchoClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoClassMap(reference.pointer,
            _id_callFlutterEchoClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, NIAllNullableTypes?>(
                jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNonNullStringMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> callFlutterEchoNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> callFlutterEchoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullStringMap(
            reference.pointer,
            _id_callFlutterEchoNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_callFlutterEchoNonNullIntMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullIntMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> callFlutterEchoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullIntMap(
            reference.pointer,
            _id_callFlutterEchoNonNullIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_callFlutterEchoNonNullEnumMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<NIAnEnum, NIAnEnum> callFlutterEchoNonNullEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum> callFlutterEchoNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullEnumMap(
            reference.pointer,
            _id_callFlutterEchoNonNullEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<NIAnEnum, NIAnEnum>>(
            const jni$_.JMapType<NIAnEnum, NIAnEnum>(
                $NIAnEnum$Type(), $NIAnEnum$Type()));
  }

  static final _id_callFlutterEchoNonNullClassMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, NIAllNullableTypes> callFlutterEchoNonNullClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes> callFlutterEchoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullClassMap(
            reference.pointer,
            _id_callFlutterEchoNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>>(
            const jni$_.JMapType<jni$_.JLong, NIAllNullableTypes>(
                jni$_.JLongType(), $NIAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoEnum = _class.instanceMethodId(
    r'callFlutterEchoEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _callFlutterEchoEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAnEnum callFlutterEchoEnum(NIAnEnum nIAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum callFlutterEchoEnum(
    NIAnEnum nIAnEnum,
  ) {
    final _$nIAnEnum = nIAnEnum.reference;
    return _callFlutterEchoEnum(reference.pointer,
            _id_callFlutterEchoEnum as jni$_.JMethodIDPtr, _$nIAnEnum.pointer)
        .object<NIAnEnum>(const $NIAnEnum$Type());
  }

  static final _id_callFlutterEchoNIAnotherEnum = _class.instanceMethodId(
    r'callFlutterEchoNIAnotherEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _callFlutterEchoNIAnotherEnum =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAnotherEnum callFlutterEchoNIAnotherEnum(NIAnotherEnum nIAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum callFlutterEchoNIAnotherEnum(
    NIAnotherEnum nIAnotherEnum,
  ) {
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    return _callFlutterEchoNIAnotherEnum(
            reference.pointer,
            _id_callFlutterEchoNIAnotherEnum as jni$_.JMethodIDPtr,
            _$nIAnotherEnum.pointer)
        .object<NIAnotherEnum>(const $NIAnotherEnum$Type());
  }

  static final _id_callFlutterEchoNullableBool = _class.instanceMethodId(
    r'callFlutterEchoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _callFlutterEchoNullableBool =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Boolean callFlutterEchoNullableBool(java.lang.Boolean boolean)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? callFlutterEchoNullableBool(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableBool(
            reference.pointer,
            _id_callFlutterEchoNullableBool as jni$_.JMethodIDPtr,
            _$boolean.pointer)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_callFlutterEchoNullableInt = _class.instanceMethodId(
    r'callFlutterEchoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _callFlutterEchoNullableInt =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Long callFlutterEchoNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? callFlutterEchoNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableInt(
            reference.pointer,
            _id_callFlutterEchoNullableInt as jni$_.JMethodIDPtr,
            _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_callFlutterEchoNullableDouble = _class.instanceMethodId(
    r'callFlutterEchoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _callFlutterEchoNullableDouble =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Double callFlutterEchoNullableDouble(java.lang.Double double)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? callFlutterEchoNullableDouble(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableDouble(
            reference.pointer,
            _id_callFlutterEchoNullableDouble as jni$_.JMethodIDPtr,
            _$double.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_callFlutterEchoNullableString = _class.instanceMethodId(
    r'callFlutterEchoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _callFlutterEchoNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String callFlutterEchoNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? callFlutterEchoNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableString(
            reference.pointer,
            _id_callFlutterEchoNullableString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_callFlutterEchoNullableUint8List = _class.instanceMethodId(
    r'callFlutterEchoNullableUint8List',
    r'([B)[B',
  );

  static final _callFlutterEchoNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] callFlutterEchoNullableUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? callFlutterEchoNullableUint8List(
    jni$_.JByteArray? bs,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableUint8List(
            reference.pointer,
            _id_callFlutterEchoNullableUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_callFlutterEchoNullableList = _class.instanceMethodId(
    r'callFlutterEchoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> callFlutterEchoNullableList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? callFlutterEchoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableList(
            reference.pointer,
            _id_callFlutterEchoNullableList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoNullableEnumList = _class.instanceMethodId(
    r'callFlutterEchoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAnEnum> callFlutterEchoNullableEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? callFlutterEchoNullableEnumList(
    jni$_.JList<NIAnEnum?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableEnumList(
            reference.pointer,
            _id_callFlutterEchoNullableEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAnEnum?>?>(
            const jni$_.JListNullableType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoNullableClassList = _class.instanceMethodId(
    r'callFlutterEchoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAllNullableTypes> callFlutterEchoNullableClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?>? callFlutterEchoNullableClassList(
    jni$_.JList<NIAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableClassList(
            reference.pointer,
            _id_callFlutterEchoNullableClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes?>?>(
            const jni$_.JListNullableType<NIAllNullableTypes?>(
                $NIAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNullableNonNullEnumList =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAnEnum> callFlutterEchoNullableNonNullEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum>? callFlutterEchoNullableNonNullEnumList(
    jni$_.JList<NIAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullEnumList(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAnEnum>?>(
            const jni$_.JListNullableType<NIAnEnum>($NIAnEnum$Type()));
  }

  static final _id_callFlutterEchoNullableNonNullClassList =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAllNullableTypes> callFlutterEchoNullableNonNullClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes>? callFlutterEchoNullableNonNullClassList(
    jni$_.JList<NIAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullClassList(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes>?>(
            const jni$_.JListNullableType<NIAllNullableTypes>(
                $NIAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoNullableMap = _class.instanceMethodId(
    r'callFlutterEchoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> callFlutterEchoNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? callFlutterEchoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableMap(reference.pointer,
            _id_callFlutterEchoNullableMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoNullableStringMap = _class.instanceMethodId(
    r'callFlutterEchoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> callFlutterEchoNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? callFlutterEchoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableStringMap(
            reference.pointer,
            _id_callFlutterEchoNullableStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_callFlutterEchoNullableIntMap = _class.instanceMethodId(
    r'callFlutterEchoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableIntMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? callFlutterEchoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableIntMap(
            reference.pointer,
            _id_callFlutterEchoNullableIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_callFlutterEchoNullableEnumMap = _class.instanceMethodId(
    r'callFlutterEchoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<NIAnEnum, NIAnEnum> callFlutterEchoNullableEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? callFlutterEchoNullableEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableEnumMap(
            reference.pointer,
            _id_callFlutterEchoNullableEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
            const jni$_.JMapNullableType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoNullableClassMap = _class.instanceMethodId(
    r'callFlutterEchoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, NIAllNullableTypes> callFlutterEchoNullableClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?
      callFlutterEchoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableClassMap(
            reference.pointer,
            _id_callFlutterEchoNullableClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, NIAllNullableTypes?>(
                jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNullableNonNullStringMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> callFlutterEchoNullableNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>?
      callFlutterEchoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullStringMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_callFlutterEchoNullableNonNullIntMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullIntMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoNullableNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? callFlutterEchoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullIntMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
            const jni$_.JMapNullableType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_callFlutterEchoNullableNonNullEnumMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<NIAnEnum, NIAnEnum> callFlutterEchoNullableNonNullEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum>? callFlutterEchoNullableNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullEnumMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<NIAnEnum, NIAnEnum>?>(
            const jni$_.JMapNullableType<NIAnEnum, NIAnEnum>(
                $NIAnEnum$Type(), $NIAnEnum$Type()));
  }

  static final _id_callFlutterEchoNullableNonNullClassMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, NIAllNullableTypes> callFlutterEchoNullableNonNullClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes>?
      callFlutterEchoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullClassMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>?>(
            const jni$_.JMapNullableType<jni$_.JLong, NIAllNullableTypes>(
                jni$_.JLongType(), $NIAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoNullableEnum = _class.instanceMethodId(
    r'callFlutterEchoNullableEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _callFlutterEchoNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAnEnum callFlutterEchoNullableEnum(NIAnEnum nIAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? callFlutterEchoNullableEnum(
    NIAnEnum? nIAnEnum,
  ) {
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableEnum(
            reference.pointer,
            _id_callFlutterEchoNullableEnum as jni$_.JMethodIDPtr,
            _$nIAnEnum.pointer)
        .object<NIAnEnum?>(const $NIAnEnum$NullableType());
  }

  static final _id_callFlutterEchoAnotherNullableEnum = _class.instanceMethodId(
    r'callFlutterEchoAnotherNullableEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _callFlutterEchoAnotherNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAnotherEnum callFlutterEchoAnotherNullableEnum(NIAnotherEnum nIAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? callFlutterEchoAnotherNullableEnum(
    NIAnotherEnum? nIAnotherEnum,
  ) {
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoAnotherNullableEnum(
            reference.pointer,
            _id_callFlutterEchoAnotherNullableEnum as jni$_.JMethodIDPtr,
            _$nIAnotherEnum.pointer)
        .object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType());
  }
}

final class $NIHostIntegrationCoreApi$NullableType
    extends jni$_.JObjType<NIHostIntegrationCoreApi?> {
  @jni$_.internal
  const $NIHostIntegrationCoreApi$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  NIHostIntegrationCoreApi? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIHostIntegrationCoreApi.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIHostIntegrationCoreApi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIHostIntegrationCoreApi$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostIntegrationCoreApi$NullableType) &&
        other is $NIHostIntegrationCoreApi$NullableType;
  }
}

final class $NIHostIntegrationCoreApi$Type
    extends jni$_.JObjType<NIHostIntegrationCoreApi> {
  @jni$_.internal
  const $NIHostIntegrationCoreApi$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  NIHostIntegrationCoreApi fromReference(jni$_.JReference reference) =>
      NIHostIntegrationCoreApi.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIHostIntegrationCoreApi?> get nullableType =>
      const $NIHostIntegrationCoreApi$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIHostIntegrationCoreApi$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostIntegrationCoreApi$Type) &&
        other is $NIHostIntegrationCoreApi$Type;
  }
}

/// from: `NIHostIntegrationCoreApiRegistrar`
class NIHostIntegrationCoreApiRegistrar extends NIHostIntegrationCoreApi {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIHostIntegrationCoreApiRegistrar> $type;

  @jni$_.internal
  NIHostIntegrationCoreApiRegistrar.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'NIHostIntegrationCoreApiRegistrar');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIHostIntegrationCoreApiRegistrar$NullableType();
  static const type = $NIHostIntegrationCoreApiRegistrar$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIHostIntegrationCoreApiRegistrar() {
    return NIHostIntegrationCoreApiRegistrar.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getApi = _class.instanceMethodId(
    r'getApi',
    r'()LNIHostIntegrationCoreApi;',
  );

  static final _getApi = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIHostIntegrationCoreApi getApi()`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostIntegrationCoreApi? getApi() {
    return _getApi(reference.pointer, _id_getApi as jni$_.JMethodIDPtr)
        .object<NIHostIntegrationCoreApi?>(
            const $NIHostIntegrationCoreApi$NullableType());
  }

  static final _id_setApi = _class.instanceMethodId(
    r'setApi',
    r'(LNIHostIntegrationCoreApi;)V',
  );

  static final _setApi = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setApi(NIHostIntegrationCoreApi nIHostIntegrationCoreApi)`
  void setApi(
    NIHostIntegrationCoreApi? nIHostIntegrationCoreApi,
  ) {
    final _$nIHostIntegrationCoreApi =
        nIHostIntegrationCoreApi?.reference ?? jni$_.jNullReference;
    _setApi(reference.pointer, _id_setApi as jni$_.JMethodIDPtr,
            _$nIHostIntegrationCoreApi.pointer)
        .check();
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(LNIHostIntegrationCoreApi;Ljava/lang/String;)LNIHostIntegrationCoreApiRegistrar;',
  );

  static final _register = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIHostIntegrationCoreApiRegistrar register(NIHostIntegrationCoreApi nIHostIntegrationCoreApi, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostIntegrationCoreApiRegistrar register(
    NIHostIntegrationCoreApi nIHostIntegrationCoreApi,
    jni$_.JString string,
  ) {
    final _$nIHostIntegrationCoreApi = nIHostIntegrationCoreApi.reference;
    final _$string = string.reference;
    return _register(reference.pointer, _id_register as jni$_.JMethodIDPtr,
            _$nIHostIntegrationCoreApi.pointer, _$string.pointer)
        .object<NIHostIntegrationCoreApiRegistrar>(
            const $NIHostIntegrationCoreApiRegistrar$Type());
  }

  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Ljava/lang/String;)LNIHostIntegrationCoreApiRegistrar;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIHostIntegrationCoreApiRegistrar getInstance(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostIntegrationCoreApiRegistrar? getInstance(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getInstance(reference.pointer,
            _id_getInstance as jni$_.JMethodIDPtr, _$string.pointer)
        .object<NIHostIntegrationCoreApiRegistrar?>(
            const $NIHostIntegrationCoreApiRegistrar$NullableType());
  }

  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }

  static final _id_echoAllTypes = _class.instanceMethodId(
    r'echoAllTypes',
    r'(LNIAllTypes;)LNIAllTypes;',
  );

  static final _echoAllTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAllTypes echoAllTypes(NIAllTypes nIAllTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes echoAllTypes(
    NIAllTypes nIAllTypes,
  ) {
    final _$nIAllTypes = nIAllTypes.reference;
    return _echoAllTypes(reference.pointer,
            _id_echoAllTypes as jni$_.JMethodIDPtr, _$nIAllTypes.pointer)
        .object<NIAllTypes>(const $NIAllTypes$Type());
  }

  static final _id_throwError = _class.instanceMethodId(
    r'throwError',
    r'()Ljava/lang/Object;',
  );

  static final _throwError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object throwError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwError() {
    return _throwError(reference.pointer, _id_throwError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_throwErrorFromVoid = _class.instanceMethodId(
    r'throwErrorFromVoid',
    r'()V',
  );

  static final _throwErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void throwErrorFromVoid()`
  void throwErrorFromVoid() {
    _throwErrorFromVoid(
            reference.pointer, _id_throwErrorFromVoid as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_throwFlutterError = _class.instanceMethodId(
    r'throwFlutterError',
    r'()Ljava/lang/Object;',
  );

  static final _throwFlutterError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object throwFlutterError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwFlutterError() {
    return _throwFlutterError(
            reference.pointer, _id_throwFlutterError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_echoInt = _class.instanceMethodId(
    r'echoInt',
    r'(J)J',
  );

  static final _echoInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public long echoInt(long j)`
  int echoInt(
    int j,
  ) {
    return _echoInt(reference.pointer, _id_echoInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoDouble = _class.instanceMethodId(
    r'echoDouble',
    r'(D)D',
  );

  static final _echoDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public double echoDouble(double d)`
  double echoDouble(
    double d,
  ) {
    return _echoDouble(
            reference.pointer, _id_echoDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoBool = _class.instanceMethodId(
    r'echoBool',
    r'(Z)Z',
  );

  static final _echoBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean echoBool(boolean z)`
  bool echoBool(
    bool z,
  ) {
    return _echoBool(
            reference.pointer, _id_echoBool as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_echoString = _class.instanceMethodId(
    r'echoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echoString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoString(reference.pointer, _id_echoString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoUint8List = _class.instanceMethodId(
    r'echoUint8List',
    r'([B)[B',
  );

  static final _echoUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public byte[] echoUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray echoUint8List(
    jni$_.JByteArray bs,
  ) {
    final _$bs = bs.reference;
    return _echoUint8List(reference.pointer,
            _id_echoUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_echoInt32List = _class.instanceMethodId(
    r'echoInt32List',
    r'([I)[I',
  );

  static final _echoInt32List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int[] echoInt32List(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray echoInt32List(
    jni$_.JIntArray is$,
  ) {
    final _$is$ = is$.reference;
    return _echoInt32List(reference.pointer,
            _id_echoInt32List as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<jni$_.JIntArray>(const jni$_.JIntArrayType());
  }

  static final _id_echoInt64List = _class.instanceMethodId(
    r'echoInt64List',
    r'([J)[J',
  );

  static final _echoInt64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long[] echoInt64List(long[] js)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray echoInt64List(
    jni$_.JLongArray js,
  ) {
    final _$js = js.reference;
    return _echoInt64List(reference.pointer,
            _id_echoInt64List as jni$_.JMethodIDPtr, _$js.pointer)
        .object<jni$_.JLongArray>(const jni$_.JLongArrayType());
  }

  static final _id_echoFloat64List = _class.instanceMethodId(
    r'echoFloat64List',
    r'([D)[D',
  );

  static final _echoFloat64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public double[] echoFloat64List(double[] ds)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray echoFloat64List(
    jni$_.JDoubleArray ds,
  ) {
    final _$ds = ds.reference;
    return _echoFloat64List(reference.pointer,
            _id_echoFloat64List as jni$_.JMethodIDPtr, _$ds.pointer)
        .object<jni$_.JDoubleArray>(const jni$_.JDoubleArrayType());
  }

  static final _id_echoObject = _class.instanceMethodId(
    r'echoObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoObject = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoObject(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject echoObject(
    jni$_.JObject object,
  ) {
    final _$object = object.reference;
    return _echoObject(reference.pointer, _id_echoObject as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_echoList = _class.instanceMethodId(
    r'echoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<java.lang.Object> echoList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> echoList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _echoList(reference.pointer, _id_echoList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_echoEnumList = _class.instanceMethodId(
    r'echoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAnEnum> echoEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?> echoEnumList(
    jni$_.JList<NIAnEnum?> list,
  ) {
    final _$list = list.reference;
    return _echoEnumList(reference.pointer,
            _id_echoEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAnEnum?>>(
            const jni$_.JListType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_echoClassList = _class.instanceMethodId(
    r'echoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAllNullableTypes> echoClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?> echoClassList(
    jni$_.JList<NIAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _echoClassList(reference.pointer,
            _id_echoClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes?>>(
            const jni$_.JListType<NIAllNullableTypes?>(
                $NIAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullEnumList = _class.instanceMethodId(
    r'echoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAnEnum> echoNonNullEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> echoNonNullEnumList(
    jni$_.JList<NIAnEnum> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullEnumList(reference.pointer,
            _id_echoNonNullEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAnEnum>>(
            const jni$_.JListType<NIAnEnum>($NIAnEnum$Type()));
  }

  static final _id_echoNonNullClassList = _class.instanceMethodId(
    r'echoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAllNullableTypes> echoNonNullClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes> echoNonNullClassList(
    jni$_.JList<NIAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullClassList(reference.pointer,
            _id_echoNonNullClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes>>(
            const jni$_.JListType<NIAllNullableTypes>(
                $NIAllNullableTypes$Type()));
  }

  static final _id_echoMap = _class.instanceMethodId(
    r'echoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Object, java.lang.Object> echoMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _echoMap(
            reference.pointer, _id_echoMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoStringMap = _class.instanceMethodId(
    r'echoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> echoStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _echoStringMap(reference.pointer,
            _id_echoStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoIntMap = _class.instanceMethodId(
    r'echoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> echoIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _echoIntMap(reference.pointer, _id_echoIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
            const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoEnumMap = _class.instanceMethodId(
    r'echoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<NIAnEnum, NIAnEnum> echoEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?> echoEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _echoEnumMap(reference.pointer,
            _id_echoEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>>(
            const jni$_.JMapType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_echoClassMap = _class.instanceMethodId(
    r'echoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, NIAllNullableTypes> echoClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> echoClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _echoClassMap(reference.pointer,
            _id_echoClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, NIAllNullableTypes?>(
                jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullStringMap = _class.instanceMethodId(
    r'echoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> echoNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullStringMap(reference.pointer,
            _id_echoNonNullStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNonNullIntMap = _class.instanceMethodId(
    r'echoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> echoNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullIntMap(reference.pointer,
            _id_echoNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNonNullEnumMap = _class.instanceMethodId(
    r'echoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<NIAnEnum, NIAnEnum> echoNonNullEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum> echoNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullEnumMap(reference.pointer,
            _id_echoNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum, NIAnEnum>>(
            const jni$_.JMapType<NIAnEnum, NIAnEnum>(
                $NIAnEnum$Type(), $NIAnEnum$Type()));
  }

  static final _id_echoNonNullClassMap = _class.instanceMethodId(
    r'echoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, NIAllNullableTypes> echoNonNullClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes> echoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullClassMap(reference.pointer,
            _id_echoNonNullClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>>(
            const jni$_.JMapType<jni$_.JLong, NIAllNullableTypes>(
                jni$_.JLongType(), $NIAllNullableTypes$Type()));
  }

  static final _id_echoClassWrapper = _class.instanceMethodId(
    r'echoClassWrapper',
    r'(LNIAllClassesWrapper;)LNIAllClassesWrapper;',
  );

  static final _echoClassWrapper = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAllClassesWrapper echoClassWrapper(NIAllClassesWrapper nIAllClassesWrapper)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper echoClassWrapper(
    NIAllClassesWrapper nIAllClassesWrapper,
  ) {
    final _$nIAllClassesWrapper = nIAllClassesWrapper.reference;
    return _echoClassWrapper(
            reference.pointer,
            _id_echoClassWrapper as jni$_.JMethodIDPtr,
            _$nIAllClassesWrapper.pointer)
        .object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type());
  }

  static final _id_echoEnum = _class.instanceMethodId(
    r'echoEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAnEnum echoEnum(NIAnEnum nIAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum echoEnum(
    NIAnEnum nIAnEnum,
  ) {
    final _$nIAnEnum = nIAnEnum.reference;
    return _echoEnum(reference.pointer, _id_echoEnum as jni$_.JMethodIDPtr,
            _$nIAnEnum.pointer)
        .object<NIAnEnum>(const $NIAnEnum$Type());
  }

  static final _id_echoAnotherEnum = _class.instanceMethodId(
    r'echoAnotherEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoAnotherEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAnotherEnum echoAnotherEnum(NIAnotherEnum nIAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum echoAnotherEnum(
    NIAnotherEnum nIAnotherEnum,
  ) {
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    return _echoAnotherEnum(reference.pointer,
            _id_echoAnotherEnum as jni$_.JMethodIDPtr, _$nIAnotherEnum.pointer)
        .object<NIAnotherEnum>(const $NIAnotherEnum$Type());
  }

  static final _id_echoNamedDefaultString = _class.instanceMethodId(
    r'echoNamedDefaultString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNamedDefaultString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echoNamedDefaultString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoNamedDefaultString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoNamedDefaultString(reference.pointer,
            _id_echoNamedDefaultString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoOptionalDefaultDouble = _class.instanceMethodId(
    r'echoOptionalDefaultDouble',
    r'(D)D',
  );

  static final _echoOptionalDefaultDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public double echoOptionalDefaultDouble(double d)`
  double echoOptionalDefaultDouble(
    double d,
  ) {
    return _echoOptionalDefaultDouble(reference.pointer,
            _id_echoOptionalDefaultDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoRequiredInt = _class.instanceMethodId(
    r'echoRequiredInt',
    r'(J)J',
  );

  static final _echoRequiredInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public long echoRequiredInt(long j)`
  int echoRequiredInt(
    int j,
  ) {
    return _echoRequiredInt(
            reference.pointer, _id_echoRequiredInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoAllNullableTypes = _class.instanceMethodId(
    r'echoAllNullableTypes',
    r'(LNIAllNullableTypes;)LNIAllNullableTypes;',
  );

  static final _echoAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAllNullableTypes echoAllNullableTypes(NIAllNullableTypes nIAllNullableTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes? echoAllNullableTypes(
    NIAllNullableTypes? nIAllNullableTypes,
  ) {
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypes(
            reference.pointer,
            _id_echoAllNullableTypes as jni$_.JMethodIDPtr,
            _$nIAllNullableTypes.pointer)
        .object<NIAllNullableTypes?>(const $NIAllNullableTypes$NullableType());
  }

  static final _id_echoAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoAllNullableTypesWithoutRecursion',
    r'(LNIAllNullableTypesWithoutRecursion;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _echoAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAllNullableTypesWithoutRecursion echoAllNullableTypesWithoutRecursion(NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion? echoAllNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
  ) {
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$nIAllNullableTypesWithoutRecursion.pointer)
        .object<NIAllNullableTypesWithoutRecursion?>(
            const $NIAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_extractNestedNullableString = _class.instanceMethodId(
    r'extractNestedNullableString',
    r'(LNIAllClassesWrapper;)Ljava/lang/String;',
  );

  static final _extractNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String extractNestedNullableString(NIAllClassesWrapper nIAllClassesWrapper)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? extractNestedNullableString(
    NIAllClassesWrapper nIAllClassesWrapper,
  ) {
    final _$nIAllClassesWrapper = nIAllClassesWrapper.reference;
    return _extractNestedNullableString(
            reference.pointer,
            _id_extractNestedNullableString as jni$_.JMethodIDPtr,
            _$nIAllClassesWrapper.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_createNestedNullableString = _class.instanceMethodId(
    r'createNestedNullableString',
    r'(Ljava/lang/String;)LNIAllClassesWrapper;',
  );

  static final _createNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAllClassesWrapper createNestedNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper createNestedNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createNestedNullableString(
            reference.pointer,
            _id_createNestedNullableString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type());
  }

  static final _id_sendMultipleNullableTypes = _class.instanceMethodId(
    r'sendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypes;',
  );

  static final _sendMultipleNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAllNullableTypes sendMultipleNullableTypes(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes sendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypes(
            reference.pointer,
            _id_sendMultipleNullableTypes as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<NIAllNullableTypes>(const $NIAllNullableTypes$Type());
  }

  static final _id_sendMultipleNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'sendMultipleNullableTypesWithoutRecursion',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _sendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypesWithoutRecursion(
            reference.pointer,
            _id_sendMultipleNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<NIAllNullableTypesWithoutRecursion>(
            const $NIAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_echoNullableInt = _class.instanceMethodId(
    r'echoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Long echoNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoNullableInt(reference.pointer,
            _id_echoNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNullableDouble = _class.instanceMethodId(
    r'echoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _echoNullableDouble = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Double echoNullableDouble(java.lang.Double double)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? echoNullableDouble(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _echoNullableDouble(reference.pointer,
            _id_echoNullableDouble as jni$_.JMethodIDPtr, _$double.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_echoNullableBool = _class.instanceMethodId(
    r'echoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _echoNullableBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Boolean echoNullableBool(java.lang.Boolean boolean)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? echoNullableBool(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _echoNullableBool(reference.pointer,
            _id_echoNullableBool as jni$_.JMethodIDPtr, _$boolean.pointer)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_echoNullableString = _class.instanceMethodId(
    r'echoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echoNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNullableString(reference.pointer,
            _id_echoNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_echoNullableUint8List = _class.instanceMethodId(
    r'echoNullableUint8List',
    r'([B)[B',
  );

  static final _echoNullableUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public byte[] echoNullableUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? echoNullableUint8List(
    jni$_.JByteArray? bs,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _echoNullableUint8List(reference.pointer,
            _id_echoNullableUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_echoNullableInt32List = _class.instanceMethodId(
    r'echoNullableInt32List',
    r'([I)[I',
  );

  static final _echoNullableInt32List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int[] echoNullableInt32List(int[] is)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? echoNullableInt32List(
    jni$_.JIntArray? is$,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _echoNullableInt32List(reference.pointer,
            _id_echoNullableInt32List as jni$_.JMethodIDPtr, _$is$.pointer)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_echoNullableInt64List = _class.instanceMethodId(
    r'echoNullableInt64List',
    r'([J)[J',
  );

  static final _echoNullableInt64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long[] echoNullableInt64List(long[] js)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? echoNullableInt64List(
    jni$_.JLongArray? js,
  ) {
    final _$js = js?.reference ?? jni$_.jNullReference;
    return _echoNullableInt64List(reference.pointer,
            _id_echoNullableInt64List as jni$_.JMethodIDPtr, _$js.pointer)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_echoNullableFloat64List = _class.instanceMethodId(
    r'echoNullableFloat64List',
    r'([D)[D',
  );

  static final _echoNullableFloat64List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public double[] echoNullableFloat64List(double[] ds)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? echoNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    return _echoNullableFloat64List(reference.pointer,
            _id_echoNullableFloat64List as jni$_.JMethodIDPtr, _$ds.pointer)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_echoNullableObject = _class.instanceMethodId(
    r'echoNullableObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoNullableObject = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoNullableObject(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? echoNullableObject(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _echoNullableObject(reference.pointer,
            _id_echoNullableObject as jni$_.JMethodIDPtr, _$object.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_echoNullableList = _class.instanceMethodId(
    r'echoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<java.lang.Object> echoNullableList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? echoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableList(reference.pointer,
            _id_echoNullableList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableEnumList = _class.instanceMethodId(
    r'echoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAnEnum> echoNullableEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? echoNullableEnumList(
    jni$_.JList<NIAnEnum?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumList(reference.pointer,
            _id_echoNullableEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAnEnum?>?>(
            const jni$_.JListNullableType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_echoNullableClassList = _class.instanceMethodId(
    r'echoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAllNullableTypes> echoNullableClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?>? echoNullableClassList(
    jni$_.JList<NIAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableClassList(reference.pointer,
            _id_echoNullableClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes?>?>(
            const jni$_.JListNullableType<NIAllNullableTypes?>(
                $NIAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullEnumList = _class.instanceMethodId(
    r'echoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAnEnum> echoNullableNonNullEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum>? echoNullableNonNullEnumList(
    jni$_.JList<NIAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumList(
            reference.pointer,
            _id_echoNullableNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAnEnum>?>(
            const jni$_.JListNullableType<NIAnEnum>($NIAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassList = _class.instanceMethodId(
    r'echoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAllNullableTypes> echoNullableNonNullClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes>? echoNullableNonNullClassList(
    jni$_.JList<NIAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassList(
            reference.pointer,
            _id_echoNullableNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes>?>(
            const jni$_.JListNullableType<NIAllNullableTypes>(
                $NIAllNullableTypes$Type()));
  }

  static final _id_echoNullableMap = _class.instanceMethodId(
    r'echoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Object, java.lang.Object> echoNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableMap(reference.pointer,
            _id_echoNullableMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableStringMap = _class.instanceMethodId(
    r'echoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> echoNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableStringMap(reference.pointer,
            _id_echoNullableStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoNullableIntMap = _class.instanceMethodId(
    r'echoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> echoNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableIntMap(reference.pointer,
            _id_echoNullableIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoNullableEnumMap = _class.instanceMethodId(
    r'echoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<NIAnEnum, NIAnEnum> echoNullableEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? echoNullableEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumMap(reference.pointer,
            _id_echoNullableEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
            const jni$_.JMapNullableType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_echoNullableClassMap = _class.instanceMethodId(
    r'echoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, NIAllNullableTypes> echoNullableClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? echoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableClassMap(reference.pointer,
            _id_echoNullableClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, NIAllNullableTypes?>(
                jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullStringMap = _class.instanceMethodId(
    r'echoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> echoNullableNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullStringMap(
            reference.pointer,
            _id_echoNullableNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNullableNonNullIntMap = _class.instanceMethodId(
    r'echoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> echoNullableNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullIntMap(reference.pointer,
            _id_echoNullableNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
            const jni$_.JMapNullableType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNullableNonNullEnumMap = _class.instanceMethodId(
    r'echoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<NIAnEnum, NIAnEnum> echoNullableNonNullEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum>? echoNullableNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumMap(reference.pointer,
            _id_echoNullableNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum, NIAnEnum>?>(
            const jni$_.JMapNullableType<NIAnEnum, NIAnEnum>(
                $NIAnEnum$Type(), $NIAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassMap = _class.instanceMethodId(
    r'echoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, NIAllNullableTypes> echoNullableNonNullClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? echoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassMap(
            reference.pointer,
            _id_echoNullableNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>?>(
            const jni$_.JMapNullableType<jni$_.JLong, NIAllNullableTypes>(
                jni$_.JLongType(), $NIAllNullableTypes$Type()));
  }

  static final _id_echoNullableEnum = _class.instanceMethodId(
    r'echoNullableEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAnEnum echoNullableEnum(NIAnEnum nIAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? echoNullableEnum(
    NIAnEnum? nIAnEnum,
  ) {
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    return _echoNullableEnum(reference.pointer,
            _id_echoNullableEnum as jni$_.JMethodIDPtr, _$nIAnEnum.pointer)
        .object<NIAnEnum?>(const $NIAnEnum$NullableType());
  }

  static final _id_echoAnotherNullableEnum = _class.instanceMethodId(
    r'echoAnotherNullableEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAnotherEnum echoAnotherNullableEnum(NIAnotherEnum nIAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? echoAnotherNullableEnum(
    NIAnotherEnum? nIAnotherEnum,
  ) {
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    return _echoAnotherNullableEnum(
            reference.pointer,
            _id_echoAnotherNullableEnum as jni$_.JMethodIDPtr,
            _$nIAnotherEnum.pointer)
        .object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType());
  }

  static final _id_echoOptionalNullableInt = _class.instanceMethodId(
    r'echoOptionalNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoOptionalNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Long echoOptionalNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoOptionalNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoOptionalNullableInt(reference.pointer,
            _id_echoOptionalNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNamedNullableString = _class.instanceMethodId(
    r'echoNamedNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNamedNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echoNamedNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNamedNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNamedNullableString(reference.pointer,
            _id_echoNamedNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_noopAsync = _class.instanceMethodId(
    r'noopAsync',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _noopAsync = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object noopAsync(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> noopAsync() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _noopAsync(reference.pointer,
            _id_noopAsync as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt = _class.instanceMethodId(
    r'echoAsyncInt',
    r'(JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncInt(long j, kotlin.coroutines.Continuation<? super java.lang.Long> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong> echoAsyncInt(
    int j,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncInt(reference.pointer,
            _id_echoAsyncInt as jni$_.JMethodIDPtr, j, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLong>(
      const jni$_.JLongType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncDouble = _class.instanceMethodId(
    r'echoAsyncDouble',
    r'(DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, double, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncDouble(double d, kotlin.coroutines.Continuation<? super java.lang.Double> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble> echoAsyncDouble(
    double d,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncDouble(
            reference.pointer,
            _id_echoAsyncDouble as jni$_.JMethodIDPtr,
            d,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDouble>(
      const jni$_.JDoubleType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncBool = _class.instanceMethodId(
    r'echoAsyncBool',
    r'(ZLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncBool(boolean z, kotlin.coroutines.Continuation<? super java.lang.Boolean> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean> echoAsyncBool(
    bool z,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _echoAsyncBool(
            reference.pointer,
            _id_echoAsyncBool as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JBoolean>(
      const jni$_.JBooleanType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncString = _class.instanceMethodId(
    r'echoAsyncString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncString(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echoAsyncString(
    jni$_.JString string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echoAsyncString(
            reference.pointer,
            _id_echoAsyncString as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.JStringType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncUint8List = _class.instanceMethodId(
    r'echoAsyncUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncUint8List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncUint8List(byte[] bs, kotlin.coroutines.Continuation<? super byte[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray> echoAsyncUint8List(
    jni$_.JByteArray bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs.reference;
    final $r = _echoAsyncUint8List(
            reference.pointer,
            _id_echoAsyncUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JByteArray>(
      const jni$_.JByteArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt32List = _class.instanceMethodId(
    r'echoAsyncInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt32List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncInt32List(int[] is, kotlin.coroutines.Continuation<? super int[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray> echoAsyncInt32List(
    jni$_.JIntArray is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$.reference;
    final $r = _echoAsyncInt32List(
            reference.pointer,
            _id_echoAsyncInt32List as jni$_.JMethodIDPtr,
            _$is$.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JIntArray>(
      const jni$_.JIntArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncInt64List = _class.instanceMethodId(
    r'echoAsyncInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncInt64List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncInt64List(long[] js, kotlin.coroutines.Continuation<? super long[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray> echoAsyncInt64List(
    jni$_.JLongArray js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js.reference;
    final $r = _echoAsyncInt64List(
            reference.pointer,
            _id_echoAsyncInt64List as jni$_.JMethodIDPtr,
            _$js.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JLongArray>(
      const jni$_.JLongArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncFloat64List = _class.instanceMethodId(
    r'echoAsyncFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncFloat64List = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncFloat64List(double[] ds, kotlin.coroutines.Continuation<? super double[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray> echoAsyncFloat64List(
    jni$_.JDoubleArray ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds.reference;
    final $r = _echoAsyncFloat64List(
            reference.pointer,
            _id_echoAsyncFloat64List as jni$_.JMethodIDPtr,
            _$ds.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JDoubleArray>(
      const jni$_.JDoubleArrayType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncObject = _class.instanceMethodId(
    r'echoAsyncObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncObject(java.lang.Object object, kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> echoAsyncObject(
    jni$_.JObject object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object.reference;
    final $r = _echoAsyncObject(
            reference.pointer,
            _id_echoAsyncObject as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncList = _class.instanceMethodId(
    r'echoAsyncList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncList(java.util.List<? extends java.lang.Object> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>> echoAsyncList(
    jni$_.JList<jni$_.JObject?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncList(
            reference.pointer,
            _id_echoAsyncList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<jni$_.JObject?>>(
      const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumList = _class.instanceMethodId(
    r'echoAsyncEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncEnumList(java.util.List<? extends NIAnEnum> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAnEnum?>> echoAsyncEnumList(
    jni$_.JList<NIAnEnum?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncEnumList(
            reference.pointer,
            _id_echoAsyncEnumList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<NIAnEnum?>>(
      const jni$_.JListType<NIAnEnum?>($NIAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassList = _class.instanceMethodId(
    r'echoAsyncClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncClassList(java.util.List<NIAllNullableTypes> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAllNullableTypes?>> echoAsyncClassList(
    jni$_.JList<NIAllNullableTypes?> list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list.reference;
    final $r = _echoAsyncClassList(
            reference.pointer,
            _id_echoAsyncClassList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JList<NIAllNullableTypes?>>(
      const jni$_.JListType<NIAllNullableTypes?>(
          $NIAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncMap = _class.instanceMethodId(
    r'echoAsyncMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> echoAsyncMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncMap(
            reference.pointer,
            _id_echoAsyncMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
      const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
          jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncStringMap = _class.instanceMethodId(
    r'echoAsyncStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncStringMap(java.util.Map<java.lang.String, java.lang.String> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>> echoAsyncStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncStringMap(
            reference.pointer,
            _id_echoAsyncStringMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
      const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(), jni$_.JStringNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncIntMap = _class.instanceMethodId(
    r'echoAsyncIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncIntMap(java.util.Map<java.lang.Long, java.lang.Long> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>> echoAsyncIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncIntMap(
            reference.pointer,
            _id_echoAsyncIntMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
      const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
          jni$_.JLongNullableType(), jni$_.JLongNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnumMap = _class.instanceMethodId(
    r'echoAsyncEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<NIAnEnum?, NIAnEnum?>> echoAsyncEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncEnumMap(
            reference.pointer,
            _id_echoAsyncEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<NIAnEnum?, NIAnEnum?>>(
      const jni$_.JMapType<NIAnEnum?, NIAnEnum?>(
          $NIAnEnum$NullableType(), $NIAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncClassMap = _class.instanceMethodId(
    r'echoAsyncClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>
      echoAsyncClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map.reference;
    final $r = _echoAsyncClassMap(
            reference.pointer,
            _id_echoAsyncClassMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>(
      const jni$_.JMapType<jni$_.JLong?, NIAllNullableTypes?>(
          jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncEnum = _class.instanceMethodId(
    r'echoAsyncEnum',
    r'(LNIAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncEnum(NIAnEnum nIAnEnum, kotlin.coroutines.Continuation<? super NIAnEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnEnum> echoAsyncEnum(
    NIAnEnum nIAnEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnEnum = nIAnEnum.reference;
    final $r = _echoAsyncEnum(
            reference.pointer,
            _id_echoAsyncEnum as jni$_.JMethodIDPtr,
            _$nIAnEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<NIAnEnum>(
      const $NIAnEnum$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncEnum = _class.instanceMethodId(
    r'echoAnotherAsyncEnum',
    r'(LNIAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAnotherAsyncEnum(NIAnotherEnum nIAnotherEnum, kotlin.coroutines.Continuation<? super NIAnotherEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnotherEnum> echoAnotherAsyncEnum(
    NIAnotherEnum nIAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    final $r = _echoAnotherAsyncEnum(
            reference.pointer,
            _id_echoAnotherAsyncEnum as jni$_.JMethodIDPtr,
            _$nIAnotherEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<NIAnotherEnum>(
      const $NIAnotherEnum$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncError = _class.instanceMethodId(
    r'throwAsyncError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object throwAsyncError(kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncError(reference.pointer,
            _id_throwAsyncError as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncErrorFromVoid = _class.instanceMethodId(
    r'throwAsyncErrorFromVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object throwAsyncErrorFromVoid(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> throwAsyncErrorFromVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncErrorFromVoid(
            reference.pointer,
            _id_throwAsyncErrorFromVoid as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }

  static final _id_throwAsyncFlutterError = _class.instanceMethodId(
    r'throwAsyncFlutterError',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _throwAsyncFlutterError = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object throwAsyncFlutterError(kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> throwAsyncFlutterError() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _throwAsyncFlutterError(
            reference.pointer,
            _id_throwAsyncFlutterError as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNIAllTypes = _class.instanceMethodId(
    r'echoAsyncNIAllTypes',
    r'(LNIAllTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNIAllTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNIAllTypes(NIAllTypes nIAllTypes, kotlin.coroutines.Continuation<? super NIAllTypes> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAllTypes> echoAsyncNIAllTypes(
    NIAllTypes nIAllTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAllTypes = nIAllTypes.reference;
    final $r = _echoAsyncNIAllTypes(
            reference.pointer,
            _id_echoAsyncNIAllTypes as jni$_.JMethodIDPtr,
            _$nIAllTypes.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<NIAllTypes>(
      const $NIAllTypes$Type(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableNIAllNullableTypes =
      _class.instanceMethodId(
    r'echoAsyncNullableNIAllNullableTypes',
    r'(LNIAllNullableTypes;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableNIAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableNIAllNullableTypes(NIAllNullableTypes nIAllNullableTypes, kotlin.coroutines.Continuation<? super NIAllNullableTypes> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAllNullableTypes?> echoAsyncNullableNIAllNullableTypes(
    NIAllNullableTypes? nIAllNullableTypes,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableNIAllNullableTypes(
            reference.pointer,
            _id_echoAsyncNullableNIAllNullableTypes as jni$_.JMethodIDPtr,
            _$nIAllNullableTypes.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAllNullableTypes?>(
      const $NIAllNullableTypes$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableNIAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoAsyncNullableNIAllNullableTypesWithoutRecursion',
    r'(LNIAllNullableTypesWithoutRecursion;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableNIAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableNIAllNullableTypesWithoutRecursion(NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion, kotlin.coroutines.Continuation<? super NIAllNullableTypesWithoutRecursion> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAllNullableTypesWithoutRecursion?>
      echoAsyncNullableNIAllNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableNIAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoAsyncNullableNIAllNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$nIAllNullableTypesWithoutRecursion.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAllNullableTypesWithoutRecursion?>(
      const $NIAllNullableTypesWithoutRecursion$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt = _class.instanceMethodId(
    r'echoAsyncNullableInt',
    r'(Ljava/lang/Long;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableInt(java.lang.Long long, kotlin.coroutines.Continuation<? super java.lang.Long> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLong?> echoAsyncNullableInt(
    jni$_.JLong? long,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$long = long?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt(
            reference.pointer,
            _id_echoAsyncNullableInt as jni$_.JMethodIDPtr,
            _$long.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLong?>(
      const jni$_.JLongNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableDouble = _class.instanceMethodId(
    r'echoAsyncNullableDouble',
    r'(Ljava/lang/Double;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableDouble(java.lang.Double double, kotlin.coroutines.Continuation<? super java.lang.Double> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDouble?> echoAsyncNullableDouble(
    jni$_.JDouble? double,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$double = double?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableDouble(
            reference.pointer,
            _id_echoAsyncNullableDouble as jni$_.JMethodIDPtr,
            _$double.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDouble?>(
      const jni$_.JDoubleNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableBool = _class.instanceMethodId(
    r'echoAsyncNullableBool',
    r'(Ljava/lang/Boolean;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableBool(java.lang.Boolean boolean, kotlin.coroutines.Continuation<? super java.lang.Boolean> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JBoolean?> echoAsyncNullableBool(
    jni$_.JBoolean? boolean,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableBool(
            reference.pointer,
            _id_echoAsyncNullableBool as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JBoolean?>(
      const jni$_.JBooleanNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableString = _class.instanceMethodId(
    r'echoAsyncNullableString',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableString(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString?> echoAsyncNullableString(
    jni$_.JString? string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableString(
            reference.pointer,
            _id_echoAsyncNullableString as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JString?>(
      const jni$_.JStringNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableUint8List = _class.instanceMethodId(
    r'echoAsyncNullableUint8List',
    r'([BLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableUint8List(byte[] bs, kotlin.coroutines.Continuation<? super byte[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JByteArray?> echoAsyncNullableUint8List(
    jni$_.JByteArray? bs,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableUint8List(
            reference.pointer,
            _id_echoAsyncNullableUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JByteArray?>(
      const jni$_.JByteArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt32List = _class.instanceMethodId(
    r'echoAsyncNullableInt32List',
    r'([ILkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt32List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableInt32List(int[] is, kotlin.coroutines.Continuation<? super int[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JIntArray?> echoAsyncNullableInt32List(
    jni$_.JIntArray? is$,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt32List(
            reference.pointer,
            _id_echoAsyncNullableInt32List as jni$_.JMethodIDPtr,
            _$is$.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JIntArray?>(
      const jni$_.JIntArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableInt64List = _class.instanceMethodId(
    r'echoAsyncNullableInt64List',
    r'([JLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableInt64List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableInt64List(long[] js, kotlin.coroutines.Continuation<? super long[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JLongArray?> echoAsyncNullableInt64List(
    jni$_.JLongArray? js,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$js = js?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableInt64List(
            reference.pointer,
            _id_echoAsyncNullableInt64List as jni$_.JMethodIDPtr,
            _$js.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JLongArray?>(
      const jni$_.JLongArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableFloat64List = _class.instanceMethodId(
    r'echoAsyncNullableFloat64List',
    r'([DLkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableFloat64List =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableFloat64List(double[] ds, kotlin.coroutines.Continuation<? super double[]> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JDoubleArray?> echoAsyncNullableFloat64List(
    jni$_.JDoubleArray? ds,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableFloat64List(
            reference.pointer,
            _id_echoAsyncNullableFloat64List as jni$_.JMethodIDPtr,
            _$ds.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JDoubleArray?>(
      const jni$_.JDoubleArrayNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableObject = _class.instanceMethodId(
    r'echoAsyncNullableObject',
    r'(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableObject(java.lang.Object object, kotlin.coroutines.Continuation<java.lang.Object> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject?> echoAsyncNullableObject(
    jni$_.JObject? object,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$object = object?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableObject(
            reference.pointer,
            _id_echoAsyncNullableObject as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JObject?>(
      const jni$_.JObjectNullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableList = _class.instanceMethodId(
    r'echoAsyncNullableList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableList(java.util.List<? extends java.lang.Object> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<jni$_.JObject?>?> echoAsyncNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableList(
            reference.pointer,
            _id_echoAsyncNullableList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.JListNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumList = _class.instanceMethodId(
    r'echoAsyncNullableEnumList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableEnumList(java.util.List<? extends NIAnEnum> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAnEnum?>?> echoAsyncNullableEnumList(
    jni$_.JList<NIAnEnum?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumList(
            reference.pointer,
            _id_echoAsyncNullableEnumList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<NIAnEnum?>?>(
      const jni$_.JListNullableType<NIAnEnum?>($NIAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassList = _class.instanceMethodId(
    r'echoAsyncNullableClassList',
    r'(Ljava/util/List;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableClassList(java.util.List<NIAllNullableTypes> list, kotlin.coroutines.Continuation<? super java.util.List> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JList<NIAllNullableTypes?>?> echoAsyncNullableClassList(
    jni$_.JList<NIAllNullableTypes?>? list,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$list = list?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassList(
            reference.pointer,
            _id_echoAsyncNullableClassList as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JList<NIAllNullableTypes?>?>(
      const jni$_.JListNullableType<NIAllNullableTypes?>(
          $NIAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableMap = _class.instanceMethodId(
    r'echoAsyncNullableMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>
      echoAsyncNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableMap(
            reference.pointer,
            _id_echoAsyncNullableMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
          jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableStringMap = _class.instanceMethodId(
    r'echoAsyncNullableStringMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>
      echoAsyncNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableStringMap(
            reference.pointer,
            _id_echoAsyncNullableStringMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(), jni$_.JStringNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableIntMap = _class.instanceMethodId(
    r'echoAsyncNullableIntMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>
      echoAsyncNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableIntMap(
            reference.pointer,
            _id_echoAsyncNullableIntMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
      const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
          jni$_.JLongNullableType(), jni$_.JLongNullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnumMap = _class.instanceMethodId(
    r'echoAsyncNullableEnumMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<NIAnEnum?, NIAnEnum?>?> echoAsyncNullableEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnumMap(
            reference.pointer,
            _id_echoAsyncNullableEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
      const jni$_.JMapNullableType<NIAnEnum?, NIAnEnum?>(
          $NIAnEnum$NullableType(), $NIAnEnum$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableClassMap = _class.instanceMethodId(
    r'echoAsyncNullableClassMap',
    r'(Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map, kotlin.coroutines.Continuation<? super java.util.Map> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>
      echoAsyncNullableClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$map = map?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableClassMap(
            reference.pointer,
            _id_echoAsyncNullableClassMap as jni$_.JMethodIDPtr,
            _$map.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
      const jni$_.JMapNullableType<jni$_.JLong?, NIAllNullableTypes?>(
          jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()),
      releaseOriginal: true,
    );
  }

  static final _id_echoAsyncNullableEnum = _class.instanceMethodId(
    r'echoAsyncNullableEnum',
    r'(LNIAnEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAsyncNullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAsyncNullableEnum(NIAnEnum nIAnEnum, kotlin.coroutines.Continuation<? super NIAnEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnEnum?> echoAsyncNullableEnum(
    NIAnEnum? nIAnEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAsyncNullableEnum(
            reference.pointer,
            _id_echoAsyncNullableEnum as jni$_.JMethodIDPtr,
            _$nIAnEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAnEnum?>(
      const $NIAnEnum$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_echoAnotherAsyncNullableEnum = _class.instanceMethodId(
    r'echoAnotherAsyncNullableEnum',
    r'(LNIAnotherEnum;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echoAnotherAsyncNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echoAnotherAsyncNullableEnum(NIAnotherEnum nIAnotherEnum, kotlin.coroutines.Continuation<? super NIAnotherEnum> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<NIAnotherEnum?> echoAnotherAsyncNullableEnum(
    NIAnotherEnum? nIAnotherEnum,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final $r = _echoAnotherAsyncNullableEnum(
            reference.pointer,
            _id_echoAnotherAsyncNullableEnum as jni$_.JMethodIDPtr,
            _$nIAnotherEnum.pointer,
            _$continuation.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
    _$continuation.release();
    final jni$_.JObject? $o;
    if ($r != null && $r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = $a == 0
          ? null
          : jni$_.JObject.fromReference(
              jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o != null && $o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o?.as<NIAnotherEnum?>(
      const $NIAnotherEnum$NullableType(),
      releaseOriginal: true,
    );
  }

  static final _id_callFlutterNoop = _class.instanceMethodId(
    r'callFlutterNoop',
    r'()V',
  );

  static final _callFlutterNoop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void callFlutterNoop()`
  void callFlutterNoop() {
    _callFlutterNoop(
            reference.pointer, _id_callFlutterNoop as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_callFlutterThrowError = _class.instanceMethodId(
    r'callFlutterThrowError',
    r'()Ljava/lang/Object;',
  );

  static final _callFlutterThrowError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object callFlutterThrowError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? callFlutterThrowError() {
    return _callFlutterThrowError(
            reference.pointer, _id_callFlutterThrowError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_callFlutterThrowErrorFromVoid = _class.instanceMethodId(
    r'callFlutterThrowErrorFromVoid',
    r'()V',
  );

  static final _callFlutterThrowErrorFromVoid =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public void callFlutterThrowErrorFromVoid()`
  void callFlutterThrowErrorFromVoid() {
    _callFlutterThrowErrorFromVoid(reference.pointer,
            _id_callFlutterThrowErrorFromVoid as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_callFlutterEchoNIAllTypes = _class.instanceMethodId(
    r'callFlutterEchoNIAllTypes',
    r'(LNIAllTypes;)LNIAllTypes;',
  );

  static final _callFlutterEchoNIAllTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAllTypes callFlutterEchoNIAllTypes(NIAllTypes nIAllTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes callFlutterEchoNIAllTypes(
    NIAllTypes nIAllTypes,
  ) {
    final _$nIAllTypes = nIAllTypes.reference;
    return _callFlutterEchoNIAllTypes(
            reference.pointer,
            _id_callFlutterEchoNIAllTypes as jni$_.JMethodIDPtr,
            _$nIAllTypes.pointer)
        .object<NIAllTypes>(const $NIAllTypes$Type());
  }

  static final _id_callFlutterEchoNIAllNullableTypes = _class.instanceMethodId(
    r'callFlutterEchoNIAllNullableTypes',
    r'(LNIAllNullableTypes;)LNIAllNullableTypes;',
  );

  static final _callFlutterEchoNIAllNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAllNullableTypes callFlutterEchoNIAllNullableTypes(NIAllNullableTypes nIAllNullableTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes? callFlutterEchoNIAllNullableTypes(
    NIAllNullableTypes? nIAllNullableTypes,
  ) {
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNIAllNullableTypes(
            reference.pointer,
            _id_callFlutterEchoNIAllNullableTypes as jni$_.JMethodIDPtr,
            _$nIAllNullableTypes.pointer)
        .object<NIAllNullableTypes?>(const $NIAllNullableTypes$NullableType());
  }

  static final _id_callFlutterSendMultipleNullableTypes =
      _class.instanceMethodId(
    r'callFlutterSendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypes;',
  );

  static final _callFlutterSendMultipleNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAllNullableTypes callFlutterSendMultipleNullableTypes(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes callFlutterSendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _callFlutterSendMultipleNullableTypes(
            reference.pointer,
            _id_callFlutterSendMultipleNullableTypes as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<NIAllNullableTypes>(const $NIAllNullableTypes$Type());
  }

  static final _id_callFlutterEchoNIAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'callFlutterEchoNIAllNullableTypesWithoutRecursion',
    r'(LNIAllNullableTypesWithoutRecursion;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _callFlutterEchoNIAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAllNullableTypesWithoutRecursion callFlutterEchoNIAllNullableTypesWithoutRecursion(NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion?
      callFlutterEchoNIAllNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
  ) {
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNIAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_callFlutterEchoNIAllNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$nIAllNullableTypesWithoutRecursion.pointer)
        .object<NIAllNullableTypesWithoutRecursion?>(
            const $NIAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_callFlutterSendMultipleNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'callFlutterSendMultipleNullableTypesWithoutRecursion',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _callFlutterSendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAllNullableTypesWithoutRecursion callFlutterSendMultipleNullableTypesWithoutRecursion(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion
      callFlutterSendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _callFlutterSendMultipleNullableTypesWithoutRecursion(
            reference.pointer,
            _id_callFlutterSendMultipleNullableTypesWithoutRecursion
                as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<NIAllNullableTypesWithoutRecursion>(
            const $NIAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_callFlutterEchoBool = _class.instanceMethodId(
    r'callFlutterEchoBool',
    r'(Z)Z',
  );

  static final _callFlutterEchoBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean callFlutterEchoBool(boolean z)`
  bool callFlutterEchoBool(
    bool z,
  ) {
    return _callFlutterEchoBool(reference.pointer,
            _id_callFlutterEchoBool as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_callFlutterEchoInt = _class.instanceMethodId(
    r'callFlutterEchoInt',
    r'(J)J',
  );

  static final _callFlutterEchoInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public long callFlutterEchoInt(long j)`
  int callFlutterEchoInt(
    int j,
  ) {
    return _callFlutterEchoInt(
            reference.pointer, _id_callFlutterEchoInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_callFlutterEchoDouble = _class.instanceMethodId(
    r'callFlutterEchoDouble',
    r'(D)D',
  );

  static final _callFlutterEchoDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public double callFlutterEchoDouble(double d)`
  double callFlutterEchoDouble(
    double d,
  ) {
    return _callFlutterEchoDouble(reference.pointer,
            _id_callFlutterEchoDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_callFlutterEchoString = _class.instanceMethodId(
    r'callFlutterEchoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _callFlutterEchoString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String callFlutterEchoString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString callFlutterEchoString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _callFlutterEchoString(reference.pointer,
            _id_callFlutterEchoString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_callFlutterEchoUint8List = _class.instanceMethodId(
    r'callFlutterEchoUint8List',
    r'([B)[B',
  );

  static final _callFlutterEchoUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public byte[] callFlutterEchoUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray callFlutterEchoUint8List(
    jni$_.JByteArray bs,
  ) {
    final _$bs = bs.reference;
    return _callFlutterEchoUint8List(reference.pointer,
            _id_callFlutterEchoUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_callFlutterEchoList = _class.instanceMethodId(
    r'callFlutterEchoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<java.lang.Object> callFlutterEchoList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> callFlutterEchoList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoList(reference.pointer,
            _id_callFlutterEchoList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoEnumList = _class.instanceMethodId(
    r'callFlutterEchoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAnEnum> callFlutterEchoEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?> callFlutterEchoEnumList(
    jni$_.JList<NIAnEnum?> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoEnumList(reference.pointer,
            _id_callFlutterEchoEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAnEnum?>>(
            const jni$_.JListType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoClassList = _class.instanceMethodId(
    r'callFlutterEchoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAllNullableTypes> callFlutterEchoClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?> callFlutterEchoClassList(
    jni$_.JList<NIAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoClassList(reference.pointer,
            _id_callFlutterEchoClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes?>>(
            const jni$_.JListType<NIAllNullableTypes?>(
                $NIAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNonNullEnumList = _class.instanceMethodId(
    r'callFlutterEchoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAnEnum> callFlutterEchoNonNullEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> callFlutterEchoNonNullEnumList(
    jni$_.JList<NIAnEnum> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoNonNullEnumList(
            reference.pointer,
            _id_callFlutterEchoNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAnEnum>>(
            const jni$_.JListType<NIAnEnum>($NIAnEnum$Type()));
  }

  static final _id_callFlutterEchoNonNullClassList = _class.instanceMethodId(
    r'callFlutterEchoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAllNullableTypes> callFlutterEchoNonNullClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes> callFlutterEchoNonNullClassList(
    jni$_.JList<NIAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _callFlutterEchoNonNullClassList(
            reference.pointer,
            _id_callFlutterEchoNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes>>(
            const jni$_.JListType<NIAllNullableTypes>(
                $NIAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoMap = _class.instanceMethodId(
    r'callFlutterEchoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Object, java.lang.Object> callFlutterEchoMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> callFlutterEchoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoMap(reference.pointer,
            _id_callFlutterEchoMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoStringMap = _class.instanceMethodId(
    r'callFlutterEchoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> callFlutterEchoStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> callFlutterEchoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoStringMap(reference.pointer,
            _id_callFlutterEchoStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_callFlutterEchoIntMap = _class.instanceMethodId(
    r'callFlutterEchoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> callFlutterEchoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoIntMap(reference.pointer,
            _id_callFlutterEchoIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
            const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_callFlutterEchoEnumMap = _class.instanceMethodId(
    r'callFlutterEchoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<NIAnEnum, NIAnEnum> callFlutterEchoEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?> callFlutterEchoEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoEnumMap(reference.pointer,
            _id_callFlutterEchoEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>>(
            const jni$_.JMapType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoClassMap = _class.instanceMethodId(
    r'callFlutterEchoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, NIAllNullableTypes> callFlutterEchoClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> callFlutterEchoClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoClassMap(reference.pointer,
            _id_callFlutterEchoClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, NIAllNullableTypes?>(
                jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNonNullStringMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> callFlutterEchoNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> callFlutterEchoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullStringMap(
            reference.pointer,
            _id_callFlutterEchoNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_callFlutterEchoNonNullIntMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullIntMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> callFlutterEchoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullIntMap(
            reference.pointer,
            _id_callFlutterEchoNonNullIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_callFlutterEchoNonNullEnumMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<NIAnEnum, NIAnEnum> callFlutterEchoNonNullEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum> callFlutterEchoNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullEnumMap(
            reference.pointer,
            _id_callFlutterEchoNonNullEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<NIAnEnum, NIAnEnum>>(
            const jni$_.JMapType<NIAnEnum, NIAnEnum>(
                $NIAnEnum$Type(), $NIAnEnum$Type()));
  }

  static final _id_callFlutterEchoNonNullClassMap = _class.instanceMethodId(
    r'callFlutterEchoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, NIAllNullableTypes> callFlutterEchoNonNullClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes> callFlutterEchoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _callFlutterEchoNonNullClassMap(
            reference.pointer,
            _id_callFlutterEchoNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>>(
            const jni$_.JMapType<jni$_.JLong, NIAllNullableTypes>(
                jni$_.JLongType(), $NIAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoEnum = _class.instanceMethodId(
    r'callFlutterEchoEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _callFlutterEchoEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAnEnum callFlutterEchoEnum(NIAnEnum nIAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum callFlutterEchoEnum(
    NIAnEnum nIAnEnum,
  ) {
    final _$nIAnEnum = nIAnEnum.reference;
    return _callFlutterEchoEnum(reference.pointer,
            _id_callFlutterEchoEnum as jni$_.JMethodIDPtr, _$nIAnEnum.pointer)
        .object<NIAnEnum>(const $NIAnEnum$Type());
  }

  static final _id_callFlutterEchoNIAnotherEnum = _class.instanceMethodId(
    r'callFlutterEchoNIAnotherEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _callFlutterEchoNIAnotherEnum =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAnotherEnum callFlutterEchoNIAnotherEnum(NIAnotherEnum nIAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum callFlutterEchoNIAnotherEnum(
    NIAnotherEnum nIAnotherEnum,
  ) {
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    return _callFlutterEchoNIAnotherEnum(
            reference.pointer,
            _id_callFlutterEchoNIAnotherEnum as jni$_.JMethodIDPtr,
            _$nIAnotherEnum.pointer)
        .object<NIAnotherEnum>(const $NIAnotherEnum$Type());
  }

  static final _id_callFlutterEchoNullableBool = _class.instanceMethodId(
    r'callFlutterEchoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _callFlutterEchoNullableBool =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Boolean callFlutterEchoNullableBool(java.lang.Boolean boolean)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? callFlutterEchoNullableBool(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableBool(
            reference.pointer,
            _id_callFlutterEchoNullableBool as jni$_.JMethodIDPtr,
            _$boolean.pointer)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_callFlutterEchoNullableInt = _class.instanceMethodId(
    r'callFlutterEchoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _callFlutterEchoNullableInt =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Long callFlutterEchoNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? callFlutterEchoNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableInt(
            reference.pointer,
            _id_callFlutterEchoNullableInt as jni$_.JMethodIDPtr,
            _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_callFlutterEchoNullableDouble = _class.instanceMethodId(
    r'callFlutterEchoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _callFlutterEchoNullableDouble =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Double callFlutterEchoNullableDouble(java.lang.Double double)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? callFlutterEchoNullableDouble(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableDouble(
            reference.pointer,
            _id_callFlutterEchoNullableDouble as jni$_.JMethodIDPtr,
            _$double.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_callFlutterEchoNullableString = _class.instanceMethodId(
    r'callFlutterEchoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _callFlutterEchoNullableString =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String callFlutterEchoNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? callFlutterEchoNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableString(
            reference.pointer,
            _id_callFlutterEchoNullableString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_callFlutterEchoNullableUint8List = _class.instanceMethodId(
    r'callFlutterEchoNullableUint8List',
    r'([B)[B',
  );

  static final _callFlutterEchoNullableUint8List =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public byte[] callFlutterEchoNullableUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? callFlutterEchoNullableUint8List(
    jni$_.JByteArray? bs,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableUint8List(
            reference.pointer,
            _id_callFlutterEchoNullableUint8List as jni$_.JMethodIDPtr,
            _$bs.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_callFlutterEchoNullableList = _class.instanceMethodId(
    r'callFlutterEchoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<java.lang.Object> callFlutterEchoNullableList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? callFlutterEchoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableList(
            reference.pointer,
            _id_callFlutterEchoNullableList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoNullableEnumList = _class.instanceMethodId(
    r'callFlutterEchoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAnEnum> callFlutterEchoNullableEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? callFlutterEchoNullableEnumList(
    jni$_.JList<NIAnEnum?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableEnumList(
            reference.pointer,
            _id_callFlutterEchoNullableEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAnEnum?>?>(
            const jni$_.JListNullableType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoNullableClassList = _class.instanceMethodId(
    r'callFlutterEchoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAllNullableTypes> callFlutterEchoNullableClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?>? callFlutterEchoNullableClassList(
    jni$_.JList<NIAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableClassList(
            reference.pointer,
            _id_callFlutterEchoNullableClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes?>?>(
            const jni$_.JListNullableType<NIAllNullableTypes?>(
                $NIAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNullableNonNullEnumList =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAnEnum> callFlutterEchoNullableNonNullEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum>? callFlutterEchoNullableNonNullEnumList(
    jni$_.JList<NIAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullEnumList(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAnEnum>?>(
            const jni$_.JListNullableType<NIAnEnum>($NIAnEnum$Type()));
  }

  static final _id_callFlutterEchoNullableNonNullClassList =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _callFlutterEchoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<NIAllNullableTypes> callFlutterEchoNullableNonNullClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes>? callFlutterEchoNullableNonNullClassList(
    jni$_.JList<NIAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullClassList(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes>?>(
            const jni$_.JListNullableType<NIAllNullableTypes>(
                $NIAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoNullableMap = _class.instanceMethodId(
    r'callFlutterEchoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Object, java.lang.Object> callFlutterEchoNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? callFlutterEchoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableMap(reference.pointer,
            _id_callFlutterEchoNullableMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_callFlutterEchoNullableStringMap = _class.instanceMethodId(
    r'callFlutterEchoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> callFlutterEchoNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? callFlutterEchoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableStringMap(
            reference.pointer,
            _id_callFlutterEchoNullableStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_callFlutterEchoNullableIntMap = _class.instanceMethodId(
    r'callFlutterEchoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableIntMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? callFlutterEchoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableIntMap(
            reference.pointer,
            _id_callFlutterEchoNullableIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_callFlutterEchoNullableEnumMap = _class.instanceMethodId(
    r'callFlutterEchoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<NIAnEnum, NIAnEnum> callFlutterEchoNullableEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? callFlutterEchoNullableEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableEnumMap(
            reference.pointer,
            _id_callFlutterEchoNullableEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
            const jni$_.JMapNullableType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_callFlutterEchoNullableClassMap = _class.instanceMethodId(
    r'callFlutterEchoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, NIAllNullableTypes> callFlutterEchoNullableClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?
      callFlutterEchoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableClassMap(
            reference.pointer,
            _id_callFlutterEchoNullableClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, NIAllNullableTypes?>(
                jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()));
  }

  static final _id_callFlutterEchoNullableNonNullStringMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> callFlutterEchoNullableNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>?
      callFlutterEchoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullStringMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_callFlutterEchoNullableNonNullIntMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullIntMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, java.lang.Long> callFlutterEchoNullableNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? callFlutterEchoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullIntMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
            const jni$_.JMapNullableType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_callFlutterEchoNullableNonNullEnumMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<NIAnEnum, NIAnEnum> callFlutterEchoNullableNonNullEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum>? callFlutterEchoNullableNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullEnumMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullEnumMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<NIAnEnum, NIAnEnum>?>(
            const jni$_.JMapNullableType<NIAnEnum, NIAnEnum>(
                $NIAnEnum$Type(), $NIAnEnum$Type()));
  }

  static final _id_callFlutterEchoNullableNonNullClassMap =
      _class.instanceMethodId(
    r'callFlutterEchoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _callFlutterEchoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map<java.lang.Long, NIAllNullableTypes> callFlutterEchoNullableNonNullClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes>?
      callFlutterEchoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableNonNullClassMap(
            reference.pointer,
            _id_callFlutterEchoNullableNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>?>(
            const jni$_.JMapNullableType<jni$_.JLong, NIAllNullableTypes>(
                jni$_.JLongType(), $NIAllNullableTypes$Type()));
  }

  static final _id_callFlutterEchoNullableEnum = _class.instanceMethodId(
    r'callFlutterEchoNullableEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _callFlutterEchoNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAnEnum callFlutterEchoNullableEnum(NIAnEnum nIAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? callFlutterEchoNullableEnum(
    NIAnEnum? nIAnEnum,
  ) {
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoNullableEnum(
            reference.pointer,
            _id_callFlutterEchoNullableEnum as jni$_.JMethodIDPtr,
            _$nIAnEnum.pointer)
        .object<NIAnEnum?>(const $NIAnEnum$NullableType());
  }

  static final _id_callFlutterEchoAnotherNullableEnum = _class.instanceMethodId(
    r'callFlutterEchoAnotherNullableEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _callFlutterEchoAnotherNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public NIAnotherEnum callFlutterEchoAnotherNullableEnum(NIAnotherEnum nIAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? callFlutterEchoAnotherNullableEnum(
    NIAnotherEnum? nIAnotherEnum,
  ) {
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    return _callFlutterEchoAnotherNullableEnum(
            reference.pointer,
            _id_callFlutterEchoAnotherNullableEnum as jni$_.JMethodIDPtr,
            _$nIAnotherEnum.pointer)
        .object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType());
  }
}

final class $NIHostIntegrationCoreApiRegistrar$NullableType
    extends jni$_.JObjType<NIHostIntegrationCoreApiRegistrar?> {
  @jni$_.internal
  const $NIHostIntegrationCoreApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  NIHostIntegrationCoreApiRegistrar? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIHostIntegrationCoreApiRegistrar.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $NIHostIntegrationCoreApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIHostIntegrationCoreApiRegistrar?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode =>
      ($NIHostIntegrationCoreApiRegistrar$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIHostIntegrationCoreApiRegistrar$NullableType) &&
        other is $NIHostIntegrationCoreApiRegistrar$NullableType;
  }
}

final class $NIHostIntegrationCoreApiRegistrar$Type
    extends jni$_.JObjType<NIHostIntegrationCoreApiRegistrar> {
  @jni$_.internal
  const $NIHostIntegrationCoreApiRegistrar$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  NIHostIntegrationCoreApiRegistrar fromReference(jni$_.JReference reference) =>
      NIHostIntegrationCoreApiRegistrar.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $NIHostIntegrationCoreApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIHostIntegrationCoreApiRegistrar?> get nullableType =>
      const $NIHostIntegrationCoreApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($NIHostIntegrationCoreApiRegistrar$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostIntegrationCoreApiRegistrar$Type) &&
        other is $NIHostIntegrationCoreApiRegistrar$Type;
  }
}

/// from: `NIHostTrivialApi`
class NIHostTrivialApi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIHostTrivialApi> $type;

  @jni$_.internal
  NIHostTrivialApi.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIHostTrivialApi');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIHostTrivialApi$NullableType();
  static const type = $NIHostTrivialApi$Type();
  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }
}

final class $NIHostTrivialApi$NullableType
    extends jni$_.JObjType<NIHostTrivialApi?> {
  @jni$_.internal
  const $NIHostTrivialApi$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostTrivialApi;';

  @jni$_.internal
  @core$_.override
  NIHostTrivialApi? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIHostTrivialApi.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIHostTrivialApi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIHostTrivialApi$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostTrivialApi$NullableType) &&
        other is $NIHostTrivialApi$NullableType;
  }
}

final class $NIHostTrivialApi$Type extends jni$_.JObjType<NIHostTrivialApi> {
  @jni$_.internal
  const $NIHostTrivialApi$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostTrivialApi;';

  @jni$_.internal
  @core$_.override
  NIHostTrivialApi fromReference(jni$_.JReference reference) =>
      NIHostTrivialApi.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIHostTrivialApi?> get nullableType =>
      const $NIHostTrivialApi$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIHostTrivialApi$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostTrivialApi$Type) &&
        other is $NIHostTrivialApi$Type;
  }
}

/// from: `NIHostTrivialApiRegistrar`
class NIHostTrivialApiRegistrar extends NIHostTrivialApi {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIHostTrivialApiRegistrar> $type;

  @jni$_.internal
  NIHostTrivialApiRegistrar.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIHostTrivialApiRegistrar');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIHostTrivialApiRegistrar$NullableType();
  static const type = $NIHostTrivialApiRegistrar$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIHostTrivialApiRegistrar() {
    return NIHostTrivialApiRegistrar.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getApi = _class.instanceMethodId(
    r'getApi',
    r'()LNIHostTrivialApi;',
  );

  static final _getApi = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIHostTrivialApi getApi()`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostTrivialApi? getApi() {
    return _getApi(reference.pointer, _id_getApi as jni$_.JMethodIDPtr)
        .object<NIHostTrivialApi?>(const $NIHostTrivialApi$NullableType());
  }

  static final _id_setApi = _class.instanceMethodId(
    r'setApi',
    r'(LNIHostTrivialApi;)V',
  );

  static final _setApi = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setApi(NIHostTrivialApi nIHostTrivialApi)`
  void setApi(
    NIHostTrivialApi? nIHostTrivialApi,
  ) {
    final _$nIHostTrivialApi =
        nIHostTrivialApi?.reference ?? jni$_.jNullReference;
    _setApi(reference.pointer, _id_setApi as jni$_.JMethodIDPtr,
            _$nIHostTrivialApi.pointer)
        .check();
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(LNIHostTrivialApi;Ljava/lang/String;)LNIHostTrivialApiRegistrar;',
  );

  static final _register = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIHostTrivialApiRegistrar register(NIHostTrivialApi nIHostTrivialApi, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostTrivialApiRegistrar register(
    NIHostTrivialApi nIHostTrivialApi,
    jni$_.JString string,
  ) {
    final _$nIHostTrivialApi = nIHostTrivialApi.reference;
    final _$string = string.reference;
    return _register(reference.pointer, _id_register as jni$_.JMethodIDPtr,
            _$nIHostTrivialApi.pointer, _$string.pointer)
        .object<NIHostTrivialApiRegistrar>(
            const $NIHostTrivialApiRegistrar$Type());
  }

  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Ljava/lang/String;)LNIHostTrivialApiRegistrar;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIHostTrivialApiRegistrar getInstance(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostTrivialApiRegistrar? getInstance(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getInstance(reference.pointer,
            _id_getInstance as jni$_.JMethodIDPtr, _$string.pointer)
        .object<NIHostTrivialApiRegistrar?>(
            const $NIHostTrivialApiRegistrar$NullableType());
  }

  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }
}

final class $NIHostTrivialApiRegistrar$NullableType
    extends jni$_.JObjType<NIHostTrivialApiRegistrar?> {
  @jni$_.internal
  const $NIHostTrivialApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostTrivialApiRegistrar;';

  @jni$_.internal
  @core$_.override
  NIHostTrivialApiRegistrar? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIHostTrivialApiRegistrar.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $NIHostTrivialApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIHostTrivialApiRegistrar?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($NIHostTrivialApiRegistrar$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostTrivialApiRegistrar$NullableType) &&
        other is $NIHostTrivialApiRegistrar$NullableType;
  }
}

final class $NIHostTrivialApiRegistrar$Type
    extends jni$_.JObjType<NIHostTrivialApiRegistrar> {
  @jni$_.internal
  const $NIHostTrivialApiRegistrar$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostTrivialApiRegistrar;';

  @jni$_.internal
  @core$_.override
  NIHostTrivialApiRegistrar fromReference(jni$_.JReference reference) =>
      NIHostTrivialApiRegistrar.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $NIHostTrivialApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIHostTrivialApiRegistrar?> get nullableType =>
      const $NIHostTrivialApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($NIHostTrivialApiRegistrar$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostTrivialApiRegistrar$Type) &&
        other is $NIHostTrivialApiRegistrar$Type;
  }
}

/// from: `NIHostSmallApi`
class NIHostSmallApi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIHostSmallApi> $type;

  @jni$_.internal
  NIHostSmallApi.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIHostSmallApi');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIHostSmallApi$NullableType();
  static const type = $NIHostSmallApi$Type();
  static final _id_echo = _class.instanceMethodId(
    r'echo',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object echo(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echo(
    jni$_.JString string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echo(reference.pointer, _id_echo as jni$_.JMethodIDPtr,
            _$string.pointer, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.JStringType(),
      releaseOriginal: true,
    );
  }

  static final _id_voidVoid = _class.instanceMethodId(
    r'voidVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _voidVoid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object voidVoid(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> voidVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _voidVoid(reference.pointer, _id_voidVoid as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }
}

final class $NIHostSmallApi$NullableType
    extends jni$_.JObjType<NIHostSmallApi?> {
  @jni$_.internal
  const $NIHostSmallApi$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostSmallApi;';

  @jni$_.internal
  @core$_.override
  NIHostSmallApi? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : NIHostSmallApi.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIHostSmallApi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIHostSmallApi$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostSmallApi$NullableType) &&
        other is $NIHostSmallApi$NullableType;
  }
}

final class $NIHostSmallApi$Type extends jni$_.JObjType<NIHostSmallApi> {
  @jni$_.internal
  const $NIHostSmallApi$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostSmallApi;';

  @jni$_.internal
  @core$_.override
  NIHostSmallApi fromReference(jni$_.JReference reference) =>
      NIHostSmallApi.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIHostSmallApi?> get nullableType =>
      const $NIHostSmallApi$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIHostSmallApi$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostSmallApi$Type) &&
        other is $NIHostSmallApi$Type;
  }
}

/// from: `NIHostSmallApiRegistrar`
class NIHostSmallApiRegistrar extends NIHostSmallApi {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIHostSmallApiRegistrar> $type;

  @jni$_.internal
  NIHostSmallApiRegistrar.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIHostSmallApiRegistrar');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIHostSmallApiRegistrar$NullableType();
  static const type = $NIHostSmallApiRegistrar$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIHostSmallApiRegistrar() {
    return NIHostSmallApiRegistrar.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getApi = _class.instanceMethodId(
    r'getApi',
    r'()LNIHostSmallApi;',
  );

  static final _getApi = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIHostSmallApi getApi()`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostSmallApi? getApi() {
    return _getApi(reference.pointer, _id_getApi as jni$_.JMethodIDPtr)
        .object<NIHostSmallApi?>(const $NIHostSmallApi$NullableType());
  }

  static final _id_setApi = _class.instanceMethodId(
    r'setApi',
    r'(LNIHostSmallApi;)V',
  );

  static final _setApi = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void setApi(NIHostSmallApi nIHostSmallApi)`
  void setApi(
    NIHostSmallApi? nIHostSmallApi,
  ) {
    final _$nIHostSmallApi = nIHostSmallApi?.reference ?? jni$_.jNullReference;
    _setApi(reference.pointer, _id_setApi as jni$_.JMethodIDPtr,
            _$nIHostSmallApi.pointer)
        .check();
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(LNIHostSmallApi;Ljava/lang/String;)LNIHostSmallApiRegistrar;',
  );

  static final _register = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIHostSmallApiRegistrar register(NIHostSmallApi nIHostSmallApi, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostSmallApiRegistrar register(
    NIHostSmallApi nIHostSmallApi,
    jni$_.JString string,
  ) {
    final _$nIHostSmallApi = nIHostSmallApi.reference;
    final _$string = string.reference;
    return _register(reference.pointer, _id_register as jni$_.JMethodIDPtr,
            _$nIHostSmallApi.pointer, _$string.pointer)
        .object<NIHostSmallApiRegistrar>(const $NIHostSmallApiRegistrar$Type());
  }

  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Ljava/lang/String;)LNIHostSmallApiRegistrar;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIHostSmallApiRegistrar getInstance(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostSmallApiRegistrar? getInstance(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getInstance(reference.pointer,
            _id_getInstance as jni$_.JMethodIDPtr, _$string.pointer)
        .object<NIHostSmallApiRegistrar?>(
            const $NIHostSmallApiRegistrar$NullableType());
  }

  static final _id_echo = _class.instanceMethodId(
    r'echo',
    r'(Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _echo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object echo(java.lang.String string, kotlin.coroutines.Continuation<? super java.lang.String> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JString> echo(
    jni$_.JString string,
  ) async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);
    final _$string = string.reference;
    final $r = _echo(reference.pointer, _id_echo as jni$_.JMethodIDPtr,
            _$string.pointer, _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JString>(
      const jni$_.JStringType(),
      releaseOriginal: true,
    );
  }

  static final _id_voidVoid = _class.instanceMethodId(
    r'voidVoid',
    r'(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;',
  );

  static final _voidVoid = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object voidVoid(kotlin.coroutines.Continuation<? super kotlin.Unit> continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  core$_.Future<jni$_.JObject> voidVoid() async {
    final $p = jni$_.ReceivePort();
    final _$continuation = jni$_.ProtectedJniExtensions.newPortContinuation($p);

    final $r = _voidVoid(reference.pointer, _id_voidVoid as jni$_.JMethodIDPtr,
            _$continuation.pointer)
        .object<jni$_.JObject>(const jni$_.JObjectType());
    _$continuation.release();
    final jni$_.JObject $o;
    if ($r.isInstanceOf(jni$_.coroutineSingletonsClass)) {
      $r.release();
      final $a = await $p.first;
      $o = jni$_.JObject.fromReference(
          jni$_.JGlobalReference(jni$_.JObjectPtr.fromAddress($a)));
      if ($o.isInstanceOf(jni$_.result$FailureClass)) {
        final $e =
            jni$_.failureExceptionField.get($o, const jni$_.JObjectType());
        $o.release();
        jni$_.Jni.throwException($e.reference.toPointer());
      }
    } else {
      $o = $r;
    }
    return $o.as<jni$_.JObject>(
      const jni$_.JObjectType(),
      releaseOriginal: true,
    );
  }
}

final class $NIHostSmallApiRegistrar$NullableType
    extends jni$_.JObjType<NIHostSmallApiRegistrar?> {
  @jni$_.internal
  const $NIHostSmallApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostSmallApiRegistrar;';

  @jni$_.internal
  @core$_.override
  NIHostSmallApiRegistrar? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIHostSmallApiRegistrar.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $NIHostSmallApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIHostSmallApiRegistrar?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($NIHostSmallApiRegistrar$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostSmallApiRegistrar$NullableType) &&
        other is $NIHostSmallApiRegistrar$NullableType;
  }
}

final class $NIHostSmallApiRegistrar$Type
    extends jni$_.JObjType<NIHostSmallApiRegistrar> {
  @jni$_.internal
  const $NIHostSmallApiRegistrar$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostSmallApiRegistrar;';

  @jni$_.internal
  @core$_.override
  NIHostSmallApiRegistrar fromReference(jni$_.JReference reference) =>
      NIHostSmallApiRegistrar.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $NIHostSmallApi$Type();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIHostSmallApiRegistrar?> get nullableType =>
      const $NIHostSmallApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($NIHostSmallApiRegistrar$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostSmallApiRegistrar$Type) &&
        other is $NIHostSmallApiRegistrar$Type;
  }
}

/// from: `NIFlutterIntegrationCoreApi`
class NIFlutterIntegrationCoreApi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIFlutterIntegrationCoreApi> $type;

  @jni$_.internal
  NIFlutterIntegrationCoreApi.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIFlutterIntegrationCoreApi');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIFlutterIntegrationCoreApi$NullableType();
  static const type = $NIFlutterIntegrationCoreApi$Type();
  static final _id_noop = _class.instanceMethodId(
    r'noop',
    r'()V',
  );

  static final _noop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void noop()`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }

  static final _id_throwError = _class.instanceMethodId(
    r'throwError',
    r'()Ljava/lang/Object;',
  );

  static final _throwError = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.Object throwError()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwError() {
    return _throwError(reference.pointer, _id_throwError as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_throwErrorFromVoid = _class.instanceMethodId(
    r'throwErrorFromVoid',
    r'()V',
  );

  static final _throwErrorFromVoid = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void throwErrorFromVoid()`
  void throwErrorFromVoid() {
    _throwErrorFromVoid(
            reference.pointer, _id_throwErrorFromVoid as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_echoNIAllTypes = _class.instanceMethodId(
    r'echoNIAllTypes',
    r'(LNIAllTypes;)LNIAllTypes;',
  );

  static final _echoNIAllTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllTypes echoNIAllTypes(NIAllTypes nIAllTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes echoNIAllTypes(
    NIAllTypes nIAllTypes,
  ) {
    final _$nIAllTypes = nIAllTypes.reference;
    return _echoNIAllTypes(reference.pointer,
            _id_echoNIAllTypes as jni$_.JMethodIDPtr, _$nIAllTypes.pointer)
        .object<NIAllTypes>(const $NIAllTypes$Type());
  }

  static final _id_echoNIAllNullableTypes = _class.instanceMethodId(
    r'echoNIAllNullableTypes',
    r'(LNIAllNullableTypes;)LNIAllNullableTypes;',
  );

  static final _echoNIAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllNullableTypes echoNIAllNullableTypes(NIAllNullableTypes nIAllNullableTypes)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes? echoNIAllNullableTypes(
    NIAllNullableTypes? nIAllNullableTypes,
  ) {
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    return _echoNIAllNullableTypes(
            reference.pointer,
            _id_echoNIAllNullableTypes as jni$_.JMethodIDPtr,
            _$nIAllNullableTypes.pointer)
        .object<NIAllNullableTypes?>(const $NIAllNullableTypes$NullableType());
  }

  static final _id_sendMultipleNullableTypes = _class.instanceMethodId(
    r'sendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypes;',
  );

  static final _sendMultipleNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllNullableTypes sendMultipleNullableTypes(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes sendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypes(
            reference.pointer,
            _id_sendMultipleNullableTypes as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<NIAllNullableTypes>(const $NIAllNullableTypes$Type());
  }

  static final _id_echoNIAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'echoNIAllNullableTypesWithoutRecursion',
    r'(LNIAllNullableTypesWithoutRecursion;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _echoNIAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllNullableTypesWithoutRecursion echoNIAllNullableTypesWithoutRecursion(NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion? echoNIAllNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
  ) {
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _echoNIAllNullableTypesWithoutRecursion(
            reference.pointer,
            _id_echoNIAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$nIAllNullableTypesWithoutRecursion.pointer)
        .object<NIAllNullableTypesWithoutRecursion?>(
            const $NIAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_sendMultipleNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'sendMultipleNullableTypesWithoutRecursion',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _sendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(java.lang.Boolean boolean, java.lang.Long long, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypesWithoutRecursion(
            reference.pointer,
            _id_sendMultipleNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$string.pointer)
        .object<NIAllNullableTypesWithoutRecursion>(
            const $NIAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_echoBool = _class.instanceMethodId(
    r'echoBool',
    r'(Z)Z',
  );

  static final _echoBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract boolean echoBool(boolean z)`
  bool echoBool(
    bool z,
  ) {
    return _echoBool(
            reference.pointer, _id_echoBool as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_echoInt = _class.instanceMethodId(
    r'echoInt',
    r'(J)J',
  );

  static final _echoInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract long echoInt(long j)`
  int echoInt(
    int j,
  ) {
    return _echoInt(reference.pointer, _id_echoInt as jni$_.JMethodIDPtr, j)
        .long;
  }

  static final _id_echoDouble = _class.instanceMethodId(
    r'echoDouble',
    r'(D)D',
  );

  static final _echoDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public abstract double echoDouble(double d)`
  double echoDouble(
    double d,
  ) {
    return _echoDouble(
            reference.pointer, _id_echoDouble as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }

  static final _id_echoString = _class.instanceMethodId(
    r'echoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoString(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echoString(reference.pointer, _id_echoString as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_echoUint8List = _class.instanceMethodId(
    r'echoUint8List',
    r'([B)[B',
  );

  static final _echoUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] echoUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray echoUint8List(
    jni$_.JByteArray bs,
  ) {
    final _$bs = bs.reference;
    return _echoUint8List(reference.pointer,
            _id_echoUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_echoList = _class.instanceMethodId(
    r'echoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> echoList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> echoList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _echoList(reference.pointer, _id_echoList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_echoEnumList = _class.instanceMethodId(
    r'echoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAnEnum> echoEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?> echoEnumList(
    jni$_.JList<NIAnEnum?> list,
  ) {
    final _$list = list.reference;
    return _echoEnumList(reference.pointer,
            _id_echoEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAnEnum?>>(
            const jni$_.JListType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_echoClassList = _class.instanceMethodId(
    r'echoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAllNullableTypes> echoClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?> echoClassList(
    jni$_.JList<NIAllNullableTypes?> list,
  ) {
    final _$list = list.reference;
    return _echoClassList(reference.pointer,
            _id_echoClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes?>>(
            const jni$_.JListType<NIAllNullableTypes?>(
                $NIAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullEnumList = _class.instanceMethodId(
    r'echoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAnEnum> echoNonNullEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> echoNonNullEnumList(
    jni$_.JList<NIAnEnum> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullEnumList(reference.pointer,
            _id_echoNonNullEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAnEnum>>(
            const jni$_.JListType<NIAnEnum>($NIAnEnum$Type()));
  }

  static final _id_echoNonNullClassList = _class.instanceMethodId(
    r'echoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAllNullableTypes> echoNonNullClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes> echoNonNullClassList(
    jni$_.JList<NIAllNullableTypes> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullClassList(reference.pointer,
            _id_echoNonNullClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes>>(
            const jni$_.JListType<NIAllNullableTypes>(
                $NIAllNullableTypes$Type()));
  }

  static final _id_echoMap = _class.instanceMethodId(
    r'echoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> echoMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _echoMap(
            reference.pointer, _id_echoMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoStringMap = _class.instanceMethodId(
    r'echoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _echoStringMap(reference.pointer,
            _id_echoStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
            const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoIntMap = _class.instanceMethodId(
    r'echoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _echoIntMap(reference.pointer, _id_echoIntMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
            const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoEnumMap = _class.instanceMethodId(
    r'echoEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<NIAnEnum, NIAnEnum> echoEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?> echoEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?> map,
  ) {
    final _$map = map.reference;
    return _echoEnumMap(reference.pointer,
            _id_echoEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>>(
            const jni$_.JMapType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_echoClassMap = _class.instanceMethodId(
    r'echoClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, NIAllNullableTypes> echoClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> echoClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map,
  ) {
    final _$map = map.reference;
    return _echoClassMap(reference.pointer,
            _id_echoClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, NIAllNullableTypes?>(
                jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()));
  }

  static final _id_echoNonNullStringMap = _class.instanceMethodId(
    r'echoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullStringMap(reference.pointer,
            _id_echoNonNullStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNonNullIntMap = _class.instanceMethodId(
    r'echoNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullIntMap(reference.pointer,
            _id_echoNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNonNullEnumMap = _class.instanceMethodId(
    r'echoNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<NIAnEnum, NIAnEnum> echoNonNullEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum> echoNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullEnumMap(reference.pointer,
            _id_echoNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum, NIAnEnum>>(
            const jni$_.JMapType<NIAnEnum, NIAnEnum>(
                $NIAnEnum$Type(), $NIAnEnum$Type()));
  }

  static final _id_echoNonNullClassMap = _class.instanceMethodId(
    r'echoNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, NIAllNullableTypes> echoNonNullClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes> echoNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullClassMap(reference.pointer,
            _id_echoNonNullClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>>(
            const jni$_.JMapType<jni$_.JLong, NIAllNullableTypes>(
                jni$_.JLongType(), $NIAllNullableTypes$Type()));
  }

  static final _id_echoEnum = _class.instanceMethodId(
    r'echoEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAnEnum echoEnum(NIAnEnum nIAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum echoEnum(
    NIAnEnum nIAnEnum,
  ) {
    final _$nIAnEnum = nIAnEnum.reference;
    return _echoEnum(reference.pointer, _id_echoEnum as jni$_.JMethodIDPtr,
            _$nIAnEnum.pointer)
        .object<NIAnEnum>(const $NIAnEnum$Type());
  }

  static final _id_echoNIAnotherEnum = _class.instanceMethodId(
    r'echoNIAnotherEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoNIAnotherEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAnotherEnum echoNIAnotherEnum(NIAnotherEnum nIAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum echoNIAnotherEnum(
    NIAnotherEnum nIAnotherEnum,
  ) {
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    return _echoNIAnotherEnum(
            reference.pointer,
            _id_echoNIAnotherEnum as jni$_.JMethodIDPtr,
            _$nIAnotherEnum.pointer)
        .object<NIAnotherEnum>(const $NIAnotherEnum$Type());
  }

  static final _id_echoNullableBool = _class.instanceMethodId(
    r'echoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _echoNullableBool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Boolean echoNullableBool(java.lang.Boolean boolean)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? echoNullableBool(
    jni$_.JBoolean? boolean,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _echoNullableBool(reference.pointer,
            _id_echoNullableBool as jni$_.JMethodIDPtr, _$boolean.pointer)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_echoNullableInt = _class.instanceMethodId(
    r'echoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoNullableInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Long echoNullableInt(java.lang.Long long)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoNullableInt(
    jni$_.JLong? long,
  ) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoNullableInt(reference.pointer,
            _id_echoNullableInt as jni$_.JMethodIDPtr, _$long.pointer)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_echoNullableDouble = _class.instanceMethodId(
    r'echoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _echoNullableDouble = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Double echoNullableDouble(java.lang.Double double)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? echoNullableDouble(
    jni$_.JDouble? double,
  ) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _echoNullableDouble(reference.pointer,
            _id_echoNullableDouble as jni$_.JMethodIDPtr, _$double.pointer)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_echoNullableString = _class.instanceMethodId(
    r'echoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNullableString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String echoNullableString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNullableString(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNullableString(reference.pointer,
            _id_echoNullableString as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_echoNullableUint8List = _class.instanceMethodId(
    r'echoNullableUint8List',
    r'([B)[B',
  );

  static final _echoNullableUint8List = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract byte[] echoNullableUint8List(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? echoNullableUint8List(
    jni$_.JByteArray? bs,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _echoNullableUint8List(reference.pointer,
            _id_echoNullableUint8List as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_echoNullableList = _class.instanceMethodId(
    r'echoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<java.lang.Object> echoNullableList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? echoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableList(reference.pointer,
            _id_echoNullableList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableEnumList = _class.instanceMethodId(
    r'echoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableEnumList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAnEnum> echoNullableEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? echoNullableEnumList(
    jni$_.JList<NIAnEnum?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumList(reference.pointer,
            _id_echoNullableEnumList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAnEnum?>?>(
            const jni$_.JListNullableType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_echoNullableClassList = _class.instanceMethodId(
    r'echoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableClassList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAllNullableTypes> echoNullableClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?>? echoNullableClassList(
    jni$_.JList<NIAllNullableTypes?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableClassList(reference.pointer,
            _id_echoNullableClassList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes?>?>(
            const jni$_.JListNullableType<NIAllNullableTypes?>(
                $NIAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullEnumList = _class.instanceMethodId(
    r'echoNullableNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAnEnum> echoNullableNonNullEnumList(java.util.List<? extends NIAnEnum> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum>? echoNullableNonNullEnumList(
    jni$_.JList<NIAnEnum>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumList(
            reference.pointer,
            _id_echoNullableNonNullEnumList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAnEnum>?>(
            const jni$_.JListNullableType<NIAnEnum>($NIAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassList = _class.instanceMethodId(
    r'echoNullableNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.List<NIAllNullableTypes> echoNullableNonNullClassList(java.util.List<NIAllNullableTypes> list)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes>? echoNullableNonNullClassList(
    jni$_.JList<NIAllNullableTypes>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassList(
            reference.pointer,
            _id_echoNullableNonNullClassList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<jni$_.JList<NIAllNullableTypes>?>(
            const jni$_.JListNullableType<NIAllNullableTypes>(
                $NIAllNullableTypes$Type()));
  }

  static final _id_echoNullableMap = _class.instanceMethodId(
    r'echoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Object, java.lang.Object> echoNullableMap(java.util.Map<java.lang.Object, ? extends java.lang.Object> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableMap(reference.pointer,
            _id_echoNullableMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_echoNullableStringMap = _class.instanceMethodId(
    r'echoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableStringMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNullableStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableStringMap(reference.pointer,
            _id_echoNullableStringMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_echoNullableIntMap = _class.instanceMethodId(
    r'echoNullableIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNullableIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableIntMap(reference.pointer,
            _id_echoNullableIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_echoNullableEnumMap = _class.instanceMethodId(
    r'echoNullableEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableEnumMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<NIAnEnum, NIAnEnum> echoNullableEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? echoNullableEnumMap(
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumMap(reference.pointer,
            _id_echoNullableEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
            const jni$_.JMapNullableType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_echoNullableClassMap = _class.instanceMethodId(
    r'echoNullableClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, NIAllNullableTypes> echoNullableClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? echoNullableClassMap(
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableClassMap(reference.pointer,
            _id_echoNullableClassMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, NIAllNullableTypes?>(
                jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()));
  }

  static final _id_echoNullableNonNullStringMap = _class.instanceMethodId(
    r'echoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.String, java.lang.String> echoNullableNonNullStringMap(java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullStringMap(
            reference.pointer,
            _id_echoNullableNonNullStringMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
            const jni$_.JMapNullableType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_echoNullableNonNullIntMap = _class.instanceMethodId(
    r'echoNullableNonNullIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullIntMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, java.lang.Long> echoNullableNonNullIntMap(java.util.Map<java.lang.Long, java.lang.Long> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
    jni$_.JMap<jni$_.JLong, jni$_.JLong>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullIntMap(reference.pointer,
            _id_echoNullableNonNullIntMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>?>(
            const jni$_.JMapNullableType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_echoNullableNonNullEnumMap = _class.instanceMethodId(
    r'echoNullableNonNullEnumMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullEnumMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<NIAnEnum, NIAnEnum> echoNullableNonNullEnumMap(java.util.Map<NIAnEnum, ? extends NIAnEnum> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum>? echoNullableNonNullEnumMap(
    jni$_.JMap<NIAnEnum, NIAnEnum>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullEnumMap(reference.pointer,
            _id_echoNullableNonNullEnumMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JMap<NIAnEnum, NIAnEnum>?>(
            const jni$_.JMapNullableType<NIAnEnum, NIAnEnum>(
                $NIAnEnum$Type(), $NIAnEnum$Type()));
  }

  static final _id_echoNullableNonNullClassMap = _class.instanceMethodId(
    r'echoNullableNonNullClassMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullClassMap =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<java.lang.Long, NIAllNullableTypes> echoNullableNonNullClassMap(java.util.Map<java.lang.Long, NIAllNullableTypes> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? echoNullableNonNullClassMap(
    jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullClassMap(
            reference.pointer,
            _id_echoNullableNonNullClassMap as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<jni$_.JMap<jni$_.JLong, NIAllNullableTypes>?>(
            const jni$_.JMapNullableType<jni$_.JLong, NIAllNullableTypes>(
                jni$_.JLongType(), $NIAllNullableTypes$Type()));
  }

  static final _id_echoNullableEnum = _class.instanceMethodId(
    r'echoNullableEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAnEnum echoNullableEnum(NIAnEnum nIAnEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? echoNullableEnum(
    NIAnEnum? nIAnEnum,
  ) {
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    return _echoNullableEnum(reference.pointer,
            _id_echoNullableEnum as jni$_.JMethodIDPtr, _$nIAnEnum.pointer)
        .object<NIAnEnum?>(const $NIAnEnum$NullableType());
  }

  static final _id_echoAnotherNullableEnum = _class.instanceMethodId(
    r'echoAnotherNullableEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract NIAnotherEnum echoAnotherNullableEnum(NIAnotherEnum nIAnotherEnum)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? echoAnotherNullableEnum(
    NIAnotherEnum? nIAnotherEnum,
  ) {
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    return _echoAnotherNullableEnum(
            reference.pointer,
            _id_echoAnotherNullableEnum as jni$_.JMethodIDPtr,
            _$nIAnotherEnum.pointer)
        .object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $NIFlutterIntegrationCoreApi> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'noop()V') {
        _$impls[$p]!.noop();
        return jni$_.nullptr;
      }
      if ($d == r'throwError()Ljava/lang/Object;') {
        final $r = _$impls[$p]!.throwError();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'throwErrorFromVoid()V') {
        _$impls[$p]!.throwErrorFromVoid();
        return jni$_.nullptr;
      }
      if ($d == r'echoNIAllTypes(LNIAllTypes;)LNIAllTypes;') {
        final $r = _$impls[$p]!.echoNIAllTypes(
          $a![0]!.as(const $NIAllTypes$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'echoNIAllNullableTypes(LNIAllNullableTypes;)LNIAllNullableTypes;') {
        final $r = _$impls[$p]!.echoNIAllNullableTypes(
          $a![0]?.as(const $NIAllNullableTypes$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'sendMultipleNullableTypes(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypes;') {
        final $r = _$impls[$p]!.sendMultipleNullableTypes(
          $a![0]?.as(const jni$_.JBooleanType(), releaseOriginal: true),
          $a![1]?.as(const jni$_.JLongType(), releaseOriginal: true),
          $a![2]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'echoNIAllNullableTypesWithoutRecursion(LNIAllNullableTypesWithoutRecursion;)LNIAllNullableTypesWithoutRecursion;') {
        final $r = _$impls[$p]!.echoNIAllNullableTypesWithoutRecursion(
          $a![0]?.as(const $NIAllNullableTypesWithoutRecursion$Type(),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'sendMultipleNullableTypesWithoutRecursion(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypesWithoutRecursion;') {
        final $r = _$impls[$p]!.sendMultipleNullableTypesWithoutRecursion(
          $a![0]?.as(const jni$_.JBooleanType(), releaseOriginal: true),
          $a![1]?.as(const jni$_.JLongType(), releaseOriginal: true),
          $a![2]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoBool(Z)Z') {
        final $r = _$impls[$p]!.echoBool(
          $a![0]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'echoInt(J)J') {
        final $r = _$impls[$p]!.echoInt(
          $a![0]!
              .as(const jni$_.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'echoDouble(D)D') {
        final $r = _$impls[$p]!.echoDouble(
          $a![0]!
              .as(const jni$_.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni$_.JDouble($r).reference.toPointer();
      }
      if ($d == r'echoString(Ljava/lang/String;)Ljava/lang/String;') {
        final $r = _$impls[$p]!.echoString(
          $a![0]!.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoUint8List([B)[B') {
        final $r = _$impls[$p]!.echoUint8List(
          $a![0]!.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoList(
          $a![0]!.as(
              const jni$_.JListType<jni$_.JObject?>(
                  jni$_.JObjectNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoEnumList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoEnumList(
          $a![0]!.as(const jni$_.JListType<NIAnEnum?>($NIAnEnum$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoClassList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoClassList(
          $a![0]!.as(
              const jni$_.JListType<NIAllNullableTypes?>(
                  $NIAllNullableTypes$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNonNullEnumList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNonNullEnumList(
          $a![0]!.as(const jni$_.JListType<NIAnEnum>($NIAnEnum$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNonNullClassList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNonNullClassList(
          $a![0]!.as(
              const jni$_.JListType<NIAllNullableTypes>(
                  $NIAllNullableTypes$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                  jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoStringMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoStringMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                  jni$_.JStringNullableType(), jni$_.JStringNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoIntMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoIntMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                  jni$_.JLongNullableType(), jni$_.JLongNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoEnumMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoEnumMap(
          $a![0]!.as(
              const jni$_.JMapType<NIAnEnum?, NIAnEnum?>(
                  $NIAnEnum$NullableType(), $NIAnEnum$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoClassMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoClassMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JLong?, NIAllNullableTypes?>(
                  jni$_.JLongNullableType(),
                  $NIAllNullableTypes$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNonNullStringMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNonNullStringMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                  jni$_.JStringType(), jni$_.JStringType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNonNullIntMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNonNullIntMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                  jni$_.JLongType(), jni$_.JLongType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNonNullEnumMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNonNullEnumMap(
          $a![0]!.as(
              const jni$_.JMapType<NIAnEnum, NIAnEnum>(
                  $NIAnEnum$Type(), $NIAnEnum$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNonNullClassMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNonNullClassMap(
          $a![0]!.as(
              const jni$_.JMapType<jni$_.JLong, NIAllNullableTypes>(
                  jni$_.JLongType(), $NIAllNullableTypes$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoEnum(LNIAnEnum;)LNIAnEnum;') {
        final $r = _$impls[$p]!.echoEnum(
          $a![0]!.as(const $NIAnEnum$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNIAnotherEnum(LNIAnotherEnum;)LNIAnotherEnum;') {
        final $r = _$impls[$p]!.echoNIAnotherEnum(
          $a![0]!.as(const $NIAnotherEnum$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableBool(Ljava/lang/Boolean;)Ljava/lang/Boolean;') {
        final $r = _$impls[$p]!.echoNullableBool(
          $a![0]?.as(const jni$_.JBooleanType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableInt(Ljava/lang/Long;)Ljava/lang/Long;') {
        final $r = _$impls[$p]!.echoNullableInt(
          $a![0]?.as(const jni$_.JLongType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableDouble(Ljava/lang/Double;)Ljava/lang/Double;') {
        final $r = _$impls[$p]!.echoNullableDouble(
          $a![0]?.as(const jni$_.JDoubleType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableString(Ljava/lang/String;)Ljava/lang/String;') {
        final $r = _$impls[$p]!.echoNullableString(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableUint8List([B)[B') {
        final $r = _$impls[$p]!.echoNullableUint8List(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNullableList(
          $a![0]?.as(
              const jni$_.JListType<jni$_.JObject?>(
                  jni$_.JObjectNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableEnumList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNullableEnumList(
          $a![0]?.as(const jni$_.JListType<NIAnEnum?>($NIAnEnum$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableClassList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNullableClassList(
          $a![0]?.as(
              const jni$_.JListType<NIAllNullableTypes?>(
                  $NIAllNullableTypes$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'echoNullableNonNullEnumList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNullableNonNullEnumList(
          $a![0]?.as(const jni$_.JListType<NIAnEnum>($NIAnEnum$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'echoNullableNonNullClassList(Ljava/util/List;)Ljava/util/List;') {
        final $r = _$impls[$p]!.echoNullableNonNullClassList(
          $a![0]?.as(
              const jni$_.JListType<NIAllNullableTypes>(
                  $NIAllNullableTypes$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                  jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableStringMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableStringMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JString?, jni$_.JString?>(
                  jni$_.JStringNullableType(), jni$_.JStringNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableIntMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableIntMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JLong?, jni$_.JLong?>(
                  jni$_.JLongNullableType(), jni$_.JLongNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableEnumMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableEnumMap(
          $a![0]?.as(
              const jni$_.JMapType<NIAnEnum?, NIAnEnum?>(
                  $NIAnEnum$NullableType(), $NIAnEnum$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableClassMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableClassMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JLong?, NIAllNullableTypes?>(
                  jni$_.JLongNullableType(),
                  $NIAllNullableTypes$NullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'echoNullableNonNullStringMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableNonNullStringMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                  jni$_.JStringType(), jni$_.JStringType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableNonNullIntMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableNonNullIntMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                  jni$_.JLongType(), jni$_.JLongType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableNonNullEnumMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableNonNullEnumMap(
          $a![0]?.as(
              const jni$_.JMapType<NIAnEnum, NIAnEnum>(
                  $NIAnEnum$Type(), $NIAnEnum$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'echoNullableNonNullClassMap(Ljava/util/Map;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.echoNullableNonNullClassMap(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JLong, NIAllNullableTypes>(
                  jni$_.JLongType(), $NIAllNullableTypes$Type()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoNullableEnum(LNIAnEnum;)LNIAnEnum;') {
        final $r = _$impls[$p]!.echoNullableEnum(
          $a![0]?.as(const $NIAnEnum$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'echoAnotherNullableEnum(LNIAnotherEnum;)LNIAnotherEnum;') {
        final $r = _$impls[$p]!.echoAnotherNullableEnum(
          $a![0]?.as(const $NIAnotherEnum$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $NIFlutterIntegrationCoreApi $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'NIFlutterIntegrationCoreApi',
      $p,
      _$invokePointer,
      [
        if ($impl.noop$async) r'noop()V',
        if ($impl.throwErrorFromVoid$async) r'throwErrorFromVoid()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory NIFlutterIntegrationCoreApi.implement(
    $NIFlutterIntegrationCoreApi $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return NIFlutterIntegrationCoreApi.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $NIFlutterIntegrationCoreApi {
  factory $NIFlutterIntegrationCoreApi({
    required void Function() noop,
    bool noop$async,
    required jni$_.JObject? Function() throwError,
    required void Function() throwErrorFromVoid,
    bool throwErrorFromVoid$async,
    required NIAllTypes Function(NIAllTypes nIAllTypes) echoNIAllTypes,
    required NIAllNullableTypes? Function(
            NIAllNullableTypes? nIAllNullableTypes)
        echoNIAllNullableTypes,
    required NIAllNullableTypes Function(
            jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string)
        sendMultipleNullableTypes,
    required NIAllNullableTypesWithoutRecursion? Function(
            NIAllNullableTypesWithoutRecursion?
                nIAllNullableTypesWithoutRecursion)
        echoNIAllNullableTypesWithoutRecursion,
    required NIAllNullableTypesWithoutRecursion Function(
            jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string)
        sendMultipleNullableTypesWithoutRecursion,
    required bool Function(bool z) echoBool,
    required int Function(int j) echoInt,
    required double Function(double d) echoDouble,
    required jni$_.JString Function(jni$_.JString string) echoString,
    required jni$_.JByteArray Function(jni$_.JByteArray bs) echoUint8List,
    required jni$_.JList<jni$_.JObject?> Function(
            jni$_.JList<jni$_.JObject?> list)
        echoList,
    required jni$_.JList<NIAnEnum?> Function(jni$_.JList<NIAnEnum?> list)
        echoEnumList,
    required jni$_.JList<NIAllNullableTypes?> Function(
            jni$_.JList<NIAllNullableTypes?> list)
        echoClassList,
    required jni$_.JList<NIAnEnum> Function(jni$_.JList<NIAnEnum> list)
        echoNonNullEnumList,
    required jni$_.JList<NIAllNullableTypes> Function(
            jni$_.JList<NIAllNullableTypes> list)
        echoNonNullClassList,
    required jni$_.JMap<jni$_.JObject?, jni$_.JObject?> Function(
            jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map)
        echoMap,
    required jni$_.JMap<jni$_.JString?, jni$_.JString?> Function(
            jni$_.JMap<jni$_.JString?, jni$_.JString?> map)
        echoStringMap,
    required jni$_.JMap<jni$_.JLong?, jni$_.JLong?> Function(
            jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map)
        echoIntMap,
    required jni$_.JMap<NIAnEnum?, NIAnEnum?> Function(
            jni$_.JMap<NIAnEnum?, NIAnEnum?> map)
        echoEnumMap,
    required jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> Function(
            jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map)
        echoClassMap,
    required jni$_.JMap<jni$_.JString, jni$_.JString> Function(
            jni$_.JMap<jni$_.JString, jni$_.JString> map)
        echoNonNullStringMap,
    required jni$_.JMap<jni$_.JLong, jni$_.JLong> Function(
            jni$_.JMap<jni$_.JLong, jni$_.JLong> map)
        echoNonNullIntMap,
    required jni$_.JMap<NIAnEnum, NIAnEnum> Function(
            jni$_.JMap<NIAnEnum, NIAnEnum> map)
        echoNonNullEnumMap,
    required jni$_.JMap<jni$_.JLong, NIAllNullableTypes> Function(
            jni$_.JMap<jni$_.JLong, NIAllNullableTypes> map)
        echoNonNullClassMap,
    required NIAnEnum Function(NIAnEnum nIAnEnum) echoEnum,
    required NIAnotherEnum Function(NIAnotherEnum nIAnotherEnum)
        echoNIAnotherEnum,
    required jni$_.JBoolean? Function(jni$_.JBoolean? boolean) echoNullableBool,
    required jni$_.JLong? Function(jni$_.JLong? long) echoNullableInt,
    required jni$_.JDouble? Function(jni$_.JDouble? double) echoNullableDouble,
    required jni$_.JString? Function(jni$_.JString? string) echoNullableString,
    required jni$_.JByteArray? Function(jni$_.JByteArray? bs)
        echoNullableUint8List,
    required jni$_.JList<jni$_.JObject?>? Function(
            jni$_.JList<jni$_.JObject?>? list)
        echoNullableList,
    required jni$_.JList<NIAnEnum?>? Function(jni$_.JList<NIAnEnum?>? list)
        echoNullableEnumList,
    required jni$_.JList<NIAllNullableTypes?>? Function(
            jni$_.JList<NIAllNullableTypes?>? list)
        echoNullableClassList,
    required jni$_.JList<NIAnEnum>? Function(jni$_.JList<NIAnEnum>? list)
        echoNullableNonNullEnumList,
    required jni$_.JList<NIAllNullableTypes>? Function(
            jni$_.JList<NIAllNullableTypes>? list)
        echoNullableNonNullClassList,
    required jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? Function(
            jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
        echoNullableMap,
    required jni$_.JMap<jni$_.JString?, jni$_.JString?>? Function(
            jni$_.JMap<jni$_.JString?, jni$_.JString?>? map)
        echoNullableStringMap,
    required jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? Function(
            jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map)
        echoNullableIntMap,
    required jni$_.JMap<NIAnEnum?, NIAnEnum?>? Function(
            jni$_.JMap<NIAnEnum?, NIAnEnum?>? map)
        echoNullableEnumMap,
    required jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? Function(
            jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map)
        echoNullableClassMap,
    required jni$_.JMap<jni$_.JString, jni$_.JString>? Function(
            jni$_.JMap<jni$_.JString, jni$_.JString>? map)
        echoNullableNonNullStringMap,
    required jni$_.JMap<jni$_.JLong, jni$_.JLong>? Function(
            jni$_.JMap<jni$_.JLong, jni$_.JLong>? map)
        echoNullableNonNullIntMap,
    required jni$_.JMap<NIAnEnum, NIAnEnum>? Function(
            jni$_.JMap<NIAnEnum, NIAnEnum>? map)
        echoNullableNonNullEnumMap,
    required jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? Function(
            jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? map)
        echoNullableNonNullClassMap,
    required NIAnEnum? Function(NIAnEnum? nIAnEnum) echoNullableEnum,
    required NIAnotherEnum? Function(NIAnotherEnum? nIAnotherEnum)
        echoAnotherNullableEnum,
  }) = _$NIFlutterIntegrationCoreApi;

  void noop();
  bool get noop$async => false;
  jni$_.JObject? throwError();
  void throwErrorFromVoid();
  bool get throwErrorFromVoid$async => false;
  NIAllTypes echoNIAllTypes(NIAllTypes nIAllTypes);
  NIAllNullableTypes? echoNIAllNullableTypes(
      NIAllNullableTypes? nIAllNullableTypes);
  NIAllNullableTypes sendMultipleNullableTypes(
      jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string);
  NIAllNullableTypesWithoutRecursion? echoNIAllNullableTypesWithoutRecursion(
      NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion);
  NIAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
      jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string);
  bool echoBool(bool z);
  int echoInt(int j);
  double echoDouble(double d);
  jni$_.JString echoString(jni$_.JString string);
  jni$_.JByteArray echoUint8List(jni$_.JByteArray bs);
  jni$_.JList<jni$_.JObject?> echoList(jni$_.JList<jni$_.JObject?> list);
  jni$_.JList<NIAnEnum?> echoEnumList(jni$_.JList<NIAnEnum?> list);
  jni$_.JList<NIAllNullableTypes?> echoClassList(
      jni$_.JList<NIAllNullableTypes?> list);
  jni$_.JList<NIAnEnum> echoNonNullEnumList(jni$_.JList<NIAnEnum> list);
  jni$_.JList<NIAllNullableTypes> echoNonNullClassList(
      jni$_.JList<NIAllNullableTypes> list);
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
      jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map);
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
      jni$_.JMap<jni$_.JString?, jni$_.JString?> map);
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
      jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map);
  jni$_.JMap<NIAnEnum?, NIAnEnum?> echoEnumMap(
      jni$_.JMap<NIAnEnum?, NIAnEnum?> map);
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> echoClassMap(
      jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map);
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
      jni$_.JMap<jni$_.JString, jni$_.JString> map);
  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
      jni$_.JMap<jni$_.JLong, jni$_.JLong> map);
  jni$_.JMap<NIAnEnum, NIAnEnum> echoNonNullEnumMap(
      jni$_.JMap<NIAnEnum, NIAnEnum> map);
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes> echoNonNullClassMap(
      jni$_.JMap<jni$_.JLong, NIAllNullableTypes> map);
  NIAnEnum echoEnum(NIAnEnum nIAnEnum);
  NIAnotherEnum echoNIAnotherEnum(NIAnotherEnum nIAnotherEnum);
  jni$_.JBoolean? echoNullableBool(jni$_.JBoolean? boolean);
  jni$_.JLong? echoNullableInt(jni$_.JLong? long);
  jni$_.JDouble? echoNullableDouble(jni$_.JDouble? double);
  jni$_.JString? echoNullableString(jni$_.JString? string);
  jni$_.JByteArray? echoNullableUint8List(jni$_.JByteArray? bs);
  jni$_.JList<jni$_.JObject?>? echoNullableList(
      jni$_.JList<jni$_.JObject?>? list);
  jni$_.JList<NIAnEnum?>? echoNullableEnumList(jni$_.JList<NIAnEnum?>? list);
  jni$_.JList<NIAllNullableTypes?>? echoNullableClassList(
      jni$_.JList<NIAllNullableTypes?>? list);
  jni$_.JList<NIAnEnum>? echoNullableNonNullEnumList(
      jni$_.JList<NIAnEnum>? list);
  jni$_.JList<NIAllNullableTypes>? echoNullableNonNullClassList(
      jni$_.JList<NIAllNullableTypes>? list);
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
      jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map);
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
      jni$_.JMap<jni$_.JString?, jni$_.JString?>? map);
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
      jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map);
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? echoNullableEnumMap(
      jni$_.JMap<NIAnEnum?, NIAnEnum?>? map);
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? echoNullableClassMap(
      jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map);
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
      jni$_.JMap<jni$_.JString, jni$_.JString>? map);
  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
      jni$_.JMap<jni$_.JLong, jni$_.JLong>? map);
  jni$_.JMap<NIAnEnum, NIAnEnum>? echoNullableNonNullEnumMap(
      jni$_.JMap<NIAnEnum, NIAnEnum>? map);
  jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? echoNullableNonNullClassMap(
      jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? map);
  NIAnEnum? echoNullableEnum(NIAnEnum? nIAnEnum);
  NIAnotherEnum? echoAnotherNullableEnum(NIAnotherEnum? nIAnotherEnum);
}

final class _$NIFlutterIntegrationCoreApi with $NIFlutterIntegrationCoreApi {
  _$NIFlutterIntegrationCoreApi({
    required void Function() noop,
    this.noop$async = false,
    required jni$_.JObject? Function() throwError,
    required void Function() throwErrorFromVoid,
    this.throwErrorFromVoid$async = false,
    required NIAllTypes Function(NIAllTypes nIAllTypes) echoNIAllTypes,
    required NIAllNullableTypes? Function(
            NIAllNullableTypes? nIAllNullableTypes)
        echoNIAllNullableTypes,
    required NIAllNullableTypes Function(
            jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string)
        sendMultipleNullableTypes,
    required NIAllNullableTypesWithoutRecursion? Function(
            NIAllNullableTypesWithoutRecursion?
                nIAllNullableTypesWithoutRecursion)
        echoNIAllNullableTypesWithoutRecursion,
    required NIAllNullableTypesWithoutRecursion Function(
            jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string)
        sendMultipleNullableTypesWithoutRecursion,
    required bool Function(bool z) echoBool,
    required int Function(int j) echoInt,
    required double Function(double d) echoDouble,
    required jni$_.JString Function(jni$_.JString string) echoString,
    required jni$_.JByteArray Function(jni$_.JByteArray bs) echoUint8List,
    required jni$_.JList<jni$_.JObject?> Function(
            jni$_.JList<jni$_.JObject?> list)
        echoList,
    required jni$_.JList<NIAnEnum?> Function(jni$_.JList<NIAnEnum?> list)
        echoEnumList,
    required jni$_.JList<NIAllNullableTypes?> Function(
            jni$_.JList<NIAllNullableTypes?> list)
        echoClassList,
    required jni$_.JList<NIAnEnum> Function(jni$_.JList<NIAnEnum> list)
        echoNonNullEnumList,
    required jni$_.JList<NIAllNullableTypes> Function(
            jni$_.JList<NIAllNullableTypes> list)
        echoNonNullClassList,
    required jni$_.JMap<jni$_.JObject?, jni$_.JObject?> Function(
            jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map)
        echoMap,
    required jni$_.JMap<jni$_.JString?, jni$_.JString?> Function(
            jni$_.JMap<jni$_.JString?, jni$_.JString?> map)
        echoStringMap,
    required jni$_.JMap<jni$_.JLong?, jni$_.JLong?> Function(
            jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map)
        echoIntMap,
    required jni$_.JMap<NIAnEnum?, NIAnEnum?> Function(
            jni$_.JMap<NIAnEnum?, NIAnEnum?> map)
        echoEnumMap,
    required jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> Function(
            jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map)
        echoClassMap,
    required jni$_.JMap<jni$_.JString, jni$_.JString> Function(
            jni$_.JMap<jni$_.JString, jni$_.JString> map)
        echoNonNullStringMap,
    required jni$_.JMap<jni$_.JLong, jni$_.JLong> Function(
            jni$_.JMap<jni$_.JLong, jni$_.JLong> map)
        echoNonNullIntMap,
    required jni$_.JMap<NIAnEnum, NIAnEnum> Function(
            jni$_.JMap<NIAnEnum, NIAnEnum> map)
        echoNonNullEnumMap,
    required jni$_.JMap<jni$_.JLong, NIAllNullableTypes> Function(
            jni$_.JMap<jni$_.JLong, NIAllNullableTypes> map)
        echoNonNullClassMap,
    required NIAnEnum Function(NIAnEnum nIAnEnum) echoEnum,
    required NIAnotherEnum Function(NIAnotherEnum nIAnotherEnum)
        echoNIAnotherEnum,
    required jni$_.JBoolean? Function(jni$_.JBoolean? boolean) echoNullableBool,
    required jni$_.JLong? Function(jni$_.JLong? long) echoNullableInt,
    required jni$_.JDouble? Function(jni$_.JDouble? double) echoNullableDouble,
    required jni$_.JString? Function(jni$_.JString? string) echoNullableString,
    required jni$_.JByteArray? Function(jni$_.JByteArray? bs)
        echoNullableUint8List,
    required jni$_.JList<jni$_.JObject?>? Function(
            jni$_.JList<jni$_.JObject?>? list)
        echoNullableList,
    required jni$_.JList<NIAnEnum?>? Function(jni$_.JList<NIAnEnum?>? list)
        echoNullableEnumList,
    required jni$_.JList<NIAllNullableTypes?>? Function(
            jni$_.JList<NIAllNullableTypes?>? list)
        echoNullableClassList,
    required jni$_.JList<NIAnEnum>? Function(jni$_.JList<NIAnEnum>? list)
        echoNullableNonNullEnumList,
    required jni$_.JList<NIAllNullableTypes>? Function(
            jni$_.JList<NIAllNullableTypes>? list)
        echoNullableNonNullClassList,
    required jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? Function(
            jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
        echoNullableMap,
    required jni$_.JMap<jni$_.JString?, jni$_.JString?>? Function(
            jni$_.JMap<jni$_.JString?, jni$_.JString?>? map)
        echoNullableStringMap,
    required jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? Function(
            jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map)
        echoNullableIntMap,
    required jni$_.JMap<NIAnEnum?, NIAnEnum?>? Function(
            jni$_.JMap<NIAnEnum?, NIAnEnum?>? map)
        echoNullableEnumMap,
    required jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? Function(
            jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map)
        echoNullableClassMap,
    required jni$_.JMap<jni$_.JString, jni$_.JString>? Function(
            jni$_.JMap<jni$_.JString, jni$_.JString>? map)
        echoNullableNonNullStringMap,
    required jni$_.JMap<jni$_.JLong, jni$_.JLong>? Function(
            jni$_.JMap<jni$_.JLong, jni$_.JLong>? map)
        echoNullableNonNullIntMap,
    required jni$_.JMap<NIAnEnum, NIAnEnum>? Function(
            jni$_.JMap<NIAnEnum, NIAnEnum>? map)
        echoNullableNonNullEnumMap,
    required jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? Function(
            jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? map)
        echoNullableNonNullClassMap,
    required NIAnEnum? Function(NIAnEnum? nIAnEnum) echoNullableEnum,
    required NIAnotherEnum? Function(NIAnotherEnum? nIAnotherEnum)
        echoAnotherNullableEnum,
  })  : _noop = noop,
        _throwError = throwError,
        _throwErrorFromVoid = throwErrorFromVoid,
        _echoNIAllTypes = echoNIAllTypes,
        _echoNIAllNullableTypes = echoNIAllNullableTypes,
        _sendMultipleNullableTypes = sendMultipleNullableTypes,
        _echoNIAllNullableTypesWithoutRecursion =
            echoNIAllNullableTypesWithoutRecursion,
        _sendMultipleNullableTypesWithoutRecursion =
            sendMultipleNullableTypesWithoutRecursion,
        _echoBool = echoBool,
        _echoInt = echoInt,
        _echoDouble = echoDouble,
        _echoString = echoString,
        _echoUint8List = echoUint8List,
        _echoList = echoList,
        _echoEnumList = echoEnumList,
        _echoClassList = echoClassList,
        _echoNonNullEnumList = echoNonNullEnumList,
        _echoNonNullClassList = echoNonNullClassList,
        _echoMap = echoMap,
        _echoStringMap = echoStringMap,
        _echoIntMap = echoIntMap,
        _echoEnumMap = echoEnumMap,
        _echoClassMap = echoClassMap,
        _echoNonNullStringMap = echoNonNullStringMap,
        _echoNonNullIntMap = echoNonNullIntMap,
        _echoNonNullEnumMap = echoNonNullEnumMap,
        _echoNonNullClassMap = echoNonNullClassMap,
        _echoEnum = echoEnum,
        _echoNIAnotherEnum = echoNIAnotherEnum,
        _echoNullableBool = echoNullableBool,
        _echoNullableInt = echoNullableInt,
        _echoNullableDouble = echoNullableDouble,
        _echoNullableString = echoNullableString,
        _echoNullableUint8List = echoNullableUint8List,
        _echoNullableList = echoNullableList,
        _echoNullableEnumList = echoNullableEnumList,
        _echoNullableClassList = echoNullableClassList,
        _echoNullableNonNullEnumList = echoNullableNonNullEnumList,
        _echoNullableNonNullClassList = echoNullableNonNullClassList,
        _echoNullableMap = echoNullableMap,
        _echoNullableStringMap = echoNullableStringMap,
        _echoNullableIntMap = echoNullableIntMap,
        _echoNullableEnumMap = echoNullableEnumMap,
        _echoNullableClassMap = echoNullableClassMap,
        _echoNullableNonNullStringMap = echoNullableNonNullStringMap,
        _echoNullableNonNullIntMap = echoNullableNonNullIntMap,
        _echoNullableNonNullEnumMap = echoNullableNonNullEnumMap,
        _echoNullableNonNullClassMap = echoNullableNonNullClassMap,
        _echoNullableEnum = echoNullableEnum,
        _echoAnotherNullableEnum = echoAnotherNullableEnum;

  final void Function() _noop;
  final bool noop$async;
  final jni$_.JObject? Function() _throwError;
  final void Function() _throwErrorFromVoid;
  final bool throwErrorFromVoid$async;
  final NIAllTypes Function(NIAllTypes nIAllTypes) _echoNIAllTypes;
  final NIAllNullableTypes? Function(NIAllNullableTypes? nIAllNullableTypes)
      _echoNIAllNullableTypes;
  final NIAllNullableTypes Function(
          jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string)
      _sendMultipleNullableTypes;
  final NIAllNullableTypesWithoutRecursion? Function(
          NIAllNullableTypesWithoutRecursion?
              nIAllNullableTypesWithoutRecursion)
      _echoNIAllNullableTypesWithoutRecursion;
  final NIAllNullableTypesWithoutRecursion Function(
          jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string)
      _sendMultipleNullableTypesWithoutRecursion;
  final bool Function(bool z) _echoBool;
  final int Function(int j) _echoInt;
  final double Function(double d) _echoDouble;
  final jni$_.JString Function(jni$_.JString string) _echoString;
  final jni$_.JByteArray Function(jni$_.JByteArray bs) _echoUint8List;
  final jni$_.JList<jni$_.JObject?> Function(jni$_.JList<jni$_.JObject?> list)
      _echoList;
  final jni$_.JList<NIAnEnum?> Function(jni$_.JList<NIAnEnum?> list)
      _echoEnumList;
  final jni$_.JList<NIAllNullableTypes?> Function(
      jni$_.JList<NIAllNullableTypes?> list) _echoClassList;
  final jni$_.JList<NIAnEnum> Function(jni$_.JList<NIAnEnum> list)
      _echoNonNullEnumList;
  final jni$_.JList<NIAllNullableTypes> Function(
      jni$_.JList<NIAllNullableTypes> list) _echoNonNullClassList;
  final jni$_.JMap<jni$_.JObject?, jni$_.JObject?> Function(
      jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map) _echoMap;
  final jni$_.JMap<jni$_.JString?, jni$_.JString?> Function(
      jni$_.JMap<jni$_.JString?, jni$_.JString?> map) _echoStringMap;
  final jni$_.JMap<jni$_.JLong?, jni$_.JLong?> Function(
      jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map) _echoIntMap;
  final jni$_.JMap<NIAnEnum?, NIAnEnum?> Function(
      jni$_.JMap<NIAnEnum?, NIAnEnum?> map) _echoEnumMap;
  final jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> Function(
      jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map) _echoClassMap;
  final jni$_.JMap<jni$_.JString, jni$_.JString> Function(
      jni$_.JMap<jni$_.JString, jni$_.JString> map) _echoNonNullStringMap;
  final jni$_.JMap<jni$_.JLong, jni$_.JLong> Function(
      jni$_.JMap<jni$_.JLong, jni$_.JLong> map) _echoNonNullIntMap;
  final jni$_.JMap<NIAnEnum, NIAnEnum> Function(
      jni$_.JMap<NIAnEnum, NIAnEnum> map) _echoNonNullEnumMap;
  final jni$_.JMap<jni$_.JLong, NIAllNullableTypes> Function(
      jni$_.JMap<jni$_.JLong, NIAllNullableTypes> map) _echoNonNullClassMap;
  final NIAnEnum Function(NIAnEnum nIAnEnum) _echoEnum;
  final NIAnotherEnum Function(NIAnotherEnum nIAnotherEnum) _echoNIAnotherEnum;
  final jni$_.JBoolean? Function(jni$_.JBoolean? boolean) _echoNullableBool;
  final jni$_.JLong? Function(jni$_.JLong? long) _echoNullableInt;
  final jni$_.JDouble? Function(jni$_.JDouble? double) _echoNullableDouble;
  final jni$_.JString? Function(jni$_.JString? string) _echoNullableString;
  final jni$_.JByteArray? Function(jni$_.JByteArray? bs) _echoNullableUint8List;
  final jni$_.JList<jni$_.JObject?>? Function(jni$_.JList<jni$_.JObject?>? list)
      _echoNullableList;
  final jni$_.JList<NIAnEnum?>? Function(jni$_.JList<NIAnEnum?>? list)
      _echoNullableEnumList;
  final jni$_.JList<NIAllNullableTypes?>? Function(
      jni$_.JList<NIAllNullableTypes?>? list) _echoNullableClassList;
  final jni$_.JList<NIAnEnum>? Function(jni$_.JList<NIAnEnum>? list)
      _echoNullableNonNullEnumList;
  final jni$_.JList<NIAllNullableTypes>? Function(
      jni$_.JList<NIAllNullableTypes>? list) _echoNullableNonNullClassList;
  final jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? Function(
      jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map) _echoNullableMap;
  final jni$_.JMap<jni$_.JString?, jni$_.JString?>? Function(
      jni$_.JMap<jni$_.JString?, jni$_.JString?>? map) _echoNullableStringMap;
  final jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? Function(
      jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map) _echoNullableIntMap;
  final jni$_.JMap<NIAnEnum?, NIAnEnum?>? Function(
      jni$_.JMap<NIAnEnum?, NIAnEnum?>? map) _echoNullableEnumMap;
  final jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? Function(
      jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map) _echoNullableClassMap;
  final jni$_.JMap<jni$_.JString, jni$_.JString>? Function(
          jni$_.JMap<jni$_.JString, jni$_.JString>? map)
      _echoNullableNonNullStringMap;
  final jni$_.JMap<jni$_.JLong, jni$_.JLong>? Function(
      jni$_.JMap<jni$_.JLong, jni$_.JLong>? map) _echoNullableNonNullIntMap;
  final jni$_.JMap<NIAnEnum, NIAnEnum>? Function(
      jni$_.JMap<NIAnEnum, NIAnEnum>? map) _echoNullableNonNullEnumMap;
  final jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? Function(
          jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? map)
      _echoNullableNonNullClassMap;
  final NIAnEnum? Function(NIAnEnum? nIAnEnum) _echoNullableEnum;
  final NIAnotherEnum? Function(NIAnotherEnum? nIAnotherEnum)
      _echoAnotherNullableEnum;

  void noop() {
    return _noop();
  }

  jni$_.JObject? throwError() {
    return _throwError();
  }

  void throwErrorFromVoid() {
    return _throwErrorFromVoid();
  }

  NIAllTypes echoNIAllTypes(NIAllTypes nIAllTypes) {
    return _echoNIAllTypes(nIAllTypes);
  }

  NIAllNullableTypes? echoNIAllNullableTypes(
      NIAllNullableTypes? nIAllNullableTypes) {
    return _echoNIAllNullableTypes(nIAllNullableTypes);
  }

  NIAllNullableTypes sendMultipleNullableTypes(
      jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string) {
    return _sendMultipleNullableTypes(boolean, long, string);
  }

  NIAllNullableTypesWithoutRecursion? echoNIAllNullableTypesWithoutRecursion(
      NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion) {
    return _echoNIAllNullableTypesWithoutRecursion(
        nIAllNullableTypesWithoutRecursion);
  }

  NIAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
      jni$_.JBoolean? boolean, jni$_.JLong? long, jni$_.JString? string) {
    return _sendMultipleNullableTypesWithoutRecursion(boolean, long, string);
  }

  bool echoBool(bool z) {
    return _echoBool(z);
  }

  int echoInt(int j) {
    return _echoInt(j);
  }

  double echoDouble(double d) {
    return _echoDouble(d);
  }

  jni$_.JString echoString(jni$_.JString string) {
    return _echoString(string);
  }

  jni$_.JByteArray echoUint8List(jni$_.JByteArray bs) {
    return _echoUint8List(bs);
  }

  jni$_.JList<jni$_.JObject?> echoList(jni$_.JList<jni$_.JObject?> list) {
    return _echoList(list);
  }

  jni$_.JList<NIAnEnum?> echoEnumList(jni$_.JList<NIAnEnum?> list) {
    return _echoEnumList(list);
  }

  jni$_.JList<NIAllNullableTypes?> echoClassList(
      jni$_.JList<NIAllNullableTypes?> list) {
    return _echoClassList(list);
  }

  jni$_.JList<NIAnEnum> echoNonNullEnumList(jni$_.JList<NIAnEnum> list) {
    return _echoNonNullEnumList(list);
  }

  jni$_.JList<NIAllNullableTypes> echoNonNullClassList(
      jni$_.JList<NIAllNullableTypes> list) {
    return _echoNonNullClassList(list);
  }

  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
      jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map) {
    return _echoMap(map);
  }

  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
      jni$_.JMap<jni$_.JString?, jni$_.JString?> map) {
    return _echoStringMap(map);
  }

  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
      jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map) {
    return _echoIntMap(map);
  }

  jni$_.JMap<NIAnEnum?, NIAnEnum?> echoEnumMap(
      jni$_.JMap<NIAnEnum?, NIAnEnum?> map) {
    return _echoEnumMap(map);
  }

  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> echoClassMap(
      jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?> map) {
    return _echoClassMap(map);
  }

  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
      jni$_.JMap<jni$_.JString, jni$_.JString> map) {
    return _echoNonNullStringMap(map);
  }

  jni$_.JMap<jni$_.JLong, jni$_.JLong> echoNonNullIntMap(
      jni$_.JMap<jni$_.JLong, jni$_.JLong> map) {
    return _echoNonNullIntMap(map);
  }

  jni$_.JMap<NIAnEnum, NIAnEnum> echoNonNullEnumMap(
      jni$_.JMap<NIAnEnum, NIAnEnum> map) {
    return _echoNonNullEnumMap(map);
  }

  jni$_.JMap<jni$_.JLong, NIAllNullableTypes> echoNonNullClassMap(
      jni$_.JMap<jni$_.JLong, NIAllNullableTypes> map) {
    return _echoNonNullClassMap(map);
  }

  NIAnEnum echoEnum(NIAnEnum nIAnEnum) {
    return _echoEnum(nIAnEnum);
  }

  NIAnotherEnum echoNIAnotherEnum(NIAnotherEnum nIAnotherEnum) {
    return _echoNIAnotherEnum(nIAnotherEnum);
  }

  jni$_.JBoolean? echoNullableBool(jni$_.JBoolean? boolean) {
    return _echoNullableBool(boolean);
  }

  jni$_.JLong? echoNullableInt(jni$_.JLong? long) {
    return _echoNullableInt(long);
  }

  jni$_.JDouble? echoNullableDouble(jni$_.JDouble? double) {
    return _echoNullableDouble(double);
  }

  jni$_.JString? echoNullableString(jni$_.JString? string) {
    return _echoNullableString(string);
  }

  jni$_.JByteArray? echoNullableUint8List(jni$_.JByteArray? bs) {
    return _echoNullableUint8List(bs);
  }

  jni$_.JList<jni$_.JObject?>? echoNullableList(
      jni$_.JList<jni$_.JObject?>? list) {
    return _echoNullableList(list);
  }

  jni$_.JList<NIAnEnum?>? echoNullableEnumList(jni$_.JList<NIAnEnum?>? list) {
    return _echoNullableEnumList(list);
  }

  jni$_.JList<NIAllNullableTypes?>? echoNullableClassList(
      jni$_.JList<NIAllNullableTypes?>? list) {
    return _echoNullableClassList(list);
  }

  jni$_.JList<NIAnEnum>? echoNullableNonNullEnumList(
      jni$_.JList<NIAnEnum>? list) {
    return _echoNullableNonNullEnumList(list);
  }

  jni$_.JList<NIAllNullableTypes>? echoNullableNonNullClassList(
      jni$_.JList<NIAllNullableTypes>? list) {
    return _echoNullableNonNullClassList(list);
  }

  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
      jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map) {
    return _echoNullableMap(map);
  }

  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
      jni$_.JMap<jni$_.JString?, jni$_.JString?>? map) {
    return _echoNullableStringMap(map);
  }

  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? echoNullableIntMap(
      jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map) {
    return _echoNullableIntMap(map);
  }

  jni$_.JMap<NIAnEnum?, NIAnEnum?>? echoNullableEnumMap(
      jni$_.JMap<NIAnEnum?, NIAnEnum?>? map) {
    return _echoNullableEnumMap(map);
  }

  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? echoNullableClassMap(
      jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map) {
    return _echoNullableClassMap(map);
  }

  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
      jni$_.JMap<jni$_.JString, jni$_.JString>? map) {
    return _echoNullableNonNullStringMap(map);
  }

  jni$_.JMap<jni$_.JLong, jni$_.JLong>? echoNullableNonNullIntMap(
      jni$_.JMap<jni$_.JLong, jni$_.JLong>? map) {
    return _echoNullableNonNullIntMap(map);
  }

  jni$_.JMap<NIAnEnum, NIAnEnum>? echoNullableNonNullEnumMap(
      jni$_.JMap<NIAnEnum, NIAnEnum>? map) {
    return _echoNullableNonNullEnumMap(map);
  }

  jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? echoNullableNonNullClassMap(
      jni$_.JMap<jni$_.JLong, NIAllNullableTypes>? map) {
    return _echoNullableNonNullClassMap(map);
  }

  NIAnEnum? echoNullableEnum(NIAnEnum? nIAnEnum) {
    return _echoNullableEnum(nIAnEnum);
  }

  NIAnotherEnum? echoAnotherNullableEnum(NIAnotherEnum? nIAnotherEnum) {
    return _echoAnotherNullableEnum(nIAnotherEnum);
  }
}

final class $NIFlutterIntegrationCoreApi$NullableType
    extends jni$_.JObjType<NIFlutterIntegrationCoreApi?> {
  @jni$_.internal
  const $NIFlutterIntegrationCoreApi$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIFlutterIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  NIFlutterIntegrationCoreApi? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIFlutterIntegrationCoreApi.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIFlutterIntegrationCoreApi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIFlutterIntegrationCoreApi$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIFlutterIntegrationCoreApi$NullableType) &&
        other is $NIFlutterIntegrationCoreApi$NullableType;
  }
}

final class $NIFlutterIntegrationCoreApi$Type
    extends jni$_.JObjType<NIFlutterIntegrationCoreApi> {
  @jni$_.internal
  const $NIFlutterIntegrationCoreApi$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIFlutterIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  NIFlutterIntegrationCoreApi fromReference(jni$_.JReference reference) =>
      NIFlutterIntegrationCoreApi.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIFlutterIntegrationCoreApi?> get nullableType =>
      const $NIFlutterIntegrationCoreApi$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIFlutterIntegrationCoreApi$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIFlutterIntegrationCoreApi$Type) &&
        other is $NIFlutterIntegrationCoreApi$Type;
  }
}

/// from: `NIFlutterIntegrationCoreApiRegistrar`
class NIFlutterIntegrationCoreApiRegistrar extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIFlutterIntegrationCoreApiRegistrar> $type;

  @jni$_.internal
  NIFlutterIntegrationCoreApiRegistrar.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'NIFlutterIntegrationCoreApiRegistrar');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $NIFlutterIntegrationCoreApiRegistrar$NullableType();
  static const type = $NIFlutterIntegrationCoreApiRegistrar$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIFlutterIntegrationCoreApiRegistrar() {
    return NIFlutterIntegrationCoreApiRegistrar.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_registerInstance = _class.instanceMethodId(
    r'registerInstance',
    r'(LNIFlutterIntegrationCoreApi;Ljava/lang/String;)V',
  );

  static final _registerInstance = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final void registerInstance(NIFlutterIntegrationCoreApi nIFlutterIntegrationCoreApi, java.lang.String string)`
  void registerInstance(
    NIFlutterIntegrationCoreApi nIFlutterIntegrationCoreApi,
    jni$_.JString string,
  ) {
    final _$nIFlutterIntegrationCoreApi = nIFlutterIntegrationCoreApi.reference;
    final _$string = string.reference;
    _registerInstance(
            reference.pointer,
            _id_registerInstance as jni$_.JMethodIDPtr,
            _$nIFlutterIntegrationCoreApi.pointer,
            _$string.pointer)
        .check();
  }

  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Ljava/lang/String;)LNIFlutterIntegrationCoreApi;',
  );

  static final _getInstance = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIFlutterIntegrationCoreApi getInstance(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  NIFlutterIntegrationCoreApi? getInstance(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _getInstance(reference.pointer,
            _id_getInstance as jni$_.JMethodIDPtr, _$string.pointer)
        .object<NIFlutterIntegrationCoreApi?>(
            const $NIFlutterIntegrationCoreApi$NullableType());
  }
}

final class $NIFlutterIntegrationCoreApiRegistrar$NullableType
    extends jni$_.JObjType<NIFlutterIntegrationCoreApiRegistrar?> {
  @jni$_.internal
  const $NIFlutterIntegrationCoreApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIFlutterIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  NIFlutterIntegrationCoreApiRegistrar? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIFlutterIntegrationCoreApiRegistrar.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIFlutterIntegrationCoreApiRegistrar?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($NIFlutterIntegrationCoreApiRegistrar$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIFlutterIntegrationCoreApiRegistrar$NullableType) &&
        other is $NIFlutterIntegrationCoreApiRegistrar$NullableType;
  }
}

final class $NIFlutterIntegrationCoreApiRegistrar$Type
    extends jni$_.JObjType<NIFlutterIntegrationCoreApiRegistrar> {
  @jni$_.internal
  const $NIFlutterIntegrationCoreApiRegistrar$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIFlutterIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  NIFlutterIntegrationCoreApiRegistrar fromReference(
          jni$_.JReference reference) =>
      NIFlutterIntegrationCoreApiRegistrar.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIFlutterIntegrationCoreApiRegistrar?> get nullableType =>
      const $NIFlutterIntegrationCoreApiRegistrar$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIFlutterIntegrationCoreApiRegistrar$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIFlutterIntegrationCoreApiRegistrar$Type) &&
        other is $NIFlutterIntegrationCoreApiRegistrar$Type;
  }
}

/// from: `NIUnusedClass$Companion`
class NIUnusedClass$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIUnusedClass$Companion> $type;

  @jni$_.internal
  NIUnusedClass$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIUnusedClass$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIUnusedClass$Companion$NullableType();
  static const type = $NIUnusedClass$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LNIUnusedClass;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIUnusedClass fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  NIUnusedClass fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<NIUnusedClass>(const $NIUnusedClass$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIUnusedClass$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIUnusedClass$Companion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $NIUnusedClass$Companion$NullableType
    extends jni$_.JObjType<NIUnusedClass$Companion?> {
  @jni$_.internal
  const $NIUnusedClass$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIUnusedClass$Companion;';

  @jni$_.internal
  @core$_.override
  NIUnusedClass$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIUnusedClass$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIUnusedClass$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIUnusedClass$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIUnusedClass$Companion$NullableType) &&
        other is $NIUnusedClass$Companion$NullableType;
  }
}

final class $NIUnusedClass$Companion$Type
    extends jni$_.JObjType<NIUnusedClass$Companion> {
  @jni$_.internal
  const $NIUnusedClass$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIUnusedClass$Companion;';

  @jni$_.internal
  @core$_.override
  NIUnusedClass$Companion fromReference(jni$_.JReference reference) =>
      NIUnusedClass$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIUnusedClass$Companion?> get nullableType =>
      const $NIUnusedClass$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIUnusedClass$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIUnusedClass$Companion$Type) &&
        other is $NIUnusedClass$Companion$Type;
  }
}

/// from: `NIUnusedClass`
class NIUnusedClass extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIUnusedClass> $type;

  @jni$_.internal
  NIUnusedClass.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIUnusedClass');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIUnusedClass$NullableType();
  static const type = $NIUnusedClass$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIUnusedClass$Companion;',
  );

  /// from: `static public final NIUnusedClass$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIUnusedClass$Companion get Companion =>
      _id_Companion.get(_class, const $NIUnusedClass$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIUnusedClass(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return NIUnusedClass.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$object.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Object;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(java.lang.Object object, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIUnusedClass.new$1(
    jni$_.JObject? object,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIUnusedClass.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$object.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getAField = _class.instanceMethodId(
    r'getAField',
    r'()Ljava/lang/Object;',
  );

  static final _getAField = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object getAField()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getAField() {
    return _getAField(reference.pointer, _id_getAField as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/Object;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object component1()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/Object;)LNIUnusedClass;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIUnusedClass copy(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  NIUnusedClass copy(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _copy(
            reference.pointer, _id_copy as jni$_.JMethodIDPtr, _$object.pointer)
        .object<NIUnusedClass>(const $NIUnusedClass$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIUnusedClass.new$2() {
    return NIUnusedClass.fromReference(
        _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $NIUnusedClass$NullableType extends jni$_.JObjType<NIUnusedClass?> {
  @jni$_.internal
  const $NIUnusedClass$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIUnusedClass;';

  @jni$_.internal
  @core$_.override
  NIUnusedClass? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : NIUnusedClass.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIUnusedClass?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIUnusedClass$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIUnusedClass$NullableType) &&
        other is $NIUnusedClass$NullableType;
  }
}

final class $NIUnusedClass$Type extends jni$_.JObjType<NIUnusedClass> {
  @jni$_.internal
  const $NIUnusedClass$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIUnusedClass;';

  @jni$_.internal
  @core$_.override
  NIUnusedClass fromReference(jni$_.JReference reference) =>
      NIUnusedClass.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIUnusedClass?> get nullableType =>
      const $NIUnusedClass$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIUnusedClass$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIUnusedClass$Type) &&
        other is $NIUnusedClass$Type;
  }
}

/// from: `NIAllTypes$Companion`
class NIAllTypes$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIAllTypes$Companion> $type;

  @jni$_.internal
  NIAllTypes$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllTypes$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIAllTypes$Companion$NullableType();
  static const type = $NIAllTypes$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LNIAllTypes;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIAllTypes fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<NIAllTypes>(const $NIAllTypes$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllTypes$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllTypes$Companion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $NIAllTypes$Companion$NullableType
    extends jni$_.JObjType<NIAllTypes$Companion?> {
  @jni$_.internal
  const $NIAllTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllTypes$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllTypes$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIAllTypes$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllTypes$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllTypes$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllTypes$Companion$NullableType) &&
        other is $NIAllTypes$Companion$NullableType;
  }
}

final class $NIAllTypes$Companion$Type
    extends jni$_.JObjType<NIAllTypes$Companion> {
  @jni$_.internal
  const $NIAllTypes$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllTypes$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllTypes$Companion fromReference(jni$_.JReference reference) =>
      NIAllTypes$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllTypes$Companion?> get nullableType =>
      const $NIAllTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllTypes$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllTypes$Companion$Type) &&
        other is $NIAllTypes$Companion$Type;
  }
}

/// from: `NIAllTypes`
class NIAllTypes extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIAllTypes> $type;

  @jni$_.internal
  NIAllTypes.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllTypes');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIAllTypes$NullableType();
  static const type = $NIAllTypes$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAllTypes$Companion;',
  );

  /// from: `static public final NIAllTypes$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAllTypes$Companion get Companion =>
      _id_Companion.get(_class, const $NIAllTypes$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(ZJJD[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(boolean z, long j, long j1, double d, byte[] bs, int[] is, long[] js, double[] ds, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends NIAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<NIAnEnum, ? extends NIAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllTypes(
    bool z,
    int j,
    int j1,
    double d,
    jni$_.JByteArray bs,
    jni$_.JIntArray is$,
    jni$_.JLongArray js,
    jni$_.JDoubleArray ds,
    NIAnEnum nIAnEnum,
    NIAnotherEnum nIAnotherEnum,
    jni$_.JString string,
    jni$_.JObject object,
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JList<jni$_.JString> list1,
    jni$_.JList<jni$_.JLong> list2,
    jni$_.JList<jni$_.JDouble> list3,
    jni$_.JList<jni$_.JBoolean> list4,
    jni$_.JList<NIAnEnum> list5,
    jni$_.JList<jni$_.JObject> list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>> list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?> map,
    jni$_.JMap<jni$_.JString, jni$_.JString> map1,
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map2,
    jni$_.JMap<NIAnEnum, NIAnEnum> map3,
    jni$_.JMap<jni$_.JObject, jni$_.JObject> map4,
    jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> map5,
    jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> map6,
  ) {
    final _$bs = bs.reference;
    final _$is$ = is$.reference;
    final _$js = js.reference;
    final _$ds = ds.reference;
    final _$nIAnEnum = nIAnEnum.reference;
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    final _$string = string.reference;
    final _$object = object.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$list2 = list2.reference;
    final _$list3 = list3.reference;
    final _$list4 = list4.reference;
    final _$list5 = list5.reference;
    final _$list6 = list6.reference;
    final _$list7 = list7.reference;
    final _$list8 = list8.reference;
    final _$map = map.reference;
    final _$map1 = map1.reference;
    final _$map2 = map2.reference;
    final _$map3 = map3.reference;
    final _$map4 = map4.reference;
    final _$map5 = map5.reference;
    final _$map6 = map6.reference;
    return NIAllTypes.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            j,
            j1,
            d,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$nIAnEnum.pointer,
            _$nIAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer)
        .reference);
  }

  static final _id_getABool = _class.instanceMethodId(
    r'getABool',
    r'()Z',
  );

  static final _getABool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final boolean getABool()`
  bool getABool() {
    return _getABool(reference.pointer, _id_getABool as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getAnInt = _class.instanceMethodId(
    r'getAnInt',
    r'()J',
  );

  static final _getAnInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long getAnInt()`
  int getAnInt() {
    return _getAnInt(reference.pointer, _id_getAnInt as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getAnInt64 = _class.instanceMethodId(
    r'getAnInt64',
    r'()J',
  );

  static final _getAnInt64 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long getAnInt64()`
  int getAnInt64() {
    return _getAnInt64(reference.pointer, _id_getAnInt64 as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getADouble = _class.instanceMethodId(
    r'getADouble',
    r'()D',
  );

  static final _getADouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double getADouble()`
  double getADouble() {
    return _getADouble(reference.pointer, _id_getADouble as jni$_.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getAByteArray = _class.instanceMethodId(
    r'getAByteArray',
    r'()[B',
  );

  static final _getAByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] getAByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray getAByteArray() {
    return _getAByteArray(
            reference.pointer, _id_getAByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_getA4ByteArray = _class.instanceMethodId(
    r'getA4ByteArray',
    r'()[I',
  );

  static final _getA4ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] getA4ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray getA4ByteArray() {
    return _getA4ByteArray(
            reference.pointer, _id_getA4ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray>(const jni$_.JIntArrayType());
  }

  static final _id_getA8ByteArray = _class.instanceMethodId(
    r'getA8ByteArray',
    r'()[J',
  );

  static final _getA8ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] getA8ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray getA8ByteArray() {
    return _getA8ByteArray(
            reference.pointer, _id_getA8ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray>(const jni$_.JLongArrayType());
  }

  static final _id_getAFloatArray = _class.instanceMethodId(
    r'getAFloatArray',
    r'()[D',
  );

  static final _getAFloatArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] getAFloatArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray getAFloatArray() {
    return _getAFloatArray(
            reference.pointer, _id_getAFloatArray as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray>(const jni$_.JDoubleArrayType());
  }

  static final _id_getAnEnum = _class.instanceMethodId(
    r'getAnEnum',
    r'()LNIAnEnum;',
  );

  static final _getAnEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAnEnum getAnEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum getAnEnum() {
    return _getAnEnum(reference.pointer, _id_getAnEnum as jni$_.JMethodIDPtr)
        .object<NIAnEnum>(const $NIAnEnum$Type());
  }

  static final _id_getAnotherEnum = _class.instanceMethodId(
    r'getAnotherEnum',
    r'()LNIAnotherEnum;',
  );

  static final _getAnotherEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAnotherEnum getAnotherEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum getAnotherEnum() {
    return _getAnotherEnum(
            reference.pointer, _id_getAnotherEnum as jni$_.JMethodIDPtr)
        .object<NIAnotherEnum>(const $NIAnotherEnum$Type());
  }

  static final _id_getAString = _class.instanceMethodId(
    r'getAString',
    r'()Ljava/lang/String;',
  );

  static final _getAString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getAString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getAString() {
    return _getAString(reference.pointer, _id_getAString as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getAnObject = _class.instanceMethodId(
    r'getAnObject',
    r'()Ljava/lang/Object;',
  );

  static final _getAnObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object getAnObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getAnObject() {
    return _getAnObject(
            reference.pointer, _id_getAnObject as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getList() {
    return _getList(reference.pointer, _id_getList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString> getStringList() {
    return _getStringList(
            reference.pointer, _id_getStringList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString>>(
            const jni$_.JListType<jni$_.JString>(jni$_.JStringType()));
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong> getIntList() {
    return _getIntList(reference.pointer, _id_getIntList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong>>(
            const jni$_.JListType<jni$_.JLong>(jni$_.JLongType()));
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble> getDoubleList() {
    return _getDoubleList(
            reference.pointer, _id_getDoubleList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble>>(
            const jni$_.JListType<jni$_.JDouble>(jni$_.JDoubleType()));
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean> getBoolList() {
    return _getBoolList(
            reference.pointer, _id_getBoolList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean>>(
            const jni$_.JListType<jni$_.JBoolean>(jni$_.JBooleanType()));
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<NIAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> getEnumList() {
    return _getEnumList(
            reference.pointer, _id_getEnumList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<NIAnEnum>>(
            const jni$_.JListType<NIAnEnum>($NIAnEnum$Type()));
  }

  static final _id_getObjectList = _class.instanceMethodId(
    r'getObjectList',
    r'()Ljava/util/List;',
  );

  static final _getObjectList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getObjectList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject> getObjectList() {
    return _getObjectList(
            reference.pointer, _id_getObjectList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject>>(
            const jni$_.JListType<jni$_.JObject>(jni$_.JObjectType()));
  }

  static final _id_getListList = _class.instanceMethodId(
    r'getListList',
    r'()Ljava/util/List;',
  );

  static final _getListList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> getListList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>> getListList() {
    return _getListList(
            reference.pointer, _id_getListList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>>>(
            const jni$_.JListType<jni$_.JList<jni$_.JObject?>>(
                jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType())));
  }

  static final _id_getMapList = _class.instanceMethodId(
    r'getMapList',
    r'()Ljava/util/List;',
  );

  static final _getMapList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> getMapList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> getMapList() {
    return _getMapList(reference.pointer, _id_getMapList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(
            const jni$_.JListType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
                jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?> getMap() {
    return _getMap(reference.pointer, _id_getMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> getStringMap() {
    return _getStringMap(
            reference.pointer, _id_getStringMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_getIntMap = _class.instanceMethodId(
    r'getIntMap',
    r'()Ljava/util/Map;',
  );

  static final _getIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> getIntMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> getIntMap() {
    return _getIntMap(reference.pointer, _id_getIntMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_getEnumMap = _class.instanceMethodId(
    r'getEnumMap',
    r'()Ljava/util/Map;',
  );

  static final _getEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<NIAnEnum, NIAnEnum> getEnumMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum> getEnumMap() {
    return _getEnumMap(reference.pointer, _id_getEnumMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<NIAnEnum, NIAnEnum>>(
            const jni$_.JMapType<NIAnEnum, NIAnEnum>(
                $NIAnEnum$Type(), $NIAnEnum$Type()));
  }

  static final _id_getObjectMap = _class.instanceMethodId(
    r'getObjectMap',
    r'()Ljava/util/Map;',
  );

  static final _getObjectMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getObjectMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject> getObjectMap() {
    return _getObjectMap(
            reference.pointer, _id_getObjectMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject>>(
            const jni$_.JMapType<jni$_.JObject, jni$_.JObject>(
                jni$_.JObjectType(), jni$_.JObjectType()));
  }

  static final _id_getListMap = _class.instanceMethodId(
    r'getListMap',
    r'()Ljava/util/Map;',
  );

  static final _getListMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> getListMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> getListMap() {
    return _getListMap(reference.pointer, _id_getListMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JList<jni$_.JObject?>>(
                jni$_.JLongType(),
                jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType())));
  }

  static final _id_getMapMap = _class.instanceMethodId(
    r'getMapMap',
    r'()Ljava/util/Map;',
  );

  static final _getMapMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> getMapMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>
      getMapMap() {
    return _getMapMap(reference.pointer, _id_getMapMap as jni$_.JMethodIDPtr)
        .object<
            jni$_.JMap<jni$_.JLong,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(const jni$_
            .JMapType<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            jni$_.JLongType(),
            jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Z',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final boolean component1()`
  bool component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()J',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long component2()`
  int component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()J',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long component3()`
  int component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()D',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double component4()`
  double component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()[B',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] component5()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray>(const jni$_.JByteArrayType());
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()[I',
  );

  static final _component6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] component6()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray component6() {
    return _component6(reference.pointer, _id_component6 as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray>(const jni$_.JIntArrayType());
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()[J',
  );

  static final _component7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] component7()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray component7() {
    return _component7(reference.pointer, _id_component7 as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray>(const jni$_.JLongArrayType());
  }

  static final _id_component8 = _class.instanceMethodId(
    r'component8',
    r'()[D',
  );

  static final _component8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] component8()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray component8() {
    return _component8(reference.pointer, _id_component8 as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray>(const jni$_.JDoubleArrayType());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()LNIAnEnum;',
  );

  static final _component9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAnEnum component9()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum component9() {
    return _component9(reference.pointer, _id_component9 as jni$_.JMethodIDPtr)
        .object<NIAnEnum>(const $NIAnEnum$Type());
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()LNIAnotherEnum;',
  );

  static final _component10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAnotherEnum component10()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum component10() {
    return _component10(
            reference.pointer, _id_component10 as jni$_.JMethodIDPtr)
        .object<NIAnotherEnum>(const $NIAnotherEnum$Type());
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/lang/String;',
  );

  static final _component11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component11()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString component11() {
    return _component11(
            reference.pointer, _id_component11 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/lang/Object;',
  );

  static final _component12 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object component12()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject component12() {
    return _component12(
            reference.pointer, _id_component12 as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()Ljava/util/List;',
  );

  static final _component13 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component13()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> component13() {
    return _component13(
            reference.pointer, _id_component13 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> component14()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString> component14() {
    return _component14(
            reference.pointer, _id_component14 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString>>(
            const jni$_.JListType<jni$_.JString>(jni$_.JStringType()));
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/List;',
  );

  static final _component15 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> component15()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong> component15() {
    return _component15(
            reference.pointer, _id_component15 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong>>(
            const jni$_.JListType<jni$_.JLong>(jni$_.JLongType()));
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/List;',
  );

  static final _component16 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> component16()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble> component16() {
    return _component16(
            reference.pointer, _id_component16 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble>>(
            const jni$_.JListType<jni$_.JDouble>(jni$_.JDoubleType()));
  }

  static final _id_component17 = _class.instanceMethodId(
    r'component17',
    r'()Ljava/util/List;',
  );

  static final _component17 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> component17()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean> component17() {
    return _component17(
            reference.pointer, _id_component17 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean>>(
            const jni$_.JListType<jni$_.JBoolean>(jni$_.JBooleanType()));
  }

  static final _id_component18 = _class.instanceMethodId(
    r'component18',
    r'()Ljava/util/List;',
  );

  static final _component18 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<NIAnEnum> component18()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> component18() {
    return _component18(
            reference.pointer, _id_component18 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<NIAnEnum>>(
            const jni$_.JListType<NIAnEnum>($NIAnEnum$Type()));
  }

  static final _id_component19 = _class.instanceMethodId(
    r'component19',
    r'()Ljava/util/List;',
  );

  static final _component19 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component19()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject> component19() {
    return _component19(
            reference.pointer, _id_component19 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject>>(
            const jni$_.JListType<jni$_.JObject>(jni$_.JObjectType()));
  }

  static final _id_component20 = _class.instanceMethodId(
    r'component20',
    r'()Ljava/util/List;',
  );

  static final _component20 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> component20()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>> component20() {
    return _component20(
            reference.pointer, _id_component20 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>>>(
            const jni$_.JListType<jni$_.JList<jni$_.JObject?>>(
                jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType())));
  }

  static final _id_component21 = _class.instanceMethodId(
    r'component21',
    r'()Ljava/util/List;',
  );

  static final _component21 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> component21()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> component21() {
    return _component21(
            reference.pointer, _id_component21 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(
            const jni$_.JListType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
                jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_component22 = _class.instanceMethodId(
    r'component22',
    r'()Ljava/util/Map;',
  );

  static final _component22 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component22()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?> component22() {
    return _component22(
            reference.pointer, _id_component22 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>>(
            const jni$_.JMapType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_component23 = _class.instanceMethodId(
    r'component23',
    r'()Ljava/util/Map;',
  );

  static final _component23 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> component23()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> component23() {
    return _component23(
            reference.pointer, _id_component23 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
            const jni$_.JMapType<jni$_.JString, jni$_.JString>(
                jni$_.JStringType(), jni$_.JStringType()));
  }

  static final _id_component24 = _class.instanceMethodId(
    r'component24',
    r'()Ljava/util/Map;',
  );

  static final _component24 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> component24()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JLong> component24() {
    return _component24(
            reference.pointer, _id_component24 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JLong>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JLong>(
                jni$_.JLongType(), jni$_.JLongType()));
  }

  static final _id_component25 = _class.instanceMethodId(
    r'component25',
    r'()Ljava/util/Map;',
  );

  static final _component25 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<NIAnEnum, NIAnEnum> component25()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum, NIAnEnum> component25() {
    return _component25(
            reference.pointer, _id_component25 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<NIAnEnum, NIAnEnum>>(
            const jni$_.JMapType<NIAnEnum, NIAnEnum>(
                $NIAnEnum$Type(), $NIAnEnum$Type()));
  }

  static final _id_component26 = _class.instanceMethodId(
    r'component26',
    r'()Ljava/util/Map;',
  );

  static final _component26 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component26()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject> component26() {
    return _component26(
            reference.pointer, _id_component26 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject>>(
            const jni$_.JMapType<jni$_.JObject, jni$_.JObject>(
                jni$_.JObjectType(), jni$_.JObjectType()));
  }

  static final _id_component27 = _class.instanceMethodId(
    r'component27',
    r'()Ljava/util/Map;',
  );

  static final _component27 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> component27()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> component27() {
    return _component27(
            reference.pointer, _id_component27 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>>>(
            const jni$_.JMapType<jni$_.JLong, jni$_.JList<jni$_.JObject?>>(
                jni$_.JLongType(),
                jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType())));
  }

  static final _id_component28 = _class.instanceMethodId(
    r'component28',
    r'()Ljava/util/Map;',
  );

  static final _component28 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> component28()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>
      component28() {
    return _component28(
            reference.pointer, _id_component28 as jni$_.JMethodIDPtr)
        .object<
            jni$_.JMap<jni$_.JLong,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>>(const jni$_
            .JMapType<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
            jni$_.JLongType(),
            jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(ZJJD[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)LNIAllTypes;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIAllTypes copy(boolean z, long j, long j1, double d, byte[] bs, int[] is, long[] js, double[] ds, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends NIAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<NIAnEnum, ? extends NIAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes copy(
    bool z,
    int j,
    int j1,
    double d,
    jni$_.JByteArray bs,
    jni$_.JIntArray is$,
    jni$_.JLongArray js,
    jni$_.JDoubleArray ds,
    NIAnEnum nIAnEnum,
    NIAnotherEnum nIAnotherEnum,
    jni$_.JString string,
    jni$_.JObject object,
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JList<jni$_.JString> list1,
    jni$_.JList<jni$_.JLong> list2,
    jni$_.JList<jni$_.JDouble> list3,
    jni$_.JList<jni$_.JBoolean> list4,
    jni$_.JList<NIAnEnum> list5,
    jni$_.JList<jni$_.JObject> list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>> list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?> map,
    jni$_.JMap<jni$_.JString, jni$_.JString> map1,
    jni$_.JMap<jni$_.JLong, jni$_.JLong> map2,
    jni$_.JMap<NIAnEnum, NIAnEnum> map3,
    jni$_.JMap<jni$_.JObject, jni$_.JObject> map4,
    jni$_.JMap<jni$_.JLong, jni$_.JList<jni$_.JObject?>> map5,
    jni$_.JMap<jni$_.JLong, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>> map6,
  ) {
    final _$bs = bs.reference;
    final _$is$ = is$.reference;
    final _$js = js.reference;
    final _$ds = ds.reference;
    final _$nIAnEnum = nIAnEnum.reference;
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    final _$string = string.reference;
    final _$object = object.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$list2 = list2.reference;
    final _$list3 = list3.reference;
    final _$list4 = list4.reference;
    final _$list5 = list5.reference;
    final _$list6 = list6.reference;
    final _$list7 = list7.reference;
    final _$list8 = list8.reference;
    final _$map = map.reference;
    final _$map1 = map1.reference;
    final _$map2 = map2.reference;
    final _$map3 = map3.reference;
    final _$map4 = map4.reference;
    final _$map5 = map5.reference;
    final _$map6 = map6.reference;
    return _copy(
            reference.pointer,
            _id_copy as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            j,
            j1,
            d,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$nIAnEnum.pointer,
            _$nIAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer)
        .object<NIAllTypes>(const $NIAllTypes$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $NIAllTypes$NullableType extends jni$_.JObjType<NIAllTypes?> {
  @jni$_.internal
  const $NIAllTypes$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllTypes;';

  @jni$_.internal
  @core$_.override
  NIAllTypes? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : NIAllTypes.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllTypes?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllTypes$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllTypes$NullableType) &&
        other is $NIAllTypes$NullableType;
  }
}

final class $NIAllTypes$Type extends jni$_.JObjType<NIAllTypes> {
  @jni$_.internal
  const $NIAllTypes$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllTypes;';

  @jni$_.internal
  @core$_.override
  NIAllTypes fromReference(jni$_.JReference reference) =>
      NIAllTypes.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllTypes?> get nullableType =>
      const $NIAllTypes$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllTypes$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllTypes$Type) && other is $NIAllTypes$Type;
  }
}

/// from: `NIAllNullableTypes$Companion`
class NIAllNullableTypes$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIAllNullableTypes$Companion> $type;

  @jni$_.internal
  NIAllNullableTypes$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllNullableTypes$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIAllNullableTypes$Companion$NullableType();
  static const type = $NIAllNullableTypes$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LNIAllNullableTypes;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIAllNullableTypes fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<NIAllNullableTypes>(const $NIAllNullableTypes$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypes$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypes$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $NIAllNullableTypes$Companion$NullableType
    extends jni$_.JObjType<NIAllNullableTypes$Companion?> {
  @jni$_.internal
  const $NIAllNullableTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypes$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypes$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIAllNullableTypes$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllNullableTypes$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllNullableTypes$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllNullableTypes$Companion$NullableType) &&
        other is $NIAllNullableTypes$Companion$NullableType;
  }
}

final class $NIAllNullableTypes$Companion$Type
    extends jni$_.JObjType<NIAllNullableTypes$Companion> {
  @jni$_.internal
  const $NIAllNullableTypes$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypes$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypes$Companion fromReference(jni$_.JReference reference) =>
      NIAllNullableTypes$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllNullableTypes$Companion?> get nullableType =>
      const $NIAllNullableTypes$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllNullableTypes$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllNullableTypes$Companion$Type) &&
        other is $NIAllNullableTypes$Companion$Type;
  }
}

/// from: `NIAllNullableTypes`
class NIAllNullableTypes extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIAllNullableTypes> $type;

  @jni$_.internal
  NIAllNullableTypes.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllNullableTypes');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIAllNullableTypes$NullableType();
  static const type = $NIAllNullableTypes$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAllNullableTypes$Companion;',
  );

  /// from: `static public final NIAllNullableTypes$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAllNullableTypes$Companion get Companion =>
      _id_Companion.get(_class, const $NIAllNullableTypes$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;LNIAllNullableTypes;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, NIAllNullableTypes nIAllNullableTypes, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends NIAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.List<NIAllNullableTypes> list9, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<NIAnEnum, ? extends NIAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6, java.util.Map<java.lang.Long, NIAllNullableTypes> map7)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    NIAllNullableTypes? nIAllNullableTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<NIAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JList<NIAllNullableTypes?>? list9,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map7,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$list9 = list9?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$map7 = map7?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypes.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$nIAnEnum.pointer,
            _$nIAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$nIAllNullableTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$list9.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer,
            _$map7.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;LNIAllNullableTypes;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, NIAllNullableTypes nIAllNullableTypes, java.util.List list, java.util.List list1, java.util.List list2, java.util.List list3, java.util.List list4, java.util.List list5, java.util.List list6, java.util.List list7, java.util.List list8, java.util.List list9, java.util.Map map, java.util.Map map1, java.util.Map map2, java.util.Map map3, java.util.Map map4, java.util.Map map5, java.util.Map map6, java.util.Map map7, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypes.new$1(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    NIAllNullableTypes? nIAllNullableTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    jni$_.JList<jni$_.JObject?>? list2,
    jni$_.JList<jni$_.JObject?>? list3,
    jni$_.JList<jni$_.JObject?>? list4,
    jni$_.JList<jni$_.JObject?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JObject?>? list7,
    jni$_.JList<jni$_.JObject?>? list8,
    jni$_.JList<jni$_.JObject?>? list9,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map1,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map2,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map5,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map6,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map7,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$list9 = list9?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$map7 = map7?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypes.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$nIAnEnum.pointer,
            _$nIAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$nIAllNullableTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$list9.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer,
            _$map7.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getANullableBool = _class.instanceMethodId(
    r'getANullableBool',
    r'()Ljava/lang/Boolean;',
  );

  static final _getANullableBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Boolean getANullableBool()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? getANullableBool() {
    return _getANullableBool(
            reference.pointer, _id_getANullableBool as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_getANullableInt = _class.instanceMethodId(
    r'getANullableInt',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long getANullableInt()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt() {
    return _getANullableInt(
            reference.pointer, _id_getANullableInt as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_getANullableInt64 = _class.instanceMethodId(
    r'getANullableInt64',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt64 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long getANullableInt64()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt64() {
    return _getANullableInt64(
            reference.pointer, _id_getANullableInt64 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_getANullableDouble = _class.instanceMethodId(
    r'getANullableDouble',
    r'()Ljava/lang/Double;',
  );

  static final _getANullableDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Double getANullableDouble()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getANullableDouble() {
    return _getANullableDouble(
            reference.pointer, _id_getANullableDouble as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_getANullableByteArray = _class.instanceMethodId(
    r'getANullableByteArray',
    r'()[B',
  );

  static final _getANullableByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] getANullableByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getANullableByteArray() {
    return _getANullableByteArray(
            reference.pointer, _id_getANullableByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_getANullable4ByteArray = _class.instanceMethodId(
    r'getANullable4ByteArray',
    r'()[I',
  );

  static final _getANullable4ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] getANullable4ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? getANullable4ByteArray() {
    return _getANullable4ByteArray(
            reference.pointer, _id_getANullable4ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_getANullable8ByteArray = _class.instanceMethodId(
    r'getANullable8ByteArray',
    r'()[J',
  );

  static final _getANullable8ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] getANullable8ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? getANullable8ByteArray() {
    return _getANullable8ByteArray(
            reference.pointer, _id_getANullable8ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_getANullableFloatArray = _class.instanceMethodId(
    r'getANullableFloatArray',
    r'()[D',
  );

  static final _getANullableFloatArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] getANullableFloatArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? getANullableFloatArray() {
    return _getANullableFloatArray(
            reference.pointer, _id_getANullableFloatArray as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_getANullableEnum = _class.instanceMethodId(
    r'getANullableEnum',
    r'()LNIAnEnum;',
  );

  static final _getANullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAnEnum getANullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? getANullableEnum() {
    return _getANullableEnum(
            reference.pointer, _id_getANullableEnum as jni$_.JMethodIDPtr)
        .object<NIAnEnum?>(const $NIAnEnum$NullableType());
  }

  static final _id_getAnotherNullableEnum = _class.instanceMethodId(
    r'getAnotherNullableEnum',
    r'()LNIAnotherEnum;',
  );

  static final _getAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAnotherEnum getAnotherNullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? getAnotherNullableEnum() {
    return _getAnotherNullableEnum(
            reference.pointer, _id_getAnotherNullableEnum as jni$_.JMethodIDPtr)
        .object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType());
  }

  static final _id_getANullableString = _class.instanceMethodId(
    r'getANullableString',
    r'()Ljava/lang/String;',
  );

  static final _getANullableString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getANullableString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getANullableString() {
    return _getANullableString(
            reference.pointer, _id_getANullableString as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getANullableObject = _class.instanceMethodId(
    r'getANullableObject',
    r'()Ljava/lang/Object;',
  );

  static final _getANullableObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object getANullableObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getANullableObject() {
    return _getANullableObject(
            reference.pointer, _id_getANullableObject as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getAllNullableTypes = _class.instanceMethodId(
    r'getAllNullableTypes',
    r'()LNIAllNullableTypes;',
  );

  static final _getAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAllNullableTypes getAllNullableTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes? getAllNullableTypes() {
    return _getAllNullableTypes(
            reference.pointer, _id_getAllNullableTypes as jni$_.JMethodIDPtr)
        .object<NIAllNullableTypes?>(const $NIAllNullableTypes$NullableType());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getList() {
    return _getList(reference.pointer, _id_getList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getStringList() {
    return _getStringList(
            reference.pointer, _id_getStringList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? getIntList() {
    return _getIntList(reference.pointer, _id_getIntList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong?>?>(
            const jni$_.JListNullableType<jni$_.JLong?>(
                jni$_.JLongNullableType()));
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? getDoubleList() {
    return _getDoubleList(
            reference.pointer, _id_getDoubleList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble?>?>(
            const jni$_.JListNullableType<jni$_.JDouble?>(
                jni$_.JDoubleNullableType()));
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? getBoolList() {
    return _getBoolList(
            reference.pointer, _id_getBoolList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean?>?>(
            const jni$_.JListNullableType<jni$_.JBoolean?>(
                jni$_.JBooleanNullableType()));
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<NIAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? getEnumList() {
    return _getEnumList(
            reference.pointer, _id_getEnumList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<NIAnEnum?>?>(
            const jni$_.JListNullableType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_getObjectList = _class.instanceMethodId(
    r'getObjectList',
    r'()Ljava/util/List;',
  );

  static final _getObjectList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getObjectList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getObjectList() {
    return _getObjectList(
            reference.pointer, _id_getObjectList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getListList = _class.instanceMethodId(
    r'getListList',
    r'()Ljava/util/List;',
  );

  static final _getListList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> getListList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? getListList() {
    return _getListList(
            reference.pointer, _id_getListList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_.JListNullableType<jni$_.JList<jni$_.JObject?>?>(
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_getMapList = _class.instanceMethodId(
    r'getMapList',
    r'()Ljava/util/List;',
  );

  static final _getMapList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> getMapList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? getMapList() {
    return _getMapList(reference.pointer, _id_getMapList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_
                .JListNullableType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_getRecursiveClassList = _class.instanceMethodId(
    r'getRecursiveClassList',
    r'()Ljava/util/List;',
  );

  static final _getRecursiveClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<NIAllNullableTypes> getRecursiveClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?>? getRecursiveClassList() {
    return _getRecursiveClassList(
            reference.pointer, _id_getRecursiveClassList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<NIAllNullableTypes?>?>(
            const jni$_.JListNullableType<NIAllNullableTypes?>(
                $NIAllNullableTypes$NullableType()));
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? getMap() {
    return _getMap(reference.pointer, _id_getMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? getStringMap() {
    return _getStringMap(
            reference.pointer, _id_getStringMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_getIntMap = _class.instanceMethodId(
    r'getIntMap',
    r'()Ljava/util/Map;',
  );

  static final _getIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> getIntMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? getIntMap() {
    return _getIntMap(reference.pointer, _id_getIntMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_getEnumMap = _class.instanceMethodId(
    r'getEnumMap',
    r'()Ljava/util/Map;',
  );

  static final _getEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<NIAnEnum, NIAnEnum> getEnumMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? getEnumMap() {
    return _getEnumMap(reference.pointer, _id_getEnumMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
            const jni$_.JMapNullableType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_getObjectMap = _class.instanceMethodId(
    r'getObjectMap',
    r'()Ljava/util/Map;',
  );

  static final _getObjectMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getObjectMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? getObjectMap() {
    return _getObjectMap(
            reference.pointer, _id_getObjectMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_getListMap = _class.instanceMethodId(
    r'getListMap',
    r'()Ljava/util/Map;',
  );

  static final _getListMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> getListMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? getListMap() {
    return _getListMap(reference.pointer, _id_getListMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_
                .JMapNullableType<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_getMapMap = _class.instanceMethodId(
    r'getMapMap',
    r'()Ljava/util/Map;',
  );

  static final _getMapMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> getMapMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
      getMapMap() {
    return _getMapMap(reference.pointer, _id_getMapMap as jni$_.JMethodIDPtr)
        .object<
                jni$_.JMap<jni$_.JLong?,
                    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?,
                    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_getRecursiveClassMap = _class.instanceMethodId(
    r'getRecursiveClassMap',
    r'()Ljava/util/Map;',
  );

  static final _getRecursiveClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, NIAllNullableTypes> getRecursiveClassMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? getRecursiveClassMap() {
    return _getRecursiveClassMap(
            reference.pointer, _id_getRecursiveClassMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, NIAllNullableTypes?>(
                jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()));
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/Boolean;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Boolean component1()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()Ljava/lang/Long;',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long component2()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()Ljava/lang/Long;',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long component3()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/lang/Double;',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Double component4()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()[B',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] component5()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()[I',
  );

  static final _component6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] component6()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? component6() {
    return _component6(reference.pointer, _id_component6 as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()[J',
  );

  static final _component7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] component7()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? component7() {
    return _component7(reference.pointer, _id_component7 as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_component8 = _class.instanceMethodId(
    r'component8',
    r'()[D',
  );

  static final _component8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] component8()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? component8() {
    return _component8(reference.pointer, _id_component8 as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()LNIAnEnum;',
  );

  static final _component9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAnEnum component9()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? component9() {
    return _component9(reference.pointer, _id_component9 as jni$_.JMethodIDPtr)
        .object<NIAnEnum?>(const $NIAnEnum$NullableType());
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()LNIAnotherEnum;',
  );

  static final _component10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAnotherEnum component10()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? component10() {
    return _component10(
            reference.pointer, _id_component10 as jni$_.JMethodIDPtr)
        .object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType());
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/lang/String;',
  );

  static final _component11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component11()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? component11() {
    return _component11(
            reference.pointer, _id_component11 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/lang/Object;',
  );

  static final _component12 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object component12()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? component12() {
    return _component12(
            reference.pointer, _id_component12 as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()LNIAllNullableTypes;',
  );

  static final _component13 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAllNullableTypes component13()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes? component13() {
    return _component13(
            reference.pointer, _id_component13 as jni$_.JMethodIDPtr)
        .object<NIAllNullableTypes?>(const $NIAllNullableTypes$NullableType());
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component14()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component14() {
    return _component14(
            reference.pointer, _id_component14 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/List;',
  );

  static final _component15 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> component15()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? component15() {
    return _component15(
            reference.pointer, _id_component15 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/List;',
  );

  static final _component16 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> component16()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? component16() {
    return _component16(
            reference.pointer, _id_component16 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong?>?>(
            const jni$_.JListNullableType<jni$_.JLong?>(
                jni$_.JLongNullableType()));
  }

  static final _id_component17 = _class.instanceMethodId(
    r'component17',
    r'()Ljava/util/List;',
  );

  static final _component17 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> component17()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? component17() {
    return _component17(
            reference.pointer, _id_component17 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble?>?>(
            const jni$_.JListNullableType<jni$_.JDouble?>(
                jni$_.JDoubleNullableType()));
  }

  static final _id_component18 = _class.instanceMethodId(
    r'component18',
    r'()Ljava/util/List;',
  );

  static final _component18 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> component18()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? component18() {
    return _component18(
            reference.pointer, _id_component18 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean?>?>(
            const jni$_.JListNullableType<jni$_.JBoolean?>(
                jni$_.JBooleanNullableType()));
  }

  static final _id_component19 = _class.instanceMethodId(
    r'component19',
    r'()Ljava/util/List;',
  );

  static final _component19 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<NIAnEnum> component19()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? component19() {
    return _component19(
            reference.pointer, _id_component19 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<NIAnEnum?>?>(
            const jni$_.JListNullableType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_component20 = _class.instanceMethodId(
    r'component20',
    r'()Ljava/util/List;',
  );

  static final _component20 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component20()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component20() {
    return _component20(
            reference.pointer, _id_component20 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_component21 = _class.instanceMethodId(
    r'component21',
    r'()Ljava/util/List;',
  );

  static final _component21 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> component21()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? component21() {
    return _component21(
            reference.pointer, _id_component21 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_.JListNullableType<jni$_.JList<jni$_.JObject?>?>(
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_component22 = _class.instanceMethodId(
    r'component22',
    r'()Ljava/util/List;',
  );

  static final _component22 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> component22()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? component22() {
    return _component22(
            reference.pointer, _id_component22 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_
                .JListNullableType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_component23 = _class.instanceMethodId(
    r'component23',
    r'()Ljava/util/List;',
  );

  static final _component23 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<NIAllNullableTypes> component23()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypes?>? component23() {
    return _component23(
            reference.pointer, _id_component23 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<NIAllNullableTypes?>?>(
            const jni$_.JListNullableType<NIAllNullableTypes?>(
                $NIAllNullableTypes$NullableType()));
  }

  static final _id_component24 = _class.instanceMethodId(
    r'component24',
    r'()Ljava/util/Map;',
  );

  static final _component24 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component24()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? component24() {
    return _component24(
            reference.pointer, _id_component24 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_component25 = _class.instanceMethodId(
    r'component25',
    r'()Ljava/util/Map;',
  );

  static final _component25 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> component25()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? component25() {
    return _component25(
            reference.pointer, _id_component25 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_component26 = _class.instanceMethodId(
    r'component26',
    r'()Ljava/util/Map;',
  );

  static final _component26 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> component26()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? component26() {
    return _component26(
            reference.pointer, _id_component26 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_component27 = _class.instanceMethodId(
    r'component27',
    r'()Ljava/util/Map;',
  );

  static final _component27 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<NIAnEnum, NIAnEnum> component27()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? component27() {
    return _component27(
            reference.pointer, _id_component27 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
            const jni$_.JMapNullableType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_component28 = _class.instanceMethodId(
    r'component28',
    r'()Ljava/util/Map;',
  );

  static final _component28 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component28()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? component28() {
    return _component28(
            reference.pointer, _id_component28 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_component29 = _class.instanceMethodId(
    r'component29',
    r'()Ljava/util/Map;',
  );

  static final _component29 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> component29()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? component29() {
    return _component29(
            reference.pointer, _id_component29 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_
                .JMapNullableType<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_component30 = _class.instanceMethodId(
    r'component30',
    r'()Ljava/util/Map;',
  );

  static final _component30 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> component30()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
      component30() {
    return _component30(reference.pointer, _id_component30 as jni$_.JMethodIDPtr)
        .object<
            jni$_.JMap<jni$_.JLong?,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(const jni$_
            .JMapNullableType<jni$_.JLong?,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            jni$_.JLongNullableType(),
            jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_component31 = _class.instanceMethodId(
    r'component31',
    r'()Ljava/util/Map;',
  );

  static final _component31 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, NIAllNullableTypes> component31()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? component31() {
    return _component31(
            reference.pointer, _id_component31 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, NIAllNullableTypes?>(
                jni$_.JLongNullableType(), $NIAllNullableTypes$NullableType()));
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;LNIAllNullableTypes;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)LNIAllNullableTypes;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIAllNullableTypes copy(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, NIAllNullableTypes nIAllNullableTypes, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends NIAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.List<NIAllNullableTypes> list9, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<NIAnEnum, ? extends NIAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6, java.util.Map<java.lang.Long, NIAllNullableTypes> map7)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes copy(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    NIAllNullableTypes? nIAllNullableTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<NIAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JList<NIAllNullableTypes?>? list9,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypes?>? map7,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$list9 = list9?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$map7 = map7?.reference ?? jni$_.jNullReference;
    return _copy(
            reference.pointer,
            _id_copy as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$nIAnEnum.pointer,
            _$nIAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$nIAllNullableTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$list9.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer,
            _$map7.pointer)
        .object<NIAllNullableTypes>(const $NIAllNullableTypes$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypes.new$2() {
    return NIAllNullableTypes.fromReference(
        _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $NIAllNullableTypes$NullableType
    extends jni$_.JObjType<NIAllNullableTypes?> {
  @jni$_.internal
  const $NIAllNullableTypes$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypes;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypes? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIAllNullableTypes.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllNullableTypes?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllNullableTypes$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllNullableTypes$NullableType) &&
        other is $NIAllNullableTypes$NullableType;
  }
}

final class $NIAllNullableTypes$Type
    extends jni$_.JObjType<NIAllNullableTypes> {
  @jni$_.internal
  const $NIAllNullableTypes$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypes;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypes fromReference(jni$_.JReference reference) =>
      NIAllNullableTypes.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllNullableTypes?> get nullableType =>
      const $NIAllNullableTypes$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllNullableTypes$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllNullableTypes$Type) &&
        other is $NIAllNullableTypes$Type;
  }
}

/// from: `NIAllNullableTypesWithoutRecursion$Companion`
class NIAllNullableTypesWithoutRecursion$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIAllNullableTypesWithoutRecursion$Companion> $type;

  @jni$_.internal
  NIAllNullableTypesWithoutRecursion$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'NIAllNullableTypesWithoutRecursion$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $NIAllNullableTypesWithoutRecursion$Companion$NullableType();
  static const type = $NIAllNullableTypesWithoutRecursion$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIAllNullableTypesWithoutRecursion fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<NIAllNullableTypesWithoutRecursion>(
            const $NIAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypesWithoutRecursion$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypesWithoutRecursion$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $NIAllNullableTypesWithoutRecursion$Companion$NullableType
    extends jni$_.JObjType<NIAllNullableTypesWithoutRecursion$Companion?> {
  @jni$_.internal
  const $NIAllNullableTypesWithoutRecursion$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypesWithoutRecursion$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypesWithoutRecursion$Companion? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIAllNullableTypesWithoutRecursion$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllNullableTypesWithoutRecursion$Companion?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($NIAllNullableTypesWithoutRecursion$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIAllNullableTypesWithoutRecursion$Companion$NullableType) &&
        other is $NIAllNullableTypesWithoutRecursion$Companion$NullableType;
  }
}

final class $NIAllNullableTypesWithoutRecursion$Companion$Type
    extends jni$_.JObjType<NIAllNullableTypesWithoutRecursion$Companion> {
  @jni$_.internal
  const $NIAllNullableTypesWithoutRecursion$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypesWithoutRecursion$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypesWithoutRecursion$Companion fromReference(
          jni$_.JReference reference) =>
      NIAllNullableTypesWithoutRecursion$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllNullableTypesWithoutRecursion$Companion?>
      get nullableType =>
          const $NIAllNullableTypesWithoutRecursion$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($NIAllNullableTypesWithoutRecursion$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIAllNullableTypesWithoutRecursion$Companion$Type) &&
        other is $NIAllNullableTypesWithoutRecursion$Companion$Type;
  }
}

/// from: `NIAllNullableTypesWithoutRecursion`
class NIAllNullableTypesWithoutRecursion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIAllNullableTypesWithoutRecursion> $type;

  @jni$_.internal
  NIAllNullableTypesWithoutRecursion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'NIAllNullableTypesWithoutRecursion');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $NIAllNullableTypesWithoutRecursion$NullableType();
  static const type = $NIAllNullableTypesWithoutRecursion$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAllNullableTypesWithoutRecursion$Companion;',
  );

  /// from: `static public final NIAllNullableTypesWithoutRecursion$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAllNullableTypesWithoutRecursion$Companion get Companion =>
      _id_Companion.get(
          _class, const $NIAllNullableTypesWithoutRecursion$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends NIAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<NIAnEnum, ? extends NIAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<NIAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypesWithoutRecursion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$nIAnEnum.pointer,
            _$nIAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List list, java.util.List list1, java.util.List list2, java.util.List list3, java.util.List list4, java.util.List list5, java.util.List list6, java.util.List list7, java.util.List list8, java.util.Map map, java.util.Map map1, java.util.Map map2, java.util.Map map3, java.util.Map map4, java.util.Map map5, java.util.Map map6, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypesWithoutRecursion.new$1(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    jni$_.JList<jni$_.JObject?>? list2,
    jni$_.JList<jni$_.JObject?>? list3,
    jni$_.JList<jni$_.JObject?>? list4,
    jni$_.JList<jni$_.JObject?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JObject?>? list7,
    jni$_.JList<jni$_.JObject?>? list8,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map1,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map2,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map5,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map6,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypesWithoutRecursion.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$nIAnEnum.pointer,
            _$nIAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getANullableBool = _class.instanceMethodId(
    r'getANullableBool',
    r'()Ljava/lang/Boolean;',
  );

  static final _getANullableBool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Boolean getANullableBool()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? getANullableBool() {
    return _getANullableBool(
            reference.pointer, _id_getANullableBool as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_getANullableInt = _class.instanceMethodId(
    r'getANullableInt',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long getANullableInt()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt() {
    return _getANullableInt(
            reference.pointer, _id_getANullableInt as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_getANullableInt64 = _class.instanceMethodId(
    r'getANullableInt64',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt64 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long getANullableInt64()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt64() {
    return _getANullableInt64(
            reference.pointer, _id_getANullableInt64 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_getANullableDouble = _class.instanceMethodId(
    r'getANullableDouble',
    r'()Ljava/lang/Double;',
  );

  static final _getANullableDouble = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Double getANullableDouble()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getANullableDouble() {
    return _getANullableDouble(
            reference.pointer, _id_getANullableDouble as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_getANullableByteArray = _class.instanceMethodId(
    r'getANullableByteArray',
    r'()[B',
  );

  static final _getANullableByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] getANullableByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getANullableByteArray() {
    return _getANullableByteArray(
            reference.pointer, _id_getANullableByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_getANullable4ByteArray = _class.instanceMethodId(
    r'getANullable4ByteArray',
    r'()[I',
  );

  static final _getANullable4ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] getANullable4ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? getANullable4ByteArray() {
    return _getANullable4ByteArray(
            reference.pointer, _id_getANullable4ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_getANullable8ByteArray = _class.instanceMethodId(
    r'getANullable8ByteArray',
    r'()[J',
  );

  static final _getANullable8ByteArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] getANullable8ByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? getANullable8ByteArray() {
    return _getANullable8ByteArray(
            reference.pointer, _id_getANullable8ByteArray as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_getANullableFloatArray = _class.instanceMethodId(
    r'getANullableFloatArray',
    r'()[D',
  );

  static final _getANullableFloatArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] getANullableFloatArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? getANullableFloatArray() {
    return _getANullableFloatArray(
            reference.pointer, _id_getANullableFloatArray as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_getANullableEnum = _class.instanceMethodId(
    r'getANullableEnum',
    r'()LNIAnEnum;',
  );

  static final _getANullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAnEnum getANullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? getANullableEnum() {
    return _getANullableEnum(
            reference.pointer, _id_getANullableEnum as jni$_.JMethodIDPtr)
        .object<NIAnEnum?>(const $NIAnEnum$NullableType());
  }

  static final _id_getAnotherNullableEnum = _class.instanceMethodId(
    r'getAnotherNullableEnum',
    r'()LNIAnotherEnum;',
  );

  static final _getAnotherNullableEnum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAnotherEnum getAnotherNullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? getAnotherNullableEnum() {
    return _getAnotherNullableEnum(
            reference.pointer, _id_getAnotherNullableEnum as jni$_.JMethodIDPtr)
        .object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType());
  }

  static final _id_getANullableString = _class.instanceMethodId(
    r'getANullableString',
    r'()Ljava/lang/String;',
  );

  static final _getANullableString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String getANullableString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getANullableString() {
    return _getANullableString(
            reference.pointer, _id_getANullableString as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getANullableObject = _class.instanceMethodId(
    r'getANullableObject',
    r'()Ljava/lang/Object;',
  );

  static final _getANullableObject = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object getANullableObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getANullableObject() {
    return _getANullableObject(
            reference.pointer, _id_getANullableObject as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getList() {
    return _getList(reference.pointer, _id_getList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getStringList() {
    return _getStringList(
            reference.pointer, _id_getStringList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? getIntList() {
    return _getIntList(reference.pointer, _id_getIntList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong?>?>(
            const jni$_.JListNullableType<jni$_.JLong?>(
                jni$_.JLongNullableType()));
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? getDoubleList() {
    return _getDoubleList(
            reference.pointer, _id_getDoubleList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble?>?>(
            const jni$_.JListNullableType<jni$_.JDouble?>(
                jni$_.JDoubleNullableType()));
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? getBoolList() {
    return _getBoolList(
            reference.pointer, _id_getBoolList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean?>?>(
            const jni$_.JListNullableType<jni$_.JBoolean?>(
                jni$_.JBooleanNullableType()));
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<NIAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? getEnumList() {
    return _getEnumList(
            reference.pointer, _id_getEnumList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<NIAnEnum?>?>(
            const jni$_.JListNullableType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_getObjectList = _class.instanceMethodId(
    r'getObjectList',
    r'()Ljava/util/List;',
  );

  static final _getObjectList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> getObjectList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getObjectList() {
    return _getObjectList(
            reference.pointer, _id_getObjectList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getListList = _class.instanceMethodId(
    r'getListList',
    r'()Ljava/util/List;',
  );

  static final _getListList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> getListList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? getListList() {
    return _getListList(
            reference.pointer, _id_getListList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_.JListNullableType<jni$_.JList<jni$_.JObject?>?>(
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_getMapList = _class.instanceMethodId(
    r'getMapList',
    r'()Ljava/util/List;',
  );

  static final _getMapList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> getMapList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? getMapList() {
    return _getMapList(reference.pointer, _id_getMapList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_
                .JListNullableType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? getMap() {
    return _getMap(reference.pointer, _id_getMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? getStringMap() {
    return _getStringMap(
            reference.pointer, _id_getStringMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_getIntMap = _class.instanceMethodId(
    r'getIntMap',
    r'()Ljava/util/Map;',
  );

  static final _getIntMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> getIntMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? getIntMap() {
    return _getIntMap(reference.pointer, _id_getIntMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_getEnumMap = _class.instanceMethodId(
    r'getEnumMap',
    r'()Ljava/util/Map;',
  );

  static final _getEnumMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<NIAnEnum, NIAnEnum> getEnumMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? getEnumMap() {
    return _getEnumMap(reference.pointer, _id_getEnumMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
            const jni$_.JMapNullableType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_getObjectMap = _class.instanceMethodId(
    r'getObjectMap',
    r'()Ljava/util/Map;',
  );

  static final _getObjectMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getObjectMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? getObjectMap() {
    return _getObjectMap(
            reference.pointer, _id_getObjectMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_getListMap = _class.instanceMethodId(
    r'getListMap',
    r'()Ljava/util/Map;',
  );

  static final _getListMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> getListMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? getListMap() {
    return _getListMap(reference.pointer, _id_getListMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_
                .JMapNullableType<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_getMapMap = _class.instanceMethodId(
    r'getMapMap',
    r'()Ljava/util/Map;',
  );

  static final _getMapMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> getMapMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
      getMapMap() {
    return _getMapMap(reference.pointer, _id_getMapMap as jni$_.JMethodIDPtr)
        .object<
                jni$_.JMap<jni$_.JLong?,
                    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?,
                    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/Boolean;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Boolean component1()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<jni$_.JBoolean?>(const jni$_.JBooleanNullableType());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()Ljava/lang/Long;',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long component2()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()Ljava/lang/Long;',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Long component3()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/lang/Double;',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Double component4()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .object<jni$_.JDouble?>(const jni$_.JDoubleNullableType());
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()[B',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final byte[] component5()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()[I',
  );

  static final _component6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int[] component6()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? component6() {
    return _component6(reference.pointer, _id_component6 as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()[J',
  );

  static final _component7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final long[] component7()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLongArray? component7() {
    return _component7(reference.pointer, _id_component7 as jni$_.JMethodIDPtr)
        .object<jni$_.JLongArray?>(const jni$_.JLongArrayNullableType());
  }

  static final _id_component8 = _class.instanceMethodId(
    r'component8',
    r'()[D',
  );

  static final _component8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final double[] component8()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? component8() {
    return _component8(reference.pointer, _id_component8 as jni$_.JMethodIDPtr)
        .object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()LNIAnEnum;',
  );

  static final _component9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAnEnum component9()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? component9() {
    return _component9(reference.pointer, _id_component9 as jni$_.JMethodIDPtr)
        .object<NIAnEnum?>(const $NIAnEnum$NullableType());
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()LNIAnotherEnum;',
  );

  static final _component10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAnotherEnum component10()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? component10() {
    return _component10(
            reference.pointer, _id_component10 as jni$_.JMethodIDPtr)
        .object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType());
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/lang/String;',
  );

  static final _component11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.String component11()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? component11() {
    return _component11(
            reference.pointer, _id_component11 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/lang/Object;',
  );

  static final _component12 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.lang.Object component12()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? component12() {
    return _component12(
            reference.pointer, _id_component12 as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()Ljava/util/List;',
  );

  static final _component13 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component13()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component13() {
    return _component13(
            reference.pointer, _id_component13 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.String> component14()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? component14() {
    return _component14(
            reference.pointer, _id_component14 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/List;',
  );

  static final _component15 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Long> component15()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? component15() {
    return _component15(
            reference.pointer, _id_component15 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JLong?>?>(
            const jni$_.JListNullableType<jni$_.JLong?>(
                jni$_.JLongNullableType()));
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/List;',
  );

  static final _component16 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Double> component16()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? component16() {
    return _component16(
            reference.pointer, _id_component16 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JDouble?>?>(
            const jni$_.JListNullableType<jni$_.JDouble?>(
                jni$_.JDoubleNullableType()));
  }

  static final _id_component17 = _class.instanceMethodId(
    r'component17',
    r'()Ljava/util/List;',
  );

  static final _component17 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Boolean> component17()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? component17() {
    return _component17(
            reference.pointer, _id_component17 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JBoolean?>?>(
            const jni$_.JListNullableType<jni$_.JBoolean?>(
                jni$_.JBooleanNullableType()));
  }

  static final _id_component18 = _class.instanceMethodId(
    r'component18',
    r'()Ljava/util/List;',
  );

  static final _component18 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<NIAnEnum> component18()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? component18() {
    return _component18(
            reference.pointer, _id_component18 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<NIAnEnum?>?>(
            const jni$_.JListNullableType<NIAnEnum?>($NIAnEnum$NullableType()));
  }

  static final _id_component19 = _class.instanceMethodId(
    r'component19',
    r'()Ljava/util/List;',
  );

  static final _component19 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> component19()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component19() {
    return _component19(
            reference.pointer, _id_component19 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_component20 = _class.instanceMethodId(
    r'component20',
    r'()Ljava/util/List;',
  );

  static final _component20 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.List<java.lang.Object>> component20()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JObject?>?>? component20() {
    return _component20(
            reference.pointer, _id_component20 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_.JListNullableType<jni$_.JList<jni$_.JObject?>?>(
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_component21 = _class.instanceMethodId(
    r'component21',
    r'()Ljava/util/List;',
  );

  static final _component21 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.util.Map<java.lang.Object, java.lang.Object>> component21()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? component21() {
    return _component21(
            reference.pointer, _id_component21 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(
            const jni$_
                .JListNullableType<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
                jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                    jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_component22 = _class.instanceMethodId(
    r'component22',
    r'()Ljava/util/Map;',
  );

  static final _component22 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component22()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? component22() {
    return _component22(
            reference.pointer, _id_component22 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject, jni$_.JObject?>(
                jni$_.JObjectType(), jni$_.JObjectNullableType()));
  }

  static final _id_component23 = _class.instanceMethodId(
    r'component23',
    r'()Ljava/util/Map;',
  );

  static final _component23 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> component23()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? component23() {
    return _component23(
            reference.pointer, _id_component23 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
            const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
                jni$_.JStringNullableType(), jni$_.JStringNullableType()));
  }

  static final _id_component24 = _class.instanceMethodId(
    r'component24',
    r'()Ljava/util/Map;',
  );

  static final _component24 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.lang.Long> component24()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? component24() {
    return _component24(
            reference.pointer, _id_component24 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?, jni$_.JLong?>(
                jni$_.JLongNullableType(), jni$_.JLongNullableType()));
  }

  static final _id_component25 = _class.instanceMethodId(
    r'component25',
    r'()Ljava/util/Map;',
  );

  static final _component25 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<NIAnEnum, NIAnEnum> component25()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<NIAnEnum?, NIAnEnum?>? component25() {
    return _component25(
            reference.pointer, _id_component25 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<NIAnEnum?, NIAnEnum?>?>(
            const jni$_.JMapNullableType<NIAnEnum?, NIAnEnum?>(
                $NIAnEnum$NullableType(), $NIAnEnum$NullableType()));
  }

  static final _id_component26 = _class.instanceMethodId(
    r'component26',
    r'()Ljava/util/Map;',
  );

  static final _component26 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> component26()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? component26() {
    return _component26(
            reference.pointer, _id_component26 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            const jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType()));
  }

  static final _id_component27 = _class.instanceMethodId(
    r'component27',
    r'()Ljava/util/Map;',
  );

  static final _component27 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.List<java.lang.Object>> component27()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? component27() {
    return _component27(
            reference.pointer, _id_component27 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>?>(
            const jni$_
                .JMapNullableType<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>(
                jni$_.JLongNullableType(),
                jni$_.JListNullableType<jni$_.JObject?>(
                    jni$_.JObjectNullableType())));
  }

  static final _id_component28 = _class.instanceMethodId(
    r'component28',
    r'()Ljava/util/Map;',
  );

  static final _component28 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, java.util.Map<java.lang.Object, java.lang.Object>> component28()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?
      component28() {
    return _component28(reference.pointer, _id_component28 as jni$_.JMethodIDPtr)
        .object<
            jni$_.JMap<jni$_.JLong?,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>?>(const jni$_
            .JMapNullableType<jni$_.JLong?,
                jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
            jni$_.JLongNullableType(),
            jni$_.JMapNullableType<jni$_.JObject?, jni$_.JObject?>(
                jni$_.JObjectNullableType(), jni$_.JObjectNullableType())));
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;[B[I[J[DLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIAllNullableTypesWithoutRecursion copy(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, byte[] bs, int[] is, long[] js, double[] ds, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends NIAnEnum> list5, java.util.List<? extends java.lang.Object> list6, java.util.List<? extends java.util.List> list7, java.util.List<? extends java.util.Map> list8, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1, java.util.Map<java.lang.Long, java.lang.Long> map2, java.util.Map<NIAnEnum, ? extends NIAnEnum> map3, java.util.Map<java.lang.Object, ? extends java.lang.Object> map4, java.util.Map<java.lang.Long, ? extends java.util.List> map5, java.util.Map<java.lang.Long, ? extends java.util.Map> map6)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion copy(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    jni$_.JByteArray? bs,
    jni$_.JIntArray? is$,
    jni$_.JLongArray? js,
    jni$_.JDoubleArray? ds,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<NIAnEnum?>? list5,
    jni$_.JList<jni$_.JObject?>? list6,
    jni$_.JList<jni$_.JList<jni$_.JObject?>?>? list7,
    jni$_.JList<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? list8,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?>? map2,
    jni$_.JMap<NIAnEnum?, NIAnEnum?>? map3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map4,
    jni$_.JMap<jni$_.JLong?, jni$_.JList<jni$_.JObject?>?>? map5,
    jni$_.JMap<jni$_.JLong?, jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>? map6,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$js = js?.reference ?? jni$_.jNullReference;
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$list6 = list6?.reference ?? jni$_.jNullReference;
    final _$list7 = list7?.reference ?? jni$_.jNullReference;
    final _$list8 = list8?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$map2 = map2?.reference ?? jni$_.jNullReference;
    final _$map3 = map3?.reference ?? jni$_.jNullReference;
    final _$map4 = map4?.reference ?? jni$_.jNullReference;
    final _$map5 = map5?.reference ?? jni$_.jNullReference;
    final _$map6 = map6?.reference ?? jni$_.jNullReference;
    return _copy(
            reference.pointer,
            _id_copy as jni$_.JMethodIDPtr,
            _$boolean.pointer,
            _$long.pointer,
            _$long1.pointer,
            _$double.pointer,
            _$bs.pointer,
            _$is$.pointer,
            _$js.pointer,
            _$ds.pointer,
            _$nIAnEnum.pointer,
            _$nIAnotherEnum.pointer,
            _$string.pointer,
            _$object.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$list2.pointer,
            _$list3.pointer,
            _$list4.pointer,
            _$list5.pointer,
            _$list6.pointer,
            _$list7.pointer,
            _$list8.pointer,
            _$map.pointer,
            _$map1.pointer,
            _$map2.pointer,
            _$map3.pointer,
            _$map4.pointer,
            _$map5.pointer,
            _$map6.pointer)
        .object<NIAllNullableTypesWithoutRecursion>(
            const $NIAllNullableTypesWithoutRecursion$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypesWithoutRecursion.new$2() {
    return NIAllNullableTypesWithoutRecursion.fromReference(
        _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $NIAllNullableTypesWithoutRecursion$NullableType
    extends jni$_.JObjType<NIAllNullableTypesWithoutRecursion?> {
  @jni$_.internal
  const $NIAllNullableTypesWithoutRecursion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypesWithoutRecursion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypesWithoutRecursion? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIAllNullableTypesWithoutRecursion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllNullableTypesWithoutRecursion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($NIAllNullableTypesWithoutRecursion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIAllNullableTypesWithoutRecursion$NullableType) &&
        other is $NIAllNullableTypesWithoutRecursion$NullableType;
  }
}

final class $NIAllNullableTypesWithoutRecursion$Type
    extends jni$_.JObjType<NIAllNullableTypesWithoutRecursion> {
  @jni$_.internal
  const $NIAllNullableTypesWithoutRecursion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypesWithoutRecursion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypesWithoutRecursion fromReference(
          jni$_.JReference reference) =>
      NIAllNullableTypesWithoutRecursion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllNullableTypesWithoutRecursion?> get nullableType =>
      const $NIAllNullableTypesWithoutRecursion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllNullableTypesWithoutRecursion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllNullableTypesWithoutRecursion$Type) &&
        other is $NIAllNullableTypesWithoutRecursion$Type;
  }
}

/// from: `NIAllClassesWrapper$Companion`
class NIAllClassesWrapper$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIAllClassesWrapper$Companion> $type;

  @jni$_.internal
  NIAllClassesWrapper$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllClassesWrapper$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIAllClassesWrapper$Companion$NullableType();
  static const type = $NIAllClassesWrapper$Companion$Type();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LNIAllClassesWrapper;',
  );

  static final _fromList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIAllClassesWrapper fromList(java.util.List<? extends java.lang.Object> list)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(reference.pointer, _id_fromList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllClassesWrapper$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllClassesWrapper$Companion.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $NIAllClassesWrapper$Companion$NullableType
    extends jni$_.JObjType<NIAllClassesWrapper$Companion?> {
  @jni$_.internal
  const $NIAllClassesWrapper$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllClassesWrapper$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllClassesWrapper$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIAllClassesWrapper$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllClassesWrapper$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllClassesWrapper$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllClassesWrapper$Companion$NullableType) &&
        other is $NIAllClassesWrapper$Companion$NullableType;
  }
}

final class $NIAllClassesWrapper$Companion$Type
    extends jni$_.JObjType<NIAllClassesWrapper$Companion> {
  @jni$_.internal
  const $NIAllClassesWrapper$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllClassesWrapper$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllClassesWrapper$Companion fromReference(jni$_.JReference reference) =>
      NIAllClassesWrapper$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllClassesWrapper$Companion?> get nullableType =>
      const $NIAllClassesWrapper$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllClassesWrapper$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllClassesWrapper$Companion$Type) &&
        other is $NIAllClassesWrapper$Companion$Type;
  }
}

/// from: `NIAllClassesWrapper`
class NIAllClassesWrapper extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIAllClassesWrapper> $type;

  @jni$_.internal
  NIAllClassesWrapper.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllClassesWrapper');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIAllClassesWrapper$NullableType();
  static const type = $NIAllClassesWrapper$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAllClassesWrapper$Companion;',
  );

  /// from: `static public final NIAllClassesWrapper$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAllClassesWrapper$Companion get Companion =>
      _id_Companion.get(_class, const $NIAllClassesWrapper$Companion$Type());

  static final _id_new$ = _class.constructorId(
    r'(LNIAllNullableTypes;LNIAllNullableTypesWithoutRecursion;LNIAllTypes;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(NIAllNullableTypes nIAllNullableTypes, NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion, NIAllTypes nIAllTypes, java.util.List<NIAllTypes> list, java.util.List<NIAllNullableTypesWithoutRecursion> list1, java.util.Map<java.lang.Long, NIAllTypes> map, java.util.Map<java.lang.Long, NIAllNullableTypesWithoutRecursion> map1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllClassesWrapper(
    NIAllNullableTypes nIAllNullableTypes,
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
    NIAllTypes? nIAllTypes,
    jni$_.JList<NIAllTypes?> list,
    jni$_.JList<NIAllNullableTypesWithoutRecursion?>? list1,
    jni$_.JMap<jni$_.JLong?, NIAllTypes?> map,
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypesWithoutRecursion?>? map1,
  ) {
    final _$nIAllNullableTypes = nIAllNullableTypes.reference;
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$nIAllTypes = nIAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list.reference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$map = map.reference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    return NIAllClassesWrapper.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$nIAllNullableTypes.pointer,
            _$nIAllNullableTypesWithoutRecursion.pointer,
            _$nIAllTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$map.pointer,
            _$map1.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(LNIAllNullableTypes;LNIAllNullableTypesWithoutRecursion;LNIAllTypes;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(NIAllNullableTypes nIAllNullableTypes, NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion, NIAllTypes nIAllTypes, java.util.List list, java.util.List list1, java.util.Map map, java.util.Map map1, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllClassesWrapper.new$1(
    NIAllNullableTypes? nIAllNullableTypes,
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
    NIAllTypes? nIAllTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map1,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$nIAllNullableTypes =
        nIAllNullableTypes?.reference ?? jni$_.jNullReference;
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$nIAllTypes = nIAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllClassesWrapper.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$nIAllNullableTypes.pointer,
            _$nIAllNullableTypesWithoutRecursion.pointer,
            _$nIAllTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$map.pointer,
            _$map1.pointer,
            i,
            _$defaultConstructorMarker.pointer)
        .reference);
  }

  static final _id_getAllNullableTypes = _class.instanceMethodId(
    r'getAllNullableTypes',
    r'()LNIAllNullableTypes;',
  );

  static final _getAllNullableTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAllNullableTypes getAllNullableTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes getAllNullableTypes() {
    return _getAllNullableTypes(
            reference.pointer, _id_getAllNullableTypes as jni$_.JMethodIDPtr)
        .object<NIAllNullableTypes>(const $NIAllNullableTypes$Type());
  }

  static final _id_getAllNullableTypesWithoutRecursion =
      _class.instanceMethodId(
    r'getAllNullableTypesWithoutRecursion',
    r'()LNIAllNullableTypesWithoutRecursion;',
  );

  static final _getAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public final NIAllNullableTypesWithoutRecursion getAllNullableTypesWithoutRecursion()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion? getAllNullableTypesWithoutRecursion() {
    return _getAllNullableTypesWithoutRecursion(reference.pointer,
            _id_getAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr)
        .object<NIAllNullableTypesWithoutRecursion?>(
            const $NIAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_getAllTypes = _class.instanceMethodId(
    r'getAllTypes',
    r'()LNIAllTypes;',
  );

  static final _getAllTypes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAllTypes getAllTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes? getAllTypes() {
    return _getAllTypes(
            reference.pointer, _id_getAllTypes as jni$_.JMethodIDPtr)
        .object<NIAllTypes?>(const $NIAllTypes$NullableType());
  }

  static final _id_getClassList = _class.instanceMethodId(
    r'getClassList',
    r'()Ljava/util/List;',
  );

  static final _getClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<NIAllTypes> getClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllTypes?> getClassList() {
    return _getClassList(
            reference.pointer, _id_getClassList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<NIAllTypes?>>(
            const jni$_.JListType<NIAllTypes?>($NIAllTypes$NullableType()));
  }

  static final _id_getNullableClassList = _class.instanceMethodId(
    r'getNullableClassList',
    r'()Ljava/util/List;',
  );

  static final _getNullableClassList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<NIAllNullableTypesWithoutRecursion> getNullableClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypesWithoutRecursion?>? getNullableClassList() {
    return _getNullableClassList(
            reference.pointer, _id_getNullableClassList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<NIAllNullableTypesWithoutRecursion?>?>(
            const jni$_.JListNullableType<NIAllNullableTypesWithoutRecursion?>(
                $NIAllNullableTypesWithoutRecursion$NullableType()));
  }

  static final _id_getClassMap = _class.instanceMethodId(
    r'getClassMap',
    r'()Ljava/util/Map;',
  );

  static final _getClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, NIAllTypes> getClassMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllTypes?> getClassMap() {
    return _getClassMap(
            reference.pointer, _id_getClassMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, NIAllTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, NIAllTypes?>(
                jni$_.JLongNullableType(), $NIAllTypes$NullableType()));
  }

  static final _id_getNullableClassMap = _class.instanceMethodId(
    r'getNullableClassMap',
    r'()Ljava/util/Map;',
  );

  static final _getNullableClassMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, NIAllNullableTypesWithoutRecursion> getNullableClassMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypesWithoutRecursion?>?
      getNullableClassMap() {
    return _getNullableClassMap(
            reference.pointer, _id_getNullableClassMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypesWithoutRecursion?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?,
                    NIAllNullableTypesWithoutRecursion?>(
                jni$_.JLongNullableType(),
                $NIAllNullableTypesWithoutRecursion$NullableType()));
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<java.lang.Object> toList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(reference.pointer, _id_toList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>>(
            const jni$_.JListType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()LNIAllNullableTypes;',
  );

  static final _component1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAllNullableTypes component1()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypes component1() {
    return _component1(reference.pointer, _id_component1 as jni$_.JMethodIDPtr)
        .object<NIAllNullableTypes>(const $NIAllNullableTypes$Type());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()LNIAllNullableTypesWithoutRecursion;',
  );

  static final _component2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAllNullableTypesWithoutRecursion component2()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion? component2() {
    return _component2(reference.pointer, _id_component2 as jni$_.JMethodIDPtr)
        .object<NIAllNullableTypesWithoutRecursion?>(
            const $NIAllNullableTypesWithoutRecursion$NullableType());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()LNIAllTypes;',
  );

  static final _component3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final NIAllTypes component3()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes? component3() {
    return _component3(reference.pointer, _id_component3 as jni$_.JMethodIDPtr)
        .object<NIAllTypes?>(const $NIAllTypes$NullableType());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/util/List;',
  );

  static final _component4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<NIAllTypes> component4()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllTypes?> component4() {
    return _component4(reference.pointer, _id_component4 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<NIAllTypes?>>(
            const jni$_.JListType<NIAllTypes?>($NIAllTypes$NullableType()));
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()Ljava/util/List;',
  );

  static final _component5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.List<NIAllNullableTypesWithoutRecursion> component5()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypesWithoutRecursion?>? component5() {
    return _component5(reference.pointer, _id_component5 as jni$_.JMethodIDPtr)
        .object<jni$_.JList<NIAllNullableTypesWithoutRecursion?>?>(
            const jni$_.JListNullableType<NIAllNullableTypesWithoutRecursion?>(
                $NIAllNullableTypesWithoutRecursion$NullableType()));
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()Ljava/util/Map;',
  );

  static final _component6 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, NIAllTypes> component6()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllTypes?> component6() {
    return _component6(reference.pointer, _id_component6 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, NIAllTypes?>>(
            const jni$_.JMapType<jni$_.JLong?, NIAllTypes?>(
                jni$_.JLongNullableType(), $NIAllTypes$NullableType()));
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()Ljava/util/Map;',
  );

  static final _component7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final java.util.Map<java.lang.Long, NIAllNullableTypesWithoutRecursion> component7()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, NIAllNullableTypesWithoutRecursion?>? component7() {
    return _component7(reference.pointer, _id_component7 as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JLong?, NIAllNullableTypesWithoutRecursion?>?>(
            const jni$_.JMapNullableType<jni$_.JLong?,
                    NIAllNullableTypesWithoutRecursion?>(
                jni$_.JLongNullableType(),
                $NIAllNullableTypesWithoutRecursion$NullableType()));
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(LNIAllNullableTypes;LNIAllNullableTypesWithoutRecursion;LNIAllTypes;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;)LNIAllClassesWrapper;',
  );

  static final _copy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public final NIAllClassesWrapper copy(NIAllNullableTypes nIAllNullableTypes, NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion, NIAllTypes nIAllTypes, java.util.List<NIAllTypes> list, java.util.List<NIAllNullableTypesWithoutRecursion> list1, java.util.Map<java.lang.Long, NIAllTypes> map, java.util.Map<java.lang.Long, NIAllNullableTypesWithoutRecursion> map1)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper copy(
    NIAllNullableTypes nIAllNullableTypes,
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
    NIAllTypes? nIAllTypes,
    jni$_.JList<NIAllTypes?> list,
    jni$_.JList<NIAllNullableTypesWithoutRecursion?>? list1,
    jni$_.JMap<jni$_.JLong?, NIAllTypes?> map,
    jni$_.JMap<jni$_.JLong?, NIAllNullableTypesWithoutRecursion?>? map1,
  ) {
    final _$nIAllNullableTypes = nIAllNullableTypes.reference;
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$nIAllTypes = nIAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list.reference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$map = map.reference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    return _copy(
            reference.pointer,
            _id_copy as jni$_.JMethodIDPtr,
            _$nIAllNullableTypes.pointer,
            _$nIAllNullableTypesWithoutRecursion.pointer,
            _$nIAllTypes.pointer,
            _$list.pointer,
            _$list1.pointer,
            _$map.pointer,
            _$map1.pointer)
        .object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $NIAllClassesWrapper$NullableType
    extends jni$_.JObjType<NIAllClassesWrapper?> {
  @jni$_.internal
  const $NIAllClassesWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllClassesWrapper;';

  @jni$_.internal
  @core$_.override
  NIAllClassesWrapper? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIAllClassesWrapper.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllClassesWrapper?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllClassesWrapper$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllClassesWrapper$NullableType) &&
        other is $NIAllClassesWrapper$NullableType;
  }
}

final class $NIAllClassesWrapper$Type
    extends jni$_.JObjType<NIAllClassesWrapper> {
  @jni$_.internal
  const $NIAllClassesWrapper$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllClassesWrapper;';

  @jni$_.internal
  @core$_.override
  NIAllClassesWrapper fromReference(jni$_.JReference reference) =>
      NIAllClassesWrapper.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAllClassesWrapper?> get nullableType =>
      const $NIAllClassesWrapper$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllClassesWrapper$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllClassesWrapper$Type) &&
        other is $NIAllClassesWrapper$Type;
  }
}

/// from: `NIAnEnum$Companion`
class NIAnEnum$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIAnEnum$Companion> $type;

  @jni$_.internal
  NIAnEnum$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAnEnum$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIAnEnum$Companion$NullableType();
  static const type = $NIAnEnum$Companion$Type();
  static final _id_ofRaw = _class.instanceMethodId(
    r'ofRaw',
    r'(I)LNIAnEnum;',
  );

  static final _ofRaw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final NIAnEnum ofRaw(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? ofRaw(
    int i,
  ) {
    return _ofRaw(reference.pointer, _id_ofRaw as jni$_.JMethodIDPtr, i)
        .object<NIAnEnum?>(const $NIAnEnum$NullableType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAnEnum$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAnEnum$Companion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $NIAnEnum$Companion$NullableType
    extends jni$_.JObjType<NIAnEnum$Companion?> {
  @jni$_.internal
  const $NIAnEnum$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnEnum$Companion;';

  @jni$_.internal
  @core$_.override
  NIAnEnum$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIAnEnum$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAnEnum$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnEnum$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnEnum$Companion$NullableType) &&
        other is $NIAnEnum$Companion$NullableType;
  }
}

final class $NIAnEnum$Companion$Type
    extends jni$_.JObjType<NIAnEnum$Companion> {
  @jni$_.internal
  const $NIAnEnum$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnEnum$Companion;';

  @jni$_.internal
  @core$_.override
  NIAnEnum$Companion fromReference(jni$_.JReference reference) =>
      NIAnEnum$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAnEnum$Companion?> get nullableType =>
      const $NIAnEnum$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnEnum$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnEnum$Companion$Type) &&
        other is $NIAnEnum$Companion$Type;
  }
}

/// from: `NIAnEnum`
class NIAnEnum extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIAnEnum> $type;

  @jni$_.internal
  NIAnEnum.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAnEnum');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIAnEnum$NullableType();
  static const type = $NIAnEnum$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAnEnum$Companion;',
  );

  /// from: `static public final NIAnEnum$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum$Companion get Companion =>
      _id_Companion.get(_class, const $NIAnEnum$Companion$Type());

  static final _id_ONE = _class.staticFieldId(
    r'ONE',
    r'LNIAnEnum;',
  );

  /// from: `static public final NIAnEnum ONE`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get ONE => _id_ONE.get(_class, const $NIAnEnum$Type());

  static final _id_TWO = _class.staticFieldId(
    r'TWO',
    r'LNIAnEnum;',
  );

  /// from: `static public final NIAnEnum TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get TWO => _id_TWO.get(_class, const $NIAnEnum$Type());

  static final _id_THREE = _class.staticFieldId(
    r'THREE',
    r'LNIAnEnum;',
  );

  /// from: `static public final NIAnEnum THREE`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get THREE => _id_THREE.get(_class, const $NIAnEnum$Type());

  static final _id_FORTY_TWO = _class.staticFieldId(
    r'FORTY_TWO',
    r'LNIAnEnum;',
  );

  /// from: `static public final NIAnEnum FORTY_TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get FORTY_TWO =>
      _id_FORTY_TWO.get(_class, const $NIAnEnum$Type());

  static final _id_FOUR_HUNDRED_TWENTY_TWO = _class.staticFieldId(
    r'FOUR_HUNDRED_TWENTY_TWO',
    r'LNIAnEnum;',
  );

  /// from: `static public final NIAnEnum FOUR_HUNDRED_TWENTY_TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get FOUR_HUNDRED_TWENTY_TWO =>
      _id_FOUR_HUNDRED_TWENTY_TWO.get(_class, const $NIAnEnum$Type());

  static final _id_getRaw = _class.instanceMethodId(
    r'getRaw',
    r'()I',
  );

  static final _getRaw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int getRaw()`
  int getRaw() {
    return _getRaw(reference.pointer, _id_getRaw as jni$_.JMethodIDPtr).integer;
  }

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[LNIAnEnum;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public NIAnEnum[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<NIAnEnum?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<NIAnEnum?>?>(
            const jni$_.JArrayNullableType<NIAnEnum?>(
                $NIAnEnum$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)LNIAnEnum;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public NIAnEnum valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<NIAnEnum?>(const $NIAnEnum$NullableType());
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public kotlin.enums.EnumEntries<NIAnEnum> getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
            _class.reference.pointer, _id_getEntries as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $NIAnEnum$NullableType extends jni$_.JObjType<NIAnEnum?> {
  @jni$_.internal
  const $NIAnEnum$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnEnum;';

  @jni$_.internal
  @core$_.override
  NIAnEnum? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : NIAnEnum.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAnEnum?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnEnum$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnEnum$NullableType) &&
        other is $NIAnEnum$NullableType;
  }
}

final class $NIAnEnum$Type extends jni$_.JObjType<NIAnEnum> {
  @jni$_.internal
  const $NIAnEnum$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnEnum;';

  @jni$_.internal
  @core$_.override
  NIAnEnum fromReference(jni$_.JReference reference) => NIAnEnum.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAnEnum?> get nullableType => const $NIAnEnum$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnEnum$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnEnum$Type) && other is $NIAnEnum$Type;
  }
}

/// from: `NIAnotherEnum$Companion`
class NIAnotherEnum$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIAnotherEnum$Companion> $type;

  @jni$_.internal
  NIAnotherEnum$Companion.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAnotherEnum$Companion');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIAnotherEnum$Companion$NullableType();
  static const type = $NIAnotherEnum$Companion$Type();
  static final _id_ofRaw = _class.instanceMethodId(
    r'ofRaw',
    r'(I)LNIAnotherEnum;',
  );

  static final _ofRaw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public final NIAnotherEnum ofRaw(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? ofRaw(
    int i,
  ) {
    return _ofRaw(reference.pointer, _id_ofRaw as jni$_.JMethodIDPtr, i)
        .object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAnotherEnum$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAnotherEnum$Companion.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$defaultConstructorMarker.pointer)
        .reference);
  }
}

final class $NIAnotherEnum$Companion$NullableType
    extends jni$_.JObjType<NIAnotherEnum$Companion?> {
  @jni$_.internal
  const $NIAnotherEnum$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnotherEnum$Companion;';

  @jni$_.internal
  @core$_.override
  NIAnotherEnum$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NIAnotherEnum$Companion.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAnotherEnum$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnotherEnum$Companion$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnotherEnum$Companion$NullableType) &&
        other is $NIAnotherEnum$Companion$NullableType;
  }
}

final class $NIAnotherEnum$Companion$Type
    extends jni$_.JObjType<NIAnotherEnum$Companion> {
  @jni$_.internal
  const $NIAnotherEnum$Companion$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnotherEnum$Companion;';

  @jni$_.internal
  @core$_.override
  NIAnotherEnum$Companion fromReference(jni$_.JReference reference) =>
      NIAnotherEnum$Companion.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAnotherEnum$Companion?> get nullableType =>
      const $NIAnotherEnum$Companion$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnotherEnum$Companion$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnotherEnum$Companion$Type) &&
        other is $NIAnotherEnum$Companion$Type;
  }
}

/// from: `NIAnotherEnum`
class NIAnotherEnum extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NIAnotherEnum> $type;

  @jni$_.internal
  NIAnotherEnum.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAnotherEnum');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NIAnotherEnum$NullableType();
  static const type = $NIAnotherEnum$Type();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAnotherEnum$Companion;',
  );

  /// from: `static public final NIAnotherEnum$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnotherEnum$Companion get Companion =>
      _id_Companion.get(_class, const $NIAnotherEnum$Companion$Type());

  static final _id_JUST_IN_CASE = _class.staticFieldId(
    r'JUST_IN_CASE',
    r'LNIAnotherEnum;',
  );

  /// from: `static public final NIAnotherEnum JUST_IN_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnotherEnum get JUST_IN_CASE =>
      _id_JUST_IN_CASE.get(_class, const $NIAnotherEnum$Type());

  static final _id_getRaw = _class.instanceMethodId(
    r'getRaw',
    r'()I',
  );

  static final _getRaw = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final int getRaw()`
  int getRaw() {
    return _getRaw(reference.pointer, _id_getRaw as jni$_.JMethodIDPtr).integer;
  }

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[LNIAnotherEnum;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public NIAnotherEnum[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<NIAnotherEnum?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<NIAnotherEnum?>?>(
            const jni$_.JArrayNullableType<NIAnotherEnum?>(
                $NIAnotherEnum$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)LNIAnotherEnum;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public NIAnotherEnum valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnotherEnum? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType());
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public kotlin.enums.EnumEntries<NIAnotherEnum> getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
            _class.reference.pointer, _id_getEntries as jni$_.JMethodIDPtr)
        .object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $NIAnotherEnum$NullableType extends jni$_.JObjType<NIAnotherEnum?> {
  @jni$_.internal
  const $NIAnotherEnum$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnotherEnum;';

  @jni$_.internal
  @core$_.override
  NIAnotherEnum? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : NIAnotherEnum.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAnotherEnum?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnotherEnum$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnotherEnum$NullableType) &&
        other is $NIAnotherEnum$NullableType;
  }
}

final class $NIAnotherEnum$Type extends jni$_.JObjType<NIAnotherEnum> {
  @jni$_.internal
  const $NIAnotherEnum$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnotherEnum;';

  @jni$_.internal
  @core$_.override
  NIAnotherEnum fromReference(jni$_.JReference reference) =>
      NIAnotherEnum.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NIAnotherEnum?> get nullableType =>
      const $NIAnotherEnum$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnotherEnum$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnotherEnum$Type) &&
        other is $NIAnotherEnum$Type;
  }
}
