// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `NIHostIntegrationCoreApi`
class NIHostIntegrationCoreApi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIHostIntegrationCoreApi> $type;

  @jni$_.internal
  NIHostIntegrationCoreApi.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIHostIntegrationCoreApi');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIHostIntegrationCoreApi?> nullableType =
      $NIHostIntegrationCoreApi$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIHostIntegrationCoreApi> type =
      $NIHostIntegrationCoreApi$Type$();
  static final _id_noop = _class.instanceMethodId(r'noop', r'()V');

  static final _noop =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun noop(): kotlin.Unit`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }

  static final _id_echoAllTypes = _class.instanceMethodId(
    r'echoAllTypes',
    r'(LNIAllTypes;)LNIAllTypes;',
  );

  static final _echoAllTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAllTypes(everything: NIAllTypes): NIAllTypes`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes echoAllTypes(NIAllTypes nIAllTypes) {
    final _$nIAllTypes = nIAllTypes.reference;
    return _echoAllTypes(
      reference.pointer,
      _id_echoAllTypes as jni$_.JMethodIDPtr,
      _$nIAllTypes.pointer,
    ).object<NIAllTypes>(const $NIAllTypes$Type$());
  }

  static final _id_echoInt = _class.instanceMethodId(r'echoInt', r'(J)J');

  static final _echoInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public fun echoInt(anInt: kotlin.Long): kotlin.Long`
  int echoInt(int j) {
    return _echoInt(
      reference.pointer,
      _id_echoInt as jni$_.JMethodIDPtr,
      j,
    ).long;
  }

  static final _id_echoDouble = _class.instanceMethodId(r'echoDouble', r'(D)D');

  static final _echoDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public fun echoDouble(aDouble: kotlin.Double): kotlin.Double`
  double echoDouble(double d) {
    return _echoDouble(
      reference.pointer,
      _id_echoDouble as jni$_.JMethodIDPtr,
      d,
    ).doubleFloat;
  }

  static final _id_echoBool = _class.instanceMethodId(r'echoBool', r'(Z)Z');

  static final _echoBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public fun echoBool(aBool: kotlin.Boolean): kotlin.Boolean`
  bool echoBool(bool z) {
    return _echoBool(
      reference.pointer,
      _id_echoBool as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_echoString = _class.instanceMethodId(
    r'echoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoString(aString: kotlin.String): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoString(jni$_.JString string) {
    final _$string = string.reference;
    return _echoString(
      reference.pointer,
      _id_echoString as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_echoObject = _class.instanceMethodId(
    r'echoObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoObject(anObject: kotlin.Any): kotlin.Any`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject echoObject(jni$_.JObject object) {
    final _$object = object.reference;
    return _echoObject(
      reference.pointer,
      _id_echoObject as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_echoList = _class.instanceMethodId(
    r'echoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoList(list: kotlin.collections.List<kotlin.Any?>): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> echoList(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _echoList(
      reference.pointer,
      _id_echoList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_echoStringList = _class.instanceMethodId(
    r'echoStringList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoStringList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoStringList(stringList: kotlin.collections.List<kotlin.String?>): kotlin.collections.List<kotlin.String?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> echoStringList(jni$_.JList<jni$_.JString?> list) {
    final _$list = list.reference;
    return _echoStringList(
      reference.pointer,
      _id_echoStringList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JString?>>(
      const jni$_.$JList$Type$<jni$_.JString?>(jni$_.$JString$NullableType$()),
    );
  }

  static final _id_echoIntList = _class.instanceMethodId(
    r'echoIntList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoIntList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoIntList(intList: kotlin.collections.List<kotlin.Long?>): kotlin.collections.List<kotlin.Long?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?> echoIntList(jni$_.JList<jni$_.JLong?> list) {
    final _$list = list.reference;
    return _echoIntList(
      reference.pointer,
      _id_echoIntList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JLong?>>(
      const jni$_.$JList$Type$<jni$_.JLong?>(jni$_.$JLong$NullableType$()),
    );
  }

  static final _id_echoDoubleList = _class.instanceMethodId(
    r'echoDoubleList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoDoubleList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoDoubleList(doubleList: kotlin.collections.List<kotlin.Double?>): kotlin.collections.List<kotlin.Double?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?> echoDoubleList(jni$_.JList<jni$_.JDouble?> list) {
    final _$list = list.reference;
    return _echoDoubleList(
      reference.pointer,
      _id_echoDoubleList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JDouble?>>(
      const jni$_.$JList$Type$<jni$_.JDouble?>(jni$_.$JDouble$NullableType$()),
    );
  }

  static final _id_echoBoolList = _class.instanceMethodId(
    r'echoBoolList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoBoolList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoBoolList(boolList: kotlin.collections.List<kotlin.Boolean?>): kotlin.collections.List<kotlin.Boolean?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?> echoBoolList(jni$_.JList<jni$_.JBoolean?> list) {
    final _$list = list.reference;
    return _echoBoolList(
      reference.pointer,
      _id_echoBoolList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JBoolean?>>(
      const jni$_.$JList$Type$<jni$_.JBoolean?>(
        jni$_.$JBoolean$NullableType$(),
      ),
    );
  }

  static final _id_echoEnumList = _class.instanceMethodId(
    r'echoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoEnumList(enumList: kotlin.collections.List<NIAnEnum?>): kotlin.collections.List<NIAnEnum?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?> echoEnumList(jni$_.JList<NIAnEnum?> list) {
    final _$list = list.reference;
    return _echoEnumList(
      reference.pointer,
      _id_echoEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum?>>(
      const jni$_.$JList$Type$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_echoClassList = _class.instanceMethodId(
    r'echoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoClassList(classList: kotlin.collections.List<NIAllNullableTypesWithoutRecursion?>): kotlin.collections.List<NIAllNullableTypesWithoutRecursion?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypesWithoutRecursion?> echoClassList(
    jni$_.JList<NIAllNullableTypesWithoutRecursion?> list,
  ) {
    final _$list = list.reference;
    return _echoClassList(
      reference.pointer,
      _id_echoClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypesWithoutRecursion?>>(
      const jni$_.$JList$Type$<NIAllNullableTypesWithoutRecursion?>(
        $NIAllNullableTypesWithoutRecursion$NullableType$(),
      ),
    );
  }

  static final _id_echoNonNullEnumList = _class.instanceMethodId(
    r'echoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullEnumList(enumList: kotlin.collections.List<NIAnEnum>): kotlin.collections.List<NIAnEnum>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> echoNonNullEnumList(jni$_.JList<NIAnEnum> list) {
    final _$list = list.reference;
    return _echoNonNullEnumList(
      reference.pointer,
      _id_echoNonNullEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum>>(
      const jni$_.$JList$Type$<NIAnEnum>($NIAnEnum$Type$()),
    );
  }

  static final _id_echoNonNullClassList = _class.instanceMethodId(
    r'echoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullClassList(classList: kotlin.collections.List<NIAllNullableTypesWithoutRecursion>): kotlin.collections.List<NIAllNullableTypesWithoutRecursion>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypesWithoutRecursion> echoNonNullClassList(
    jni$_.JList<NIAllNullableTypesWithoutRecursion> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullClassList(
      reference.pointer,
      _id_echoNonNullClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypesWithoutRecursion>>(
      const jni$_.$JList$Type$<NIAllNullableTypesWithoutRecursion>(
        $NIAllNullableTypesWithoutRecursion$Type$(),
      ),
    );
  }

  static final _id_echoMap = _class.instanceMethodId(
    r'echoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoMap(map: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _echoMap(
      reference.pointer,
      _id_echoMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
      const jni$_.$JMap$Type$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_echoStringMap = _class.instanceMethodId(
    r'echoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoStringMap(stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>): kotlin.collections.Map<kotlin.String?, kotlin.String?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _echoStringMap(
      reference.pointer,
      _id_echoStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
      const jni$_.$JMap$Type$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_echoIntMap = _class.instanceMethodId(
    r'echoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoIntMap(intMap: kotlin.collections.Map<kotlin.Long?, kotlin.Long?>): kotlin.collections.Map<kotlin.Long?, kotlin.Long?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _echoIntMap(
      reference.pointer,
      _id_echoIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
      const jni$_.$JMap$Type$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_echoNonNullStringMap = _class.instanceMethodId(
    r'echoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullStringMap(stringMap: kotlin.collections.Map<kotlin.String, kotlin.String>): kotlin.collections.Map<kotlin.String, kotlin.String>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullStringMap(
      reference.pointer,
      _id_echoNonNullStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
      const jni$_.$JMap$Type$<jni$_.JString, jni$_.JString>(
        jni$_.$JString$Type$(),
        jni$_.$JString$Type$(),
      ),
    );
  }

  static final _id_echoClassWrapper = _class.instanceMethodId(
    r'echoClassWrapper',
    r'(LNIAllClassesWrapper;)LNIAllClassesWrapper;',
  );

  static final _echoClassWrapper =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoClassWrapper(wrapper: NIAllClassesWrapper): NIAllClassesWrapper`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper echoClassWrapper(
    NIAllClassesWrapper nIAllClassesWrapper,
  ) {
    final _$nIAllClassesWrapper = nIAllClassesWrapper.reference;
    return _echoClassWrapper(
      reference.pointer,
      _id_echoClassWrapper as jni$_.JMethodIDPtr,
      _$nIAllClassesWrapper.pointer,
    ).object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type$());
  }

  static final _id_echoEnum = _class.instanceMethodId(
    r'echoEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoEnum(anEnum: NIAnEnum): NIAnEnum`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum echoEnum(NIAnEnum nIAnEnum) {
    final _$nIAnEnum = nIAnEnum.reference;
    return _echoEnum(
      reference.pointer,
      _id_echoEnum as jni$_.JMethodIDPtr,
      _$nIAnEnum.pointer,
    ).object<NIAnEnum>(const $NIAnEnum$Type$());
  }

  static final _id_echoAnotherEnum = _class.instanceMethodId(
    r'echoAnotherEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoAnotherEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAnotherEnum(anotherEnum: NIAnotherEnum): NIAnotherEnum`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum echoAnotherEnum(NIAnotherEnum nIAnotherEnum) {
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    return _echoAnotherEnum(
      reference.pointer,
      _id_echoAnotherEnum as jni$_.JMethodIDPtr,
      _$nIAnotherEnum.pointer,
    ).object<NIAnotherEnum>(const $NIAnotherEnum$Type$());
  }

  static final _id_echoAllNullableTypesWithoutRecursion = _class.instanceMethodId(
    r'echoAllNullableTypesWithoutRecursion',
    r'(LNIAllNullableTypesWithoutRecursion;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _echoAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAllNullableTypesWithoutRecursion(everything: NIAllNullableTypesWithoutRecursion?): NIAllNullableTypesWithoutRecursion?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion? echoAllNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
  ) {
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypesWithoutRecursion(
      reference.pointer,
      _id_echoAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
      _$nIAllNullableTypesWithoutRecursion.pointer,
    ).object<NIAllNullableTypesWithoutRecursion?>(
      const $NIAllNullableTypesWithoutRecursion$NullableType$(),
    );
  }

  static final _id_extractNestedNullableString = _class.instanceMethodId(
    r'extractNestedNullableString',
    r'(LNIAllClassesWrapper;)Ljava/lang/String;',
  );

  static final _extractNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun extractNestedNullableString(wrapper: NIAllClassesWrapper): kotlin.String?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? extractNestedNullableString(
    NIAllClassesWrapper nIAllClassesWrapper,
  ) {
    final _$nIAllClassesWrapper = nIAllClassesWrapper.reference;
    return _extractNestedNullableString(
      reference.pointer,
      _id_extractNestedNullableString as jni$_.JMethodIDPtr,
      _$nIAllClassesWrapper.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_createNestedNullableString = _class.instanceMethodId(
    r'createNestedNullableString',
    r'(Ljava/lang/String;)LNIAllClassesWrapper;',
  );

  static final _createNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun createNestedNullableString(nullableString: kotlin.String?): NIAllClassesWrapper`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper createNestedNullableString(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createNestedNullableString(
      reference.pointer,
      _id_createNestedNullableString as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type$());
  }

  static final _id_sendMultipleNullableTypes = _class.instanceMethodId(
    r'sendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _sendMultipleNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun sendMultipleNullableTypes(aNullableBool: kotlin.Boolean?, aNullableInt: kotlin.Long?, aNullableString: kotlin.String?): NIAllNullableTypesWithoutRecursion`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion sendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypes(
      reference.pointer,
      _id_sendMultipleNullableTypes as jni$_.JMethodIDPtr,
      _$boolean.pointer,
      _$long.pointer,
      _$string.pointer,
    ).object<NIAllNullableTypesWithoutRecursion>(
      const $NIAllNullableTypesWithoutRecursion$Type$(),
    );
  }

  static final _id_sendMultipleNullableTypesWithoutRecursion = _class
      .instanceMethodId(
        r'sendMultipleNullableTypesWithoutRecursion',
        r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypesWithoutRecursion;',
      );

  static final _sendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun sendMultipleNullableTypesWithoutRecursion(aNullableBool: kotlin.Boolean?, aNullableInt: kotlin.Long?, aNullableString: kotlin.String?): NIAllNullableTypesWithoutRecursion`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypesWithoutRecursion(
      reference.pointer,
      _id_sendMultipleNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
      _$boolean.pointer,
      _$long.pointer,
      _$string.pointer,
    ).object<NIAllNullableTypesWithoutRecursion>(
      const $NIAllNullableTypesWithoutRecursion$Type$(),
    );
  }

  static final _id_echoNullableInt = _class.instanceMethodId(
    r'echoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoNullableInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableInt(aNullableInt: kotlin.Long?): kotlin.Long?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoNullableInt(jni$_.JLong? long) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoNullableInt(
      reference.pointer,
      _id_echoNullableInt as jni$_.JMethodIDPtr,
      _$long.pointer,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_echoNullableDouble = _class.instanceMethodId(
    r'echoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _echoNullableDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableDouble(aNullableDouble: kotlin.Double?): kotlin.Double?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? echoNullableDouble(jni$_.JDouble? double) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _echoNullableDouble(
      reference.pointer,
      _id_echoNullableDouble as jni$_.JMethodIDPtr,
      _$double.pointer,
    ).object<jni$_.JDouble?>(const jni$_.$JDouble$NullableType$());
  }

  static final _id_echoNullableBool = _class.instanceMethodId(
    r'echoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _echoNullableBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableBool(aNullableBool: kotlin.Boolean?): kotlin.Boolean?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? echoNullableBool(jni$_.JBoolean? boolean) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _echoNullableBool(
      reference.pointer,
      _id_echoNullableBool as jni$_.JMethodIDPtr,
      _$boolean.pointer,
    ).object<jni$_.JBoolean?>(const jni$_.$JBoolean$NullableType$());
  }

  static final _id_echoNullableString = _class.instanceMethodId(
    r'echoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableString(aNullableString: kotlin.String?): kotlin.String?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNullableString(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNullableString(
      reference.pointer,
      _id_echoNullableString as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_echoNullableObject = _class.instanceMethodId(
    r'echoNullableObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoNullableObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableObject(aNullableObject: kotlin.Any?): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? echoNullableObject(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _echoNullableObject(
      reference.pointer,
      _id_echoNullableObject as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_echoNullableList = _class.instanceMethodId(
    r'echoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableList(aNullableList: kotlin.collections.List<kotlin.Any?>?): kotlin.collections.List<kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? echoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableList(
      reference.pointer,
      _id_echoNullableList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableEnumList = _class.instanceMethodId(
    r'echoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableEnumList(enumList: kotlin.collections.List<NIAnEnum?>?): kotlin.collections.List<NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? echoNullableEnumList(jni$_.JList<NIAnEnum?>? list) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumList(
      reference.pointer,
      _id_echoNullableEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum?>?>(
      const jni$_.$JList$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_echoNullableClassList = _class.instanceMethodId(
    r'echoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableClassList(classList: kotlin.collections.List<NIAllNullableTypesWithoutRecursion?>?): kotlin.collections.List<NIAllNullableTypesWithoutRecursion?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypesWithoutRecursion?>? echoNullableClassList(
    jni$_.JList<NIAllNullableTypesWithoutRecursion?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableClassList(
      reference.pointer,
      _id_echoNullableClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypesWithoutRecursion?>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypesWithoutRecursion?>(
        $NIAllNullableTypesWithoutRecursion$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableMap = _class.instanceMethodId(
    r'echoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableMap(map: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableMap(
      reference.pointer,
      _id_echoNullableMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableStringMap = _class.instanceMethodId(
    r'echoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableStringMap(stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>?): kotlin.collections.Map<kotlin.String?, kotlin.String?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableStringMap(
      reference.pointer,
      _id_echoNullableStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableNonNullStringMap = _class.instanceMethodId(
    r'echoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullStringMap(stringMap: kotlin.collections.Map<kotlin.String, kotlin.String>?): kotlin.collections.Map<kotlin.String, kotlin.String>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullStringMap(
      reference.pointer,
      _id_echoNullableNonNullStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString, jni$_.JString>(
        jni$_.$JString$Type$(),
        jni$_.$JString$Type$(),
      ),
    );
  }

  static final _id_echoNullableEnum = _class.instanceMethodId(
    r'echoNullableEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableEnum(anEnum: NIAnEnum?): NIAnEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? echoNullableEnum(NIAnEnum? nIAnEnum) {
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    return _echoNullableEnum(
      reference.pointer,
      _id_echoNullableEnum as jni$_.JMethodIDPtr,
      _$nIAnEnum.pointer,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_echoAnotherNullableEnum = _class.instanceMethodId(
    r'echoAnotherNullableEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoAnotherNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAnotherNullableEnum(anotherEnum: NIAnotherEnum?): NIAnotherEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? echoAnotherNullableEnum(NIAnotherEnum? nIAnotherEnum) {
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    return _echoAnotherNullableEnum(
      reference.pointer,
      _id_echoAnotherNullableEnum as jni$_.JMethodIDPtr,
      _$nIAnotherEnum.pointer,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }
}

final class $NIHostIntegrationCoreApi$NullableType$
    extends jni$_.JType<NIHostIntegrationCoreApi?> {
  @jni$_.internal
  const $NIHostIntegrationCoreApi$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  NIHostIntegrationCoreApi? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : NIHostIntegrationCoreApi.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIHostIntegrationCoreApi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIHostIntegrationCoreApi$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostIntegrationCoreApi$NullableType$) &&
        other is $NIHostIntegrationCoreApi$NullableType$;
  }
}

final class $NIHostIntegrationCoreApi$Type$
    extends jni$_.JType<NIHostIntegrationCoreApi> {
  @jni$_.internal
  const $NIHostIntegrationCoreApi$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostIntegrationCoreApi;';

  @jni$_.internal
  @core$_.override
  NIHostIntegrationCoreApi fromReference(jni$_.JReference reference) =>
      NIHostIntegrationCoreApi.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIHostIntegrationCoreApi?> get nullableType =>
      const $NIHostIntegrationCoreApi$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIHostIntegrationCoreApi$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostIntegrationCoreApi$Type$) &&
        other is $NIHostIntegrationCoreApi$Type$;
  }
}

/// from: `NIHostIntegrationCoreApiRegistrar`
class NIHostIntegrationCoreApiRegistrar extends NIHostIntegrationCoreApi {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIHostIntegrationCoreApiRegistrar> $type;

  @jni$_.internal
  NIHostIntegrationCoreApiRegistrar.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'NIHostIntegrationCoreApiRegistrar',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIHostIntegrationCoreApiRegistrar?> nullableType =
      $NIHostIntegrationCoreApiRegistrar$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIHostIntegrationCoreApiRegistrar> type =
      $NIHostIntegrationCoreApiRegistrar$Type$();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIHostIntegrationCoreApiRegistrar() {
    return NIHostIntegrationCoreApiRegistrar.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_getApi = _class.instanceMethodId(
    r'getApi',
    r'()LNIHostIntegrationCoreApi;',
  );

  static final _getApi =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIHostIntegrationCoreApi getApi()`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostIntegrationCoreApi? getApi() {
    return _getApi(
      reference.pointer,
      _id_getApi as jni$_.JMethodIDPtr,
    ).object<NIHostIntegrationCoreApi?>(
      const $NIHostIntegrationCoreApi$NullableType$(),
    );
  }

  static final _id_setApi = _class.instanceMethodId(
    r'setApi',
    r'(LNIHostIntegrationCoreApi;)V',
  );

  static final _setApi =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void setApi(NIHostIntegrationCoreApi nIHostIntegrationCoreApi)`
  void setApi(NIHostIntegrationCoreApi? nIHostIntegrationCoreApi) {
    final _$nIHostIntegrationCoreApi =
        nIHostIntegrationCoreApi?.reference ?? jni$_.jNullReference;
    _setApi(
      reference.pointer,
      _id_setApi as jni$_.JMethodIDPtr,
      _$nIHostIntegrationCoreApi.pointer,
    ).check();
  }

  static final _id_register = _class.instanceMethodId(
    r'register',
    r'(LNIHostIntegrationCoreApi;Ljava/lang/String;)LNIHostIntegrationCoreApiRegistrar;',
  );

  static final _register =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun register(api: NIHostIntegrationCoreApi, name: kotlin.String): NIHostIntegrationCoreApiRegistrar`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostIntegrationCoreApiRegistrar register(
    NIHostIntegrationCoreApi nIHostIntegrationCoreApi,
    jni$_.JString string,
  ) {
    final _$nIHostIntegrationCoreApi = nIHostIntegrationCoreApi.reference;
    final _$string = string.reference;
    return _register(
      reference.pointer,
      _id_register as jni$_.JMethodIDPtr,
      _$nIHostIntegrationCoreApi.pointer,
      _$string.pointer,
    ).object<NIHostIntegrationCoreApiRegistrar>(
      const $NIHostIntegrationCoreApiRegistrar$Type$(),
    );
  }

  static final _id_getInstance = _class.instanceMethodId(
    r'getInstance',
    r'(Ljava/lang/String;)LNIHostIntegrationCoreApiRegistrar;',
  );

  static final _getInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun getInstance(name: kotlin.String): NIHostIntegrationCoreApiRegistrar?`
  /// The returned object must be released after use, by calling the [release] method.
  NIHostIntegrationCoreApiRegistrar? getInstance(jni$_.JString string) {
    final _$string = string.reference;
    return _getInstance(
      reference.pointer,
      _id_getInstance as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<NIHostIntegrationCoreApiRegistrar?>(
      const $NIHostIntegrationCoreApiRegistrar$NullableType$(),
    );
  }

  static final _id_noop = _class.instanceMethodId(r'noop', r'()V');

  static final _noop =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun noop(): kotlin.Unit`
  void noop() {
    _noop(reference.pointer, _id_noop as jni$_.JMethodIDPtr).check();
  }

  static final _id_echoAllTypes = _class.instanceMethodId(
    r'echoAllTypes',
    r'(LNIAllTypes;)LNIAllTypes;',
  );

  static final _echoAllTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAllTypes(everything: NIAllTypes): NIAllTypes`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes echoAllTypes(NIAllTypes nIAllTypes) {
    final _$nIAllTypes = nIAllTypes.reference;
    return _echoAllTypes(
      reference.pointer,
      _id_echoAllTypes as jni$_.JMethodIDPtr,
      _$nIAllTypes.pointer,
    ).object<NIAllTypes>(const $NIAllTypes$Type$());
  }

  static final _id_echoInt = _class.instanceMethodId(r'echoInt', r'(J)J');

  static final _echoInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public fun echoInt(anInt: kotlin.Long): kotlin.Long`
  int echoInt(int j) {
    return _echoInt(
      reference.pointer,
      _id_echoInt as jni$_.JMethodIDPtr,
      j,
    ).long;
  }

  static final _id_echoDouble = _class.instanceMethodId(r'echoDouble', r'(D)D');

  static final _echoDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public fun echoDouble(aDouble: kotlin.Double): kotlin.Double`
  double echoDouble(double d) {
    return _echoDouble(
      reference.pointer,
      _id_echoDouble as jni$_.JMethodIDPtr,
      d,
    ).doubleFloat;
  }

  static final _id_echoBool = _class.instanceMethodId(r'echoBool', r'(Z)Z');

  static final _echoBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public fun echoBool(aBool: kotlin.Boolean): kotlin.Boolean`
  bool echoBool(bool z) {
    return _echoBool(
      reference.pointer,
      _id_echoBool as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_echoString = _class.instanceMethodId(
    r'echoString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoString(aString: kotlin.String): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echoString(jni$_.JString string) {
    final _$string = string.reference;
    return _echoString(
      reference.pointer,
      _id_echoString as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_echoObject = _class.instanceMethodId(
    r'echoObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoObject(anObject: kotlin.Any): kotlin.Any`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject echoObject(jni$_.JObject object) {
    final _$object = object.reference;
    return _echoObject(
      reference.pointer,
      _id_echoObject as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_echoList = _class.instanceMethodId(
    r'echoList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoList(list: kotlin.collections.List<kotlin.Any?>): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> echoList(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _echoList(
      reference.pointer,
      _id_echoList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_echoStringList = _class.instanceMethodId(
    r'echoStringList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoStringList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoStringList(stringList: kotlin.collections.List<kotlin.String?>): kotlin.collections.List<kotlin.String?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> echoStringList(jni$_.JList<jni$_.JString?> list) {
    final _$list = list.reference;
    return _echoStringList(
      reference.pointer,
      _id_echoStringList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JString?>>(
      const jni$_.$JList$Type$<jni$_.JString?>(jni$_.$JString$NullableType$()),
    );
  }

  static final _id_echoIntList = _class.instanceMethodId(
    r'echoIntList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoIntList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoIntList(intList: kotlin.collections.List<kotlin.Long?>): kotlin.collections.List<kotlin.Long?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?> echoIntList(jni$_.JList<jni$_.JLong?> list) {
    final _$list = list.reference;
    return _echoIntList(
      reference.pointer,
      _id_echoIntList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JLong?>>(
      const jni$_.$JList$Type$<jni$_.JLong?>(jni$_.$JLong$NullableType$()),
    );
  }

  static final _id_echoDoubleList = _class.instanceMethodId(
    r'echoDoubleList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoDoubleList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoDoubleList(doubleList: kotlin.collections.List<kotlin.Double?>): kotlin.collections.List<kotlin.Double?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?> echoDoubleList(jni$_.JList<jni$_.JDouble?> list) {
    final _$list = list.reference;
    return _echoDoubleList(
      reference.pointer,
      _id_echoDoubleList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JDouble?>>(
      const jni$_.$JList$Type$<jni$_.JDouble?>(jni$_.$JDouble$NullableType$()),
    );
  }

  static final _id_echoBoolList = _class.instanceMethodId(
    r'echoBoolList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoBoolList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoBoolList(boolList: kotlin.collections.List<kotlin.Boolean?>): kotlin.collections.List<kotlin.Boolean?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?> echoBoolList(jni$_.JList<jni$_.JBoolean?> list) {
    final _$list = list.reference;
    return _echoBoolList(
      reference.pointer,
      _id_echoBoolList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JBoolean?>>(
      const jni$_.$JList$Type$<jni$_.JBoolean?>(
        jni$_.$JBoolean$NullableType$(),
      ),
    );
  }

  static final _id_echoEnumList = _class.instanceMethodId(
    r'echoEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoEnumList(enumList: kotlin.collections.List<NIAnEnum?>): kotlin.collections.List<NIAnEnum?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?> echoEnumList(jni$_.JList<NIAnEnum?> list) {
    final _$list = list.reference;
    return _echoEnumList(
      reference.pointer,
      _id_echoEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum?>>(
      const jni$_.$JList$Type$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_echoClassList = _class.instanceMethodId(
    r'echoClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoClassList(classList: kotlin.collections.List<NIAllNullableTypesWithoutRecursion?>): kotlin.collections.List<NIAllNullableTypesWithoutRecursion?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypesWithoutRecursion?> echoClassList(
    jni$_.JList<NIAllNullableTypesWithoutRecursion?> list,
  ) {
    final _$list = list.reference;
    return _echoClassList(
      reference.pointer,
      _id_echoClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypesWithoutRecursion?>>(
      const jni$_.$JList$Type$<NIAllNullableTypesWithoutRecursion?>(
        $NIAllNullableTypesWithoutRecursion$NullableType$(),
      ),
    );
  }

  static final _id_echoNonNullEnumList = _class.instanceMethodId(
    r'echoNonNullEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullEnumList(enumList: kotlin.collections.List<NIAnEnum>): kotlin.collections.List<NIAnEnum>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> echoNonNullEnumList(jni$_.JList<NIAnEnum> list) {
    final _$list = list.reference;
    return _echoNonNullEnumList(
      reference.pointer,
      _id_echoNonNullEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum>>(
      const jni$_.$JList$Type$<NIAnEnum>($NIAnEnum$Type$()),
    );
  }

  static final _id_echoNonNullClassList = _class.instanceMethodId(
    r'echoNonNullClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNonNullClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullClassList(classList: kotlin.collections.List<NIAllNullableTypesWithoutRecursion>): kotlin.collections.List<NIAllNullableTypesWithoutRecursion>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypesWithoutRecursion> echoNonNullClassList(
    jni$_.JList<NIAllNullableTypesWithoutRecursion> list,
  ) {
    final _$list = list.reference;
    return _echoNonNullClassList(
      reference.pointer,
      _id_echoNonNullClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypesWithoutRecursion>>(
      const jni$_.$JList$Type$<NIAllNullableTypesWithoutRecursion>(
        $NIAllNullableTypesWithoutRecursion$Type$(),
      ),
    );
  }

  static final _id_echoMap = _class.instanceMethodId(
    r'echoMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoMap(map: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?> echoMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?> map,
  ) {
    final _$map = map.reference;
    return _echoMap(
      reference.pointer,
      _id_echoMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>>(
      const jni$_.$JMap$Type$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_echoStringMap = _class.instanceMethodId(
    r'echoStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoStringMap(stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>): kotlin.collections.Map<kotlin.String?, kotlin.String?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?> echoStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?> map,
  ) {
    final _$map = map.reference;
    return _echoStringMap(
      reference.pointer,
      _id_echoStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>>(
      const jni$_.$JMap$Type$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_echoIntMap = _class.instanceMethodId(
    r'echoIntMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoIntMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoIntMap(intMap: kotlin.collections.Map<kotlin.Long?, kotlin.Long?>): kotlin.collections.Map<kotlin.Long?, kotlin.Long?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JLong?, jni$_.JLong?> echoIntMap(
    jni$_.JMap<jni$_.JLong?, jni$_.JLong?> map,
  ) {
    final _$map = map.reference;
    return _echoIntMap(
      reference.pointer,
      _id_echoIntMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JLong?, jni$_.JLong?>>(
      const jni$_.$JMap$Type$<jni$_.JLong?, jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_echoNonNullStringMap = _class.instanceMethodId(
    r'echoNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNonNullStringMap(stringMap: kotlin.collections.Map<kotlin.String, kotlin.String>): kotlin.collections.Map<kotlin.String, kotlin.String>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> echoNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString> map,
  ) {
    final _$map = map.reference;
    return _echoNonNullStringMap(
      reference.pointer,
      _id_echoNonNullStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
      const jni$_.$JMap$Type$<jni$_.JString, jni$_.JString>(
        jni$_.$JString$Type$(),
        jni$_.$JString$Type$(),
      ),
    );
  }

  static final _id_echoClassWrapper = _class.instanceMethodId(
    r'echoClassWrapper',
    r'(LNIAllClassesWrapper;)LNIAllClassesWrapper;',
  );

  static final _echoClassWrapper =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoClassWrapper(wrapper: NIAllClassesWrapper): NIAllClassesWrapper`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper echoClassWrapper(
    NIAllClassesWrapper nIAllClassesWrapper,
  ) {
    final _$nIAllClassesWrapper = nIAllClassesWrapper.reference;
    return _echoClassWrapper(
      reference.pointer,
      _id_echoClassWrapper as jni$_.JMethodIDPtr,
      _$nIAllClassesWrapper.pointer,
    ).object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type$());
  }

  static final _id_echoEnum = _class.instanceMethodId(
    r'echoEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoEnum(anEnum: NIAnEnum): NIAnEnum`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum echoEnum(NIAnEnum nIAnEnum) {
    final _$nIAnEnum = nIAnEnum.reference;
    return _echoEnum(
      reference.pointer,
      _id_echoEnum as jni$_.JMethodIDPtr,
      _$nIAnEnum.pointer,
    ).object<NIAnEnum>(const $NIAnEnum$Type$());
  }

  static final _id_echoAnotherEnum = _class.instanceMethodId(
    r'echoAnotherEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoAnotherEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAnotherEnum(anotherEnum: NIAnotherEnum): NIAnotherEnum`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum echoAnotherEnum(NIAnotherEnum nIAnotherEnum) {
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    return _echoAnotherEnum(
      reference.pointer,
      _id_echoAnotherEnum as jni$_.JMethodIDPtr,
      _$nIAnotherEnum.pointer,
    ).object<NIAnotherEnum>(const $NIAnotherEnum$Type$());
  }

  static final _id_echoAllNullableTypesWithoutRecursion = _class.instanceMethodId(
    r'echoAllNullableTypesWithoutRecursion',
    r'(LNIAllNullableTypesWithoutRecursion;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _echoAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAllNullableTypesWithoutRecursion(everything: NIAllNullableTypesWithoutRecursion?): NIAllNullableTypesWithoutRecursion?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion? echoAllNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
  ) {
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    return _echoAllNullableTypesWithoutRecursion(
      reference.pointer,
      _id_echoAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
      _$nIAllNullableTypesWithoutRecursion.pointer,
    ).object<NIAllNullableTypesWithoutRecursion?>(
      const $NIAllNullableTypesWithoutRecursion$NullableType$(),
    );
  }

  static final _id_extractNestedNullableString = _class.instanceMethodId(
    r'extractNestedNullableString',
    r'(LNIAllClassesWrapper;)Ljava/lang/String;',
  );

  static final _extractNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun extractNestedNullableString(wrapper: NIAllClassesWrapper): kotlin.String?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? extractNestedNullableString(
    NIAllClassesWrapper nIAllClassesWrapper,
  ) {
    final _$nIAllClassesWrapper = nIAllClassesWrapper.reference;
    return _extractNestedNullableString(
      reference.pointer,
      _id_extractNestedNullableString as jni$_.JMethodIDPtr,
      _$nIAllClassesWrapper.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_createNestedNullableString = _class.instanceMethodId(
    r'createNestedNullableString',
    r'(Ljava/lang/String;)LNIAllClassesWrapper;',
  );

  static final _createNestedNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun createNestedNullableString(nullableString: kotlin.String?): NIAllClassesWrapper`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper createNestedNullableString(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createNestedNullableString(
      reference.pointer,
      _id_createNestedNullableString as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type$());
  }

  static final _id_sendMultipleNullableTypes = _class.instanceMethodId(
    r'sendMultipleNullableTypes',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _sendMultipleNullableTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun sendMultipleNullableTypes(aNullableBool: kotlin.Boolean?, aNullableInt: kotlin.Long?, aNullableString: kotlin.String?): NIAllNullableTypesWithoutRecursion`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion sendMultipleNullableTypes(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypes(
      reference.pointer,
      _id_sendMultipleNullableTypes as jni$_.JMethodIDPtr,
      _$boolean.pointer,
      _$long.pointer,
      _$string.pointer,
    ).object<NIAllNullableTypesWithoutRecursion>(
      const $NIAllNullableTypesWithoutRecursion$Type$(),
    );
  }

  static final _id_sendMultipleNullableTypesWithoutRecursion = _class
      .instanceMethodId(
        r'sendMultipleNullableTypesWithoutRecursion',
        r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/String;)LNIAllNullableTypesWithoutRecursion;',
      );

  static final _sendMultipleNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun sendMultipleNullableTypesWithoutRecursion(aNullableBool: kotlin.Boolean?, aNullableInt: kotlin.Long?, aNullableString: kotlin.String?): NIAllNullableTypesWithoutRecursion`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion sendMultipleNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JString? string,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _sendMultipleNullableTypesWithoutRecursion(
      reference.pointer,
      _id_sendMultipleNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
      _$boolean.pointer,
      _$long.pointer,
      _$string.pointer,
    ).object<NIAllNullableTypesWithoutRecursion>(
      const $NIAllNullableTypesWithoutRecursion$Type$(),
    );
  }

  static final _id_echoNullableInt = _class.instanceMethodId(
    r'echoNullableInt',
    r'(Ljava/lang/Long;)Ljava/lang/Long;',
  );

  static final _echoNullableInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableInt(aNullableInt: kotlin.Long?): kotlin.Long?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? echoNullableInt(jni$_.JLong? long) {
    final _$long = long?.reference ?? jni$_.jNullReference;
    return _echoNullableInt(
      reference.pointer,
      _id_echoNullableInt as jni$_.JMethodIDPtr,
      _$long.pointer,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_echoNullableDouble = _class.instanceMethodId(
    r'echoNullableDouble',
    r'(Ljava/lang/Double;)Ljava/lang/Double;',
  );

  static final _echoNullableDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableDouble(aNullableDouble: kotlin.Double?): kotlin.Double?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? echoNullableDouble(jni$_.JDouble? double) {
    final _$double = double?.reference ?? jni$_.jNullReference;
    return _echoNullableDouble(
      reference.pointer,
      _id_echoNullableDouble as jni$_.JMethodIDPtr,
      _$double.pointer,
    ).object<jni$_.JDouble?>(const jni$_.$JDouble$NullableType$());
  }

  static final _id_echoNullableBool = _class.instanceMethodId(
    r'echoNullableBool',
    r'(Ljava/lang/Boolean;)Ljava/lang/Boolean;',
  );

  static final _echoNullableBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableBool(aNullableBool: kotlin.Boolean?): kotlin.Boolean?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? echoNullableBool(jni$_.JBoolean? boolean) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    return _echoNullableBool(
      reference.pointer,
      _id_echoNullableBool as jni$_.JMethodIDPtr,
      _$boolean.pointer,
    ).object<jni$_.JBoolean?>(const jni$_.$JBoolean$NullableType$());
  }

  static final _id_echoNullableString = _class.instanceMethodId(
    r'echoNullableString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echoNullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableString(aNullableString: kotlin.String?): kotlin.String?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? echoNullableString(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _echoNullableString(
      reference.pointer,
      _id_echoNullableString as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_echoNullableObject = _class.instanceMethodId(
    r'echoNullableObject',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _echoNullableObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableObject(aNullableObject: kotlin.Any?): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? echoNullableObject(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _echoNullableObject(
      reference.pointer,
      _id_echoNullableObject as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_echoNullableList = _class.instanceMethodId(
    r'echoNullableList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableList(aNullableList: kotlin.collections.List<kotlin.Any?>?): kotlin.collections.List<kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? echoNullableList(
    jni$_.JList<jni$_.JObject?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableList(
      reference.pointer,
      _id_echoNullableList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableEnumList = _class.instanceMethodId(
    r'echoNullableEnumList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableEnumList(enumList: kotlin.collections.List<NIAnEnum?>?): kotlin.collections.List<NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? echoNullableEnumList(jni$_.JList<NIAnEnum?>? list) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableEnumList(
      reference.pointer,
      _id_echoNullableEnumList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAnEnum?>?>(
      const jni$_.$JList$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_echoNullableClassList = _class.instanceMethodId(
    r'echoNullableClassList',
    r'(Ljava/util/List;)Ljava/util/List;',
  );

  static final _echoNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableClassList(classList: kotlin.collections.List<NIAllNullableTypesWithoutRecursion?>?): kotlin.collections.List<NIAllNullableTypesWithoutRecursion?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypesWithoutRecursion?>? echoNullableClassList(
    jni$_.JList<NIAllNullableTypesWithoutRecursion?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _echoNullableClassList(
      reference.pointer,
      _id_echoNullableClassList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<jni$_.JList<NIAllNullableTypesWithoutRecursion?>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypesWithoutRecursion?>(
        $NIAllNullableTypesWithoutRecursion$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableMap = _class.instanceMethodId(
    r'echoNullableMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableMap(map: kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?): kotlin.collections.Map<kotlin.Any?, kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? echoNullableMap(
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableMap(
      reference.pointer,
      _id_echoNullableMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JObject?, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject?, jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableStringMap = _class.instanceMethodId(
    r'echoNullableStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableStringMap(stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>?): kotlin.collections.Map<kotlin.String?, kotlin.String?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? echoNullableStringMap(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableStringMap(
      reference.pointer,
      _id_echoNullableStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_echoNullableNonNullStringMap = _class.instanceMethodId(
    r'echoNullableNonNullStringMap',
    r'(Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _echoNullableNonNullStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableNonNullStringMap(stringMap: kotlin.collections.Map<kotlin.String, kotlin.String>?): kotlin.collections.Map<kotlin.String, kotlin.String>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString>? echoNullableNonNullStringMap(
    jni$_.JMap<jni$_.JString, jni$_.JString>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _echoNullableNonNullStringMap(
      reference.pointer,
      _id_echoNullableNonNullStringMap as jni$_.JMethodIDPtr,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JString>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString, jni$_.JString>(
        jni$_.$JString$Type$(),
        jni$_.$JString$Type$(),
      ),
    );
  }

  static final _id_echoNullableEnum = _class.instanceMethodId(
    r'echoNullableEnum',
    r'(LNIAnEnum;)LNIAnEnum;',
  );

  static final _echoNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoNullableEnum(anEnum: NIAnEnum?): NIAnEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? echoNullableEnum(NIAnEnum? nIAnEnum) {
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    return _echoNullableEnum(
      reference.pointer,
      _id_echoNullableEnum as jni$_.JMethodIDPtr,
      _$nIAnEnum.pointer,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_echoAnotherNullableEnum = _class.instanceMethodId(
    r'echoAnotherNullableEnum',
    r'(LNIAnotherEnum;)LNIAnotherEnum;',
  );

  static final _echoAnotherNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun echoAnotherNullableEnum(anotherEnum: NIAnotherEnum?): NIAnotherEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? echoAnotherNullableEnum(NIAnotherEnum? nIAnotherEnum) {
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    return _echoAnotherNullableEnum(
      reference.pointer,
      _id_echoAnotherNullableEnum as jni$_.JMethodIDPtr,
      _$nIAnotherEnum.pointer,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }
}

final class $NIHostIntegrationCoreApiRegistrar$NullableType$
    extends jni$_.JType<NIHostIntegrationCoreApiRegistrar?> {
  @jni$_.internal
  const $NIHostIntegrationCoreApiRegistrar$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  NIHostIntegrationCoreApiRegistrar? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : NIHostIntegrationCoreApiRegistrar.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const $NIHostIntegrationCoreApi$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIHostIntegrationCoreApiRegistrar?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode =>
      ($NIHostIntegrationCoreApiRegistrar$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIHostIntegrationCoreApiRegistrar$NullableType$) &&
        other is $NIHostIntegrationCoreApiRegistrar$NullableType$;
  }
}

final class $NIHostIntegrationCoreApiRegistrar$Type$
    extends jni$_.JType<NIHostIntegrationCoreApiRegistrar> {
  @jni$_.internal
  const $NIHostIntegrationCoreApiRegistrar$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIHostIntegrationCoreApiRegistrar;';

  @jni$_.internal
  @core$_.override
  NIHostIntegrationCoreApiRegistrar fromReference(jni$_.JReference reference) =>
      NIHostIntegrationCoreApiRegistrar.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const $NIHostIntegrationCoreApi$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIHostIntegrationCoreApiRegistrar?> get nullableType =>
      const $NIHostIntegrationCoreApiRegistrar$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($NIHostIntegrationCoreApiRegistrar$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIHostIntegrationCoreApiRegistrar$Type$) &&
        other is $NIHostIntegrationCoreApiRegistrar$Type$;
  }
}

/// from: `NIAllTypes$Companion`
class NIAllTypes$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllTypes$Companion> $type;

  @jni$_.internal
  NIAllTypes$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllTypes$Companion');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllTypes$Companion?> nullableType =
      $NIAllTypes$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllTypes$Companion> type =
      $NIAllTypes$Companion$Type$();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LNIAllTypes;',
  );

  static final _fromList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun fromList(pigeonVar_list: kotlin.collections.List<kotlin.Any?>): NIAllTypes`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes fromList(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _fromList(
      reference.pointer,
      _id_fromList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<NIAllTypes>(const $NIAllTypes$Type$());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllTypes$Companion(jni$_.JObject? defaultConstructorMarker) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllTypes$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $NIAllTypes$Companion$NullableType$
    extends jni$_.JType<NIAllTypes$Companion?> {
  @jni$_.internal
  const $NIAllTypes$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllTypes$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllTypes$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIAllTypes$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllTypes$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllTypes$Companion$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllTypes$Companion$NullableType$) &&
        other is $NIAllTypes$Companion$NullableType$;
  }
}

final class $NIAllTypes$Companion$Type$
    extends jni$_.JType<NIAllTypes$Companion> {
  @jni$_.internal
  const $NIAllTypes$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllTypes$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllTypes$Companion fromReference(jni$_.JReference reference) =>
      NIAllTypes$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllTypes$Companion?> get nullableType =>
      const $NIAllTypes$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllTypes$Companion$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllTypes$Companion$Type$) &&
        other is $NIAllTypes$Companion$Type$;
  }
}

/// from: `NIAllTypes`
class NIAllTypes extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllTypes> $type;

  @jni$_.internal
  NIAllTypes.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllTypes');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllTypes?> nullableType =
      $NIAllTypes$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllTypes> type = $NIAllTypes$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAllTypes$Companion;',
  );

  /// from: `static public final NIAllTypes$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAllTypes$Companion get Companion =>
      _id_Companion.get(_class, const $NIAllTypes$Companion$Type$());

  static final _id_new$ = _class.constructorId(
    r'(ZJJDLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int64,
                    jni$_.Int64,
                    jni$_.Double,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(boolean z, long j, long j1, double d, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends NIAnEnum> list5, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllTypes(
    bool z,
    int j,
    int j1,
    double d,
    NIAnEnum nIAnEnum,
    NIAnotherEnum nIAnotherEnum,
    jni$_.JString string,
    jni$_.JObject object,
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JList<jni$_.JString> list1,
    jni$_.JList<jni$_.JLong> list2,
    jni$_.JList<jni$_.JDouble> list3,
    jni$_.JList<jni$_.JBoolean> list4,
    jni$_.JList<NIAnEnum> list5,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?> map,
    jni$_.JMap<jni$_.JString, jni$_.JString> map1,
  ) {
    final _$nIAnEnum = nIAnEnum.reference;
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    final _$string = string.reference;
    final _$object = object.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$list2 = list2.reference;
    final _$list3 = list3.reference;
    final _$list4 = list4.reference;
    final _$list5 = list5.reference;
    final _$map = map.reference;
    final _$map1 = map1.reference;
    return NIAllTypes.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        z ? 1 : 0,
        j,
        j1,
        d,
        _$nIAnEnum.pointer,
        _$nIAnotherEnum.pointer,
        _$string.pointer,
        _$object.pointer,
        _$list.pointer,
        _$list1.pointer,
        _$list2.pointer,
        _$list3.pointer,
        _$list4.pointer,
        _$list5.pointer,
        _$map.pointer,
        _$map1.pointer,
      ).reference,
    );
  }

  static final _id_getABool = _class.instanceMethodId(r'getABool', r'()Z');

  static final _getABool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean getABool()`
  bool getABool() {
    return _getABool(
      reference.pointer,
      _id_getABool as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getAnInt = _class.instanceMethodId(r'getAnInt', r'()J');

  static final _getAnInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long getAnInt()`
  int getAnInt() {
    return _getAnInt(
      reference.pointer,
      _id_getAnInt as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getAnInt64 = _class.instanceMethodId(r'getAnInt64', r'()J');

  static final _getAnInt64 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long getAnInt64()`
  int getAnInt64() {
    return _getAnInt64(
      reference.pointer,
      _id_getAnInt64 as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getADouble = _class.instanceMethodId(r'getADouble', r'()D');

  static final _getADouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final double getADouble()`
  double getADouble() {
    return _getADouble(
      reference.pointer,
      _id_getADouble as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_getAnEnum = _class.instanceMethodId(
    r'getAnEnum',
    r'()LNIAnEnum;',
  );

  static final _getAnEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAnEnum getAnEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum getAnEnum() {
    return _getAnEnum(
      reference.pointer,
      _id_getAnEnum as jni$_.JMethodIDPtr,
    ).object<NIAnEnum>(const $NIAnEnum$Type$());
  }

  static final _id_getAnotherEnum = _class.instanceMethodId(
    r'getAnotherEnum',
    r'()LNIAnotherEnum;',
  );

  static final _getAnotherEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAnotherEnum getAnotherEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum getAnotherEnum() {
    return _getAnotherEnum(
      reference.pointer,
      _id_getAnotherEnum as jni$_.JMethodIDPtr,
    ).object<NIAnotherEnum>(const $NIAnotherEnum$Type$());
  }

  static final _id_getAString = _class.instanceMethodId(
    r'getAString',
    r'()Ljava/lang/String;',
  );

  static final _getAString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getAString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getAString() {
    return _getAString(
      reference.pointer,
      _id_getAString as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_getAnObject = _class.instanceMethodId(
    r'getAnObject',
    r'()Ljava/lang/Object;',
  );

  static final _getAnObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object getAnObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getAnObject() {
    return _getAnObject(
      reference.pointer,
      _id_getAnObject as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> getList() {
    return _getList(
      reference.pointer,
      _id_getList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString> getStringList() {
    return _getStringList(
      reference.pointer,
      _id_getStringList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString>>(
      const jni$_.$JList$Type$<jni$_.JString>(jni$_.$JString$Type$()),
    );
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong> getIntList() {
    return _getIntList(
      reference.pointer,
      _id_getIntList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JLong>>(
      const jni$_.$JList$Type$<jni$_.JLong>(jni$_.$JLong$Type$()),
    );
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble> getDoubleList() {
    return _getDoubleList(
      reference.pointer,
      _id_getDoubleList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JDouble>>(
      const jni$_.$JList$Type$<jni$_.JDouble>(jni$_.$JDouble$Type$()),
    );
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean> getBoolList() {
    return _getBoolList(
      reference.pointer,
      _id_getBoolList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JBoolean>>(
      const jni$_.$JList$Type$<jni$_.JBoolean>(jni$_.$JBoolean$Type$()),
    );
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<NIAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> getEnumList() {
    return _getEnumList(
      reference.pointer,
      _id_getEnumList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAnEnum>>(
      const jni$_.$JList$Type$<NIAnEnum>($NIAnEnum$Type$()),
    );
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?> getMap() {
    return _getMap(
      reference.pointer,
      _id_getMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>>(
      const jni$_.$JMap$Type$<jni$_.JObject, jni$_.JObject?>(
        jni$_.$JObject$Type$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> getStringMap() {
    return _getStringMap(
      reference.pointer,
      _id_getStringMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
      const jni$_.$JMap$Type$<jni$_.JString, jni$_.JString>(
        jni$_.$JString$Type$(),
        jni$_.$JString$Type$(),
      ),
    );
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toList(): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(
      reference.pointer,
      _id_toList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public operator fun equals(other: kotlin.Any?): kotlin.Boolean`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun hashCode(): kotlin.Int`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_component1 = _class.instanceMethodId(r'component1', r'()Z');

  static final _component1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component1(): kotlin.Boolean`
  bool component1() {
    return _component1(
      reference.pointer,
      _id_component1 as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_component2 = _class.instanceMethodId(r'component2', r'()J');

  static final _component2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component2(): kotlin.Long`
  int component2() {
    return _component2(
      reference.pointer,
      _id_component2 as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_component3 = _class.instanceMethodId(r'component3', r'()J');

  static final _component3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component3(): kotlin.Long`
  int component3() {
    return _component3(
      reference.pointer,
      _id_component3 as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_component4 = _class.instanceMethodId(r'component4', r'()D');

  static final _component4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component4(): kotlin.Double`
  double component4() {
    return _component4(
      reference.pointer,
      _id_component4 as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()LNIAnEnum;',
  );

  static final _component5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component5(): NIAnEnum`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum component5() {
    return _component5(
      reference.pointer,
      _id_component5 as jni$_.JMethodIDPtr,
    ).object<NIAnEnum>(const $NIAnEnum$Type$());
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()LNIAnotherEnum;',
  );

  static final _component6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component6(): NIAnotherEnum`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum component6() {
    return _component6(
      reference.pointer,
      _id_component6 as jni$_.JMethodIDPtr,
    ).object<NIAnotherEnum>(const $NIAnotherEnum$Type$());
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()Ljava/lang/String;',
  );

  static final _component7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component7(): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString component7() {
    return _component7(
      reference.pointer,
      _id_component7 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_component8 = _class.instanceMethodId(
    r'component8',
    r'()Ljava/lang/Object;',
  );

  static final _component8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component8(): kotlin.Any`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject component8() {
    return _component8(
      reference.pointer,
      _id_component8 as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()Ljava/util/List;',
  );

  static final _component9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component9(): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> component9() {
    return _component9(
      reference.pointer,
      _id_component9 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()Ljava/util/List;',
  );

  static final _component10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component10(): kotlin.collections.List<kotlin.String>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString> component10() {
    return _component10(
      reference.pointer,
      _id_component10 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString>>(
      const jni$_.$JList$Type$<jni$_.JString>(jni$_.$JString$Type$()),
    );
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/util/List;',
  );

  static final _component11 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component11(): kotlin.collections.List<kotlin.Long>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong> component11() {
    return _component11(
      reference.pointer,
      _id_component11 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JLong>>(
      const jni$_.$JList$Type$<jni$_.JLong>(jni$_.$JLong$Type$()),
    );
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/util/List;',
  );

  static final _component12 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component12(): kotlin.collections.List<kotlin.Double>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble> component12() {
    return _component12(
      reference.pointer,
      _id_component12 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JDouble>>(
      const jni$_.$JList$Type$<jni$_.JDouble>(jni$_.$JDouble$Type$()),
    );
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()Ljava/util/List;',
  );

  static final _component13 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component13(): kotlin.collections.List<kotlin.Boolean>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean> component13() {
    return _component13(
      reference.pointer,
      _id_component13 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JBoolean>>(
      const jni$_.$JList$Type$<jni$_.JBoolean>(jni$_.$JBoolean$Type$()),
    );
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component14(): kotlin.collections.List<NIAnEnum>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum> component14() {
    return _component14(
      reference.pointer,
      _id_component14 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAnEnum>>(
      const jni$_.$JList$Type$<NIAnEnum>($NIAnEnum$Type$()),
    );
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/Map;',
  );

  static final _component15 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component15(): kotlin.collections.Map<kotlin.Any, kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?> component15() {
    return _component15(
      reference.pointer,
      _id_component15 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>>(
      const jni$_.$JMap$Type$<jni$_.JObject, jni$_.JObject?>(
        jni$_.$JObject$Type$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/Map;',
  );

  static final _component16 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component16(): kotlin.collections.Map<kotlin.String, kotlin.String>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString, jni$_.JString> component16() {
    return _component16(
      reference.pointer,
      _id_component16 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString, jni$_.JString>>(
      const jni$_.$JMap$Type$<jni$_.JString, jni$_.JString>(
        jni$_.$JString$Type$(),
        jni$_.$JString$Type$(),
      ),
    );
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(ZJJDLNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;)LNIAllTypes;',
  );

  static final _copy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int64,
                    jni$_.Int64,
                    jni$_.Double,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun copy(aBool: kotlin.Boolean, anInt: kotlin.Long, anInt64: kotlin.Long, aDouble: kotlin.Double, anEnum: NIAnEnum, anotherEnum: NIAnotherEnum, aString: kotlin.String, anObject: kotlin.Any, list: kotlin.collections.List<kotlin.Any?>, stringList: kotlin.collections.List<kotlin.String>, intList: kotlin.collections.List<kotlin.Long>, doubleList: kotlin.collections.List<kotlin.Double>, boolList: kotlin.collections.List<kotlin.Boolean>, enumList: kotlin.collections.List<NIAnEnum>, map: kotlin.collections.Map<kotlin.Any, kotlin.Any?>, stringMap: kotlin.collections.Map<kotlin.String, kotlin.String>): NIAllTypes`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes copy(
    bool z,
    int j,
    int j1,
    double d,
    NIAnEnum nIAnEnum,
    NIAnotherEnum nIAnotherEnum,
    jni$_.JString string,
    jni$_.JObject object,
    jni$_.JList<jni$_.JObject?> list,
    jni$_.JList<jni$_.JString> list1,
    jni$_.JList<jni$_.JLong> list2,
    jni$_.JList<jni$_.JDouble> list3,
    jni$_.JList<jni$_.JBoolean> list4,
    jni$_.JList<NIAnEnum> list5,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?> map,
    jni$_.JMap<jni$_.JString, jni$_.JString> map1,
  ) {
    final _$nIAnEnum = nIAnEnum.reference;
    final _$nIAnotherEnum = nIAnotherEnum.reference;
    final _$string = string.reference;
    final _$object = object.reference;
    final _$list = list.reference;
    final _$list1 = list1.reference;
    final _$list2 = list2.reference;
    final _$list3 = list3.reference;
    final _$list4 = list4.reference;
    final _$list5 = list5.reference;
    final _$map = map.reference;
    final _$map1 = map1.reference;
    return _copy(
      reference.pointer,
      _id_copy as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      j,
      j1,
      d,
      _$nIAnEnum.pointer,
      _$nIAnotherEnum.pointer,
      _$string.pointer,
      _$object.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$list2.pointer,
      _$list3.pointer,
      _$list4.pointer,
      _$list5.pointer,
      _$map.pointer,
      _$map1.pointer,
    ).object<NIAllTypes>(const $NIAllTypes$Type$());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toString(): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }
}

final class $NIAllTypes$NullableType$ extends jni$_.JType<NIAllTypes?> {
  @jni$_.internal
  const $NIAllTypes$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllTypes;';

  @jni$_.internal
  @core$_.override
  NIAllTypes? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIAllTypes.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllTypes?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllTypes$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllTypes$NullableType$) &&
        other is $NIAllTypes$NullableType$;
  }
}

final class $NIAllTypes$Type$ extends jni$_.JType<NIAllTypes> {
  @jni$_.internal
  const $NIAllTypes$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllTypes;';

  @jni$_.internal
  @core$_.override
  NIAllTypes fromReference(jni$_.JReference reference) =>
      NIAllTypes.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllTypes?> get nullableType =>
      const $NIAllTypes$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllTypes$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllTypes$Type$) &&
        other is $NIAllTypes$Type$;
  }
}

/// from: `NIAllNullableTypesWithoutRecursion$Companion`
class NIAllNullableTypesWithoutRecursion$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion> $type;

  @jni$_.internal
  NIAllNullableTypesWithoutRecursion$Companion.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'NIAllNullableTypesWithoutRecursion$Companion',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion?>
  nullableType = $NIAllNullableTypesWithoutRecursion$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion> type =
      $NIAllNullableTypesWithoutRecursion$Companion$Type$();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _fromList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun fromList(pigeonVar_list: kotlin.collections.List<kotlin.Any?>): NIAllNullableTypesWithoutRecursion`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion fromList(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _fromList(
      reference.pointer,
      _id_fromList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<NIAllNullableTypesWithoutRecursion>(
      const $NIAllNullableTypesWithoutRecursion$Type$(),
    );
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypesWithoutRecursion$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypesWithoutRecursion$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $NIAllNullableTypesWithoutRecursion$Companion$NullableType$
    extends jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion?> {
  @jni$_.internal
  const $NIAllNullableTypesWithoutRecursion$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypesWithoutRecursion$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypesWithoutRecursion$Companion? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : NIAllNullableTypesWithoutRecursion$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($NIAllNullableTypesWithoutRecursion$Companion$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIAllNullableTypesWithoutRecursion$Companion$NullableType$) &&
        other is $NIAllNullableTypesWithoutRecursion$Companion$NullableType$;
  }
}

final class $NIAllNullableTypesWithoutRecursion$Companion$Type$
    extends jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion> {
  @jni$_.internal
  const $NIAllNullableTypesWithoutRecursion$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypesWithoutRecursion$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypesWithoutRecursion$Companion fromReference(
    jni$_.JReference reference,
  ) => NIAllNullableTypesWithoutRecursion$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllNullableTypesWithoutRecursion$Companion?> get nullableType =>
      const $NIAllNullableTypesWithoutRecursion$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($NIAllNullableTypesWithoutRecursion$Companion$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIAllNullableTypesWithoutRecursion$Companion$Type$) &&
        other is $NIAllNullableTypesWithoutRecursion$Companion$Type$;
  }
}

/// from: `NIAllNullableTypesWithoutRecursion`
class NIAllNullableTypesWithoutRecursion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllNullableTypesWithoutRecursion> $type;

  @jni$_.internal
  NIAllNullableTypesWithoutRecursion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'NIAllNullableTypesWithoutRecursion',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllNullableTypesWithoutRecursion?> nullableType =
      $NIAllNullableTypesWithoutRecursion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllNullableTypesWithoutRecursion> type =
      $NIAllNullableTypesWithoutRecursion$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAllNullableTypesWithoutRecursion$Companion;',
  );

  /// from: `static public final NIAllNullableTypesWithoutRecursion$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAllNullableTypesWithoutRecursion$Companion get Companion =>
      _id_Companion.get(
        _class,
        const $NIAllNullableTypesWithoutRecursion$Companion$Type$(),
      );

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;LNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List<? extends java.lang.Object> list, java.util.List<java.lang.String> list1, java.util.List<java.lang.Long> list2, java.util.List<java.lang.Double> list3, java.util.List<java.lang.Boolean> list4, java.util.List<? extends NIAnEnum> list5, java.util.Map<java.lang.Object, ? extends java.lang.Object> map, java.util.Map<java.lang.String, java.lang.String> map1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypesWithoutRecursion(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<NIAnEnum?>? list5,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypesWithoutRecursion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$boolean.pointer,
        _$long.pointer,
        _$long1.pointer,
        _$double.pointer,
        _$nIAnEnum.pointer,
        _$nIAnotherEnum.pointer,
        _$string.pointer,
        _$object.pointer,
        _$list.pointer,
        _$list1.pointer,
        _$list2.pointer,
        _$list3.pointer,
        _$list4.pointer,
        _$list5.pointer,
        _$map.pointer,
        _$map1.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;LNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(java.lang.Boolean boolean, java.lang.Long long, java.lang.Long long1, java.lang.Double double, NIAnEnum nIAnEnum, NIAnotherEnum nIAnotherEnum, java.lang.String string, java.lang.Object object, java.util.List list, java.util.List list1, java.util.List list2, java.util.List list3, java.util.List list4, java.util.List list5, java.util.Map map, java.util.Map map1, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypesWithoutRecursion.new$1(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    jni$_.JList<jni$_.JObject?>? list2,
    jni$_.JList<jni$_.JObject?>? list3,
    jni$_.JList<jni$_.JObject?>? list4,
    jni$_.JList<jni$_.JObject?>? list5,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map1,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllNullableTypesWithoutRecursion.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$boolean.pointer,
        _$long.pointer,
        _$long1.pointer,
        _$double.pointer,
        _$nIAnEnum.pointer,
        _$nIAnotherEnum.pointer,
        _$string.pointer,
        _$object.pointer,
        _$list.pointer,
        _$list1.pointer,
        _$list2.pointer,
        _$list3.pointer,
        _$list4.pointer,
        _$list5.pointer,
        _$map.pointer,
        _$map1.pointer,
        i,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }

  static final _id_getANullableBool = _class.instanceMethodId(
    r'getANullableBool',
    r'()Ljava/lang/Boolean;',
  );

  static final _getANullableBool =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Boolean getANullableBool()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? getANullableBool() {
    return _getANullableBool(
      reference.pointer,
      _id_getANullableBool as jni$_.JMethodIDPtr,
    ).object<jni$_.JBoolean?>(const jni$_.$JBoolean$NullableType$());
  }

  static final _id_getANullableInt = _class.instanceMethodId(
    r'getANullableInt',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Long getANullableInt()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt() {
    return _getANullableInt(
      reference.pointer,
      _id_getANullableInt as jni$_.JMethodIDPtr,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_getANullableInt64 = _class.instanceMethodId(
    r'getANullableInt64',
    r'()Ljava/lang/Long;',
  );

  static final _getANullableInt64 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Long getANullableInt64()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? getANullableInt64() {
    return _getANullableInt64(
      reference.pointer,
      _id_getANullableInt64 as jni$_.JMethodIDPtr,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_getANullableDouble = _class.instanceMethodId(
    r'getANullableDouble',
    r'()Ljava/lang/Double;',
  );

  static final _getANullableDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Double getANullableDouble()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? getANullableDouble() {
    return _getANullableDouble(
      reference.pointer,
      _id_getANullableDouble as jni$_.JMethodIDPtr,
    ).object<jni$_.JDouble?>(const jni$_.$JDouble$NullableType$());
  }

  static final _id_getANullableEnum = _class.instanceMethodId(
    r'getANullableEnum',
    r'()LNIAnEnum;',
  );

  static final _getANullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAnEnum getANullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? getANullableEnum() {
    return _getANullableEnum(
      reference.pointer,
      _id_getANullableEnum as jni$_.JMethodIDPtr,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_getAnotherNullableEnum = _class.instanceMethodId(
    r'getAnotherNullableEnum',
    r'()LNIAnotherEnum;',
  );

  static final _getAnotherNullableEnum =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAnotherEnum getAnotherNullableEnum()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? getAnotherNullableEnum() {
    return _getAnotherNullableEnum(
      reference.pointer,
      _id_getAnotherNullableEnum as jni$_.JMethodIDPtr,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }

  static final _id_getANullableString = _class.instanceMethodId(
    r'getANullableString',
    r'()Ljava/lang/String;',
  );

  static final _getANullableString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getANullableString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getANullableString() {
    return _getANullableString(
      reference.pointer,
      _id_getANullableString as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getANullableObject = _class.instanceMethodId(
    r'getANullableObject',
    r'()Ljava/lang/Object;',
  );

  static final _getANullableObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object getANullableObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getANullableObject() {
    return _getANullableObject(
      reference.pointer,
      _id_getANullableObject as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Object> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getList() {
    return _getList(
      reference.pointer,
      _id_getList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getStringList = _class.instanceMethodId(
    r'getStringList',
    r'()Ljava/util/List;',
  );

  static final _getStringList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.String> getStringList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getStringList() {
    return _getStringList(
      reference.pointer,
      _id_getStringList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString?>?>(
      const jni$_.$JList$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_getIntList = _class.instanceMethodId(
    r'getIntList',
    r'()Ljava/util/List;',
  );

  static final _getIntList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Long> getIntList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? getIntList() {
    return _getIntList(
      reference.pointer,
      _id_getIntList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JLong?>?>(
      const jni$_.$JList$NullableType$<jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_getDoubleList = _class.instanceMethodId(
    r'getDoubleList',
    r'()Ljava/util/List;',
  );

  static final _getDoubleList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Double> getDoubleList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? getDoubleList() {
    return _getDoubleList(
      reference.pointer,
      _id_getDoubleList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JDouble?>?>(
      const jni$_.$JList$NullableType$<jni$_.JDouble?>(
        jni$_.$JDouble$NullableType$(),
      ),
    );
  }

  static final _id_getBoolList = _class.instanceMethodId(
    r'getBoolList',
    r'()Ljava/util/List;',
  );

  static final _getBoolList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<java.lang.Boolean> getBoolList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? getBoolList() {
    return _getBoolList(
      reference.pointer,
      _id_getBoolList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JBoolean?>?>(
      const jni$_.$JList$NullableType$<jni$_.JBoolean?>(
        jni$_.$JBoolean$NullableType$(),
      ),
    );
  }

  static final _id_getEnumList = _class.instanceMethodId(
    r'getEnumList',
    r'()Ljava/util/List;',
  );

  static final _getEnumList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<NIAnEnum> getEnumList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? getEnumList() {
    return _getEnumList(
      reference.pointer,
      _id_getEnumList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAnEnum?>?>(
      const jni$_.$JList$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_getMap = _class.instanceMethodId(
    r'getMap',
    r'()Ljava/util/Map;',
  );

  static final _getMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.Object, java.lang.Object> getMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? getMap() {
    return _getMap(
      reference.pointer,
      _id_getMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject, jni$_.JObject?>(
        jni$_.$JObject$Type$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_getStringMap = _class.instanceMethodId(
    r'getStringMap',
    r'()Ljava/util/Map;',
  );

  static final _getStringMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.Map<java.lang.String, java.lang.String> getStringMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? getStringMap() {
    return _getStringMap(
      reference.pointer,
      _id_getStringMap as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toList(): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(
      reference.pointer,
      _id_toList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public operator fun equals(other: kotlin.Any?): kotlin.Boolean`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun hashCode(): kotlin.Int`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()Ljava/lang/Boolean;',
  );

  static final _component1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component1(): kotlin.Boolean?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JBoolean? component1() {
    return _component1(
      reference.pointer,
      _id_component1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JBoolean?>(const jni$_.$JBoolean$NullableType$());
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()Ljava/lang/Long;',
  );

  static final _component2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component2(): kotlin.Long?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component2() {
    return _component2(
      reference.pointer,
      _id_component2 as jni$_.JMethodIDPtr,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()Ljava/lang/Long;',
  );

  static final _component3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component3(): kotlin.Long?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JLong? component3() {
    return _component3(
      reference.pointer,
      _id_component3 as jni$_.JMethodIDPtr,
    ).object<jni$_.JLong?>(const jni$_.$JLong$NullableType$());
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/lang/Double;',
  );

  static final _component4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component4(): kotlin.Double?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDouble? component4() {
    return _component4(
      reference.pointer,
      _id_component4 as jni$_.JMethodIDPtr,
    ).object<jni$_.JDouble?>(const jni$_.$JDouble$NullableType$());
  }

  static final _id_component5 = _class.instanceMethodId(
    r'component5',
    r'()LNIAnEnum;',
  );

  static final _component5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component5(): NIAnEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? component5() {
    return _component5(
      reference.pointer,
      _id_component5 as jni$_.JMethodIDPtr,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_component6 = _class.instanceMethodId(
    r'component6',
    r'()LNIAnotherEnum;',
  );

  static final _component6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component6(): NIAnotherEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? component6() {
    return _component6(
      reference.pointer,
      _id_component6 as jni$_.JMethodIDPtr,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }

  static final _id_component7 = _class.instanceMethodId(
    r'component7',
    r'()Ljava/lang/String;',
  );

  static final _component7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component7(): kotlin.String?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? component7() {
    return _component7(
      reference.pointer,
      _id_component7 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_component8 = _class.instanceMethodId(
    r'component8',
    r'()Ljava/lang/Object;',
  );

  static final _component8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component8(): kotlin.Any?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? component8() {
    return _component8(
      reference.pointer,
      _id_component8 as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_component9 = _class.instanceMethodId(
    r'component9',
    r'()Ljava/util/List;',
  );

  static final _component9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component9(): kotlin.collections.List<kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? component9() {
    return _component9(
      reference.pointer,
      _id_component9 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_component10 = _class.instanceMethodId(
    r'component10',
    r'()Ljava/util/List;',
  );

  static final _component10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component10(): kotlin.collections.List<kotlin.String?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? component10() {
    return _component10(
      reference.pointer,
      _id_component10 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JString?>?>(
      const jni$_.$JList$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_component11 = _class.instanceMethodId(
    r'component11',
    r'()Ljava/util/List;',
  );

  static final _component11 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component11(): kotlin.collections.List<kotlin.Long?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JLong?>? component11() {
    return _component11(
      reference.pointer,
      _id_component11 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JLong?>?>(
      const jni$_.$JList$NullableType$<jni$_.JLong?>(
        jni$_.$JLong$NullableType$(),
      ),
    );
  }

  static final _id_component12 = _class.instanceMethodId(
    r'component12',
    r'()Ljava/util/List;',
  );

  static final _component12 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component12(): kotlin.collections.List<kotlin.Double?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JDouble?>? component12() {
    return _component12(
      reference.pointer,
      _id_component12 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JDouble?>?>(
      const jni$_.$JList$NullableType$<jni$_.JDouble?>(
        jni$_.$JDouble$NullableType$(),
      ),
    );
  }

  static final _id_component13 = _class.instanceMethodId(
    r'component13',
    r'()Ljava/util/List;',
  );

  static final _component13 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component13(): kotlin.collections.List<kotlin.Boolean?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JBoolean?>? component13() {
    return _component13(
      reference.pointer,
      _id_component13 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JBoolean?>?>(
      const jni$_.$JList$NullableType$<jni$_.JBoolean?>(
        jni$_.$JBoolean$NullableType$(),
      ),
    );
  }

  static final _id_component14 = _class.instanceMethodId(
    r'component14',
    r'()Ljava/util/List;',
  );

  static final _component14 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component14(): kotlin.collections.List<NIAnEnum?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAnEnum?>? component14() {
    return _component14(
      reference.pointer,
      _id_component14 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAnEnum?>?>(
      const jni$_.$JList$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_component15 = _class.instanceMethodId(
    r'component15',
    r'()Ljava/util/Map;',
  );

  static final _component15 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component15(): kotlin.collections.Map<kotlin.Any, kotlin.Any?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JObject, jni$_.JObject?>? component15() {
    return _component15(
      reference.pointer,
      _id_component15 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JObject, jni$_.JObject?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JObject, jni$_.JObject?>(
        jni$_.$JObject$Type$(),
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_component16 = _class.instanceMethodId(
    r'component16',
    r'()Ljava/util/Map;',
  );

  static final _component16 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component16(): kotlin.collections.Map<kotlin.String?, kotlin.String?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? component16() {
    return _component16(
      reference.pointer,
      _id_component16 as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(Ljava/lang/Boolean;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Double;LNIAnEnum;LNIAnotherEnum;Ljava/lang/String;Ljava/lang/Object;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/List;Ljava/util/Map;Ljava/util/Map;)LNIAllNullableTypesWithoutRecursion;',
  );

  static final _copy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun copy(aNullableBool: kotlin.Boolean?, aNullableInt: kotlin.Long?, aNullableInt64: kotlin.Long?, aNullableDouble: kotlin.Double?, aNullableEnum: NIAnEnum?, anotherNullableEnum: NIAnotherEnum?, aNullableString: kotlin.String?, aNullableObject: kotlin.Any?, list: kotlin.collections.List<kotlin.Any?>?, stringList: kotlin.collections.List<kotlin.String?>?, intList: kotlin.collections.List<kotlin.Long?>?, doubleList: kotlin.collections.List<kotlin.Double?>?, boolList: kotlin.collections.List<kotlin.Boolean?>?, enumList: kotlin.collections.List<NIAnEnum?>?, map: kotlin.collections.Map<kotlin.Any, kotlin.Any?>?, stringMap: kotlin.collections.Map<kotlin.String?, kotlin.String?>?): NIAllNullableTypesWithoutRecursion`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion copy(
    jni$_.JBoolean? boolean,
    jni$_.JLong? long,
    jni$_.JLong? long1,
    jni$_.JDouble? double,
    NIAnEnum? nIAnEnum,
    NIAnotherEnum? nIAnotherEnum,
    jni$_.JString? string,
    jni$_.JObject? object,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JString?>? list1,
    jni$_.JList<jni$_.JLong?>? list2,
    jni$_.JList<jni$_.JDouble?>? list3,
    jni$_.JList<jni$_.JBoolean?>? list4,
    jni$_.JList<NIAnEnum?>? list5,
    jni$_.JMap<jni$_.JObject, jni$_.JObject?>? map,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map1,
  ) {
    final _$boolean = boolean?.reference ?? jni$_.jNullReference;
    final _$long = long?.reference ?? jni$_.jNullReference;
    final _$long1 = long1?.reference ?? jni$_.jNullReference;
    final _$double = double?.reference ?? jni$_.jNullReference;
    final _$nIAnEnum = nIAnEnum?.reference ?? jni$_.jNullReference;
    final _$nIAnotherEnum = nIAnotherEnum?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$list2 = list2?.reference ?? jni$_.jNullReference;
    final _$list3 = list3?.reference ?? jni$_.jNullReference;
    final _$list4 = list4?.reference ?? jni$_.jNullReference;
    final _$list5 = list5?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    final _$map1 = map1?.reference ?? jni$_.jNullReference;
    return _copy(
      reference.pointer,
      _id_copy as jni$_.JMethodIDPtr,
      _$boolean.pointer,
      _$long.pointer,
      _$long1.pointer,
      _$double.pointer,
      _$nIAnEnum.pointer,
      _$nIAnotherEnum.pointer,
      _$string.pointer,
      _$object.pointer,
      _$list.pointer,
      _$list1.pointer,
      _$list2.pointer,
      _$list3.pointer,
      _$list4.pointer,
      _$list5.pointer,
      _$map.pointer,
      _$map1.pointer,
    ).object<NIAllNullableTypesWithoutRecursion>(
      const $NIAllNullableTypesWithoutRecursion$Type$(),
    );
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toString(): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }

  static final _id_new$2 = _class.constructorId(r'()V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllNullableTypesWithoutRecursion.new$2() {
    return NIAllNullableTypesWithoutRecursion.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }
}

final class $NIAllNullableTypesWithoutRecursion$NullableType$
    extends jni$_.JType<NIAllNullableTypesWithoutRecursion?> {
  @jni$_.internal
  const $NIAllNullableTypesWithoutRecursion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypesWithoutRecursion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypesWithoutRecursion? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : NIAllNullableTypesWithoutRecursion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllNullableTypesWithoutRecursion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($NIAllNullableTypesWithoutRecursion$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIAllNullableTypesWithoutRecursion$NullableType$) &&
        other is $NIAllNullableTypesWithoutRecursion$NullableType$;
  }
}

final class $NIAllNullableTypesWithoutRecursion$Type$
    extends jni$_.JType<NIAllNullableTypesWithoutRecursion> {
  @jni$_.internal
  const $NIAllNullableTypesWithoutRecursion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllNullableTypesWithoutRecursion;';

  @jni$_.internal
  @core$_.override
  NIAllNullableTypesWithoutRecursion fromReference(
    jni$_.JReference reference,
  ) => NIAllNullableTypesWithoutRecursion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllNullableTypesWithoutRecursion?> get nullableType =>
      const $NIAllNullableTypesWithoutRecursion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllNullableTypesWithoutRecursion$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllNullableTypesWithoutRecursion$Type$) &&
        other is $NIAllNullableTypesWithoutRecursion$Type$;
  }
}

/// from: `NIAllClassesWrapper$Companion`
class NIAllClassesWrapper$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllClassesWrapper$Companion> $type;

  @jni$_.internal
  NIAllClassesWrapper$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllClassesWrapper$Companion');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllClassesWrapper$Companion?> nullableType =
      $NIAllClassesWrapper$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllClassesWrapper$Companion> type =
      $NIAllClassesWrapper$Companion$Type$();
  static final _id_fromList = _class.instanceMethodId(
    r'fromList',
    r'(Ljava/util/List;)LNIAllClassesWrapper;',
  );

  static final _fromList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun fromList(pigeonVar_list: kotlin.collections.List<kotlin.Any?>): NIAllClassesWrapper`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper fromList(jni$_.JList<jni$_.JObject?> list) {
    final _$list = list.reference;
    return _fromList(
      reference.pointer,
      _id_fromList as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type$());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllClassesWrapper$Companion(
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllClassesWrapper$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $NIAllClassesWrapper$Companion$NullableType$
    extends jni$_.JType<NIAllClassesWrapper$Companion?> {
  @jni$_.internal
  const $NIAllClassesWrapper$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllClassesWrapper$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllClassesWrapper$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : NIAllClassesWrapper$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllClassesWrapper$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllClassesWrapper$Companion$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($NIAllClassesWrapper$Companion$NullableType$) &&
        other is $NIAllClassesWrapper$Companion$NullableType$;
  }
}

final class $NIAllClassesWrapper$Companion$Type$
    extends jni$_.JType<NIAllClassesWrapper$Companion> {
  @jni$_.internal
  const $NIAllClassesWrapper$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllClassesWrapper$Companion;';

  @jni$_.internal
  @core$_.override
  NIAllClassesWrapper$Companion fromReference(jni$_.JReference reference) =>
      NIAllClassesWrapper$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllClassesWrapper$Companion?> get nullableType =>
      const $NIAllClassesWrapper$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllClassesWrapper$Companion$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllClassesWrapper$Companion$Type$) &&
        other is $NIAllClassesWrapper$Companion$Type$;
  }
}

/// from: `NIAllClassesWrapper`
class NIAllClassesWrapper extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAllClassesWrapper> $type;

  @jni$_.internal
  NIAllClassesWrapper.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAllClassesWrapper');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllClassesWrapper?> nullableType =
      $NIAllClassesWrapper$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAllClassesWrapper> type =
      $NIAllClassesWrapper$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAllClassesWrapper$Companion;',
  );

  /// from: `static public final NIAllClassesWrapper$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAllClassesWrapper$Companion get Companion =>
      _id_Companion.get(_class, const $NIAllClassesWrapper$Companion$Type$());

  static final _id_new$ = _class.constructorId(
    r'(LNIAllNullableTypesWithoutRecursion;LNIAllTypes;Ljava/util/List;Ljava/util/List;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion, NIAllTypes nIAllTypes, java.util.List<NIAllTypes> list, java.util.List<NIAllNullableTypesWithoutRecursion> list1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllClassesWrapper(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
    NIAllTypes? nIAllTypes,
    jni$_.JList<NIAllTypes?> list,
    jni$_.JList<NIAllNullableTypesWithoutRecursion?>? list1,
  ) {
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$nIAllTypes = nIAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list.reference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    return NIAllClassesWrapper.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$nIAllNullableTypesWithoutRecursion.pointer,
        _$nIAllTypes.pointer,
        _$list.pointer,
        _$list1.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(LNIAllNullableTypesWithoutRecursion;LNIAllTypes;Ljava/util/List;Ljava/util/List;ILkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(NIAllNullableTypesWithoutRecursion nIAllNullableTypesWithoutRecursion, NIAllTypes nIAllTypes, java.util.List list, java.util.List list1, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAllClassesWrapper.new$1(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
    NIAllTypes? nIAllTypes,
    jni$_.JList<jni$_.JObject?>? list,
    jni$_.JList<jni$_.JObject?>? list1,
    int i,
    jni$_.JObject? defaultConstructorMarker,
  ) {
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$nIAllTypes = nIAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAllClassesWrapper.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$nIAllNullableTypesWithoutRecursion.pointer,
        _$nIAllTypes.pointer,
        _$list.pointer,
        _$list1.pointer,
        i,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }

  static final _id_getAllNullableTypesWithoutRecursion = _class
      .instanceMethodId(
        r'getAllNullableTypesWithoutRecursion',
        r'()LNIAllNullableTypesWithoutRecursion;',
      );

  static final _getAllNullableTypesWithoutRecursion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAllNullableTypesWithoutRecursion getAllNullableTypesWithoutRecursion()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion? getAllNullableTypesWithoutRecursion() {
    return _getAllNullableTypesWithoutRecursion(
      reference.pointer,
      _id_getAllNullableTypesWithoutRecursion as jni$_.JMethodIDPtr,
    ).object<NIAllNullableTypesWithoutRecursion?>(
      const $NIAllNullableTypesWithoutRecursion$NullableType$(),
    );
  }

  static final _id_getAllTypes = _class.instanceMethodId(
    r'getAllTypes',
    r'()LNIAllTypes;',
  );

  static final _getAllTypes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final NIAllTypes getAllTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes? getAllTypes() {
    return _getAllTypes(
      reference.pointer,
      _id_getAllTypes as jni$_.JMethodIDPtr,
    ).object<NIAllTypes?>(const $NIAllTypes$NullableType$());
  }

  static final _id_getClassList = _class.instanceMethodId(
    r'getClassList',
    r'()Ljava/util/List;',
  );

  static final _getClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<NIAllTypes> getClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllTypes?> getClassList() {
    return _getClassList(
      reference.pointer,
      _id_getClassList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAllTypes?>>(
      const jni$_.$JList$Type$<NIAllTypes?>($NIAllTypes$NullableType$()),
    );
  }

  static final _id_getNullableClassList = _class.instanceMethodId(
    r'getNullableClassList',
    r'()Ljava/util/List;',
  );

  static final _getNullableClassList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.util.List<NIAllNullableTypesWithoutRecursion> getNullableClassList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypesWithoutRecursion?>? getNullableClassList() {
    return _getNullableClassList(
      reference.pointer,
      _id_getNullableClassList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAllNullableTypesWithoutRecursion?>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypesWithoutRecursion?>(
        $NIAllNullableTypesWithoutRecursion$NullableType$(),
      ),
    );
  }

  static final _id_toList = _class.instanceMethodId(
    r'toList',
    r'()Ljava/util/List;',
  );

  static final _toList =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toList(): kotlin.collections.List<kotlin.Any?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> toList() {
    return _toList(
      reference.pointer,
      _id_toList as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>>(
      const jni$_.$JList$Type$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public operator fun equals(other: kotlin.Any?): kotlin.Boolean`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun hashCode(): kotlin.Int`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_component1 = _class.instanceMethodId(
    r'component1',
    r'()LNIAllNullableTypesWithoutRecursion;',
  );

  static final _component1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component1(): NIAllNullableTypesWithoutRecursion?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllNullableTypesWithoutRecursion? component1() {
    return _component1(
      reference.pointer,
      _id_component1 as jni$_.JMethodIDPtr,
    ).object<NIAllNullableTypesWithoutRecursion?>(
      const $NIAllNullableTypesWithoutRecursion$NullableType$(),
    );
  }

  static final _id_component2 = _class.instanceMethodId(
    r'component2',
    r'()LNIAllTypes;',
  );

  static final _component2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component2(): NIAllTypes?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllTypes? component2() {
    return _component2(
      reference.pointer,
      _id_component2 as jni$_.JMethodIDPtr,
    ).object<NIAllTypes?>(const $NIAllTypes$NullableType$());
  }

  static final _id_component3 = _class.instanceMethodId(
    r'component3',
    r'()Ljava/util/List;',
  );

  static final _component3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component3(): kotlin.collections.List<NIAllTypes?>`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllTypes?> component3() {
    return _component3(
      reference.pointer,
      _id_component3 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAllTypes?>>(
      const jni$_.$JList$Type$<NIAllTypes?>($NIAllTypes$NullableType$()),
    );
  }

  static final _id_component4 = _class.instanceMethodId(
    r'component4',
    r'()Ljava/util/List;',
  );

  static final _component4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public operator fun component4(): kotlin.collections.List<NIAllNullableTypesWithoutRecursion?>?`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<NIAllNullableTypesWithoutRecursion?>? component4() {
    return _component4(
      reference.pointer,
      _id_component4 as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<NIAllNullableTypesWithoutRecursion?>?>(
      const jni$_.$JList$NullableType$<NIAllNullableTypesWithoutRecursion?>(
        $NIAllNullableTypesWithoutRecursion$NullableType$(),
      ),
    );
  }

  static final _id_copy = _class.instanceMethodId(
    r'copy',
    r'(LNIAllNullableTypesWithoutRecursion;LNIAllTypes;Ljava/util/List;Ljava/util/List;)LNIAllClassesWrapper;',
  );

  static final _copy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public fun copy(allNullableTypesWithoutRecursion: NIAllNullableTypesWithoutRecursion?, allTypes: NIAllTypes?, classList: kotlin.collections.List<NIAllTypes?>, nullableClassList: kotlin.collections.List<NIAllNullableTypesWithoutRecursion?>?): NIAllClassesWrapper`
  /// The returned object must be released after use, by calling the [release] method.
  NIAllClassesWrapper copy(
    NIAllNullableTypesWithoutRecursion? nIAllNullableTypesWithoutRecursion,
    NIAllTypes? nIAllTypes,
    jni$_.JList<NIAllTypes?> list,
    jni$_.JList<NIAllNullableTypesWithoutRecursion?>? list1,
  ) {
    final _$nIAllNullableTypesWithoutRecursion =
        nIAllNullableTypesWithoutRecursion?.reference ?? jni$_.jNullReference;
    final _$nIAllTypes = nIAllTypes?.reference ?? jni$_.jNullReference;
    final _$list = list.reference;
    final _$list1 = list1?.reference ?? jni$_.jNullReference;
    return _copy(
      reference.pointer,
      _id_copy as jni$_.JMethodIDPtr,
      _$nIAllNullableTypesWithoutRecursion.pointer,
      _$nIAllTypes.pointer,
      _$list.pointer,
      _$list1.pointer,
    ).object<NIAllClassesWrapper>(const $NIAllClassesWrapper$Type$());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public fun toString(): kotlin.String`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.$JString$Type$());
  }
}

final class $NIAllClassesWrapper$NullableType$
    extends jni$_.JType<NIAllClassesWrapper?> {
  @jni$_.internal
  const $NIAllClassesWrapper$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllClassesWrapper;';

  @jni$_.internal
  @core$_.override
  NIAllClassesWrapper? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIAllClassesWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllClassesWrapper?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllClassesWrapper$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllClassesWrapper$NullableType$) &&
        other is $NIAllClassesWrapper$NullableType$;
  }
}

final class $NIAllClassesWrapper$Type$
    extends jni$_.JType<NIAllClassesWrapper> {
  @jni$_.internal
  const $NIAllClassesWrapper$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAllClassesWrapper;';

  @jni$_.internal
  @core$_.override
  NIAllClassesWrapper fromReference(jni$_.JReference reference) =>
      NIAllClassesWrapper.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAllClassesWrapper?> get nullableType =>
      const $NIAllClassesWrapper$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAllClassesWrapper$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAllClassesWrapper$Type$) &&
        other is $NIAllClassesWrapper$Type$;
  }
}

/// from: `NIAnEnum$Companion`
class NIAnEnum$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAnEnum$Companion> $type;

  @jni$_.internal
  NIAnEnum$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAnEnum$Companion');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnEnum$Companion?> nullableType =
      $NIAnEnum$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnEnum$Companion> type =
      $NIAnEnum$Companion$Type$();
  static final _id_ofRaw = _class.instanceMethodId(r'ofRaw', r'(I)LNIAnEnum;');

  static final _ofRaw =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public fun ofRaw(raw: kotlin.Int): NIAnEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnEnum? ofRaw(int i) {
    return _ofRaw(
      reference.pointer,
      _id_ofRaw as jni$_.JMethodIDPtr,
      i,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAnEnum$Companion(jni$_.JObject? defaultConstructorMarker) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAnEnum$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $NIAnEnum$Companion$NullableType$
    extends jni$_.JType<NIAnEnum$Companion?> {
  @jni$_.internal
  const $NIAnEnum$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnEnum$Companion;';

  @jni$_.internal
  @core$_.override
  NIAnEnum$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIAnEnum$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnEnum$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnEnum$Companion$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnEnum$Companion$NullableType$) &&
        other is $NIAnEnum$Companion$NullableType$;
  }
}

final class $NIAnEnum$Companion$Type$ extends jni$_.JType<NIAnEnum$Companion> {
  @jni$_.internal
  const $NIAnEnum$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnEnum$Companion;';

  @jni$_.internal
  @core$_.override
  NIAnEnum$Companion fromReference(jni$_.JReference reference) =>
      NIAnEnum$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnEnum$Companion?> get nullableType =>
      const $NIAnEnum$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnEnum$Companion$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnEnum$Companion$Type$) &&
        other is $NIAnEnum$Companion$Type$;
  }
}

/// from: `NIAnEnum`
class NIAnEnum extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAnEnum> $type;

  @jni$_.internal
  NIAnEnum.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAnEnum');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnEnum?> nullableType = $NIAnEnum$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnEnum> type = $NIAnEnum$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAnEnum$Companion;',
  );

  /// from: `static public final NIAnEnum$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum$Companion get Companion =>
      _id_Companion.get(_class, const $NIAnEnum$Companion$Type$());

  static final _id_ONE = _class.staticFieldId(r'ONE', r'LNIAnEnum;');

  /// from: `static public final NIAnEnum ONE`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get ONE => _id_ONE.get(_class, const $NIAnEnum$Type$());

  static final _id_TWO = _class.staticFieldId(r'TWO', r'LNIAnEnum;');

  /// from: `static public final NIAnEnum TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get TWO => _id_TWO.get(_class, const $NIAnEnum$Type$());

  static final _id_THREE = _class.staticFieldId(r'THREE', r'LNIAnEnum;');

  /// from: `static public final NIAnEnum THREE`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get THREE => _id_THREE.get(_class, const $NIAnEnum$Type$());

  static final _id_FORTY_TWO = _class.staticFieldId(
    r'FORTY_TWO',
    r'LNIAnEnum;',
  );

  /// from: `static public final NIAnEnum FORTY_TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get FORTY_TWO =>
      _id_FORTY_TWO.get(_class, const $NIAnEnum$Type$());

  static final _id_FOUR_HUNDRED_TWENTY_TWO = _class.staticFieldId(
    r'FOUR_HUNDRED_TWENTY_TWO',
    r'LNIAnEnum;',
  );

  /// from: `static public final NIAnEnum FOUR_HUNDRED_TWENTY_TWO`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum get FOUR_HUNDRED_TWENTY_TWO =>
      _id_FOUR_HUNDRED_TWENTY_TWO.get(_class, const $NIAnEnum$Type$());

  static final _id_getRaw = _class.instanceMethodId(r'getRaw', r'()I');

  static final _getRaw =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int getRaw()`
  int getRaw() {
    return _getRaw(reference.pointer, _id_getRaw as jni$_.JMethodIDPtr).integer;
  }

  static final _id_values = _class.staticMethodId(r'values', r'()[LNIAnEnum;');

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public NIAnEnum[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<NIAnEnum?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<NIAnEnum?>?>(
      const jni$_.$JArray$NullableType$<NIAnEnum?>($NIAnEnum$NullableType$()),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)LNIAnEnum;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public NIAnEnum valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnEnum? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<NIAnEnum?>(const $NIAnEnum$NullableType$());
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public kotlin.enums.EnumEntries<NIAnEnum> getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
      _class.reference.pointer,
      _id_getEntries as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }
}

final class $NIAnEnum$NullableType$ extends jni$_.JType<NIAnEnum?> {
  @jni$_.internal
  const $NIAnEnum$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnEnum;';

  @jni$_.internal
  @core$_.override
  NIAnEnum? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIAnEnum.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnEnum?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnEnum$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnEnum$NullableType$) &&
        other is $NIAnEnum$NullableType$;
  }
}

final class $NIAnEnum$Type$ extends jni$_.JType<NIAnEnum> {
  @jni$_.internal
  const $NIAnEnum$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnEnum;';

  @jni$_.internal
  @core$_.override
  NIAnEnum fromReference(jni$_.JReference reference) =>
      NIAnEnum.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnEnum?> get nullableType => const $NIAnEnum$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnEnum$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnEnum$Type$) && other is $NIAnEnum$Type$;
  }
}

/// from: `NIAnotherEnum$Companion`
class NIAnotherEnum$Companion extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAnotherEnum$Companion> $type;

  @jni$_.internal
  NIAnotherEnum$Companion.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAnotherEnum$Companion');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnotherEnum$Companion?> nullableType =
      $NIAnotherEnum$Companion$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnotherEnum$Companion> type =
      $NIAnotherEnum$Companion$Type$();
  static final _id_ofRaw = _class.instanceMethodId(
    r'ofRaw',
    r'(I)LNIAnotherEnum;',
  );

  static final _ofRaw =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public fun ofRaw(raw: kotlin.Int): NIAnotherEnum?`
  /// The returned object must be released after use, by calling the [release] method.
  NIAnotherEnum? ofRaw(int i) {
    return _ofRaw(
      reference.pointer,
      _id_ofRaw as jni$_.JMethodIDPtr,
      i,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }

  static final _id_new$ = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `synthetic public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NIAnotherEnum$Companion(jni$_.JObject? defaultConstructorMarker) {
    final _$defaultConstructorMarker =
        defaultConstructorMarker?.reference ?? jni$_.jNullReference;
    return NIAnotherEnum$Companion.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$defaultConstructorMarker.pointer,
      ).reference,
    );
  }
}

final class $NIAnotherEnum$Companion$NullableType$
    extends jni$_.JType<NIAnotherEnum$Companion?> {
  @jni$_.internal
  const $NIAnotherEnum$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnotherEnum$Companion;';

  @jni$_.internal
  @core$_.override
  NIAnotherEnum$Companion? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : NIAnotherEnum$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnotherEnum$Companion?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnotherEnum$Companion$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnotherEnum$Companion$NullableType$) &&
        other is $NIAnotherEnum$Companion$NullableType$;
  }
}

final class $NIAnotherEnum$Companion$Type$
    extends jni$_.JType<NIAnotherEnum$Companion> {
  @jni$_.internal
  const $NIAnotherEnum$Companion$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnotherEnum$Companion;';

  @jni$_.internal
  @core$_.override
  NIAnotherEnum$Companion fromReference(jni$_.JReference reference) =>
      NIAnotherEnum$Companion.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnotherEnum$Companion?> get nullableType =>
      const $NIAnotherEnum$Companion$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnotherEnum$Companion$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnotherEnum$Companion$Type$) &&
        other is $NIAnotherEnum$Companion$Type$;
  }
}

/// from: `NIAnotherEnum`
class NIAnotherEnum extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<NIAnotherEnum> $type;

  @jni$_.internal
  NIAnotherEnum.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'NIAnotherEnum');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnotherEnum?> nullableType =
      $NIAnotherEnum$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NIAnotherEnum> type = $NIAnotherEnum$Type$();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'LNIAnotherEnum$Companion;',
  );

  /// from: `static public final NIAnotherEnum$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnotherEnum$Companion get Companion =>
      _id_Companion.get(_class, const $NIAnotherEnum$Companion$Type$());

  static final _id_JUST_IN_CASE = _class.staticFieldId(
    r'JUST_IN_CASE',
    r'LNIAnotherEnum;',
  );

  /// from: `static public final NIAnotherEnum JUST_IN_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnotherEnum get JUST_IN_CASE =>
      _id_JUST_IN_CASE.get(_class, const $NIAnotherEnum$Type$());

  static final _id_getRaw = _class.instanceMethodId(r'getRaw', r'()I');

  static final _getRaw =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int getRaw()`
  int getRaw() {
    return _getRaw(reference.pointer, _id_getRaw as jni$_.JMethodIDPtr).integer;
  }

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[LNIAnotherEnum;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public NIAnotherEnum[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<NIAnotherEnum?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<NIAnotherEnum?>?>(
      const jni$_.$JArray$NullableType$<NIAnotherEnum?>(
        $NIAnotherEnum$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)LNIAnotherEnum;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public NIAnotherEnum valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static NIAnotherEnum? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<NIAnotherEnum?>(const $NIAnotherEnum$NullableType$());
  }

  static final _id_getEntries = _class.staticMethodId(
    r'getEntries',
    r'()Lkotlin/enums/EnumEntries;',
  );

  static final _getEntries =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public kotlin.enums.EnumEntries<NIAnotherEnum> getEntries()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject getEntries() {
    return _getEntries(
      _class.reference.pointer,
      _id_getEntries as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.$JObject$Type$());
  }
}

final class $NIAnotherEnum$NullableType$ extends jni$_.JType<NIAnotherEnum?> {
  @jni$_.internal
  const $NIAnotherEnum$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnotherEnum;';

  @jni$_.internal
  @core$_.override
  NIAnotherEnum? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NIAnotherEnum.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnotherEnum?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnotherEnum$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnotherEnum$NullableType$) &&
        other is $NIAnotherEnum$NullableType$;
  }
}

final class $NIAnotherEnum$Type$ extends jni$_.JType<NIAnotherEnum> {
  @jni$_.internal
  const $NIAnotherEnum$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'LNIAnotherEnum;';

  @jni$_.internal
  @core$_.override
  NIAnotherEnum fromReference(jni$_.JReference reference) =>
      NIAnotherEnum.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<NIAnotherEnum?> get nullableType =>
      const $NIAnotherEnum$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NIAnotherEnum$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NIAnotherEnum$Type$) &&
        other is $NIAnotherEnum$Type$;
  }
}
