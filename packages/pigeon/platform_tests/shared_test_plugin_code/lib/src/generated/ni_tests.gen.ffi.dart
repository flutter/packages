// Copyright 2013 The Flutter Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//

// ignore_for_file: always_specify_types, camel_case_types, non_constant_identifier_names, unnecessary_non_null_assertion, unused_element, unused_field
// coverage:ignore-file

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _umaz4x_wrapListenerBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _umaz4x_wrapBlockingBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _umaz4x_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _umaz4x_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

late final _class_NIAllClassesWrapperBridge = objc.getClass(
  "test_plugin.NIAllClassesWrapperBridge",
);
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _class_NIAllNullableTypesBridge = objc.getClass(
  "test_plugin.NIAllNullableTypesBridge",
);
late final _class_PigeonTypedData = objc.getClass(
  "test_plugin.PigeonTypedData",
);
late final _sel_data = objc.registerName("data");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_type = objc.registerName("type");
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_initWithData_type_ = objc.registerName("initWithData:type:");
final _objc_msgSend_9slupp = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
      )
    >();
late final _sel_getUint8Array = objc.registerName("getUint8Array");
late final _sel_getInt32Array = objc.registerName("getInt32Array");
late final _sel_getInt64Array = objc.registerName("getInt64Array");
late final _sel_getFloat32Array = objc.registerName("getFloat32Array");
late final _sel_getFloat64Array = objc.registerName("getFloat64Array");
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");

/// PigeonTypedData
///
/// iOS: introduced 13.0.0
/// macOS: introduced 16.0.0
extension type PigeonTypedData._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [PigeonTypedData] that points to the same underlying object as [other].
  PigeonTypedData.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'PigeonTypedData',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [PigeonTypedData] that wraps the given raw object pointer.
  PigeonTypedData.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'PigeonTypedData',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [PigeonTypedData].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_PigeonTypedData,
  );

  /// alloc
  static PigeonTypedData alloc() {
    final $ret = _objc_msgSend_151sglz(_class_PigeonTypedData, _sel_alloc);
    return PigeonTypedData.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static PigeonTypedData allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_PigeonTypedData,
      _sel_allocWithZone_,
      zone,
    );
    return PigeonTypedData.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static PigeonTypedData new$() {
    final $ret = _objc_msgSend_151sglz(_class_PigeonTypedData, _sel_new);
    return PigeonTypedData.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of PigeonTypedData constructed with the default `new` method.
  PigeonTypedData() : this.as(new$().object$);
}

extension PigeonTypedData$Methods on PigeonTypedData {
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSData get data {
    objc.checkOsVersionInternal(
      'PigeonTypedData.data',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_data);
    return objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// getFloat32Array
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? getFloat32Array() {
    objc.checkOsVersionInternal(
      'PigeonTypedData.getFloat32Array',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_getFloat32Array,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// getFloat64Array
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? getFloat64Array() {
    objc.checkOsVersionInternal(
      'PigeonTypedData.getFloat64Array',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_getFloat64Array,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// getInt32Array
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? getInt32Array() {
    objc.checkOsVersionInternal(
      'PigeonTypedData.getInt32Array',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_getInt32Array);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// getInt64Array
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? getInt64Array() {
    objc.checkOsVersionInternal(
      'PigeonTypedData.getInt64Array',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_getInt64Array);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// getUint8Array
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? getUint8Array() {
    objc.checkOsVersionInternal(
      'PigeonTypedData.getUint8Array',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_getUint8Array);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// init
  PigeonTypedData init() {
    objc.checkOsVersionInternal(
      'PigeonTypedData.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return PigeonTypedData.fromPointer($ret, retain: false, release: true);
  }

  /// initWithData:type:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData initWithData(objc.NSData data, {required int type}) {
    objc.checkOsVersionInternal(
      'PigeonTypedData.initWithData:type:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_9slupp(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithData_type_,
      data.ref.pointer,
      type,
    );
    return PigeonTypedData.fromPointer($ret, retain: false, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  int get type {
    objc.checkOsVersionInternal(
      'PigeonTypedData.type',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_type);
  }
}

late final _sel_initWithANullableBool_aNullableInt_aNullableInt64_aNullableDouble_aNullableByteArray_aNullable4ByteArray_aNullable8ByteArray_aNullableFloatArray_aNullableEnum_anotherNullableEnum_aNullableString_aNullableObject_allNullableTypes_list_stringList_intList_doubleList_boolList_enumList_objectList_listList_mapList_recursiveClassList_map_stringMap_intMap_enumMap_objectMap_listMap_mapMap_recursiveClassMap_ =
    objc.registerName(
      "initWithANullableBool:aNullableInt:aNullableInt64:aNullableDouble:aNullableByteArray:aNullable4ByteArray:aNullable8ByteArray:aNullableFloatArray:aNullableEnum:anotherNullableEnum:aNullableString:aNullableObject:allNullableTypes:list:stringList:intList:doubleList:boolList:enumList:objectList:listList:mapList:recursiveClassList:map:stringMap:intMap:enumMap:objectMap:listMap:mapMap:recursiveClassMap:",
    );
final _objc_msgSend_etw0ff = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_aNullableBool = objc.registerName("aNullableBool");
late final _sel_setANullableBool_ = objc.registerName("setANullableBool:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_aNullableInt = objc.registerName("aNullableInt");
late final _sel_setANullableInt_ = objc.registerName("setANullableInt:");
late final _sel_aNullableInt64 = objc.registerName("aNullableInt64");
late final _sel_setANullableInt64_ = objc.registerName("setANullableInt64:");
late final _sel_aNullableDouble = objc.registerName("aNullableDouble");
late final _sel_setANullableDouble_ = objc.registerName("setANullableDouble:");
late final _sel_aNullableByteArray = objc.registerName("aNullableByteArray");
late final _sel_setANullableByteArray_ = objc.registerName(
  "setANullableByteArray:",
);
late final _sel_aNullable4ByteArray = objc.registerName("aNullable4ByteArray");
late final _sel_setANullable4ByteArray_ = objc.registerName(
  "setANullable4ByteArray:",
);
late final _sel_aNullable8ByteArray = objc.registerName("aNullable8ByteArray");
late final _sel_setANullable8ByteArray_ = objc.registerName(
  "setANullable8ByteArray:",
);
late final _sel_aNullableFloatArray = objc.registerName("aNullableFloatArray");
late final _sel_setANullableFloatArray_ = objc.registerName(
  "setANullableFloatArray:",
);
late final _sel_aNullableEnum = objc.registerName("aNullableEnum");
late final _sel_setANullableEnum_ = objc.registerName("setANullableEnum:");
late final _sel_anotherNullableEnum = objc.registerName("anotherNullableEnum");
late final _sel_setAnotherNullableEnum_ = objc.registerName(
  "setAnotherNullableEnum:",
);
late final _sel_aNullableString = objc.registerName("aNullableString");
late final _sel_setANullableString_ = objc.registerName("setANullableString:");
late final _sel_aNullableObject = objc.registerName("aNullableObject");
late final _sel_setANullableObject_ = objc.registerName("setANullableObject:");
late final _sel_allNullableTypes = objc.registerName("allNullableTypes");
late final _sel_setAllNullableTypes_ = objc.registerName(
  "setAllNullableTypes:",
);
late final _sel_list = objc.registerName("list");
late final _sel_setList_ = objc.registerName("setList:");
late final _sel_stringList = objc.registerName("stringList");
late final _sel_setStringList_ = objc.registerName("setStringList:");
late final _sel_intList = objc.registerName("intList");
late final _sel_setIntList_ = objc.registerName("setIntList:");
late final _sel_doubleList = objc.registerName("doubleList");
late final _sel_setDoubleList_ = objc.registerName("setDoubleList:");
late final _sel_boolList = objc.registerName("boolList");
late final _sel_setBoolList_ = objc.registerName("setBoolList:");
late final _sel_enumList = objc.registerName("enumList");
late final _sel_setEnumList_ = objc.registerName("setEnumList:");
late final _sel_objectList = objc.registerName("objectList");
late final _sel_setObjectList_ = objc.registerName("setObjectList:");
late final _sel_listList = objc.registerName("listList");
late final _sel_setListList_ = objc.registerName("setListList:");
late final _sel_mapList = objc.registerName("mapList");
late final _sel_setMapList_ = objc.registerName("setMapList:");
late final _sel_recursiveClassList = objc.registerName("recursiveClassList");
late final _sel_setRecursiveClassList_ = objc.registerName(
  "setRecursiveClassList:",
);
late final _sel_map = objc.registerName("map");
late final _sel_setMap_ = objc.registerName("setMap:");
late final _sel_stringMap = objc.registerName("stringMap");
late final _sel_setStringMap_ = objc.registerName("setStringMap:");
late final _sel_intMap = objc.registerName("intMap");
late final _sel_setIntMap_ = objc.registerName("setIntMap:");
late final _sel_enumMap = objc.registerName("enumMap");
late final _sel_setEnumMap_ = objc.registerName("setEnumMap:");
late final _sel_objectMap = objc.registerName("objectMap");
late final _sel_setObjectMap_ = objc.registerName("setObjectMap:");
late final _sel_listMap = objc.registerName("listMap");
late final _sel_setListMap_ = objc.registerName("setListMap:");
late final _sel_mapMap = objc.registerName("mapMap");
late final _sel_setMapMap_ = objc.registerName("setMapMap:");
late final _sel_recursiveClassMap = objc.registerName("recursiveClassMap");
late final _sel_setRecursiveClassMap_ = objc.registerName(
  "setRecursiveClassMap:",
);

/// A class containing all supported nullable types.
/// Generated bridge class from Pigeon that moves data from Swift to Objective-C.
///
/// iOS: introduced 13.0.0
/// macOS: introduced 16.0.0
extension type NIAllNullableTypesBridge._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NIAllNullableTypesBridge] that points to the same underlying object as [other].
  NIAllNullableTypesBridge.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NIAllNullableTypesBridge] that wraps the given raw object pointer.
  NIAllNullableTypesBridge.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NIAllNullableTypesBridge].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NIAllNullableTypesBridge,
  );

  /// alloc
  static NIAllNullableTypesBridge alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_NIAllNullableTypesBridge,
      _sel_alloc,
    );
    return NIAllNullableTypesBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NIAllNullableTypesBridge allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NIAllNullableTypesBridge,
      _sel_allocWithZone_,
      zone,
    );
    return NIAllNullableTypesBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static NIAllNullableTypesBridge new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_NIAllNullableTypesBridge,
      _sel_new,
    );
    return NIAllNullableTypesBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of NIAllNullableTypesBridge constructed with the default `new` method.
  NIAllNullableTypesBridge() : this.as(new$().object$);
}

extension NIAllNullableTypesBridge$Methods on NIAllNullableTypesBridge {
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? get aNullable4ByteArray {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.aNullable4ByteArray',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullable4ByteArray,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? get aNullable8ByteArray {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.aNullable8ByteArray',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullable8ByteArray,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? get aNullableBool {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.aNullableBool',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_aNullableBool);
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? get aNullableByteArray {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.aNullableByteArray',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullableByteArray,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? get aNullableDouble {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.aNullableDouble',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullableDouble,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? get aNullableEnum {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.aNullableEnum',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_aNullableEnum);
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? get aNullableFloatArray {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.aNullableFloatArray',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullableFloatArray,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? get aNullableInt {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.aNullableInt',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_aNullableInt);
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? get aNullableInt64 {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.aNullableInt64',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullableInt64,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSObject? get aNullableObject {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.aNullableObject',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullableObject,
    );
    return $ret.address == 0
        ? null
        : objc.NSObject.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSString? get aNullableString {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.aNullableString',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullableString,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllNullableTypesBridge? get allNullableTypes {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.allNullableTypes',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_allNullableTypes,
    );
    return $ret.address == 0
        ? null
        : NIAllNullableTypesBridge.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? get anotherNullableEnum {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.anotherNullableEnum',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_anotherNullableEnum,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get boolList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.boolList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_boolList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get doubleList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.doubleList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_doubleList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get enumList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.enumList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_enumList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get enumMap {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.enumMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_enumMap);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NIAllNullableTypesBridge init() {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NIAllNullableTypesBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithANullableBool:aNullableInt:aNullableInt64:aNullableDouble:aNullableByteArray:aNullable4ByteArray:aNullable8ByteArray:aNullableFloatArray:aNullableEnum:anotherNullableEnum:aNullableString:aNullableObject:allNullableTypes:list:stringList:intList:doubleList:boolList:enumList:objectList:listList:mapList:recursiveClassList:map:stringMap:intMap:enumMap:objectMap:listMap:mapMap:recursiveClassMap:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllNullableTypesBridge initWithANullableBool(
    objc.NSNumber? aNullableBool, {
    objc.NSNumber? aNullableInt,
    objc.NSNumber? aNullableInt64,
    objc.NSNumber? aNullableDouble,
    PigeonTypedData? aNullableByteArray,
    PigeonTypedData? aNullable4ByteArray,
    PigeonTypedData? aNullable8ByteArray,
    PigeonTypedData? aNullableFloatArray,
    objc.NSNumber? aNullableEnum,
    objc.NSNumber? anotherNullableEnum,
    objc.NSString? aNullableString,
    objc.NSObject? aNullableObject,
    NIAllNullableTypesBridge? allNullableTypes,
    objc.NSArray? list,
    objc.NSArray? stringList,
    objc.NSArray? intList,
    objc.NSArray? doubleList,
    objc.NSArray? boolList,
    objc.NSArray? enumList,
    objc.NSArray? objectList,
    objc.NSArray? listList,
    objc.NSArray? mapList,
    objc.NSArray? recursiveClassList,
    objc.NSDictionary? map,
    objc.NSDictionary? stringMap,
    objc.NSDictionary? intMap,
    objc.NSDictionary? enumMap,
    objc.NSDictionary? objectMap,
    objc.NSDictionary? listMap,
    objc.NSDictionary? mapMap,
    objc.NSDictionary? recursiveClassMap,
  }) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.initWithANullableBool:aNullableInt:aNullableInt64:aNullableDouble:aNullableByteArray:aNullable4ByteArray:aNullable8ByteArray:aNullableFloatArray:aNullableEnum:anotherNullableEnum:aNullableString:aNullableObject:allNullableTypes:list:stringList:intList:doubleList:boolList:enumList:objectList:listList:mapList:recursiveClassList:map:stringMap:intMap:enumMap:objectMap:listMap:mapMap:recursiveClassMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_etw0ff(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithANullableBool_aNullableInt_aNullableInt64_aNullableDouble_aNullableByteArray_aNullable4ByteArray_aNullable8ByteArray_aNullableFloatArray_aNullableEnum_anotherNullableEnum_aNullableString_aNullableObject_allNullableTypes_list_stringList_intList_doubleList_boolList_enumList_objectList_listList_mapList_recursiveClassList_map_stringMap_intMap_enumMap_objectMap_listMap_mapMap_recursiveClassMap_,
      aNullableBool?.ref.pointer ?? ffi.nullptr,
      aNullableInt?.ref.pointer ?? ffi.nullptr,
      aNullableInt64?.ref.pointer ?? ffi.nullptr,
      aNullableDouble?.ref.pointer ?? ffi.nullptr,
      aNullableByteArray?.ref.pointer ?? ffi.nullptr,
      aNullable4ByteArray?.ref.pointer ?? ffi.nullptr,
      aNullable8ByteArray?.ref.pointer ?? ffi.nullptr,
      aNullableFloatArray?.ref.pointer ?? ffi.nullptr,
      aNullableEnum?.ref.pointer ?? ffi.nullptr,
      anotherNullableEnum?.ref.pointer ?? ffi.nullptr,
      aNullableString?.ref.pointer ?? ffi.nullptr,
      aNullableObject?.ref.pointer ?? ffi.nullptr,
      allNullableTypes?.ref.pointer ?? ffi.nullptr,
      list?.ref.pointer ?? ffi.nullptr,
      stringList?.ref.pointer ?? ffi.nullptr,
      intList?.ref.pointer ?? ffi.nullptr,
      doubleList?.ref.pointer ?? ffi.nullptr,
      boolList?.ref.pointer ?? ffi.nullptr,
      enumList?.ref.pointer ?? ffi.nullptr,
      objectList?.ref.pointer ?? ffi.nullptr,
      listList?.ref.pointer ?? ffi.nullptr,
      mapList?.ref.pointer ?? ffi.nullptr,
      recursiveClassList?.ref.pointer ?? ffi.nullptr,
      map?.ref.pointer ?? ffi.nullptr,
      stringMap?.ref.pointer ?? ffi.nullptr,
      intMap?.ref.pointer ?? ffi.nullptr,
      enumMap?.ref.pointer ?? ffi.nullptr,
      objectMap?.ref.pointer ?? ffi.nullptr,
      listMap?.ref.pointer ?? ffi.nullptr,
      mapMap?.ref.pointer ?? ffi.nullptr,
      recursiveClassMap?.ref.pointer ?? ffi.nullptr,
    );
    return NIAllNullableTypesBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get intList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.intList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_intList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get intMap {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.intMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_intMap);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get list {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.list',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_list);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get listList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.listList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_listList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get listMap {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.listMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_listMap);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get map {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.map',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_map);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get mapList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.mapList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_mapList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get mapMap {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.mapMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_mapMap);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get objectList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.objectList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_objectList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get objectMap {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.objectMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_objectMap);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get recursiveClassList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.recursiveClassList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_recursiveClassList,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get recursiveClassMap {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.recursiveClassMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_recursiveClassMap,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullable4ByteArray(PigeonTypedData? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setANullable4ByteArray:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullable4ByteArray_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullable8ByteArray(PigeonTypedData? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setANullable8ByteArray:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullable8ByteArray_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableBool(objc.NSNumber? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setANullableBool:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableBool_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableByteArray(PigeonTypedData? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setANullableByteArray:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableByteArray_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableDouble(objc.NSNumber? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setANullableDouble:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableDouble_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableEnum(objc.NSNumber? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setANullableEnum:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableEnum_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableFloatArray(PigeonTypedData? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setANullableFloatArray:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableFloatArray_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableInt64(objc.NSNumber? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setANullableInt64:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableInt64_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableInt(objc.NSNumber? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setANullableInt:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableInt_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableObject(objc.NSObject? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setANullableObject:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableObject_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableString(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setANullableString:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableString_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set allNullableTypes(NIAllNullableTypesBridge? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setAllNullableTypes:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAllNullableTypes_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set anotherNullableEnum(objc.NSNumber? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setAnotherNullableEnum:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAnotherNullableEnum_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set boolList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setBoolList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setBoolList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set doubleList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setDoubleList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setDoubleList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set enumList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setEnumList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setEnumList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set enumMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setEnumMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setEnumMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set intList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setIntList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setIntList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set intMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setIntMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setIntMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set list(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set listList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setListList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setListList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set listMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setListMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setListMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set map(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set mapList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setMapList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMapList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set mapMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setMapMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMapMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set objectList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setObjectList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setObjectList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set objectMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setObjectMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setObjectMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set recursiveClassList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setRecursiveClassList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setRecursiveClassList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set recursiveClassMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setRecursiveClassMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setRecursiveClassMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set stringList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setStringList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setStringList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set stringMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.setStringMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setStringMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get stringList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.stringList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get stringMap {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesBridge.stringMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringMap);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }
}

late final _class_NIAllNullableTypesWithoutRecursionBridge = objc.getClass(
  "test_plugin.NIAllNullableTypesWithoutRecursionBridge",
);
late final _sel_initWithANullableBool_aNullableInt_aNullableInt64_aNullableDouble_aNullableByteArray_aNullable4ByteArray_aNullable8ByteArray_aNullableFloatArray_aNullableEnum_anotherNullableEnum_aNullableString_aNullableObject_list_stringList_intList_doubleList_boolList_enumList_objectList_listList_mapList_map_stringMap_intMap_enumMap_objectMap_listMap_mapMap_ =
    objc.registerName(
      "initWithANullableBool:aNullableInt:aNullableInt64:aNullableDouble:aNullableByteArray:aNullable4ByteArray:aNullable8ByteArray:aNullableFloatArray:aNullableEnum:anotherNullableEnum:aNullableString:aNullableObject:list:stringList:intList:doubleList:boolList:enumList:objectList:listList:mapList:map:stringMap:intMap:enumMap:objectMap:listMap:mapMap:",
    );
final _objc_msgSend_1hm1urt = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// The primary purpose for this class is to ensure coverage of Swift structs
/// with nullable items, as the primary [NIAllNullableTypes] class is being used to
/// test Swift classes.
/// Generated bridge class from Pigeon that moves data from Swift to Objective-C.
///
/// iOS: introduced 13.0.0
/// macOS: introduced 16.0.0
extension type NIAllNullableTypesWithoutRecursionBridge._(
  objc.ObjCObject object$
)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NIAllNullableTypesWithoutRecursionBridge] that points to the same underlying object as [other].
  NIAllNullableTypesWithoutRecursionBridge.as(objc.ObjCObject other)
    : object$ = other {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NIAllNullableTypesWithoutRecursionBridge] that wraps the given raw object pointer.
  NIAllNullableTypesWithoutRecursionBridge.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NIAllNullableTypesWithoutRecursionBridge].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NIAllNullableTypesWithoutRecursionBridge,
  );

  /// alloc
  static NIAllNullableTypesWithoutRecursionBridge alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_NIAllNullableTypesWithoutRecursionBridge,
      _sel_alloc,
    );
    return NIAllNullableTypesWithoutRecursionBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NIAllNullableTypesWithoutRecursionBridge allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NIAllNullableTypesWithoutRecursionBridge,
      _sel_allocWithZone_,
      zone,
    );
    return NIAllNullableTypesWithoutRecursionBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static NIAllNullableTypesWithoutRecursionBridge new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_NIAllNullableTypesWithoutRecursionBridge,
      _sel_new,
    );
    return NIAllNullableTypesWithoutRecursionBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of NIAllNullableTypesWithoutRecursionBridge constructed with the default `new` method.
  NIAllNullableTypesWithoutRecursionBridge() : this.as(new$().object$);
}

extension NIAllNullableTypesWithoutRecursionBridge$Methods
    on NIAllNullableTypesWithoutRecursionBridge {
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? get aNullable4ByteArray {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.aNullable4ByteArray',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullable4ByteArray,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? get aNullable8ByteArray {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.aNullable8ByteArray',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullable8ByteArray,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? get aNullableBool {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.aNullableBool',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_aNullableBool);
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? get aNullableByteArray {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.aNullableByteArray',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullableByteArray,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? get aNullableDouble {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.aNullableDouble',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullableDouble,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? get aNullableEnum {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.aNullableEnum',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_aNullableEnum);
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? get aNullableFloatArray {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.aNullableFloatArray',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullableFloatArray,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? get aNullableInt {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.aNullableInt',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_aNullableInt);
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? get aNullableInt64 {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.aNullableInt64',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullableInt64,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSObject? get aNullableObject {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.aNullableObject',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullableObject,
    );
    return $ret.address == 0
        ? null
        : objc.NSObject.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSString? get aNullableString {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.aNullableString',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_aNullableString,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? get anotherNullableEnum {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.anotherNullableEnum',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_anotherNullableEnum,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get boolList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.boolList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_boolList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get doubleList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.doubleList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_doubleList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get enumList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.enumList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_enumList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get enumMap {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.enumMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_enumMap);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NIAllNullableTypesWithoutRecursionBridge init() {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NIAllNullableTypesWithoutRecursionBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithANullableBool:aNullableInt:aNullableInt64:aNullableDouble:aNullableByteArray:aNullable4ByteArray:aNullable8ByteArray:aNullableFloatArray:aNullableEnum:anotherNullableEnum:aNullableString:aNullableObject:list:stringList:intList:doubleList:boolList:enumList:objectList:listList:mapList:map:stringMap:intMap:enumMap:objectMap:listMap:mapMap:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllNullableTypesWithoutRecursionBridge initWithANullableBool(
    objc.NSNumber? aNullableBool, {
    objc.NSNumber? aNullableInt,
    objc.NSNumber? aNullableInt64,
    objc.NSNumber? aNullableDouble,
    PigeonTypedData? aNullableByteArray,
    PigeonTypedData? aNullable4ByteArray,
    PigeonTypedData? aNullable8ByteArray,
    PigeonTypedData? aNullableFloatArray,
    objc.NSNumber? aNullableEnum,
    objc.NSNumber? anotherNullableEnum,
    objc.NSString? aNullableString,
    objc.NSObject? aNullableObject,
    objc.NSArray? list,
    objc.NSArray? stringList,
    objc.NSArray? intList,
    objc.NSArray? doubleList,
    objc.NSArray? boolList,
    objc.NSArray? enumList,
    objc.NSArray? objectList,
    objc.NSArray? listList,
    objc.NSArray? mapList,
    objc.NSDictionary? map,
    objc.NSDictionary? stringMap,
    objc.NSDictionary? intMap,
    objc.NSDictionary? enumMap,
    objc.NSDictionary? objectMap,
    objc.NSDictionary? listMap,
    objc.NSDictionary? mapMap,
  }) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.initWithANullableBool:aNullableInt:aNullableInt64:aNullableDouble:aNullableByteArray:aNullable4ByteArray:aNullable8ByteArray:aNullableFloatArray:aNullableEnum:anotherNullableEnum:aNullableString:aNullableObject:list:stringList:intList:doubleList:boolList:enumList:objectList:listList:mapList:map:stringMap:intMap:enumMap:objectMap:listMap:mapMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_1hm1urt(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithANullableBool_aNullableInt_aNullableInt64_aNullableDouble_aNullableByteArray_aNullable4ByteArray_aNullable8ByteArray_aNullableFloatArray_aNullableEnum_anotherNullableEnum_aNullableString_aNullableObject_list_stringList_intList_doubleList_boolList_enumList_objectList_listList_mapList_map_stringMap_intMap_enumMap_objectMap_listMap_mapMap_,
      aNullableBool?.ref.pointer ?? ffi.nullptr,
      aNullableInt?.ref.pointer ?? ffi.nullptr,
      aNullableInt64?.ref.pointer ?? ffi.nullptr,
      aNullableDouble?.ref.pointer ?? ffi.nullptr,
      aNullableByteArray?.ref.pointer ?? ffi.nullptr,
      aNullable4ByteArray?.ref.pointer ?? ffi.nullptr,
      aNullable8ByteArray?.ref.pointer ?? ffi.nullptr,
      aNullableFloatArray?.ref.pointer ?? ffi.nullptr,
      aNullableEnum?.ref.pointer ?? ffi.nullptr,
      anotherNullableEnum?.ref.pointer ?? ffi.nullptr,
      aNullableString?.ref.pointer ?? ffi.nullptr,
      aNullableObject?.ref.pointer ?? ffi.nullptr,
      list?.ref.pointer ?? ffi.nullptr,
      stringList?.ref.pointer ?? ffi.nullptr,
      intList?.ref.pointer ?? ffi.nullptr,
      doubleList?.ref.pointer ?? ffi.nullptr,
      boolList?.ref.pointer ?? ffi.nullptr,
      enumList?.ref.pointer ?? ffi.nullptr,
      objectList?.ref.pointer ?? ffi.nullptr,
      listList?.ref.pointer ?? ffi.nullptr,
      mapList?.ref.pointer ?? ffi.nullptr,
      map?.ref.pointer ?? ffi.nullptr,
      stringMap?.ref.pointer ?? ffi.nullptr,
      intMap?.ref.pointer ?? ffi.nullptr,
      enumMap?.ref.pointer ?? ffi.nullptr,
      objectMap?.ref.pointer ?? ffi.nullptr,
      listMap?.ref.pointer ?? ffi.nullptr,
      mapMap?.ref.pointer ?? ffi.nullptr,
    );
    return NIAllNullableTypesWithoutRecursionBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get intList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.intList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_intList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get intMap {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.intMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_intMap);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get list {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.list',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_list);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get listList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.listList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_listList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get listMap {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.listMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_listMap);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get map {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.map',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_map);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get mapList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.mapList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_mapList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get mapMap {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.mapMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_mapMap);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get objectList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.objectList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_objectList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get objectMap {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.objectMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_objectMap);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullable4ByteArray(PigeonTypedData? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setANullable4ByteArray:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullable4ByteArray_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullable8ByteArray(PigeonTypedData? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setANullable8ByteArray:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullable8ByteArray_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableBool(objc.NSNumber? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setANullableBool:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableBool_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableByteArray(PigeonTypedData? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setANullableByteArray:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableByteArray_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableDouble(objc.NSNumber? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setANullableDouble:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableDouble_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableEnum(objc.NSNumber? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setANullableEnum:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableEnum_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableFloatArray(PigeonTypedData? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setANullableFloatArray:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableFloatArray_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableInt64(objc.NSNumber? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setANullableInt64:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableInt64_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableInt(objc.NSNumber? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setANullableInt:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableInt_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableObject(objc.NSObject? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setANullableObject:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableObject_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aNullableString(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setANullableString:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setANullableString_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set anotherNullableEnum(objc.NSNumber? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setAnotherNullableEnum:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAnotherNullableEnum_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set boolList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setBoolList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setBoolList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set doubleList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setDoubleList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setDoubleList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set enumList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setEnumList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setEnumList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set enumMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setEnumMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setEnumMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set intList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setIntList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setIntList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set intMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setIntMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setIntMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set list(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set listList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setListList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setListList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set listMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setListMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setListMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set map(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set mapList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setMapList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMapList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set mapMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setMapMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMapMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set objectList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setObjectList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setObjectList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set objectMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setObjectMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setObjectMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set stringList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setStringList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setStringList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set stringMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.setStringMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setStringMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get stringList {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.stringList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringList);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get stringMap {
    objc.checkOsVersionInternal(
      'NIAllNullableTypesWithoutRecursionBridge.stringMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringMap);
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }
}

late final _class_NIAllTypesBridge = objc.getClass(
  "test_plugin.NIAllTypesBridge",
);

enum NIAnEnum {
  NIAnEnumOne(0),
  NIAnEnumTwo(1),
  NIAnEnumThree(2),
  NIAnEnumFortyTwo(3),
  NIAnEnumFourHundredTwentyTwo(4);

  final int value;
  const NIAnEnum(this.value);

  static NIAnEnum fromValue(int value) => switch (value) {
    0 => NIAnEnumOne,
    1 => NIAnEnumTwo,
    2 => NIAnEnumThree,
    3 => NIAnEnumFortyTwo,
    4 => NIAnEnumFourHundredTwentyTwo,
    _ => throw ArgumentError('Unknown value for NIAnEnum: $value'),
  };
}

enum NIAnotherEnum {
  NIAnotherEnumJustInCase(0);

  final int value;
  const NIAnotherEnum(this.value);

  static NIAnotherEnum fromValue(int value) => switch (value) {
    0 => NIAnotherEnumJustInCase,
    _ => throw ArgumentError('Unknown value for NIAnotherEnum: $value'),
  };
}

late final _sel_initWithABool_anInt_anInt64_aDouble_aByteArray_a4ByteArray_a8ByteArray_aFloatArray_anEnum_anotherEnum_aString_anObject_list_stringList_intList_doubleList_boolList_enumList_objectList_listList_mapList_map_stringMap_intMap_enumMap_objectMap_listMap_mapMap_ =
    objc.registerName(
      "initWithABool:anInt:anInt64:aDouble:aByteArray:a4ByteArray:a8ByteArray:aFloatArray:anEnum:anotherEnum:aString:anObject:list:stringList:intList:doubleList:boolList:enumList:objectList:listList:mapList:map:stringMap:intMap:enumMap:objectMap:listMap:mapMap:",
    );
final _objc_msgSend_whwize = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Int64,
          ffi.Int64,
          ffi.Double,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Long,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
        int,
        int,
        double,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_aBool = objc.registerName("aBool");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setABool_ = objc.registerName("setABool:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
late final _sel_anInt = objc.registerName("anInt");
final _objc_msgSend_pysgoz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Int64 Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setAnInt_ = objc.registerName("setAnInt:");
final _objc_msgSend_17gvxvj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int64,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_anInt64 = objc.registerName("anInt64");
late final _sel_setAnInt64_ = objc.registerName("setAnInt64:");
late final _sel_aDouble = objc.registerName("aDouble");
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setADouble_ = objc.registerName("setADouble:");
final _objc_msgSend_hwm8nu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
      )
    >();
late final _sel_aByteArray = objc.registerName("aByteArray");
late final _sel_setAByteArray_ = objc.registerName("setAByteArray:");
late final _sel_a4ByteArray = objc.registerName("a4ByteArray");
late final _sel_setA4ByteArray_ = objc.registerName("setA4ByteArray:");
late final _sel_a8ByteArray = objc.registerName("a8ByteArray");
late final _sel_setA8ByteArray_ = objc.registerName("setA8ByteArray:");
late final _sel_aFloatArray = objc.registerName("aFloatArray");
late final _sel_setAFloatArray_ = objc.registerName("setAFloatArray:");
late final _sel_anEnum = objc.registerName("anEnum");
final _objc_msgSend_d3bb7e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setAnEnum_ = objc.registerName("setAnEnum:");
final _objc_msgSend_15w00rc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_anotherEnum = objc.registerName("anotherEnum");
final _objc_msgSend_1otznu6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setAnotherEnum_ = objc.registerName("setAnotherEnum:");
final _objc_msgSend_ih63eg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_aString = objc.registerName("aString");
late final _sel_setAString_ = objc.registerName("setAString:");
late final _sel_anObject = objc.registerName("anObject");
late final _sel_setAnObject_ = objc.registerName("setAnObject:");

/// A class containing all supported types.
/// Generated bridge class from Pigeon that moves data from Swift to Objective-C.
///
/// iOS: introduced 13.0.0
/// macOS: introduced 16.0.0
extension type NIAllTypesBridge._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NIAllTypesBridge] that points to the same underlying object as [other].
  NIAllTypesBridge.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NIAllTypesBridge] that wraps the given raw object pointer.
  NIAllTypesBridge.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NIAllTypesBridge].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NIAllTypesBridge,
  );

  /// alloc
  static NIAllTypesBridge alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NIAllTypesBridge, _sel_alloc);
    return NIAllTypesBridge.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NIAllTypesBridge allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NIAllTypesBridge,
      _sel_allocWithZone_,
      zone,
    );
    return NIAllTypesBridge.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NIAllTypesBridge new$() {
    final $ret = _objc_msgSend_151sglz(_class_NIAllTypesBridge, _sel_new);
    return NIAllTypesBridge.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NIAllTypesBridge constructed with the default `new` method.
  NIAllTypesBridge() : this.as(new$().object$);
}

extension NIAllTypesBridge$Methods on NIAllTypesBridge {
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData get a4ByteArray {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.a4ByteArray',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_a4ByteArray);
    return PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData get a8ByteArray {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.a8ByteArray',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_a8ByteArray);
    return PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  bool get aBool {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.aBool',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_aBool);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData get aByteArray {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.aByteArray',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_aByteArray);
    return PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  double get aDouble {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.aDouble',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_aDouble)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_aDouble);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData get aFloatArray {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.aFloatArray',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_aFloatArray);
    return PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSString get aString {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.aString',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_aString);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAnEnum get anEnum {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.anEnum',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_d3bb7e(object$.ref.pointer, _sel_anEnum);
    return NIAnEnum.fromValue($ret);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  int get anInt {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.anInt',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    return _objc_msgSend_pysgoz(object$.ref.pointer, _sel_anInt);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  int get anInt64 {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.anInt64',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    return _objc_msgSend_pysgoz(object$.ref.pointer, _sel_anInt64);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSObject get anObject {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.anObject',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_anObject);
    return objc.NSObject.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAnotherEnum get anotherEnum {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.anotherEnum',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_1otznu6(object$.ref.pointer, _sel_anotherEnum);
    return NIAnotherEnum.fromValue($ret);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray get boolList {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.boolList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_boolList);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray get doubleList {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.doubleList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_doubleList);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray get enumList {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.enumList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_enumList);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary get enumMap {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.enumMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_enumMap);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NIAllTypesBridge init() {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NIAllTypesBridge.fromPointer($ret, retain: false, release: true);
  }

  /// initWithABool:anInt:anInt64:aDouble:aByteArray:a4ByteArray:a8ByteArray:aFloatArray:anEnum:anotherEnum:aString:anObject:list:stringList:intList:doubleList:boolList:enumList:objectList:listList:mapList:map:stringMap:intMap:enumMap:objectMap:listMap:mapMap:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllTypesBridge initWithABool(
    bool aBool, {
    required int anInt,
    required int anInt64,
    required double aDouble,
    required PigeonTypedData aByteArray,
    required PigeonTypedData a4ByteArray,
    required PigeonTypedData a8ByteArray,
    required PigeonTypedData aFloatArray,
    required NIAnEnum anEnum,
    required NIAnotherEnum anotherEnum,
    required objc.NSString aString,
    required objc.NSObject anObject,
    required objc.NSArray list,
    required objc.NSArray stringList,
    required objc.NSArray intList,
    required objc.NSArray doubleList,
    required objc.NSArray boolList,
    required objc.NSArray enumList,
    required objc.NSArray objectList,
    required objc.NSArray listList,
    required objc.NSArray mapList,
    required objc.NSDictionary map,
    required objc.NSDictionary stringMap,
    required objc.NSDictionary intMap,
    required objc.NSDictionary enumMap,
    required objc.NSDictionary objectMap,
    required objc.NSDictionary listMap,
    required objc.NSDictionary mapMap,
  }) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.initWithABool:anInt:anInt64:aDouble:aByteArray:a4ByteArray:a8ByteArray:aFloatArray:anEnum:anotherEnum:aString:anObject:list:stringList:intList:doubleList:boolList:enumList:objectList:listList:mapList:map:stringMap:intMap:enumMap:objectMap:listMap:mapMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_whwize(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithABool_anInt_anInt64_aDouble_aByteArray_a4ByteArray_a8ByteArray_aFloatArray_anEnum_anotherEnum_aString_anObject_list_stringList_intList_doubleList_boolList_enumList_objectList_listList_mapList_map_stringMap_intMap_enumMap_objectMap_listMap_mapMap_,
      aBool,
      anInt,
      anInt64,
      aDouble,
      aByteArray.ref.pointer,
      a4ByteArray.ref.pointer,
      a8ByteArray.ref.pointer,
      aFloatArray.ref.pointer,
      anEnum.value,
      anotherEnum.value,
      aString.ref.pointer,
      anObject.ref.pointer,
      list.ref.pointer,
      stringList.ref.pointer,
      intList.ref.pointer,
      doubleList.ref.pointer,
      boolList.ref.pointer,
      enumList.ref.pointer,
      objectList.ref.pointer,
      listList.ref.pointer,
      mapList.ref.pointer,
      map.ref.pointer,
      stringMap.ref.pointer,
      intMap.ref.pointer,
      enumMap.ref.pointer,
      objectMap.ref.pointer,
      listMap.ref.pointer,
      mapMap.ref.pointer,
    );
    return NIAllTypesBridge.fromPointer($ret, retain: false, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray get intList {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.intList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_intList);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary get intMap {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.intMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_intMap);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray get list {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.list',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_list);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray get listList {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.listList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_listList);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary get listMap {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.listMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_listMap);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary get map {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.map',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_map);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray get mapList {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.mapList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_mapList);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary get mapMap {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.mapMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_mapMap);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray get objectList {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.objectList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_objectList);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary get objectMap {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.objectMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_objectMap);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set a4ByteArray(PigeonTypedData value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setA4ByteArray:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setA4ByteArray_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set a8ByteArray(PigeonTypedData value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setA8ByteArray:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setA8ByteArray_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aBool(bool value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setABool:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setABool_, value);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aByteArray(PigeonTypedData value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setAByteArray:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAByteArray_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aDouble(double value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setADouble:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setADouble_, value);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aFloatArray(PigeonTypedData value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setAFloatArray:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAFloatArray_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aString(objc.NSString value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setAString:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAString_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set anEnum(NIAnEnum value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setAnEnum:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_15w00rc(object$.ref.pointer, _sel_setAnEnum_, value.value);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set anInt64(int value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setAnInt64:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_17gvxvj(object$.ref.pointer, _sel_setAnInt64_, value);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set anInt(int value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setAnInt:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_17gvxvj(object$.ref.pointer, _sel_setAnInt_, value);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set anObject(objc.NSObject value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setAnObject:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAnObject_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set anotherEnum(NIAnotherEnum value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setAnotherEnum:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_ih63eg(
      object$.ref.pointer,
      _sel_setAnotherEnum_,
      value.value,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set boolList(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setBoolList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setBoolList_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set doubleList(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setDoubleList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setDoubleList_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set enumList(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setEnumList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setEnumList_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set enumMap(objc.NSDictionary value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setEnumMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setEnumMap_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set intList(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setIntList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setIntList_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set intMap(objc.NSDictionary value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setIntMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setIntMap_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set list(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setList_, value.ref.pointer);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set listList(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setListList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setListList_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set listMap(objc.NSDictionary value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setListMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setListMap_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set map(objc.NSDictionary value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setMap_, value.ref.pointer);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set mapList(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setMapList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMapList_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set mapMap(objc.NSDictionary value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setMapMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMapMap_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set objectList(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setObjectList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setObjectList_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set objectMap(objc.NSDictionary value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setObjectMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setObjectMap_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set stringList(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setStringList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setStringList_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set stringMap(objc.NSDictionary value) {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.setStringMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setStringMap_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray get stringList {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.stringList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringList);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary get stringMap {
    objc.checkOsVersionInternal(
      'NIAllTypesBridge.stringMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_stringMap);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_initWithAllNullableTypes_allNullableTypesWithoutRecursion_allTypes_classList_nullableClassList_classMap_nullableClassMap_ =
    objc.registerName(
      "initWithAllNullableTypes:allNullableTypesWithoutRecursion:allTypes:classList:nullableClassList:classMap:nullableClassMap:",
    );
final _objc_msgSend_1387m63 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_allNullableTypesWithoutRecursion = objc.registerName(
  "allNullableTypesWithoutRecursion",
);
late final _sel_setAllNullableTypesWithoutRecursion_ = objc.registerName(
  "setAllNullableTypesWithoutRecursion:",
);
late final _sel_allTypes = objc.registerName("allTypes");
late final _sel_setAllTypes_ = objc.registerName("setAllTypes:");
late final _sel_classList = objc.registerName("classList");
late final _sel_setClassList_ = objc.registerName("setClassList:");
late final _sel_nullableClassList = objc.registerName("nullableClassList");
late final _sel_setNullableClassList_ = objc.registerName(
  "setNullableClassList:",
);
late final _sel_classMap = objc.registerName("classMap");
late final _sel_setClassMap_ = objc.registerName("setClassMap:");
late final _sel_nullableClassMap = objc.registerName("nullableClassMap");
late final _sel_setNullableClassMap_ = objc.registerName(
  "setNullableClassMap:",
);

/// A class for testing nested class handling.
/// This is needed to test nested nullable and non-nullable classes,
/// <code>NIAllNullableTypes</code> is non-nullable here as it is easier to instantiate
/// than <code>NIAllTypes</code> when testing doesnt require both (ie. testing null classes).
/// Generated bridge class from Pigeon that moves data from Swift to Objective-C.
///
/// iOS: introduced 13.0.0
/// macOS: introduced 16.0.0
extension type NIAllClassesWrapperBridge._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NIAllClassesWrapperBridge] that points to the same underlying object as [other].
  NIAllClassesWrapperBridge.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NIAllClassesWrapperBridge] that wraps the given raw object pointer.
  NIAllClassesWrapperBridge.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NIAllClassesWrapperBridge].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NIAllClassesWrapperBridge,
  );

  /// alloc
  static NIAllClassesWrapperBridge alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_NIAllClassesWrapperBridge,
      _sel_alloc,
    );
    return NIAllClassesWrapperBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NIAllClassesWrapperBridge allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NIAllClassesWrapperBridge,
      _sel_allocWithZone_,
      zone,
    );
    return NIAllClassesWrapperBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static NIAllClassesWrapperBridge new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_NIAllClassesWrapperBridge,
      _sel_new,
    );
    return NIAllClassesWrapperBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of NIAllClassesWrapperBridge constructed with the default `new` method.
  NIAllClassesWrapperBridge() : this.as(new$().object$);
}

extension NIAllClassesWrapperBridge$Methods on NIAllClassesWrapperBridge {
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllNullableTypesBridge get allNullableTypes {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.allNullableTypes',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_allNullableTypes,
    );
    return NIAllNullableTypesBridge.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllNullableTypesWithoutRecursionBridge?
  get allNullableTypesWithoutRecursion {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.allNullableTypesWithoutRecursion',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_allNullableTypesWithoutRecursion,
    );
    return $ret.address == 0
        ? null
        : NIAllNullableTypesWithoutRecursionBridge.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllTypesBridge? get allTypes {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.allTypes',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_allTypes);
    return $ret.address == 0
        ? null
        : NIAllTypesBridge.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray get classList {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.classList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_classList);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary get classMap {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.classMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_classMap);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NIAllClassesWrapperBridge init() {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NIAllClassesWrapperBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithAllNullableTypes:allNullableTypesWithoutRecursion:allTypes:classList:nullableClassList:classMap:nullableClassMap:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllClassesWrapperBridge initWithAllNullableTypes(
    NIAllNullableTypesBridge allNullableTypes, {
    NIAllNullableTypesWithoutRecursionBridge? allNullableTypesWithoutRecursion,
    NIAllTypesBridge? allTypes,
    required objc.NSArray classList,
    objc.NSArray? nullableClassList,
    required objc.NSDictionary classMap,
    objc.NSDictionary? nullableClassMap,
  }) {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.initWithAllNullableTypes:allNullableTypesWithoutRecursion:allTypes:classList:nullableClassList:classMap:nullableClassMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_1387m63(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithAllNullableTypes_allNullableTypesWithoutRecursion_allTypes_classList_nullableClassList_classMap_nullableClassMap_,
      allNullableTypes.ref.pointer,
      allNullableTypesWithoutRecursion?.ref.pointer ?? ffi.nullptr,
      allTypes?.ref.pointer ?? ffi.nullptr,
      classList.ref.pointer,
      nullableClassList?.ref.pointer ?? ffi.nullptr,
      classMap.ref.pointer,
      nullableClassMap?.ref.pointer ?? ffi.nullptr,
    );
    return NIAllClassesWrapperBridge.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? get nullableClassList {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.nullableClassList',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_nullableClassList,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? get nullableClassMap {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.nullableClassMap',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_nullableClassMap,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set allNullableTypes(NIAllNullableTypesBridge value) {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.setAllNullableTypes:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAllNullableTypes_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set allNullableTypesWithoutRecursion(
    NIAllNullableTypesWithoutRecursionBridge? value,
  ) {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.setAllNullableTypesWithoutRecursion:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAllNullableTypesWithoutRecursion_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set allTypes(NIAllTypesBridge? value) {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.setAllTypes:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAllTypes_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set classList(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.setClassList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setClassList_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set classMap(objc.NSDictionary value) {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.setClassMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setClassMap_,
      value.ref.pointer,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set nullableClassList(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.setNullableClassList:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setNullableClassList_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set nullableClassMap(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NIAllClassesWrapperBridge.setNullableClassMap:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setNullableClassMap_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _class_NIHostIntegrationCoreApiSetup = objc.getClass(
  "test_plugin.NIHostIntegrationCoreApiSetup",
);
late final _sel_getInstanceWithName_ = objc.registerName(
  "getInstanceWithName:",
);
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _class_NiTestsError = objc.getClass("test_plugin.NiTestsError");
late final _sel_code = objc.registerName("code");
late final _sel_setCode_ = objc.registerName("setCode:");
late final _sel_message = objc.registerName("message");
late final _sel_setMessage_ = objc.registerName("setMessage:");
late final _sel_details = objc.registerName("details");
late final _sel_setDetails_ = objc.registerName("setDetails:");
late final _sel_initWithCode_message_details_ = objc.registerName(
  "initWithCode:message:details:",
);
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Error class for passing custom error details to Dart side.
extension type NiTestsError._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NiTestsError] that points to the same underlying object as [other].
  NiTestsError.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [NiTestsError] that wraps the given raw object pointer.
  NiTestsError.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NiTestsError].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NiTestsError,
  );

  /// alloc
  static NiTestsError alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NiTestsError, _sel_alloc);
    return NiTestsError.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NiTestsError allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NiTestsError,
      _sel_allocWithZone_,
      zone,
    );
    return NiTestsError.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NiTestsError new$() {
    final $ret = _objc_msgSend_151sglz(_class_NiTestsError, _sel_new);
    return NiTestsError.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NiTestsError constructed with the default `new` method.
  NiTestsError() : this.as(new$().object$);
}

extension NiTestsError$Methods on NiTestsError {
  /// code
  objc.NSString? get code {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_code);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// details
  objc.NSString? get details {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_details);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NiTestsError init() {
    objc.checkOsVersionInternal(
      'NiTestsError.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NiTestsError.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCode:message:details:
  NiTestsError initWithCode(
    objc.NSString? code, {
    objc.NSString? message,
    objc.NSString? details,
  }) {
    final $ret = _objc_msgSend_11spmsz(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCode_message_details_,
      code?.ref.pointer ?? ffi.nullptr,
      message?.ref.pointer ?? ffi.nullptr,
      details?.ref.pointer ?? ffi.nullptr,
    );
    return NiTestsError.fromPointer($ret, retain: false, release: true);
  }

  /// message
  objc.NSString? get message {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_message);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// setCode:
  set code(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setCode_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setDetails:
  set details(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setDetails_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setMessage:
  set message(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMessage_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_noopWithWrappedError_ = objc.registerName(
  "noopWithWrappedError:",
);
late final _sel_echoAllTypesWithEverything_wrappedError_ = objc.registerName(
  "echoAllTypesWithEverything:wrappedError:",
);
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_throwErrorWithWrappedError_ = objc.registerName(
  "throwErrorWithWrappedError:",
);
late final _sel_throwErrorFromVoidWithWrappedError_ = objc.registerName(
  "throwErrorFromVoidWithWrappedError:",
);
late final _sel_throwFlutterErrorWithWrappedError_ = objc.registerName(
  "throwFlutterErrorWithWrappedError:",
);
late final _sel_echoIntWithAnInt_wrappedError_ = objc.registerName(
  "echoIntWithAnInt:wrappedError:",
);
final _objc_msgSend_1j962g9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int64,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_echoDoubleWithADouble_wrappedError_ = objc.registerName(
  "echoDoubleWithADouble:wrappedError:",
);
final _objc_msgSend_1ozwf6k = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_echoBoolWithABool_wrappedError_ = objc.registerName(
  "echoBoolWithABool:wrappedError:",
);
final _objc_msgSend_w1rg4f = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_echoStringWithAString_wrappedError_ = objc.registerName(
  "echoStringWithAString:wrappedError:",
);
late final _sel_echoUint8ListWithAUint8List_wrappedError_ = objc.registerName(
  "echoUint8ListWithAUint8List:wrappedError:",
);
late final _sel_echoInt32ListWithAInt32List_wrappedError_ = objc.registerName(
  "echoInt32ListWithAInt32List:wrappedError:",
);
late final _sel_echoInt64ListWithAInt64List_wrappedError_ = objc.registerName(
  "echoInt64ListWithAInt64List:wrappedError:",
);
late final _sel_echoFloat64ListWithAFloat64List_wrappedError_ = objc
    .registerName("echoFloat64ListWithAFloat64List:wrappedError:");
late final _sel_echoObjectWithAnObject_wrappedError_ = objc.registerName(
  "echoObjectWithAnObject:wrappedError:",
);
late final _sel_echoListWithList_wrappedError_ = objc.registerName(
  "echoListWithList:wrappedError:",
);
late final _sel_echoStringListWithStringList_wrappedError_ = objc.registerName(
  "echoStringListWithStringList:wrappedError:",
);
late final _sel_echoIntListWithIntList_wrappedError_ = objc.registerName(
  "echoIntListWithIntList:wrappedError:",
);
late final _sel_echoDoubleListWithDoubleList_wrappedError_ = objc.registerName(
  "echoDoubleListWithDoubleList:wrappedError:",
);
late final _sel_echoBoolListWithBoolList_wrappedError_ = objc.registerName(
  "echoBoolListWithBoolList:wrappedError:",
);
late final _sel_echoEnumListWithEnumList_wrappedError_ = objc.registerName(
  "echoEnumListWithEnumList:wrappedError:",
);
late final _sel_echoClassListWithClassList_wrappedError_ = objc.registerName(
  "echoClassListWithClassList:wrappedError:",
);
late final _sel_echoNonNullEnumListWithEnumList_wrappedError_ = objc
    .registerName("echoNonNullEnumListWithEnumList:wrappedError:");
late final _sel_echoNonNullClassListWithClassList_wrappedError_ = objc
    .registerName("echoNonNullClassListWithClassList:wrappedError:");
late final _sel_echoMapWithMap_wrappedError_ = objc.registerName(
  "echoMapWithMap:wrappedError:",
);
late final _sel_echoStringMapWithStringMap_wrappedError_ = objc.registerName(
  "echoStringMapWithStringMap:wrappedError:",
);
late final _sel_echoIntMapWithIntMap_wrappedError_ = objc.registerName(
  "echoIntMapWithIntMap:wrappedError:",
);
late final _sel_echoEnumMapWithEnumMap_wrappedError_ = objc.registerName(
  "echoEnumMapWithEnumMap:wrappedError:",
);
late final _sel_echoClassMapWithClassMap_wrappedError_ = objc.registerName(
  "echoClassMapWithClassMap:wrappedError:",
);
late final _sel_echoNonNullStringMapWithStringMap_wrappedError_ = objc
    .registerName("echoNonNullStringMapWithStringMap:wrappedError:");
late final _sel_echoNonNullIntMapWithIntMap_wrappedError_ = objc.registerName(
  "echoNonNullIntMapWithIntMap:wrappedError:",
);
late final _sel_echoNonNullEnumMapWithEnumMap_wrappedError_ = objc.registerName(
  "echoNonNullEnumMapWithEnumMap:wrappedError:",
);
late final _sel_echoNonNullClassMapWithClassMap_wrappedError_ = objc
    .registerName("echoNonNullClassMapWithClassMap:wrappedError:");
late final _sel_echoClassWrapperWithWrapper_wrappedError_ = objc.registerName(
  "echoClassWrapperWithWrapper:wrappedError:",
);
late final _sel_echoEnumWithAnEnum_wrappedError_ = objc.registerName(
  "echoEnumWithAnEnum:wrappedError:",
);
final _objc_msgSend_1k0qzru = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_echoAnotherEnumWithAnotherEnum_wrappedError_ = objc
    .registerName("echoAnotherEnumWithAnotherEnum:wrappedError:");
final _objc_msgSend_ladeuy = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_echoAllNullableTypesWithEverything_wrappedError_ = objc
    .registerName("echoAllNullableTypesWithEverything:wrappedError:");
late final _sel_echoAllNullableTypesWithoutRecursionWithEverything_wrappedError_ =
    objc.registerName(
      "echoAllNullableTypesWithoutRecursionWithEverything:wrappedError:",
    );
late final _sel_extractNestedNullableStringWithWrapper_wrappedError_ = objc
    .registerName("extractNestedNullableStringWithWrapper:wrappedError:");
late final _sel_createNestedNullableStringWithNullableString_wrappedError_ =
    objc.registerName(
      "createNestedNullableStringWithNullableString:wrappedError:",
    );
late final _sel_sendMultipleNullableTypesWithANullableBool_aNullableInt_aNullableString_wrappedError_ =
    objc.registerName(
      "sendMultipleNullableTypesWithANullableBool:aNullableInt:aNullableString:wrappedError:",
    );
final _objc_msgSend_s92gih = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_sendMultipleNullableTypesWithoutRecursionWithANullableBool_aNullableInt_aNullableString_wrappedError_ =
    objc.registerName(
      "sendMultipleNullableTypesWithoutRecursionWithANullableBool:aNullableInt:aNullableString:wrappedError:",
    );
late final _sel_echoNullableIntWithANullableInt_wrappedError_ = objc
    .registerName("echoNullableIntWithANullableInt:wrappedError:");
late final _sel_echoNullableDoubleWithANullableDouble_wrappedError_ = objc
    .registerName("echoNullableDoubleWithANullableDouble:wrappedError:");
late final _sel_echoNullableBoolWithANullableBool_wrappedError_ = objc
    .registerName("echoNullableBoolWithANullableBool:wrappedError:");
late final _sel_echoNullableStringWithANullableString_wrappedError_ = objc
    .registerName("echoNullableStringWithANullableString:wrappedError:");
late final _sel_echoNullableUint8ListWithANullableUint8List_wrappedError_ = objc
    .registerName("echoNullableUint8ListWithANullableUint8List:wrappedError:");
late final _sel_echoNullableInt32ListWithANullableInt32List_wrappedError_ = objc
    .registerName("echoNullableInt32ListWithANullableInt32List:wrappedError:");
late final _sel_echoNullableInt64ListWithANullableInt64List_wrappedError_ = objc
    .registerName("echoNullableInt64ListWithANullableInt64List:wrappedError:");
late final _sel_echoNullableFloat64ListWithANullableFloat64List_wrappedError_ =
    objc.registerName(
      "echoNullableFloat64ListWithANullableFloat64List:wrappedError:",
    );
late final _sel_echoNullableObjectWithANullableObject_wrappedError_ = objc
    .registerName("echoNullableObjectWithANullableObject:wrappedError:");
late final _sel_echoNullableListWithANullableList_wrappedError_ = objc
    .registerName("echoNullableListWithANullableList:wrappedError:");
late final _sel_echoNullableEnumListWithEnumList_wrappedError_ = objc
    .registerName("echoNullableEnumListWithEnumList:wrappedError:");
late final _sel_echoNullableClassListWithClassList_wrappedError_ = objc
    .registerName("echoNullableClassListWithClassList:wrappedError:");
late final _sel_echoNullableNonNullEnumListWithEnumList_wrappedError_ = objc
    .registerName("echoNullableNonNullEnumListWithEnumList:wrappedError:");
late final _sel_echoNullableNonNullClassListWithClassList_wrappedError_ = objc
    .registerName("echoNullableNonNullClassListWithClassList:wrappedError:");
late final _sel_echoNullableMapWithMap_wrappedError_ = objc.registerName(
  "echoNullableMapWithMap:wrappedError:",
);
late final _sel_echoNullableStringMapWithStringMap_wrappedError_ = objc
    .registerName("echoNullableStringMapWithStringMap:wrappedError:");
late final _sel_echoNullableIntMapWithIntMap_wrappedError_ = objc.registerName(
  "echoNullableIntMapWithIntMap:wrappedError:",
);
late final _sel_echoNullableEnumMapWithEnumMap_wrappedError_ = objc
    .registerName("echoNullableEnumMapWithEnumMap:wrappedError:");
late final _sel_echoNullableClassMapWithClassMap_wrappedError_ = objc
    .registerName("echoNullableClassMapWithClassMap:wrappedError:");
late final _sel_echoNullableNonNullStringMapWithStringMap_wrappedError_ = objc
    .registerName("echoNullableNonNullStringMapWithStringMap:wrappedError:");
late final _sel_echoNullableNonNullIntMapWithIntMap_wrappedError_ = objc
    .registerName("echoNullableNonNullIntMapWithIntMap:wrappedError:");
late final _sel_echoNullableNonNullEnumMapWithEnumMap_wrappedError_ = objc
    .registerName("echoNullableNonNullEnumMapWithEnumMap:wrappedError:");
late final _sel_echoNullableNonNullClassMapWithClassMap_wrappedError_ = objc
    .registerName("echoNullableNonNullClassMapWithClassMap:wrappedError:");
late final _sel_echoNullableEnumWithAnEnum_wrappedError_ = objc.registerName(
  "echoNullableEnumWithAnEnum:wrappedError:",
);
late final _sel_echoAnotherNullableEnumWithAnotherEnum_wrappedError_ = objc
    .registerName("echoAnotherNullableEnumWithAnotherEnum:wrappedError:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newClosureBlock(_closureCallable, () => fn(), keepIsolateAlive),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> listener(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function()> blocking(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapBlockingBlock_1pl9qdv(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) {
    (objc.getBlockClosure(block) as void Function())();
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function())();
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) => block
      .ref
      .target
      .cast<ffi.NativeFunction<ffi.Void Function()>>()
      .asFunction<void Function()>()();
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) =>
      (objc.getBlockClosure(block) as void Function())();
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Void Function()> {
  void call() =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      );
}

late final _sel_noopAsyncWithWrappedError_completionHandler_ = objc
    .registerName("noopAsyncWithWrappedError:completionHandler:");
final _objc_msgSend_o762yo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>`.
abstract final class ObjCBlock_ffiVoid_NSNumber {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)> fromFunction(
    void Function(objc.NSNumber?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSNumber.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)> listener(
    void Function(objc.NSNumber?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSNumber.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)> blocking(
    void Function(objc.NSNumber?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSNumber.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSNumber.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>`.
extension ObjCBlock_ffiVoid_NSNumber$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)> {
  void call(objc.NSNumber? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_echoAsyncIntWithAnInt_wrappedError_completionHandler_ = objc
    .registerName("echoAsyncIntWithAnInt:wrappedError:completionHandler:");
final _objc_msgSend_1bf2hie = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int64,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_echoAsyncDoubleWithADouble_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncDoubleWithADouble:wrappedError:completionHandler:",
    );
final _objc_msgSend_f15nnv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_echoAsyncBoolWithABool_wrappedError_completionHandler_ = objc
    .registerName("echoAsyncBoolWithABool:wrappedError:completionHandler:");
final _objc_msgSend_1oby3xk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSString?)>`.
abstract final class ObjCBlock_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSString?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSString?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?)> fromFunction(
    void Function(objc.NSString?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSString?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSString.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?)> listener(
    void Function(objc.NSString?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSString.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?)> blocking(
    void Function(objc.NSString?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSString.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSString.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSString?)>`.
extension ObjCBlock_ffiVoid_NSString$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSString?)> {
  void call(objc.NSString? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_echoAsyncStringWithAString_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncStringWithAString:wrappedError:completionHandler:",
    );
final _objc_msgSend_18qun1e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>`.
abstract final class ObjCBlock_ffiVoid_PigeonTypedData {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)> fromFunction(
    void Function(PigeonTypedData?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : PigeonTypedData.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)> listener(
    void Function(PigeonTypedData?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : PigeonTypedData.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)> blocking(
    void Function(PigeonTypedData?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : PigeonTypedData.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : PigeonTypedData.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>`.
extension ObjCBlock_ffiVoid_PigeonTypedData$CallExtension
    on objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)> {
  void call(PigeonTypedData? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_echoAsyncUint8ListWithAUint8List_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncUint8ListWithAUint8List:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncInt32ListWithAInt32List_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncInt32ListWithAInt32List:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncInt64ListWithAInt64List_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncInt64ListWithAInt64List:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncFloat64ListWithAFloat64List_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncFloat64ListWithAFloat64List:wrappedError:completionHandler:",
    );

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>`.
abstract final class ObjCBlock_ffiVoid_dispatchdatat {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?)> fromFunction(
    void Function(objc.NSObject?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSObject.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?)> listener(
    void Function(objc.NSObject?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSObject.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?)> blocking(
    void Function(objc.NSObject?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSObject.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSObject.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>`.
extension ObjCBlock_ffiVoid_dispatchdatat$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSObject?)> {
  void call(objc.NSObject? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_echoAsyncObjectWithAnObject_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncObjectWithAnObject:wrappedError:completionHandler:",
    );

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSArray?)>`.
abstract final class ObjCBlock_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSArray?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray?)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSArray?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray?)> fromFunction(
    void Function(objc.NSArray?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSArray?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSArray.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray?)> listener(
    void Function(objc.NSArray?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSArray.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSArray?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray?)> blocking(
    void Function(objc.NSArray?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSArray.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSArray.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSArray?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSArray?)>`.
extension ObjCBlock_ffiVoid_NSArray$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSArray?)> {
  void call(objc.NSArray? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_echoAsyncListWithList_wrappedError_completionHandler_ = objc
    .registerName("echoAsyncListWithList:wrappedError:completionHandler:");
late final _sel_echoAsyncEnumListWithEnumList_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncEnumListWithEnumList:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncClassListWithClassList_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncClassListWithClassList:wrappedError:completionHandler:",
    );

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>`.
abstract final class ObjCBlock_ffiVoid_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)> fromFunction(
    void Function(objc.NSDictionary?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSDictionary.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)> listener(
    void Function(objc.NSDictionary?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSDictionary.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)> blocking(
    void Function(objc.NSDictionary?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSDictionary.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSDictionary.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>`.
extension ObjCBlock_ffiVoid_NSDictionary$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)> {
  void call(objc.NSDictionary? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_echoAsyncMapWithMap_wrappedError_completionHandler_ = objc
    .registerName("echoAsyncMapWithMap:wrappedError:completionHandler:");
late final _sel_echoAsyncStringMapWithStringMap_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncStringMapWithStringMap:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncIntMapWithIntMap_wrappedError_completionHandler_ = objc
    .registerName("echoAsyncIntMapWithIntMap:wrappedError:completionHandler:");
late final _sel_echoAsyncEnumMapWithEnumMap_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncEnumMapWithEnumMap:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncClassMapWithClassMap_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncClassMapWithClassMap:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncEnumWithAnEnum_wrappedError_completionHandler_ = objc
    .registerName("echoAsyncEnumWithAnEnum:wrappedError:completionHandler:");
final _objc_msgSend_1yka6e5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_echoAnotherAsyncEnumWithAnotherEnum_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAnotherAsyncEnumWithAnotherEnum:wrappedError:completionHandler:",
    );
final _objc_msgSend_1ht8su5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_throwAsyncErrorWithWrappedError_completionHandler_ = objc
    .registerName("throwAsyncErrorWithWrappedError:completionHandler:");
late final _sel_throwAsyncErrorFromVoidWithWrappedError_completionHandler_ =
    objc.registerName(
      "throwAsyncErrorFromVoidWithWrappedError:completionHandler:",
    );
late final _sel_throwAsyncFlutterErrorWithWrappedError_completionHandler_ = objc
    .registerName("throwAsyncFlutterErrorWithWrappedError:completionHandler:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)>`.
abstract final class ObjCBlock_ffiVoid_NIAllTypesBridge {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)> fromFunction(
    void Function(NIAllTypesBridge?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NIAllTypesBridge.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)> listener(
    void Function(NIAllTypesBridge?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NIAllTypesBridge.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)> blocking(
    void Function(NIAllTypesBridge?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NIAllTypesBridge.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NIAllTypesBridge.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)>`.
extension ObjCBlock_ffiVoid_NIAllTypesBridge$CallExtension
    on objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)> {
  void call(NIAllTypesBridge? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_echoAsyncNIAllTypesWithEverything_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNIAllTypesWithEverything:wrappedError:completionHandler:",
    );

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)>`.
abstract final class ObjCBlock_ffiVoid_NIAllNullableTypesBridge {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)>
  fromFunction(
    void Function(NIAllNullableTypesBridge?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NIAllNullableTypesBridge.fromPointer(
                arg0,
                retain: true,
                release: true,
              ),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)> listener(
    void Function(NIAllNullableTypesBridge?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NIAllNullableTypesBridge.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)> blocking(
    void Function(NIAllNullableTypesBridge?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NIAllNullableTypesBridge.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NIAllNullableTypesBridge.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)>`.
extension ObjCBlock_ffiVoid_NIAllNullableTypesBridge$CallExtension
    on objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)> {
  void call(NIAllNullableTypesBridge? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_echoAsyncNullableNIAllNullableTypesWithEverything_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableNIAllNullableTypesWithEverything:wrappedError:completionHandler:",
    );

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)>`.
abstract final class ObjCBlock_ffiVoid_NIAllNullableTypesWithoutRecursionBridge {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)
  >
  fromFunction(
    void Function(NIAllNullableTypesWithoutRecursionBridge?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
            arg0.address == 0
                ? null
                : NIAllNullableTypesWithoutRecursionBridge.fromPointer(
                    arg0,
                    retain: true,
                    release: true,
                  ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)
  >
  listener(
    void Function(NIAllNullableTypesWithoutRecursionBridge?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NIAllNullableTypesWithoutRecursionBridge.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)
  >
  blocking(
    void Function(NIAllNullableTypesWithoutRecursionBridge?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NIAllNullableTypesWithoutRecursionBridge.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NIAllNullableTypesWithoutRecursionBridge.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _umaz4x_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)>`.
extension ObjCBlock_ffiVoid_NIAllNullableTypesWithoutRecursionBridge$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)
        > {
  void call(NIAllNullableTypesWithoutRecursionBridge? arg0) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_echoAsyncNullableNIAllNullableTypesWithoutRecursionWithEverything_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableNIAllNullableTypesWithoutRecursionWithEverything:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableIntWithAnInt_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableIntWithAnInt:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableDoubleWithADouble_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableDoubleWithADouble:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableBoolWithABool_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableBoolWithABool:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableStringWithAString_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableStringWithAString:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableUint8ListWithAUint8List_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableUint8ListWithAUint8List:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableInt32ListWithAInt32List_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableInt32ListWithAInt32List:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableInt64ListWithAInt64List_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableInt64ListWithAInt64List:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableFloat64ListWithAFloat64List_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableFloat64ListWithAFloat64List:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableObjectWithAnObject_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableObjectWithAnObject:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableListWithList_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableListWithList:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableEnumListWithEnumList_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableEnumListWithEnumList:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableClassListWithClassList_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableClassListWithClassList:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableMapWithMap_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableMapWithMap:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableStringMapWithStringMap_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableStringMapWithStringMap:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableIntMapWithIntMap_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableIntMapWithIntMap:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableEnumMapWithEnumMap_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableEnumMapWithEnumMap:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableClassMapWithClassMap_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableClassMapWithClassMap:wrappedError:completionHandler:",
    );
late final _sel_echoAsyncNullableEnumWithAnEnum_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAsyncNullableEnumWithAnEnum:wrappedError:completionHandler:",
    );
late final _sel_echoAnotherAsyncNullableEnumWithAnotherEnum_wrappedError_completionHandler_ =
    objc.registerName(
      "echoAnotherAsyncNullableEnumWithAnotherEnum:wrappedError:completionHandler:",
    );

/// Generated setup class from Pigeon to register implemented NIHostIntegrationCoreApi classes.
///
/// iOS: introduced 13.0.0
/// macOS: introduced 16.0.0
extension type NIHostIntegrationCoreApiSetup._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NIHostIntegrationCoreApiSetup] that points to the same underlying object as [other].
  NIHostIntegrationCoreApiSetup.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NIHostIntegrationCoreApiSetup] that wraps the given raw object pointer.
  NIHostIntegrationCoreApiSetup.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NIHostIntegrationCoreApiSetup].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NIHostIntegrationCoreApiSetup,
  );

  /// alloc
  static NIHostIntegrationCoreApiSetup alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_NIHostIntegrationCoreApiSetup,
      _sel_alloc,
    );
    return NIHostIntegrationCoreApiSetup.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NIHostIntegrationCoreApiSetup allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NIHostIntegrationCoreApiSetup,
      _sel_allocWithZone_,
      zone,
    );
    return NIHostIntegrationCoreApiSetup.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// getInstanceWithName:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  static NIHostIntegrationCoreApiSetup? getInstanceWithName(
    objc.NSString name,
  ) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.getInstanceWithName:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NIHostIntegrationCoreApiSetup,
      _sel_getInstanceWithName_,
      name.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NIHostIntegrationCoreApiSetup.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// new
  static NIHostIntegrationCoreApiSetup new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_NIHostIntegrationCoreApiSetup,
      _sel_new,
    );
    return NIHostIntegrationCoreApiSetup.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of NIHostIntegrationCoreApiSetup constructed with the default `new` method.
  NIHostIntegrationCoreApiSetup() : this.as(new$().object$);
}

extension NIHostIntegrationCoreApiSetup$Methods
    on NIHostIntegrationCoreApiSetup {
  /// Returns the inner <code>aString</code> value from the wrapped object, to test
  /// sending of nested objects.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllClassesWrapperBridge? createNestedNullableStringWithNullableString(
    objc.NSString? nullableString, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.createNestedNullableStringWithNullableString:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_createNestedNullableStringWithNullableString_wrappedError_,
      nullableString?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NIAllClassesWrapperBridge.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// Returns the passed object, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllNullableTypesBridge? echoAllNullableTypesWithEverything(
    NIAllNullableTypesBridge? everything, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAllNullableTypesWithEverything:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoAllNullableTypesWithEverything_wrappedError_,
      everything?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NIAllNullableTypesBridge.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// Returns the passed object, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllNullableTypesWithoutRecursionBridge?
  echoAllNullableTypesWithoutRecursionWithEverything(
    NIAllNullableTypesWithoutRecursionBridge? everything, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAllNullableTypesWithoutRecursionWithEverything:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoAllNullableTypesWithoutRecursionWithEverything_wrappedError_,
      everything?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NIAllNullableTypesWithoutRecursionBridge.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// Returns the passed object, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllTypesBridge? echoAllTypesWithEverything(
    NIAllTypesBridge everything, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAllTypesWithEverything:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoAllTypesWithEverything_wrappedError_,
      everything.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NIAllTypesBridge.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAnotherAsyncEnumWithAnotherEnum(
    NIAnotherEnum anotherEnum, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAnotherAsyncEnumWithAnotherEnum:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_1ht8su5(
      object$.ref.pointer,
      _sel_echoAnotherAsyncEnumWithAnotherEnum_wrappedError_completionHandler_,
      anotherEnum.value,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAnotherAsyncNullableEnumWithAnotherEnum(
    objc.NSNumber? anotherEnum, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAnotherAsyncNullableEnumWithAnotherEnum:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAnotherAsyncNullableEnumWithAnotherEnum_wrappedError_completionHandler_,
      anotherEnum?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed enum to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? echoAnotherEnumWithAnotherEnum(
    NIAnotherEnum anotherEnum, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAnotherEnumWithAnotherEnum:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_ladeuy(
      object$.ref.pointer,
      _sel_echoAnotherEnumWithAnotherEnum_wrappedError_,
      anotherEnum.value,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// echoAnotherNullableEnumWithAnotherEnum:wrappedError:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? echoAnotherNullableEnumWithAnotherEnum(
    objc.NSNumber? anotherEnum, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAnotherNullableEnumWithAnotherEnum:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoAnotherNullableEnumWithAnotherEnum_wrappedError_,
      anotherEnum?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in boolean asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncBoolWithABool(
    bool aBool, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncBoolWithABool:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_1oby3xk(
      object$.ref.pointer,
      _sel_echoAsyncBoolWithABool_wrappedError_completionHandler_,
      aBool,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncClassListWithClassList(
    objc.NSArray classList, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSArray?)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncClassListWithClassList:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncClassListWithClassList_wrappedError_completionHandler_,
      classList.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncClassMapWithClassMap(
    objc.NSDictionary classMap, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncClassMapWithClassMap:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncClassMapWithClassMap_wrappedError_completionHandler_,
      classMap.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns passed in double asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncDoubleWithADouble(
    double aDouble, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncDoubleWithADouble:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_f15nnv(
      object$.ref.pointer,
      _sel_echoAsyncDoubleWithADouble_wrappedError_completionHandler_,
      aDouble,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncEnumListWithEnumList(
    objc.NSArray enumList, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSArray?)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncEnumListWithEnumList:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncEnumListWithEnumList_wrappedError_completionHandler_,
      enumList.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncEnumMapWithEnumMap(
    objc.NSDictionary enumMap, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncEnumMapWithEnumMap:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncEnumMapWithEnumMap_wrappedError_completionHandler_,
      enumMap.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncEnumWithAnEnum(
    NIAnEnum anEnum, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncEnumWithAnEnum:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_1yka6e5(
      object$.ref.pointer,
      _sel_echoAsyncEnumWithAnEnum_wrappedError_completionHandler_,
      anEnum.value,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed in Float64List asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncFloat64ListWithAFloat64List(
    PigeonTypedData aFloat64List, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncFloat64ListWithAFloat64List:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncFloat64ListWithAFloat64List_wrappedError_completionHandler_,
      aFloat64List.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed in Int32List asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncInt32ListWithAInt32List(
    PigeonTypedData aInt32List, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncInt32ListWithAInt32List:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncInt32ListWithAInt32List_wrappedError_completionHandler_,
      aInt32List.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed in Int64List asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncInt64ListWithAInt64List(
    PigeonTypedData aInt64List, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncInt64ListWithAInt64List:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncInt64ListWithAInt64List_wrappedError_completionHandler_,
      aInt64List.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncIntMapWithIntMap(
    objc.NSDictionary intMap, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncIntMapWithIntMap:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncIntMapWithIntMap_wrappedError_completionHandler_,
      intMap.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns passed in int asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncIntWithAnInt(
    int anInt, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncIntWithAnInt:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_1bf2hie(
      object$.ref.pointer,
      _sel_echoAsyncIntWithAnInt_wrappedError_completionHandler_,
      anInt,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncListWithList(
    objc.NSArray list, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSArray?)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncListWithList:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncListWithList_wrappedError_completionHandler_,
      list.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncMapWithMap(
    objc.NSDictionary map, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncMapWithMap:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncMapWithMap_wrappedError_completionHandler_,
      map.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed object, to test async serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNIAllTypesWithEverything(
    NIAllTypesBridge everything, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(NIAllTypesBridge?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNIAllTypesWithEverything:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNIAllTypesWithEverything_wrappedError_completionHandler_,
      everything.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed in boolean asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableBoolWithABool(
    objc.NSNumber? aBool, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableBoolWithABool:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableBoolWithABool_wrappedError_completionHandler_,
      aBool?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableClassListWithClassList(
    objc.NSArray? classList, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSArray?)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableClassListWithClassList:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableClassListWithClassList_wrappedError_completionHandler_,
      classList?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableClassMapWithClassMap(
    objc.NSDictionary? classMap, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableClassMapWithClassMap:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableClassMapWithClassMap_wrappedError_completionHandler_,
      classMap?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns passed in double asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableDoubleWithADouble(
    objc.NSNumber? aDouble, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableDoubleWithADouble:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableDoubleWithADouble_wrappedError_completionHandler_,
      aDouble?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableEnumListWithEnumList(
    objc.NSArray? enumList, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSArray?)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableEnumListWithEnumList:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableEnumListWithEnumList_wrappedError_completionHandler_,
      enumList?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableEnumMapWithEnumMap(
    objc.NSDictionary? enumMap, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableEnumMapWithEnumMap:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableEnumMapWithEnumMap_wrappedError_completionHandler_,
      enumMap?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed enum, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableEnumWithAnEnum(
    objc.NSNumber? anEnum, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableEnumWithAnEnum:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableEnumWithAnEnum_wrappedError_completionHandler_,
      anEnum?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed in Float64List asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableFloat64ListWithAFloat64List(
    PigeonTypedData? aFloat64List, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableFloat64ListWithAFloat64List:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableFloat64ListWithAFloat64List_wrappedError_completionHandler_,
      aFloat64List?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed in Int32List asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableInt32ListWithAInt32List(
    PigeonTypedData? aInt32List, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableInt32ListWithAInt32List:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableInt32ListWithAInt32List_wrappedError_completionHandler_,
      aInt32List?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed in Int64List asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableInt64ListWithAInt64List(
    PigeonTypedData? aInt64List, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableInt64ListWithAInt64List:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableInt64ListWithAInt64List_wrappedError_completionHandler_,
      aInt64List?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableIntMapWithIntMap(
    objc.NSDictionary? intMap, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableIntMapWithIntMap:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableIntMapWithIntMap_wrappedError_completionHandler_,
      intMap?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns passed in int asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableIntWithAnInt(
    objc.NSNumber? anInt, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSNumber?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableIntWithAnInt:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableIntWithAnInt_wrappedError_completionHandler_,
      anInt?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed list, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableListWithList(
    objc.NSArray? list, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSArray?)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableListWithList:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableListWithList_wrappedError_completionHandler_,
      list?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableMapWithMap(
    objc.NSDictionary? map, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableMapWithMap:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableMapWithMap_wrappedError_completionHandler_,
      map?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed object, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableNIAllNullableTypesWithEverything(
    NIAllNullableTypesBridge? everything, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(NIAllNullableTypesBridge?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableNIAllNullableTypesWithEverything:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableNIAllNullableTypesWithEverything_wrappedError_completionHandler_,
      everything?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed object, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableNIAllNullableTypesWithoutRecursionWithEverything(
    NIAllNullableTypesWithoutRecursionBridge? everything, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<
      ffi.Void Function(NIAllNullableTypesWithoutRecursionBridge?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableNIAllNullableTypesWithoutRecursionWithEverything:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableNIAllNullableTypesWithoutRecursionWithEverything_wrappedError_completionHandler_,
      everything?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed in generic Object asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableObjectWithAnObject(
    objc.NSObject anObject, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableObjectWithAnObject:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableObjectWithAnObject_wrappedError_completionHandler_,
      anObject.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableStringMapWithStringMap(
    objc.NSDictionary? stringMap, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableStringMapWithStringMap:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableStringMapWithStringMap_wrappedError_completionHandler_,
      stringMap?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed string asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableStringWithAString(
    objc.NSString? aString, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSString?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableStringWithAString:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableStringWithAString_wrappedError_completionHandler_,
      aString?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed in Uint8List asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncNullableUint8ListWithAUint8List(
    PigeonTypedData? aUint8List, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncNullableUint8ListWithAUint8List:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncNullableUint8ListWithAUint8List_wrappedError_completionHandler_,
      aUint8List?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed in generic Object asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncObjectWithAnObject(
    objc.NSObject anObject, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncObjectWithAnObject:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncObjectWithAnObject_wrappedError_completionHandler_,
      anObject.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed map, to test asynchronous serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncStringMapWithStringMap(
    objc.NSDictionary stringMap, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncStringMapWithStringMap:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncStringMapWithStringMap_wrappedError_completionHandler_,
      stringMap.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed string asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncStringWithAString(
    objc.NSString aString, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(objc.NSString?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncStringWithAString:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncStringWithAString_wrappedError_completionHandler_,
      aString.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed in Uint8List asynchronously.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void echoAsyncUint8ListWithAUint8List(
    PigeonTypedData aUint8List, {
    required NiTestsError wrappedError,
    required objc.ObjCBlock<ffi.Void Function(PigeonTypedData?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoAsyncUint8ListWithAUint8List:wrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_echoAsyncUint8ListWithAUint8List_wrappedError_completionHandler_,
      aUint8List.ref.pointer,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoBoolListWithBoolList(
    objc.NSArray boolList, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoBoolListWithBoolList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoBoolListWithBoolList_wrappedError_,
      boolList.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in boolean.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? echoBoolWithABool(
    bool aBool, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoBoolWithABool:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_w1rg4f(
      object$.ref.pointer,
      _sel_echoBoolWithABool_wrappedError_,
      aBool,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoClassListWithClassList(
    objc.NSArray classList, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoClassListWithClassList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoClassListWithClassList_wrappedError_,
      classList.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoClassMapWithClassMap(
    objc.NSDictionary classMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoClassMapWithClassMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoClassMapWithClassMap_wrappedError_,
      classMap.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed class to test nested class serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllClassesWrapperBridge? echoClassWrapperWithWrapper(
    NIAllClassesWrapperBridge wrapper, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoClassWrapperWithWrapper:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoClassWrapperWithWrapper_wrappedError_,
      wrapper.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NIAllClassesWrapperBridge.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoDoubleListWithDoubleList(
    objc.NSArray doubleList, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoDoubleListWithDoubleList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoDoubleListWithDoubleList_wrappedError_,
      doubleList.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns passed in double.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? echoDoubleWithADouble(
    double aDouble, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoDoubleWithADouble:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_1ozwf6k(
      object$.ref.pointer,
      _sel_echoDoubleWithADouble_wrappedError_,
      aDouble,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoEnumListWithEnumList(
    objc.NSArray enumList, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoEnumListWithEnumList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoEnumListWithEnumList_wrappedError_,
      enumList.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoEnumMapWithEnumMap(
    objc.NSDictionary enumMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoEnumMapWithEnumMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoEnumMapWithEnumMap_wrappedError_,
      enumMap.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed enum to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? echoEnumWithAnEnum(
    NIAnEnum anEnum, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoEnumWithAnEnum:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_1k0qzru(
      object$.ref.pointer,
      _sel_echoEnumWithAnEnum_wrappedError_,
      anEnum.value,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in Float64List.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? echoFloat64ListWithAFloat64List(
    PigeonTypedData aFloat64List, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoFloat64ListWithAFloat64List:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoFloat64ListWithAFloat64List_wrappedError_,
      aFloat64List.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in Int32List.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? echoInt32ListWithAInt32List(
    PigeonTypedData aInt32List, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoInt32ListWithAInt32List:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoInt32ListWithAInt32List_wrappedError_,
      aInt32List.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in Int64List.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? echoInt64ListWithAInt64List(
    PigeonTypedData aInt64List, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoInt64ListWithAInt64List:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoInt64ListWithAInt64List_wrappedError_,
      aInt64List.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoIntListWithIntList(
    objc.NSArray intList, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoIntListWithIntList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoIntListWithIntList_wrappedError_,
      intList.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoIntMapWithIntMap(
    objc.NSDictionary intMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoIntMapWithIntMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoIntMapWithIntMap_wrappedError_,
      intMap.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns passed in int.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? echoIntWithAnInt(
    int anInt, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoIntWithAnInt:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_1j962g9(
      object$.ref.pointer,
      _sel_echoIntWithAnInt_wrappedError_,
      anInt,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoListWithList(
    objc.NSArray list, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoListWithList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoListWithList_wrappedError_,
      list.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoMapWithMap(
    objc.NSDictionary map, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoMapWithMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoMapWithMap_wrappedError_,
      map.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoNonNullClassListWithClassList(
    objc.NSArray classList, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNonNullClassListWithClassList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNonNullClassListWithClassList_wrappedError_,
      classList.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoNonNullClassMapWithClassMap(
    objc.NSDictionary classMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNonNullClassMapWithClassMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNonNullClassMapWithClassMap_wrappedError_,
      classMap.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoNonNullEnumListWithEnumList(
    objc.NSArray enumList, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNonNullEnumListWithEnumList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNonNullEnumListWithEnumList_wrappedError_,
      enumList.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoNonNullEnumMapWithEnumMap(
    objc.NSDictionary enumMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNonNullEnumMapWithEnumMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNonNullEnumMapWithEnumMap_wrappedError_,
      enumMap.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoNonNullIntMapWithIntMap(
    objc.NSDictionary intMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNonNullIntMapWithIntMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNonNullIntMapWithIntMap_wrappedError_,
      intMap.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoNonNullStringMapWithStringMap(
    objc.NSDictionary stringMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNonNullStringMapWithStringMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNonNullStringMapWithStringMap_wrappedError_,
      stringMap.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in boolean.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? echoNullableBoolWithANullableBool(
    objc.NSNumber? aNullableBool, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableBoolWithANullableBool:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableBoolWithANullableBool_wrappedError_,
      aNullableBool?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoNullableClassListWithClassList(
    objc.NSArray? classList, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableClassListWithClassList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableClassListWithClassList_wrappedError_,
      classList?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoNullableClassMapWithClassMap(
    objc.NSDictionary? classMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableClassMapWithClassMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableClassMapWithClassMap_wrappedError_,
      classMap?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns passed in double.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? echoNullableDoubleWithANullableDouble(
    objc.NSNumber? aNullableDouble, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableDoubleWithANullableDouble:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableDoubleWithANullableDouble_wrappedError_,
      aNullableDouble?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoNullableEnumListWithEnumList(
    objc.NSArray? enumList, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableEnumListWithEnumList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableEnumListWithEnumList_wrappedError_,
      enumList?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoNullableEnumMapWithEnumMap(
    objc.NSDictionary? enumMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableEnumMapWithEnumMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableEnumMapWithEnumMap_wrappedError_,
      enumMap?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// echoNullableEnumWithAnEnum:wrappedError:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? echoNullableEnumWithAnEnum(
    objc.NSNumber? anEnum, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableEnumWithAnEnum:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableEnumWithAnEnum_wrappedError_,
      anEnum?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in Float64List.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? echoNullableFloat64ListWithANullableFloat64List(
    PigeonTypedData? aNullableFloat64List, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableFloat64ListWithANullableFloat64List:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableFloat64ListWithANullableFloat64List_wrappedError_,
      aNullableFloat64List?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in Int32List.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? echoNullableInt32ListWithANullableInt32List(
    PigeonTypedData? aNullableInt32List, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableInt32ListWithANullableInt32List:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableInt32ListWithANullableInt32List_wrappedError_,
      aNullableInt32List?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in Int64List.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? echoNullableInt64ListWithANullableInt64List(
    PigeonTypedData? aNullableInt64List, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableInt64ListWithANullableInt64List:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableInt64ListWithANullableInt64List_wrappedError_,
      aNullableInt64List?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoNullableIntMapWithIntMap(
    objc.NSDictionary? intMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableIntMapWithIntMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableIntMapWithIntMap_wrappedError_,
      intMap?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns passed in int.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSNumber? echoNullableIntWithANullableInt(
    objc.NSNumber? aNullableInt, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableIntWithANullableInt:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableIntWithANullableInt_wrappedError_,
      aNullableInt?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoNullableListWithANullableList(
    objc.NSArray? aNullableList, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableListWithANullableList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableListWithANullableList_wrappedError_,
      aNullableList?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoNullableMapWithMap(
    objc.NSDictionary? map, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableMapWithMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableMapWithMap_wrappedError_,
      map?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoNullableNonNullClassListWithClassList(
    objc.NSArray? classList, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableNonNullClassListWithClassList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableNonNullClassListWithClassList_wrappedError_,
      classList?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoNullableNonNullClassMapWithClassMap(
    objc.NSDictionary? classMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableNonNullClassMapWithClassMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableNonNullClassMapWithClassMap_wrappedError_,
      classMap?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoNullableNonNullEnumListWithEnumList(
    objc.NSArray? enumList, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableNonNullEnumListWithEnumList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableNonNullEnumListWithEnumList_wrappedError_,
      enumList?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoNullableNonNullEnumMapWithEnumMap(
    objc.NSDictionary? enumMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableNonNullEnumMapWithEnumMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableNonNullEnumMapWithEnumMap_wrappedError_,
      enumMap?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoNullableNonNullIntMapWithIntMap(
    objc.NSDictionary? intMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableNonNullIntMapWithIntMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableNonNullIntMapWithIntMap_wrappedError_,
      intMap?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoNullableNonNullStringMapWithStringMap(
    objc.NSDictionary? stringMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableNonNullStringMapWithStringMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableNonNullStringMapWithStringMap_wrappedError_,
      stringMap?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in generic Object.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSObject? echoNullableObjectWithANullableObject(
    objc.NSObject aNullableObject, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableObjectWithANullableObject:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableObjectWithANullableObject_wrappedError_,
      aNullableObject.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSObject.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoNullableStringMapWithStringMap(
    objc.NSDictionary? stringMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableStringMapWithStringMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableStringMapWithStringMap_wrappedError_,
      stringMap?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in string.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSString? echoNullableStringWithANullableString(
    objc.NSString? aNullableString, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableStringWithANullableString:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableStringWithANullableString_wrappedError_,
      aNullableString?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in Uint8List.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? echoNullableUint8ListWithANullableUint8List(
    PigeonTypedData? aNullableUint8List, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoNullableUint8ListWithANullableUint8List:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoNullableUint8ListWithANullableUint8List_wrappedError_,
      aNullableUint8List?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in generic Object.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSObject? echoObjectWithAnObject(
    objc.NSObject anObject, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoObjectWithAnObject:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoObjectWithAnObject_wrappedError_,
      anObject.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSObject.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed list, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSArray? echoStringListWithStringList(
    objc.NSArray stringList, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoStringListWithStringList:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoStringListWithStringList_wrappedError_,
      stringList.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed map, to test serialization and deserialization.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSDictionary? echoStringMapWithStringMap(
    objc.NSDictionary stringMap, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoStringMapWithStringMap:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoStringMapWithStringMap_wrappedError_,
      stringMap.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in string.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSString? echoStringWithAString(
    objc.NSString aString, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoStringWithAString:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoStringWithAString_wrappedError_,
      aString.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the passed in Uint8List.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  PigeonTypedData? echoUint8ListWithAUint8List(
    PigeonTypedData aUint8List, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.echoUint8ListWithAUint8List:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_echoUint8ListWithAUint8List_wrappedError_,
      aUint8List.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : PigeonTypedData.fromPointer($ret, retain: true, release: true);
  }

  /// Returns the inner <code>aString</code> value from the wrapped object, to test
  /// sending of nested objects.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSString? extractNestedNullableStringWithWrapper(
    NIAllClassesWrapperBridge wrapper, {
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.extractNestedNullableStringWithWrapper:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_extractNestedNullableStringWithWrapper_wrappedError_,
      wrapper.ref.pointer,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NIHostIntegrationCoreApiSetup init() {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NIHostIntegrationCoreApiSetup.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic asynchronous calling.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void noopAsyncWithWrappedError(
    NiTestsError wrappedError, {
    required objc.ObjCBlock<ffi.Void Function()> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.noopAsyncWithWrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_noopAsyncWithWrappedError_completionHandler_,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// A no-op function taking no arguments and returning no value, to sanity
  /// test basic calling.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void noopWithWrappedError(NiTestsError wrappedError) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.noopWithWrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_noopWithWrappedError_,
      wrappedError.ref.pointer,
    );
  }

  /// sendMultipleNullableTypesWithANullableBool:aNullableInt:aNullableString:wrappedError:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllNullableTypesBridge? sendMultipleNullableTypesWithANullableBool(
    objc.NSNumber? aNullableBool, {
    objc.NSNumber? aNullableInt,
    objc.NSString? aNullableString,
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.sendMultipleNullableTypesWithANullableBool:aNullableInt:aNullableString:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_s92gih(
      object$.ref.pointer,
      _sel_sendMultipleNullableTypesWithANullableBool_aNullableInt_aNullableString_wrappedError_,
      aNullableBool?.ref.pointer ?? ffi.nullptr,
      aNullableInt?.ref.pointer ?? ffi.nullptr,
      aNullableString?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NIAllNullableTypesBridge.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// sendMultipleNullableTypesWithoutRecursionWithANullableBool:aNullableInt:aNullableString:wrappedError:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIAllNullableTypesWithoutRecursionBridge?
  sendMultipleNullableTypesWithoutRecursionWithANullableBool(
    objc.NSNumber? aNullableBool, {
    objc.NSNumber? aNullableInt,
    objc.NSString? aNullableString,
    required NiTestsError wrappedError,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.sendMultipleNullableTypesWithoutRecursionWithANullableBool:aNullableInt:aNullableString:wrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_s92gih(
      object$.ref.pointer,
      _sel_sendMultipleNullableTypesWithoutRecursionWithANullableBool_aNullableInt_aNullableString_wrappedError_,
      aNullableBool?.ref.pointer ?? ffi.nullptr,
      aNullableInt?.ref.pointer ?? ffi.nullptr,
      aNullableString?.ref.pointer ?? ffi.nullptr,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NIAllNullableTypesWithoutRecursionBridge.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// Responds with an error from an async void function.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void throwAsyncErrorFromVoidWithWrappedError(
    NiTestsError wrappedError, {
    required objc.ObjCBlock<ffi.Void Function()> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.throwAsyncErrorFromVoidWithWrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_throwAsyncErrorFromVoidWithWrappedError_completionHandler_,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Responds with an error from an async function returning a value.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void throwAsyncErrorWithWrappedError(
    NiTestsError wrappedError, {
    required objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.throwAsyncErrorWithWrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_throwAsyncErrorWithWrappedError_completionHandler_,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Responds with a Flutter error from an async function returning a value.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void throwAsyncFlutterErrorWithWrappedError(
    NiTestsError wrappedError, {
    required objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.throwAsyncFlutterErrorWithWrappedError:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_throwAsyncFlutterErrorWithWrappedError_completionHandler_,
      wrappedError.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Returns an error from a void function, to test error handling.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  void throwErrorFromVoidWithWrappedError(NiTestsError wrappedError) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.throwErrorFromVoidWithWrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_throwErrorFromVoidWithWrappedError_,
      wrappedError.ref.pointer,
    );
  }

  /// Returns an error, to test error handling.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSObject? throwErrorWithWrappedError(NiTestsError wrappedError) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.throwErrorWithWrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_throwErrorWithWrappedError_,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSObject.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a Flutter error, to test error handling.
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSObject? throwFlutterErrorWithWrappedError(NiTestsError wrappedError) {
    objc.checkOsVersionInternal(
      'NIHostIntegrationCoreApiSetup.throwFlutterErrorWithWrappedError:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_throwFlutterErrorWithWrappedError_,
      wrappedError.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSObject.fromPointer($ret, retain: true, release: true);
  }
}

late final _class_NIUnusedClassBridge = objc.getClass(
  "test_plugin.NIUnusedClassBridge",
);
late final _sel_initWithAField_ = objc.registerName("initWithAField:");
late final _sel_aField = objc.registerName("aField");
late final _sel_setAField_ = objc.registerName("setAField:");

/// Generated bridge class from Pigeon that moves data from Swift to Objective-C.
///
/// iOS: introduced 13.0.0
/// macOS: introduced 16.0.0
extension type NIUnusedClassBridge._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NIUnusedClassBridge] that points to the same underlying object as [other].
  NIUnusedClassBridge.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NIUnusedClassBridge',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NIUnusedClassBridge] that wraps the given raw object pointer.
  NIUnusedClassBridge.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NIUnusedClassBridge',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NIUnusedClassBridge].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NIUnusedClassBridge,
  );

  /// alloc
  static NIUnusedClassBridge alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NIUnusedClassBridge, _sel_alloc);
    return NIUnusedClassBridge.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NIUnusedClassBridge allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NIUnusedClassBridge,
      _sel_allocWithZone_,
      zone,
    );
    return NIUnusedClassBridge.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NIUnusedClassBridge new$() {
    final $ret = _objc_msgSend_151sglz(_class_NIUnusedClassBridge, _sel_new);
    return NIUnusedClassBridge.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NIUnusedClassBridge constructed with the default `new` method.
  NIUnusedClassBridge() : this.as(new$().object$);
}

extension NIUnusedClassBridge$Methods on NIUnusedClassBridge {
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  objc.NSObject? get aField {
    objc.checkOsVersionInternal(
      'NIUnusedClassBridge.aField',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_aField);
    return $ret.address == 0
        ? null
        : objc.NSObject.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NIUnusedClassBridge init() {
    objc.checkOsVersionInternal(
      'NIUnusedClassBridge.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NIUnusedClassBridge.fromPointer($ret, retain: false, release: true);
  }

  /// initWithAField:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  NIUnusedClassBridge initWithAField(objc.NSObject? aField) {
    objc.checkOsVersionInternal(
      'NIUnusedClassBridge.initWithAField:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithAField_,
      aField?.ref.pointer ?? ffi.nullptr,
    );
    return NIUnusedClassBridge.fromPointer($ret, retain: false, release: true);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 16.0.0
  set aField(objc.NSObject? value) {
    objc.checkOsVersionInternal(
      'NIUnusedClassBridge.setAField:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAField_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _class_NumberWrapper = objc.getClass("test_plugin.NumberWrapper");
late final _sel_initWithNumber_type_ = objc.registerName(
  "initWithNumber:type:",
);
late final _sel_copyWithZone_ = objc.registerName("copyWithZone:");
late final _sel_number = objc.registerName("number");
late final _sel_setNumber_ = objc.registerName("setNumber:");
late final _sel_setType_ = objc.registerName("setType:");
final _objc_msgSend_4sp4xj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_isEqual_ = objc.registerName("isEqual:");
late final _sel_hash = objc.registerName("hash");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// NumberWrapper
extension type NumberWrapper._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [NumberWrapper] that points to the same underlying object as [other].
  NumberWrapper.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [NumberWrapper] that wraps the given raw object pointer.
  NumberWrapper.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NumberWrapper].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NumberWrapper,
  );

  /// alloc
  static NumberWrapper alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NumberWrapper, _sel_alloc);
    return NumberWrapper.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NumberWrapper allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NumberWrapper,
      _sel_allocWithZone_,
      zone,
    );
    return NumberWrapper.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NumberWrapper new$() {
    final $ret = _objc_msgSend_151sglz(_class_NumberWrapper, _sel_new);
    return NumberWrapper.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NumberWrapper constructed with the default `new` method.
  NumberWrapper() : this.as(new$().object$);
}

extension NumberWrapper$Methods on NumberWrapper {
  /// copyWithZone:
  objc.ObjCObject copyWithZone$1(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      object$.ref.pointer,
      _sel_copyWithZone_,
      zone,
    );
    return objc.ObjCObject($ret, retain: false, release: true);
  }

  /// hash
  int get hash$1 {
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_hash);
  }

  /// init
  NumberWrapper init() {
    objc.checkOsVersionInternal(
      'NumberWrapper.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NumberWrapper.fromPointer($ret, retain: false, release: true);
  }

  /// initWithNumber:type:
  NumberWrapper initWithNumber(objc.NSNumber number, {required int type}) {
    final $ret = _objc_msgSend_9slupp(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithNumber_type_,
      number.ref.pointer,
      type,
    );
    return NumberWrapper.fromPointer($ret, retain: false, release: true);
  }

  /// isEqual:
  bool isEqual(objc.ObjCObject? object) {
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_isEqual_,
      object?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// number
  objc.NSNumber get number {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_number);
    return objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// setNumber:
  set number(objc.NSNumber value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setNumber_,
      value.ref.pointer,
    );
  }

  /// setType:
  set type(int value) {
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setType_, value);
  }

  /// type
  int get type {
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_type);
  }
}

late final _class_PigeonInternalNull = objc.getClass(
  "test_plugin.PigeonInternalNull",
);

/// PigeonInternalNull
extension type PigeonInternalNull._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [PigeonInternalNull] that points to the same underlying object as [other].
  PigeonInternalNull.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [PigeonInternalNull] that wraps the given raw object pointer.
  PigeonInternalNull.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [PigeonInternalNull].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_PigeonInternalNull,
  );

  /// alloc
  static PigeonInternalNull alloc() {
    final $ret = _objc_msgSend_151sglz(_class_PigeonInternalNull, _sel_alloc);
    return PigeonInternalNull.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static PigeonInternalNull allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_PigeonInternalNull,
      _sel_allocWithZone_,
      zone,
    );
    return PigeonInternalNull.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static PigeonInternalNull new$() {
    final $ret = _objc_msgSend_151sglz(_class_PigeonInternalNull, _sel_new);
    return PigeonInternalNull.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of PigeonInternalNull constructed with the default `new` method.
  PigeonInternalNull() : this.as(new$().object$);
}

extension PigeonInternalNull$Methods on PigeonInternalNull {
  /// init
  PigeonInternalNull init() {
    objc.checkOsVersionInternal(
      'PigeonInternalNull.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return PigeonInternalNull.fromPointer($ret, retain: false, release: true);
  }
}
