// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_macos/file_selector_macos.dart';
import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';

import 'src/messages.g.dart';

/// The macOS implementation of [ImagePickerPlatform].
///
/// This class implements the `package:image_picker` functionality for
/// macOS.
class ImagePickerMacOS extends CameraDelegatingImagePickerPlatform {
  /// Constructs a platform implementation.
  ImagePickerMacOS();

  /// The platform API generated by Pigeon to communicate with native macOS using a method channel.
  /// Used only when [useMacOSPHPicker] is `true` for **PHPicker implementation**.
  final ImagePickerApi _hostApi = ImagePickerApi();

  /// The file selector used to prompt the user to select images or videos.
  @visibleForTesting
  static FileSelectorPlatform fileSelector = FileSelectorMacOS();

  /// Registers this class as the default instance of [ImagePickerPlatform].
  static void registerWith() {
    ImagePickerPlatform.instance = ImagePickerMacOS();
  }

  /// Sets [ImagePickerMacOS] to use [PHPicker](https://developer.apple.com/documentation/photokit/phpickerviewcontroller)
  /// which is **only supported on macOS 13.0+**.
  ///
  /// Will fallback to [file_selector_macos](https://pub.dev/packages/file_selector_macos)
  /// if [useMacOSPHPicker] is `false` or the macOS version doesn't support
  /// this feature.
  ///
  /// Currently defaults to `false`.
  ///
  /// **Note**: This implementation depends on the photos in the [Photos for macOS App](https://www.apple.com/in/macos/photos/),
  /// if the user didn't open the app or import any photos to the app,
  /// they will see: `No photos` or `No Photos or Videos` message even if they
  /// have them as files on their desktop.
  ///
  /// Supports picking an image, multi-image, video, media, and multiple media.
  bool useMacOSPHPicker = false;

  /// Return `true` if the current macOS version supports [useMacOSPHPicker].
  ///
  /// The [PHPicker](https://developer.apple.com/documentation/photokit/phpickerviewcontroller)
  /// is **supported on macOS 13.0+**
  Future<bool> supportsPHPicker() => _hostApi.supportsPHPicker();

  /// Returns `true` if [ImagePickerMacOS] should use [PHPicker](https://developer.apple.com/documentation/photokit/phpickerviewcontroller).
  ///
  /// See also:
  ///
  ///  * [useMacOSPHPicker] to check whether **PHPicker** should be preferred over [file_selector_macos](https://pub.dev/packages/file_selector_macos).
  ///  * [supportsPHPicker] to verify if the current macOS version supports **PHPicker**.
  @visibleForTesting
  Future<bool> shouldUsePHPicker() async =>
      await supportsPHPicker() && useMacOSPHPicker;

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<PickedFile?> pickImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    final XFile? file = await getImage(
        source: source,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        imageQuality: imageQuality,
        preferredCameraDevice: preferredCameraDevice);
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getVideo.
  @override
  Future<PickedFile?> pickVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    final XFile? file = await getVideo(
        source: source,
        preferredCameraDevice: preferredCameraDevice,
        maxDuration: maxDuration);
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<XFile?> getImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    return getImageFromSource(
        source: source,
        options: ImagePickerOptions(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            imageQuality: imageQuality,
            preferredCameraDevice: preferredCameraDevice));
  }

  // [ImagePickerOptions] options are currently only supported when using
  // PHPicker implementation. If any of its fields are set,
  // they will be silently ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getImageFromSource({
    required ImageSource source,
    ImagePickerOptions options = const ImagePickerOptions(),
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getImageFromSource(source: source);
      case ImageSource.gallery:
        if (await shouldUsePHPicker()) {
          final String? imagePath = (await _hostApi.pickImages(
            _imageOptionsToImageSelectionOptions(options),
            GeneralOptions(limit: 1),
          ))
              .getSuccessOrThrow()
              .filePaths
              .firstOrNull;
          if (imagePath == null) {
            return null;
          }

          return XFile(imagePath);
        }
        const XTypeGroup typeGroup =
            XTypeGroup(uniformTypeIdentifiers: <String>['public.image']);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // `preferredCameraDevice` and `maxDuration` arguments are not currently
  // supported. If either of these arguments are supplied, they will be silently
  // ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getVideo(
            source: source,
            preferredCameraDevice: preferredCameraDevice,
            maxDuration: maxDuration);
      case ImageSource.gallery:
        if (await shouldUsePHPicker()) {
          final String? videoPath =
              (await _hostApi.pickVideos(GeneralOptions(limit: 1)))
                  .getSuccessOrThrow()
                  .filePaths
                  .firstOrNull;
          if (videoPath == null) {
            return null;
          }

          return XFile(videoPath);
        }
        const XTypeGroup typeGroup =
            XTypeGroup(uniformTypeIdentifiers: <String>['public.movie']);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getMultiImageWithOptions.
  @override
  Future<List<XFile>> getMultiImage({
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
  }) async {
    return getMultiImageWithOptions(
      options: MultiImagePickerOptions(
        imageOptions: ImageOptions(
          imageQuality: imageQuality,
          maxHeight: maxHeight,
          maxWidth: maxWidth,
        ),
      ),
    );
  }

  // [MultiImagePickerOptions] options are currently only
  // supported when using PHPicker implementation. If any of these arguments are supplied, they will be silently
  // ignored.
  @override
  Future<List<XFile>> getMultiImageWithOptions({
    MultiImagePickerOptions options = const MultiImagePickerOptions(),
  }) async {
    if (await shouldUsePHPicker()) {
      final List<String> images = (await _hostApi.pickImages(
        _imageOptionsToImageSelectionOptions(options.imageOptions),
        GeneralOptions(
          limit: options.limit ?? 0,
        ),
      ))
          .getSuccessOrThrow()
          .filePaths;
      return images.map((String imagePath) => XFile(imagePath)).toList();
    }
    const XTypeGroup typeGroup =
        XTypeGroup(uniformTypeIdentifiers: <String>['public.image']);
    final List<XFile> files = await fileSelector
        .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    return files;
  }

  ImageSelectionOptions _imageOptionsToImageSelectionOptions(
    ImageOptions imageOptions,
  ) {
    final int? imageQuality = imageOptions.imageQuality;
    if (imageQuality != null && imageQuality < 0) {
      throw ArgumentError.value(
          imageQuality, 'imageQuality', 'quality cannot be negative');
    }

    return ImageSelectionOptions(
      quality: imageQuality ?? 100,
      maxSize: MaxSize(
        width: imageOptions.maxWidth,
        height: imageOptions.maxHeight,
      ),
    );
  }

  // [ImageOptions] options are currently only
  // supported when using PHPicker implementation. If any of these arguments are supplied, they will be silently
  // ignored.
  @override
  Future<List<XFile>> getMedia({required MediaOptions options}) async {
    if (await shouldUsePHPicker()) {
      final List<String> images = (await _hostApi.pickMedia(
        MediaSelectionOptions(
          imageSelectionOptions:
              _imageOptionsToImageSelectionOptions(options.imageOptions),
        ),
        GeneralOptions(
          limit: options.limit ?? (options.allowMultiple ? 0 : 1),
        ),
      ))
          .getSuccessOrThrow()
          .filePaths;
      return images.map((String mediaPath) => XFile(mediaPath)).toList();
    }
    const XTypeGroup typeGroup = XTypeGroup(
        label: 'images and videos',
        extensions: <String>['public.image', 'public.movie']);

    List<XFile> files;

    if (options.allowMultiple) {
      files = await fileSelector
          .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    } else {
      final XFile? file = await fileSelector
          .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
      files = <XFile>[
        if (file != null) file,
      ];
    }
    return files;
  }
}

extension _ImagePickerResultExt on ImagePickerResult {
  /// Returns the result as an [ImagePickerSuccessResult], or throws a [PlatformException]
  /// if the result is an [ImagePickerErrorResult].
  ImagePickerSuccessResult getSuccessOrThrow() {
    final ImagePickerResult result = this;
    return switch (result) {
      ImagePickerSuccessResult() => result,
      ImagePickerErrorResult() => () {
          final String errorMessage = switch (result.error) {
            ImagePickerError.phpickerUnsupported =>
              'PHPicker is only supported on macOS 13.0 or newer.',
            ImagePickerError.windowNotFound =>
              'No active window to present the picker.',
            ImagePickerError.invalidImageSelection =>
              'One of the selected items is not an image.',
            ImagePickerError.invalidVideoSelection =>
              'One of the selected items is not a video.',
            ImagePickerError.imageLoadFailed =>
              'An error occurred while loading the image.',
            ImagePickerError.videoLoadFailed =>
              'An error occurred while loading the video.',
            ImagePickerError.imageConversionFailed =>
              'Failed to convert the NSImage to TIFF data.',
            ImagePickerError.imageSaveFailed =>
              'Error saving the NSImage data to a file.',
            ImagePickerError.imageCompressionFailed =>
              'Error while compressing the Data of the NSImage.',
            ImagePickerError.multiVideoSelectionUnsupported =>
              'The multi-video selection is not supported.',
          };
          // TODO(EchoEllet): Replace PlatformException with a plugin-specific exception.
          //  This is currently implemented to maintain compatibility with the existing behavior
          //  of other implementations of `image_picker`. For more details, refer to:
          //  https://github.com/flutter/flutter/blob/master/docs/ecosystem/contributing/README.md#platform-exception-handling
          throw PlatformException(
            code: result.error.name,
            message: errorMessage,
            details: result.platformErrorMessage,
          );
        }(),
    };
  }
}
