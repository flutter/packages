// Copyright 2013 The Flutter Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v26.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PigeonError {
  return PigeonError(
    code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.",
    details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

func deepEqualsMessages(_ lhs: Any?, _ rhs: Any?) -> Bool {
  let cleanLhs = nilOrValue(lhs) as Any?
  let cleanRhs = nilOrValue(rhs) as Any?
  switch (cleanLhs, cleanRhs) {
  case (nil, nil):
    return true

  case (nil, _), (_, nil):
    return false

  case is (Void, Void):
    return true

  case let (cleanLhsHashable, cleanRhsHashable) as (AnyHashable, AnyHashable):
    return cleanLhsHashable == cleanRhsHashable

  case let (cleanLhsArray, cleanRhsArray) as ([Any?], [Any?]):
    guard cleanLhsArray.count == cleanRhsArray.count else { return false }
    for (index, element) in cleanLhsArray.enumerated() {
      if !deepEqualsMessages(element, cleanRhsArray[index]) {
        return false
      }
    }
    return true

  case let (cleanLhsDictionary, cleanRhsDictionary) as ([AnyHashable: Any?], [AnyHashable: Any?]):
    guard cleanLhsDictionary.count == cleanRhsDictionary.count else { return false }
    for (key, cleanLhsValue) in cleanLhsDictionary {
      guard cleanRhsDictionary.index(forKey: key) != nil else { return false }
      if !deepEqualsMessages(cleanLhsValue, cleanRhsDictionary[key]!) {
        return false
      }
    }
    return true

  default:
    // Any other type shouldn't be able to be used with pigeon. File an issue if you find this to be untrue.
    return false
  }
}

func deepHashMessages(value: Any?, hasher: inout Hasher) {
  if let valueList = value as? [AnyHashable] {
    for item in valueList { deepHashMessages(value: item, hasher: &hasher) }
    return
  }

  if let valueDict = value as? [AnyHashable: AnyHashable] {
    for key in valueDict.keys {
      hasher.combine(key)
      deepHashMessages(value: valueDict[key]!, hasher: &hasher)
    }
    return
  }

  if let hashableValue = value as? AnyHashable {
    hasher.combine(hashableValue.hashValue)
  }

  return hasher.combine(String(describing: value))
}

enum PlatformCameraLensDirection: Int {
  /// Front facing camera (a user looking at the screen is seen by the camera).
  case front = 0
  /// Back facing camera (a user looking at the screen is not seen by the camera).
  case back = 1
  /// External camera which may not be mounted to the device.
  case external = 2
}

enum PlatformCameraLensType: Int {
  /// A built-in wide-angle camera device type.
  case wide = 0
  /// A built-in camera device type with a longer focal length than a wide-angle camera.
  case telephoto = 1
  /// A built-in camera device type with a shorter focal length than a wide-angle camera.
  case ultraWide = 2
  /// Unknown camera device type.
  case unknown = 3
}

enum PlatformDeviceOrientation: Int {
  case portraitUp = 0
  case landscapeLeft = 1
  case portraitDown = 2
  case landscapeRight = 3
}

enum PlatformExposureMode: Int {
  case auto = 0
  case locked = 1
}

enum PlatformFlashMode: Int {
  case off = 0
  case auto = 1
  case always = 2
  case torch = 3
}

enum PlatformFocusMode: Int {
  case auto = 0
  case locked = 1
}

/// Pigeon version of ImageFileFormat.
enum PlatformImageFileFormat: Int {
  case jpeg = 0
  case heif = 1
}

enum PlatformImageFormatGroup: Int {
  case bgra8888 = 0
  case yuv420 = 1
}

enum PlatformResolutionPreset: Int {
  case low = 0
  case medium = 1
  case high = 2
  case veryHigh = 3
  case ultraHigh = 4
  case max = 5
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlatformCameraDescription: Hashable {
  /// The name of the camera device.
  var name: String
  /// The direction the camera is facing.
  var lensDirection: PlatformCameraLensDirection
  /// The type of the camera lens.
  var lensType: PlatformCameraLensType

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PlatformCameraDescription? {
    let name = pigeonVar_list[0] as! String
    let lensDirection = pigeonVar_list[1] as! PlatformCameraLensDirection
    let lensType = pigeonVar_list[2] as! PlatformCameraLensType

    return PlatformCameraDescription(
      name: name,
      lensDirection: lensDirection,
      lensType: lensType
    )
  }
  func toList() -> [Any?] {
    return [
      name,
      lensDirection,
      lensType,
    ]
  }
  static func == (lhs: PlatformCameraDescription, rhs: PlatformCameraDescription) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())
  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlatformCameraState: Hashable {
  /// The size of the preview, in pixels.
  var previewSize: PlatformSize
  /// The default exposure mode
  var exposureMode: PlatformExposureMode
  /// The default focus mode
  var focusMode: PlatformFocusMode
  /// Whether setting exposure points is supported.
  var exposurePointSupported: Bool
  /// Whether setting focus points is supported.
  var focusPointSupported: Bool

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PlatformCameraState? {
    let previewSize = pigeonVar_list[0] as! PlatformSize
    let exposureMode = pigeonVar_list[1] as! PlatformExposureMode
    let focusMode = pigeonVar_list[2] as! PlatformFocusMode
    let exposurePointSupported = pigeonVar_list[3] as! Bool
    let focusPointSupported = pigeonVar_list[4] as! Bool

    return PlatformCameraState(
      previewSize: previewSize,
      exposureMode: exposureMode,
      focusMode: focusMode,
      exposurePointSupported: exposurePointSupported,
      focusPointSupported: focusPointSupported
    )
  }
  func toList() -> [Any?] {
    return [
      previewSize,
      exposureMode,
      focusMode,
      exposurePointSupported,
      focusPointSupported,
    ]
  }
  static func == (lhs: PlatformCameraState, rhs: PlatformCameraState) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())
  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlatformMediaSettings: Hashable {
  var resolutionPreset: PlatformResolutionPreset
  var framesPerSecond: Int64? = nil
  var videoBitrate: Int64? = nil
  var audioBitrate: Int64? = nil
  var enableAudio: Bool

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PlatformMediaSettings? {
    let resolutionPreset = pigeonVar_list[0] as! PlatformResolutionPreset
    let framesPerSecond: Int64? = nilOrValue(pigeonVar_list[1])
    let videoBitrate: Int64? = nilOrValue(pigeonVar_list[2])
    let audioBitrate: Int64? = nilOrValue(pigeonVar_list[3])
    let enableAudio = pigeonVar_list[4] as! Bool

    return PlatformMediaSettings(
      resolutionPreset: resolutionPreset,
      framesPerSecond: framesPerSecond,
      videoBitrate: videoBitrate,
      audioBitrate: audioBitrate,
      enableAudio: enableAudio
    )
  }
  func toList() -> [Any?] {
    return [
      resolutionPreset,
      framesPerSecond,
      videoBitrate,
      audioBitrate,
      enableAudio,
    ]
  }
  static func == (lhs: PlatformMediaSettings, rhs: PlatformMediaSettings) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())
  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlatformPoint: Hashable {
  var x: Double
  var y: Double

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PlatformPoint? {
    let x = pigeonVar_list[0] as! Double
    let y = pigeonVar_list[1] as! Double

    return PlatformPoint(
      x: x,
      y: y
    )
  }
  func toList() -> [Any?] {
    return [
      x,
      y,
    ]
  }
  static func == (lhs: PlatformPoint, rhs: PlatformPoint) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())
  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlatformSize: Hashable {
  var width: Double
  var height: Double

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PlatformSize? {
    let width = pigeonVar_list[0] as! Double
    let height = pigeonVar_list[1] as! Double

    return PlatformSize(
      width: width,
      height: height
    )
  }
  func toList() -> [Any?] {
    return [
      width,
      height,
    ]
  }
  static func == (lhs: PlatformSize, rhs: PlatformSize) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())
  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

private class MessagesPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PlatformCameraLensDirection(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PlatformCameraLensType(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PlatformDeviceOrientation(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PlatformExposureMode(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PlatformFlashMode(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PlatformFocusMode(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PlatformImageFileFormat(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PlatformImageFormatGroup(rawValue: enumResultAsInt)
      }
      return nil
    case 137:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PlatformResolutionPreset(rawValue: enumResultAsInt)
      }
      return nil
    case 138:
      return PlatformCameraDescription.fromList(self.readValue() as! [Any?])
    case 139:
      return PlatformCameraState.fromList(self.readValue() as! [Any?])
    case 140:
      return PlatformMediaSettings.fromList(self.readValue() as! [Any?])
    case 141:
      return PlatformPoint.fromList(self.readValue() as! [Any?])
    case 142:
      return PlatformSize.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class MessagesPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PlatformCameraLensDirection {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? PlatformCameraLensType {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? PlatformDeviceOrientation {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? PlatformExposureMode {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? PlatformFlashMode {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? PlatformFocusMode {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? PlatformImageFileFormat {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? PlatformImageFormatGroup {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? PlatformResolutionPreset {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? PlatformCameraDescription {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? PlatformCameraState {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? PlatformMediaSettings {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? PlatformPoint {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? PlatformSize {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class MessagesPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return MessagesPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return MessagesPigeonCodecWriter(data: data)
  }
}

class MessagesPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = MessagesPigeonCodec(readerWriter: MessagesPigeonCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol CameraApi {
  /// Returns the list of available cameras.
  func getAvailableCameras(
    completion: @escaping (Result<[PlatformCameraDescription], Error>) -> Void)
  /// Create a new camera with the given settings, and returns its ID.
  func create(
    cameraName: String, settings: PlatformMediaSettings,
    completion: @escaping (Result<Int64, Error>) -> Void)
  /// Initializes the camera with the given ID.
  func initialize(
    cameraId: Int64, imageFormat: PlatformImageFormatGroup,
    completion: @escaping (Result<Void, Error>) -> Void)
  /// Begins streaming frames from the camera.
  func startImageStream(completion: @escaping (Result<Void, Error>) -> Void)
  /// Stops streaming frames from the camera.
  func stopImageStream(completion: @escaping (Result<Void, Error>) -> Void)
  /// Called by the Dart side of the plugin when it has received the last image
  /// frame sent.
  ///
  /// This is used to throttle sending frames across the channel.
  func receivedImageStreamData(completion: @escaping (Result<Void, Error>) -> Void)
  /// Indicates that the given camera is no longer being used on the Dart side,
  /// and any associated resources can be cleaned up.
  func dispose(cameraId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  /// Locks the camera capture to the current device orientation.
  func lockCaptureOrientation(
    orientation: PlatformDeviceOrientation, completion: @escaping (Result<Void, Error>) -> Void)
  /// Unlocks camera capture orientation, allowing it to automatically adapt to
  /// device orientation.
  func unlockCaptureOrientation(completion: @escaping (Result<Void, Error>) -> Void)
  /// Takes a picture with the current settings, and returns the path to the
  /// resulting file.
  func takePicture(completion: @escaping (Result<String, Error>) -> Void)
  /// Does any preprocessing necessary before beginning to record video.
  func prepareForVideoRecording(completion: @escaping (Result<Void, Error>) -> Void)
  /// Begins recording video, optionally enabling streaming to Dart at the same
  /// time.
  func startVideoRecording(enableStream: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  /// Stops recording video, and results the path to the resulting file.
  func stopVideoRecording(completion: @escaping (Result<String, Error>) -> Void)
  /// Pauses video recording.
  func pauseVideoRecording(completion: @escaping (Result<Void, Error>) -> Void)
  /// Resumes a previously paused video recording.
  func resumeVideoRecording(completion: @escaping (Result<Void, Error>) -> Void)
  /// Switches the camera to the given flash mode.
  func setFlashMode(mode: PlatformFlashMode, completion: @escaping (Result<Void, Error>) -> Void)
  /// Switches the camera to the given exposure mode.
  func setExposureMode(
    mode: PlatformExposureMode, completion: @escaping (Result<Void, Error>) -> Void)
  /// Anchors auto-exposure to the given point in (0,1) coordinate space.
  ///
  /// A null value resets to the default exposure point.
  func setExposurePoint(point: PlatformPoint?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Returns the minimum exposure offset supported by the camera.
  func getMinExposureOffset(completion: @escaping (Result<Double, Error>) -> Void)
  /// Returns the maximum exposure offset supported by the camera.
  func getMaxExposureOffset(completion: @escaping (Result<Double, Error>) -> Void)
  /// Sets the exposure offset manually to the given value.
  func setExposureOffset(offset: Double, completion: @escaping (Result<Void, Error>) -> Void)
  /// Switches the camera to the given focus mode.
  func setFocusMode(mode: PlatformFocusMode, completion: @escaping (Result<Void, Error>) -> Void)
  /// Anchors auto-focus to the given point in (0,1) coordinate space.
  ///
  /// A null value resets to the default focus point.
  func setFocusPoint(point: PlatformPoint?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Returns the minimum zoom level supported by the camera.
  func getMinZoomLevel(completion: @escaping (Result<Double, Error>) -> Void)
  /// Returns the maximum zoom level supported by the camera.
  func getMaxZoomLevel(completion: @escaping (Result<Double, Error>) -> Void)
  /// Sets the zoom factor.
  func setZoomLevel(zoom: Double, completion: @escaping (Result<Void, Error>) -> Void)
  /// Pauses streaming of preview frames.
  func pausePreview(completion: @escaping (Result<Void, Error>) -> Void)
  /// Resumes a previously paused preview stream.
  func resumePreview(completion: @escaping (Result<Void, Error>) -> Void)
  /// Changes the camera used while recording video.
  ///
  /// This should only be called while video recording is active.
  func updateDescriptionWhileRecording(
    cameraName: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Sets the file format used for taking pictures.
  func setImageFileFormat(
    format: PlatformImageFileFormat, completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class CameraApiSetup {
  static var codec: FlutterStandardMessageCodec { MessagesPigeonCodec.shared }
  /// Sets up an instance of `CameraApi` to handle messages through the `binaryMessenger`.
  static func setUp(
    binaryMessenger: FlutterBinaryMessenger, api: CameraApi?, messageChannelSuffix: String = ""
  ) {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Returns the list of available cameras.
    let getAvailableCamerasChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.getAvailableCameras\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAvailableCamerasChannel.setMessageHandler { _, reply in
        api.getAvailableCameras { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAvailableCamerasChannel.setMessageHandler(nil)
    }
    /// Create a new camera with the given settings, and returns its ID.
    let createChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.create\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraNameArg = args[0] as! String
        let settingsArg = args[1] as! PlatformMediaSettings
        api.create(cameraName: cameraNameArg, settings: settingsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    /// Initializes the camera with the given ID.
    let initializeChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.initialize\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initializeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraIdArg = args[0] as! Int64
        let imageFormatArg = args[1] as! PlatformImageFormatGroup
        api.initialize(cameraId: cameraIdArg, imageFormat: imageFormatArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      initializeChannel.setMessageHandler(nil)
    }
    /// Begins streaming frames from the camera.
    let startImageStreamChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.startImageStream\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startImageStreamChannel.setMessageHandler { _, reply in
        api.startImageStream { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      startImageStreamChannel.setMessageHandler(nil)
    }
    /// Stops streaming frames from the camera.
    let stopImageStreamChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.stopImageStream\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopImageStreamChannel.setMessageHandler { _, reply in
        api.stopImageStream { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      stopImageStreamChannel.setMessageHandler(nil)
    }
    /// Called by the Dart side of the plugin when it has received the last image
    /// frame sent.
    ///
    /// This is used to throttle sending frames across the channel.
    let receivedImageStreamDataChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.camera_avfoundation.CameraApi.receivedImageStreamData\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      receivedImageStreamDataChannel.setMessageHandler { _, reply in
        api.receivedImageStreamData { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      receivedImageStreamDataChannel.setMessageHandler(nil)
    }
    /// Indicates that the given camera is no longer being used on the Dart side,
    /// and any associated resources can be cleaned up.
    let disposeChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.dispose\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disposeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraIdArg = args[0] as! Int64
        api.dispose(cameraId: cameraIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      disposeChannel.setMessageHandler(nil)
    }
    /// Locks the camera capture to the current device orientation.
    let lockCaptureOrientationChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.camera_avfoundation.CameraApi.lockCaptureOrientation\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      lockCaptureOrientationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let orientationArg = args[0] as! PlatformDeviceOrientation
        api.lockCaptureOrientation(orientation: orientationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      lockCaptureOrientationChannel.setMessageHandler(nil)
    }
    /// Unlocks camera capture orientation, allowing it to automatically adapt to
    /// device orientation.
    let unlockCaptureOrientationChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.camera_avfoundation.CameraApi.unlockCaptureOrientation\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      unlockCaptureOrientationChannel.setMessageHandler { _, reply in
        api.unlockCaptureOrientation { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      unlockCaptureOrientationChannel.setMessageHandler(nil)
    }
    /// Takes a picture with the current settings, and returns the path to the
    /// resulting file.
    let takePictureChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.takePicture\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      takePictureChannel.setMessageHandler { _, reply in
        api.takePicture { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      takePictureChannel.setMessageHandler(nil)
    }
    /// Does any preprocessing necessary before beginning to record video.
    let prepareForVideoRecordingChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.camera_avfoundation.CameraApi.prepareForVideoRecording\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      prepareForVideoRecordingChannel.setMessageHandler { _, reply in
        api.prepareForVideoRecording { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      prepareForVideoRecordingChannel.setMessageHandler(nil)
    }
    /// Begins recording video, optionally enabling streaming to Dart at the same
    /// time.
    let startVideoRecordingChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.startVideoRecording\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startVideoRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let enableStreamArg = args[0] as! Bool
        api.startVideoRecording(enableStream: enableStreamArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      startVideoRecordingChannel.setMessageHandler(nil)
    }
    /// Stops recording video, and results the path to the resulting file.
    let stopVideoRecordingChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.stopVideoRecording\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopVideoRecordingChannel.setMessageHandler { _, reply in
        api.stopVideoRecording { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      stopVideoRecordingChannel.setMessageHandler(nil)
    }
    /// Pauses video recording.
    let pauseVideoRecordingChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.pauseVideoRecording\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseVideoRecordingChannel.setMessageHandler { _, reply in
        api.pauseVideoRecording { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      pauseVideoRecordingChannel.setMessageHandler(nil)
    }
    /// Resumes a previously paused video recording.
    let resumeVideoRecordingChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.resumeVideoRecording\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resumeVideoRecordingChannel.setMessageHandler { _, reply in
        api.resumeVideoRecording { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      resumeVideoRecordingChannel.setMessageHandler(nil)
    }
    /// Switches the camera to the given flash mode.
    let setFlashModeChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.setFlashMode\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFlashModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modeArg = args[0] as! PlatformFlashMode
        api.setFlashMode(mode: modeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFlashModeChannel.setMessageHandler(nil)
    }
    /// Switches the camera to the given exposure mode.
    let setExposureModeChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.setExposureMode\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setExposureModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modeArg = args[0] as! PlatformExposureMode
        api.setExposureMode(mode: modeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setExposureModeChannel.setMessageHandler(nil)
    }
    /// Anchors auto-exposure to the given point in (0,1) coordinate space.
    ///
    /// A null value resets to the default exposure point.
    let setExposurePointChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.setExposurePoint\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setExposurePointChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pointArg: PlatformPoint? = nilOrValue(args[0])
        api.setExposurePoint(point: pointArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setExposurePointChannel.setMessageHandler(nil)
    }
    /// Returns the minimum exposure offset supported by the camera.
    let getMinExposureOffsetChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.getMinExposureOffset\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMinExposureOffsetChannel.setMessageHandler { _, reply in
        api.getMinExposureOffset { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getMinExposureOffsetChannel.setMessageHandler(nil)
    }
    /// Returns the maximum exposure offset supported by the camera.
    let getMaxExposureOffsetChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.getMaxExposureOffset\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMaxExposureOffsetChannel.setMessageHandler { _, reply in
        api.getMaxExposureOffset { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getMaxExposureOffsetChannel.setMessageHandler(nil)
    }
    /// Sets the exposure offset manually to the given value.
    let setExposureOffsetChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.setExposureOffset\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setExposureOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let offsetArg = args[0] as! Double
        api.setExposureOffset(offset: offsetArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setExposureOffsetChannel.setMessageHandler(nil)
    }
    /// Switches the camera to the given focus mode.
    let setFocusModeChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.setFocusMode\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFocusModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modeArg = args[0] as! PlatformFocusMode
        api.setFocusMode(mode: modeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFocusModeChannel.setMessageHandler(nil)
    }
    /// Anchors auto-focus to the given point in (0,1) coordinate space.
    ///
    /// A null value resets to the default focus point.
    let setFocusPointChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.setFocusPoint\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFocusPointChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pointArg: PlatformPoint? = nilOrValue(args[0])
        api.setFocusPoint(point: pointArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFocusPointChannel.setMessageHandler(nil)
    }
    /// Returns the minimum zoom level supported by the camera.
    let getMinZoomLevelChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.getMinZoomLevel\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMinZoomLevelChannel.setMessageHandler { _, reply in
        api.getMinZoomLevel { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getMinZoomLevelChannel.setMessageHandler(nil)
    }
    /// Returns the maximum zoom level supported by the camera.
    let getMaxZoomLevelChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.getMaxZoomLevel\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMaxZoomLevelChannel.setMessageHandler { _, reply in
        api.getMaxZoomLevel { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getMaxZoomLevelChannel.setMessageHandler(nil)
    }
    /// Sets the zoom factor.
    let setZoomLevelChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.setZoomLevel\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setZoomLevelChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let zoomArg = args[0] as! Double
        api.setZoomLevel(zoom: zoomArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setZoomLevelChannel.setMessageHandler(nil)
    }
    /// Pauses streaming of preview frames.
    let pausePreviewChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.pausePreview\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pausePreviewChannel.setMessageHandler { _, reply in
        api.pausePreview { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      pausePreviewChannel.setMessageHandler(nil)
    }
    /// Resumes a previously paused preview stream.
    let resumePreviewChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.resumePreview\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resumePreviewChannel.setMessageHandler { _, reply in
        api.resumePreview { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      resumePreviewChannel.setMessageHandler(nil)
    }
    /// Changes the camera used while recording video.
    ///
    /// This should only be called while video recording is active.
    let updateDescriptionWhileRecordingChannel = FlutterBasicMessageChannel(
      name:
        "dev.flutter.pigeon.camera_avfoundation.CameraApi.updateDescriptionWhileRecording\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateDescriptionWhileRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraNameArg = args[0] as! String
        api.updateDescriptionWhileRecording(cameraName: cameraNameArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateDescriptionWhileRecordingChannel.setMessageHandler(nil)
    }
    /// Sets the file format used for taking pictures.
    let setImageFileFormatChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.camera_avfoundation.CameraApi.setImageFileFormat\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageFileFormatChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let formatArg = args[0] as! PlatformImageFileFormat
        api.setImageFileFormat(format: formatArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setImageFileFormatChannel.setMessageHandler(nil)
    }
  }
}
/// Handler for native callbacks that are not tied to a specific camera ID.
///
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol CameraGlobalEventApiProtocol {
  /// Called when the device's physical orientation changes.
  func deviceOrientationChanged(
    orientation orientationArg: PlatformDeviceOrientation,
    completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class CameraGlobalEventApi: CameraGlobalEventApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: MessagesPigeonCodec {
    return MessagesPigeonCodec.shared
  }
  /// Called when the device's physical orientation changes.
  func deviceOrientationChanged(
    orientation orientationArg: PlatformDeviceOrientation,
    completion: @escaping (Result<Void, PigeonError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.camera_avfoundation.CameraGlobalEventApi.deviceOrientationChanged\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([orientationArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
/// Handler for native callbacks that are tied to a specific camera ID.
///
/// This is intended to be initialized with the camera ID as a suffix.
///
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol CameraEventApiProtocol {
  /// Called when the camera is inialitized for use.
  func initialized(
    initialState initialStateArg: PlatformCameraState,
    completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Called when an error occurs in the camera.
  ///
  /// This should be used for errors that occur outside of the context of
  /// handling a specific HostApi call, such as during streaming.
  func error(message messageArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class CameraEventApi: CameraEventApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: MessagesPigeonCodec {
    return MessagesPigeonCodec.shared
  }
  /// Called when the camera is inialitized for use.
  func initialized(
    initialState initialStateArg: PlatformCameraState,
    completion: @escaping (Result<Void, PigeonError>) -> Void
  ) {
    let channelName: String =
      "dev.flutter.pigeon.camera_avfoundation.CameraEventApi.initialized\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([initialStateArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  /// Called when an error occurs in the camera.
  ///
  /// This should be used for errors that occur outside of the context of
  /// handling a specific HostApi call, such as during streaming.
  func error(message messageArg: String, completion: @escaping (Result<Void, PigeonError>) -> Void)
  {
    let channelName: String =
      "dev.flutter.pigeon.camera_avfoundation.CameraEventApi.error\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([messageArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
