// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v24.2.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package io.flutter.plugins.googlesignin

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlutterError) {
    listOf(exception.code, exception.message, exception.details)
  } else {
    listOf(
        exception.javaClass.simpleName,
        exception.toString(),
        "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception))
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 *
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError(
    val code: String,
    override val message: String? = null,
    val details: Any? = null
) : Throwable()

enum class GetCredentialFailureType(val raw: Int) {
  /** Indicates that a credential was returned, but it was not of the expected type. */
  UNEXPECTED_CREDENTIAL_TYPE(0),
  /** Indicates that a server client ID was not provided. */
  MISSING_SERVER_CLIENT_ID(1),
  /** The request was internally interrupted. */
  INTERRUPTED(2),
  /** The request was canceled by the user. */
  CANCELED(3),
  /** No matching credential was found. */
  NO_CREDENTIAL(4),
  /** The provider was not properly configured. */
  PROVIDER_CONFIGURATION_ISSUE(5),
  /** The credential manager is not supported on this device. */
  UNSUPPORTED(6),
  /** The request failed for an unknown reason. */
  UNKNOWN(7);

  companion object {
    fun ofRaw(raw: Int): GetCredentialFailureType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class AuthorizeFailureType(val raw: Int) {
  /**
   * Indicates that the requested types are not currently authorized.
   *
   * This is returned only if promptIfUnauthorized is false, indicating that the user would need to
   * be prompted for authorization.
   */
  UNAUTHORIZED(0),
  /** Indicates that the call to AuthorizationClient.authorize itself failed. */
  AUTHORIZE_FAILURE(1),
  /**
   * Corresponds to SendIntentException, indicating that the pending intent is no longer available.
   */
  PENDING_INTENT_EXCEPTION(2),
  /**
   * Corresponds to an SendIntentException in onActivityResult, indicating that either authorization
   * failed, or the result was not available for some reason.
   */
  API_EXCEPTION(3),
  /**
   * Indicates that the user needs to be prompted for authorization, but there is no current
   * activity to prompt in.
   */
  NO_ACTIVITY(4);

  companion object {
    fun ofRaw(raw: Int): AuthorizeFailureType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * The information necessary to build a an authorization request.
 *
 * Corresponds to the native AuthorizationRequest object, but only contains the fields used by this
 * plugin.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class PlatformAuthorizationRequest(
    val scopes: List<String>,
    val hostedDomain: String? = null,
    val accountEmail: String? = null,
    /** If set, adds a call to requestOfflineAccess(this string, true); */
    val serverClientIdForForcedRefreshToken: String? = null
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PlatformAuthorizationRequest {
      val scopes = pigeonVar_list[0] as List<String>
      val hostedDomain = pigeonVar_list[1] as String?
      val accountEmail = pigeonVar_list[2] as String?
      val serverClientIdForForcedRefreshToken = pigeonVar_list[3] as String?
      return PlatformAuthorizationRequest(
          scopes, hostedDomain, accountEmail, serverClientIdForForcedRefreshToken)
    }
  }

  fun toList(): List<Any?> {
    return listOf(
        scopes,
        hostedDomain,
        accountEmail,
        serverClientIdForForcedRefreshToken,
    )
  }
}

/**
 * The information necessary to build a credential request.
 *
 * Combines the parts of the native GetCredentialRequest and CredentialOption classes that are used
 * for this plugin.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class GetCredentialRequestParams(
    /**
     * Whether to use the Sign in with Google button flow (GetSignInWithGoogleOption), corresponding
     * to an explicit sign-in request, or not (GetGoogleIdOption), corresponding to an implicit
     * potential sign-in.
     */
    val useButtonFlow: Boolean,
    /**
     * Parameters specific to GetGoogleIdOption.
     *
     * Ignored if useButtonFlow is true.
     */
    val googleIdOptionParams: GetCredentialRequestGoogleIdOptionParams,
    val serverClientId: String? = null,
    val nonce: String? = null
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GetCredentialRequestParams {
      val useButtonFlow = pigeonVar_list[0] as Boolean
      val googleIdOptionParams = pigeonVar_list[1] as GetCredentialRequestGoogleIdOptionParams
      val serverClientId = pigeonVar_list[2] as String?
      val nonce = pigeonVar_list[3] as String?
      return GetCredentialRequestParams(useButtonFlow, googleIdOptionParams, serverClientId, nonce)
    }
  }

  fun toList(): List<Any?> {
    return listOf(
        useButtonFlow,
        googleIdOptionParams,
        serverClientId,
        nonce,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class GetCredentialRequestGoogleIdOptionParams(
    val filterToAuthorized: Boolean,
    val autoSelectEnabled: Boolean
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GetCredentialRequestGoogleIdOptionParams {
      val filterToAuthorized = pigeonVar_list[0] as Boolean
      val autoSelectEnabled = pigeonVar_list[1] as Boolean
      return GetCredentialRequestGoogleIdOptionParams(filterToAuthorized, autoSelectEnabled)
    }
  }

  fun toList(): List<Any?> {
    return listOf(
        filterToAuthorized,
        autoSelectEnabled,
    )
  }
}

/**
 * Pigeon equivalent of the native GoogleIdTokenCredential.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class PlatformGoogleIdTokenCredential(
    val displayName: String? = null,
    val familyName: String? = null,
    val givenName: String? = null,
    val id: String,
    val idToken: String,
    val profilePictureUri: String? = null
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PlatformGoogleIdTokenCredential {
      val displayName = pigeonVar_list[0] as String?
      val familyName = pigeonVar_list[1] as String?
      val givenName = pigeonVar_list[2] as String?
      val id = pigeonVar_list[3] as String
      val idToken = pigeonVar_list[4] as String
      val profilePictureUri = pigeonVar_list[5] as String?
      return PlatformGoogleIdTokenCredential(
          displayName, familyName, givenName, id, idToken, profilePictureUri)
    }
  }

  fun toList(): List<Any?> {
    return listOf(
        displayName,
        familyName,
        givenName,
        id,
        idToken,
        profilePictureUri,
    )
  }
}

/**
 * The response from a `getCredential` call.
 *
 * This is not the same as a native GetCredentialResponse since modeling the response type hierarchy
 * and two-part callback in this interface layer would add a lot of complexity that is not needed
 * for the plugin's use case. It is instead a processed version of the results of those callbacks.
 *
 * Generated class from Pigeon that represents data sent in messages. This class should not be
 * extended by any user class outside of the generated file.
 */
sealed class GetCredentialResult
/**
 * An authentication failure.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class GetCredentialFailure(
    /** The type of failure. */
    val type: GetCredentialFailureType,
    /** The message associated with the failure, if any. */
    val message: String? = null,
    /** Extra details about the failure, if any. */
    val details: String? = null
) : GetCredentialResult() {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GetCredentialFailure {
      val type = pigeonVar_list[0] as GetCredentialFailureType
      val message = pigeonVar_list[1] as String?
      val details = pigeonVar_list[2] as String?
      return GetCredentialFailure(type, message, details)
    }
  }

  fun toList(): List<Any?> {
    return listOf(
        type,
        message,
        details,
    )
  }
}

/**
 * A successful authentication result.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class GetCredentialSuccess(val credential: PlatformGoogleIdTokenCredential) :
    GetCredentialResult() {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GetCredentialSuccess {
      val credential = pigeonVar_list[0] as PlatformGoogleIdTokenCredential
      return GetCredentialSuccess(credential)
    }
  }

  fun toList(): List<Any?> {
    return listOf(
        credential,
    )
  }
}

/**
 * The response from an `authorize` call.
 *
 * Generated class from Pigeon that represents data sent in messages. This class should not be
 * extended by any user class outside of the generated file.
 */
sealed class AuthorizeResult
/**
 * An authorization failure
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class AuthorizeFailure(
    /** The type of failure. */
    val type: AuthorizeFailureType,
    /** The message associated with the failure, if any. */
    val message: String? = null,
    /** Extra details about the failure, if any. */
    val details: String? = null
) : AuthorizeResult() {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): AuthorizeFailure {
      val type = pigeonVar_list[0] as AuthorizeFailureType
      val message = pigeonVar_list[1] as String?
      val details = pigeonVar_list[2] as String?
      return AuthorizeFailure(type, message, details)
    }
  }

  fun toList(): List<Any?> {
    return listOf(
        type,
        message,
        details,
    )
  }
}

/**
 * A successful authorization result.
 *
 * Corresponds to a native AuthorizationResult.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class PlatformAuthorizationResult(
    val accessToken: String? = null,
    val serverAuthCode: String? = null,
    val grantedScopes: List<String>
) : AuthorizeResult() {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PlatformAuthorizationResult {
      val accessToken = pigeonVar_list[0] as String?
      val serverAuthCode = pigeonVar_list[1] as String?
      val grantedScopes = pigeonVar_list[2] as List<String>
      return PlatformAuthorizationResult(accessToken, serverAuthCode, grantedScopes)
    }
  }

  fun toList(): List<Any?> {
    return listOf(
        accessToken,
        serverAuthCode,
        grantedScopes,
    )
  }
}

private open class MessagesPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let { GetCredentialFailureType.ofRaw(it.toInt()) }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let { AuthorizeFailureType.ofRaw(it.toInt()) }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PlatformAuthorizationRequest.fromList(it) }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { GetCredentialRequestParams.fromList(it) }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GetCredentialRequestGoogleIdOptionParams.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PlatformGoogleIdTokenCredential.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { GetCredentialFailure.fromList(it) }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { GetCredentialSuccess.fromList(it) }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { AuthorizeFailure.fromList(it) }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let { PlatformAuthorizationResult.fromList(it) }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }

  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is GetCredentialFailureType -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is AuthorizeFailureType -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is PlatformAuthorizationRequest -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is GetCredentialRequestParams -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is GetCredentialRequestGoogleIdOptionParams -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is PlatformGoogleIdTokenCredential -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is GetCredentialFailure -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is GetCredentialSuccess -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is AuthorizeFailure -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is PlatformAuthorizationResult -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GoogleSignInApi {
  /**
   * Returns the server client ID parsed from google-services.json by the google-services Gradle
   * script, if any.
   */
  fun getGoogleServicesJsonServerClientId(): String?
  /** Requests an authentication credential (sign in) via CredentialManager's getCredential. */
  fun getCredential(
      params: GetCredentialRequestParams,
      callback: (Result<GetCredentialResult>) -> Unit
  )
  /** Clears CredentialManager credential state. */
  fun clearCredentialState(callback: (Result<Unit>) -> Unit)
  /** Requests authorization tokens via AuthorizationClient. */
  fun authorize(
      params: PlatformAuthorizationRequest,
      promptIfUnauthorized: Boolean,
      callback: (Result<AuthorizeResult>) -> Unit
  )

  companion object {
    /** The codec used by GoogleSignInApi. */
    val codec: MessageCodec<Any?> by lazy { MessagesPigeonCodec() }
    /**
     * Sets up an instance of `GoogleSignInApi` to handle messages through the `binaryMessenger`.
     */
    @JvmOverloads
    fun setUp(
        binaryMessenger: BinaryMessenger,
        api: GoogleSignInApi?,
        messageChannelSuffix: String = ""
    ) {
      val separatedMessageChannelSuffix =
          if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel =
            BasicMessageChannel<Any?>(
                binaryMessenger,
                "dev.flutter.pigeon.google_sign_in_android.GoogleSignInApi.getGoogleServicesJsonServerClientId$separatedMessageChannelSuffix",
                codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> =
                try {
                  listOf(api.getGoogleServicesJsonServerClientId())
                } catch (exception: Throwable) {
                  wrapError(exception)
                }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
            BasicMessageChannel<Any?>(
                binaryMessenger,
                "dev.flutter.pigeon.google_sign_in_android.GoogleSignInApi.getCredential$separatedMessageChannelSuffix",
                codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val paramsArg = args[0] as GetCredentialRequestParams
            api.getCredential(paramsArg) { result: Result<GetCredentialResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
            BasicMessageChannel<Any?>(
                binaryMessenger,
                "dev.flutter.pigeon.google_sign_in_android.GoogleSignInApi.clearCredentialState$separatedMessageChannelSuffix",
                codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.clearCredentialState { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel =
            BasicMessageChannel<Any?>(
                binaryMessenger,
                "dev.flutter.pigeon.google_sign_in_android.GoogleSignInApi.authorize$separatedMessageChannelSuffix",
                codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val paramsArg = args[0] as PlatformAuthorizationRequest
            val promptIfUnauthorizedArg = args[1] as Boolean
            api.authorize(paramsArg, promptIfUnauthorizedArg) { result: Result<AuthorizeResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
