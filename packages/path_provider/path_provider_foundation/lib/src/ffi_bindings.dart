// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;

/// Bindings for NSFileManager.
class FoundationFFI {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FoundationFFI(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FoundationFFI.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  objc.NSArray NSSearchPathForDirectoriesInDomains(
    NSSearchPathDirectory directory,
    NSSearchPathDomainMask domainMask,
    bool expandTilde,
  ) {
    return objc.NSArray.castFromPointer(
        _NSSearchPathForDirectoriesInDomains(
          directory.value,
          domainMask.value,
          expandTilde,
        ),
        retain: true,
        release: true);
  }

  late final _NSSearchPathForDirectoriesInDomainsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.UnsignedLong,
              ffi.UnsignedLong,
              ffi.Bool)>>('NSSearchPathForDirectoriesInDomains');
  late final _NSSearchPathForDirectoriesInDomains =
      _NSSearchPathForDirectoriesInDomainsPtr.asFunction<
          ffi.Pointer<objc.ObjCObject> Function(int, int, bool)>();
}

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
// ignore: unused_element
external ffi.Pointer<objc.ObjCObject> _FoundationFFI_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _FoundationFFI_wrapListenerBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _FoundationFFI_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _FoundationFFI_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _FoundationFFI_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

/// WARNING: NSProgress is a stub. To generate bindings for this class, include
/// NSProgress in your config's objc-interfaces list.
///
/// NSProgress
class NSProgress extends objc.NSObject {
  NSProgress._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSProgress',
        iOS: (false, (7, 0, 0)), macOS: (false, (10, 9, 0)));
  }

  /// Constructs a [NSProgress] that points to the same underlying object as [other].
  NSProgress.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSProgress] that wraps the given raw object pointer.
  NSProgress.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _class_NSBundle = objc.getClass("NSBundle");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setPreservationPriority_forTags_ =
    objc.registerName("setPreservationPriority:forTags:");
final _objc_msgSend_130mcug = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_preservationPriorityForTag_ =
    objc.registerName("preservationPriorityForTag:");
final _objc_msgSend_mabicu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_mabicuFpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// NSBundleResourceRequestAdditions
extension NSBundleResourceRequestAdditions on NSBundle {
  /// setPreservationPriority:forTags:
  void setPreservationPriority(double priority, {required objc.NSSet forTags}) {
    objc.checkOsVersionInternal('NSBundle.setPreservationPriority:forTags:',
        iOS: (false, (9, 0, 0)), macOS: (true, null));
    _objc_msgSend_130mcug(this.ref.pointer,
        _sel_setPreservationPriority_forTags_, priority, forTags.ref.pointer);
  }

  /// preservationPriorityForTag:
  double preservationPriorityForTag(objc.NSString tag) {
    objc.checkOsVersionInternal('NSBundle.preservationPriorityForTag:',
        iOS: (false, (9, 0, 0)), macOS: (true, null));
    return objc.useMsgSendVariants
        ? _objc_msgSend_mabicuFpret(
            this.ref.pointer, _sel_preservationPriorityForTag_, tag.ref.pointer)
        : _objc_msgSend_mabicu(this.ref.pointer,
            _sel_preservationPriorityForTag_, tag.ref.pointer);
  }
}

late final _sel_mainBundle = objc.registerName("mainBundle");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_bundleWithPath_ = objc.registerName("bundleWithPath:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithPath_ = objc.registerName("initWithPath:");
late final _sel_bundleWithURL_ = objc.registerName("bundleWithURL:");
late final _sel_initWithURL_ = objc.registerName("initWithURL:");
late final _sel_bundleForClass_ = objc.registerName("bundleForClass:");
late final _sel_bundleWithIdentifier_ =
    objc.registerName("bundleWithIdentifier:");
late final _sel_allBundles = objc.registerName("allBundles");
late final _sel_allFrameworks = objc.registerName("allFrameworks");
late final _sel_load = objc.registerName("load");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isLoaded = objc.registerName("isLoaded");
late final _sel_unload = objc.registerName("unload");
late final _sel_preflightAndReturnError_ =
    objc.registerName("preflightAndReturnError:");
final _objc_msgSend_1dom33q = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_loadAndReturnError_ = objc.registerName("loadAndReturnError:");
late final _sel_bundleURL = objc.registerName("bundleURL");
late final _sel_resourceURL = objc.registerName("resourceURL");
late final _sel_executableURL = objc.registerName("executableURL");
late final _sel_URLForAuxiliaryExecutable_ =
    objc.registerName("URLForAuxiliaryExecutable:");
late final _sel_privateFrameworksURL =
    objc.registerName("privateFrameworksURL");
late final _sel_sharedFrameworksURL = objc.registerName("sharedFrameworksURL");
late final _sel_sharedSupportURL = objc.registerName("sharedSupportURL");
late final _sel_builtInPlugInsURL = objc.registerName("builtInPlugInsURL");
late final _sel_appStoreReceiptURL = objc.registerName("appStoreReceiptURL");
late final _sel_bundlePath = objc.registerName("bundlePath");
late final _sel_resourcePath = objc.registerName("resourcePath");
late final _sel_executablePath = objc.registerName("executablePath");
late final _sel_pathForAuxiliaryExecutable_ =
    objc.registerName("pathForAuxiliaryExecutable:");
late final _sel_privateFrameworksPath =
    objc.registerName("privateFrameworksPath");
late final _sel_sharedFrameworksPath =
    objc.registerName("sharedFrameworksPath");
late final _sel_sharedSupportPath = objc.registerName("sharedSupportPath");
late final _sel_builtInPlugInsPath = objc.registerName("builtInPlugInsPath");
late final _sel_URLForResource_withExtension_subdirectory_inBundleWithURL_ =
    objc.registerName(
        "URLForResource:withExtension:subdirectory:inBundleWithURL:");
final _objc_msgSend_s92gih = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_URLsForResourcesWithExtension_subdirectory_inBundleWithURL_ =
    objc.registerName(
        "URLsForResourcesWithExtension:subdirectory:inBundleWithURL:");
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_URLForResource_withExtension_ =
    objc.registerName("URLForResource:withExtension:");
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_URLForResource_withExtension_subdirectory_ =
    objc.registerName("URLForResource:withExtension:subdirectory:");
late final _sel_URLForResource_withExtension_subdirectory_localization_ = objc
    .registerName("URLForResource:withExtension:subdirectory:localization:");
late final _sel_URLsForResourcesWithExtension_subdirectory_ =
    objc.registerName("URLsForResourcesWithExtension:subdirectory:");
late final _sel_URLsForResourcesWithExtension_subdirectory_localization_ = objc
    .registerName("URLsForResourcesWithExtension:subdirectory:localization:");
late final _sel_pathForResource_ofType_inDirectory_ =
    objc.registerName("pathForResource:ofType:inDirectory:");
late final _sel_pathsForResourcesOfType_inDirectory_ =
    objc.registerName("pathsForResourcesOfType:inDirectory:");
late final _sel_pathForResource_ofType_ =
    objc.registerName("pathForResource:ofType:");
late final _sel_pathForResource_ofType_inDirectory_forLocalization_ =
    objc.registerName("pathForResource:ofType:inDirectory:forLocalization:");
late final _sel_pathsForResourcesOfType_inDirectory_forLocalization_ =
    objc.registerName("pathsForResourcesOfType:inDirectory:forLocalization:");
late final _sel_localizedStringForKey_value_table_ =
    objc.registerName("localizedStringForKey:value:table:");

/// WARNING: NSAttributedString is a stub. To generate bindings for this class, include
/// NSAttributedString in your config's objc-interfaces list.
///
/// NSAttributedString
class NSAttributedString extends objc.NSObject
    implements objc.NSCopying, objc.NSMutableCopying, objc.NSSecureCoding {
  NSAttributedString._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSAttributedString',
        iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
  }

  /// Constructs a [NSAttributedString] that points to the same underlying object as [other].
  NSAttributedString.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSAttributedString] that wraps the given raw object pointer.
  NSAttributedString.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_localizedAttributedStringForKey_value_table_ =
    objc.registerName("localizedAttributedStringForKey:value:table:");
late final _sel_localizedStringForKey_value_table_localizations_ =
    objc.registerName("localizedStringForKey:value:table:localizations:");
late final _sel_bundleIdentifier = objc.registerName("bundleIdentifier");
late final _sel_infoDictionary = objc.registerName("infoDictionary");
late final _sel_localizedInfoDictionary =
    objc.registerName("localizedInfoDictionary");
late final _sel_objectForInfoDictionaryKey_ =
    objc.registerName("objectForInfoDictionaryKey:");
late final _sel_classNamed_ = objc.registerName("classNamed:");
late final _sel_principalClass = objc.registerName("principalClass");
late final _sel_preferredLocalizations =
    objc.registerName("preferredLocalizations");
late final _sel_localizations = objc.registerName("localizations");
late final _sel_developmentLocalization =
    objc.registerName("developmentLocalization");
late final _sel_preferredLocalizationsFromArray_ =
    objc.registerName("preferredLocalizationsFromArray:");
late final _sel_preferredLocalizationsFromArray_forPreferences_ =
    objc.registerName("preferredLocalizationsFromArray:forPreferences:");
late final _sel_executableArchitectures =
    objc.registerName("executableArchitectures");
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_self = objc.registerName("self");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");

/// NSBundle
class NSBundle extends objc.NSObject {
  NSBundle._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSBundle] that points to the same underlying object as [other].
  NSBundle.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSBundle] that wraps the given raw object pointer.
  NSBundle.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSBundle].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSBundle);
  }

  /// mainBundle
  static NSBundle getMainBundle() {
    final _ret = _objc_msgSend_151sglz(_class_NSBundle, _sel_mainBundle);
    return NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// bundleWithPath:
  static NSBundle? bundleWithPath(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSBundle, _sel_bundleWithPath_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithPath:
  NSBundle? initWithPath(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithPath_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : NSBundle.castFromPointer(_ret, retain: false, release: true);
  }

  /// bundleWithURL:
  static NSBundle? bundleWithURL(objc.NSURL url) {
    objc.checkOsVersionInternal('NSBundle.bundleWithURL:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSBundle, _sel_bundleWithURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithURL:
  NSBundle? initWithURL(objc.NSURL url) {
    objc.checkOsVersionInternal('NSBundle.initWithURL:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.retainAndReturnPointer(), _sel_initWithURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : NSBundle.castFromPointer(_ret, retain: false, release: true);
  }

  /// bundleForClass:
  static NSBundle bundleForClass(objc.ObjCObjectBase aClass) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSBundle, _sel_bundleForClass_, aClass.ref.pointer);
    return NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// bundleWithIdentifier:
  static NSBundle? bundleWithIdentifier(objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSBundle, _sel_bundleWithIdentifier_, identifier.ref.pointer);
    return _ret.address == 0
        ? null
        : NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// allBundles
  static objc.NSArray getAllBundles() {
    final _ret = _objc_msgSend_151sglz(_class_NSBundle, _sel_allBundles);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// allFrameworks
  static objc.NSArray getAllFrameworks() {
    final _ret = _objc_msgSend_151sglz(_class_NSBundle, _sel_allFrameworks);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// load
  bool load() {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_load);
  }

  /// isLoaded
  bool get loaded {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isLoaded);
  }

  /// unload
  bool unload() {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_unload);
  }

  /// preflightAndReturnError:
  bool preflightAndReturnError(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal('NSBundle.preflightAndReturnError:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
    return _objc_msgSend_1dom33q(
        this.ref.pointer, _sel_preflightAndReturnError_, error);
  }

  /// loadAndReturnError:
  bool loadAndReturnError(ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal('NSBundle.loadAndReturnError:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
    return _objc_msgSend_1dom33q(
        this.ref.pointer, _sel_loadAndReturnError_, error);
  }

  /// bundleURL
  objc.NSURL get bundleURL {
    objc.checkOsVersionInternal('NSBundle.bundleURL',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_bundleURL);
    return objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// resourceURL
  objc.NSURL? get resourceURL {
    objc.checkOsVersionInternal('NSBundle.resourceURL',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_resourceURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// executableURL
  objc.NSURL? get executableURL {
    objc.checkOsVersionInternal('NSBundle.executableURL',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_executableURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLForAuxiliaryExecutable:
  objc.NSURL? URLForAuxiliaryExecutable(objc.NSString executableName) {
    objc.checkOsVersionInternal('NSBundle.URLForAuxiliaryExecutable:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_URLForAuxiliaryExecutable_, executableName.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// privateFrameworksURL
  objc.NSURL? get privateFrameworksURL {
    objc.checkOsVersionInternal('NSBundle.privateFrameworksURL',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_privateFrameworksURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// sharedFrameworksURL
  objc.NSURL? get sharedFrameworksURL {
    objc.checkOsVersionInternal('NSBundle.sharedFrameworksURL',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_sharedFrameworksURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// sharedSupportURL
  objc.NSURL? get sharedSupportURL {
    objc.checkOsVersionInternal('NSBundle.sharedSupportURL',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_sharedSupportURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// builtInPlugInsURL
  objc.NSURL? get builtInPlugInsURL {
    objc.checkOsVersionInternal('NSBundle.builtInPlugInsURL',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_builtInPlugInsURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// appStoreReceiptURL
  objc.NSURL? get appStoreReceiptURL {
    objc.checkOsVersionInternal('NSBundle.appStoreReceiptURL',
        iOS: (false, (7, 0, 0)), macOS: (false, (10, 7, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_appStoreReceiptURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// bundlePath
  objc.NSString get bundlePath {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_bundlePath);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// resourcePath
  objc.NSString? get resourcePath {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_resourcePath);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// executablePath
  objc.NSString? get executablePath {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_executablePath);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathForAuxiliaryExecutable:
  objc.NSString? pathForAuxiliaryExecutable(objc.NSString executableName) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_pathForAuxiliaryExecutable_, executableName.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// privateFrameworksPath
  objc.NSString? get privateFrameworksPath {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_privateFrameworksPath);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// sharedFrameworksPath
  objc.NSString? get sharedFrameworksPath {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_sharedFrameworksPath);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// sharedSupportPath
  objc.NSString? get sharedSupportPath {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_sharedSupportPath);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// builtInPlugInsPath
  objc.NSString? get builtInPlugInsPath {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_builtInPlugInsPath);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLForResource:withExtension:subdirectory:inBundleWithURL:
  static objc.NSURL? URLForResource(objc.NSString? name,
      {objc.NSString? withExtension,
      objc.NSString? subdirectory,
      required objc.NSURL inBundleWithURL}) {
    objc.checkOsVersionInternal(
        'NSBundle.URLForResource:withExtension:subdirectory:inBundleWithURL:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_s92gih(
        _class_NSBundle,
        _sel_URLForResource_withExtension_subdirectory_inBundleWithURL_,
        name?.ref.pointer ?? ffi.nullptr,
        withExtension?.ref.pointer ?? ffi.nullptr,
        subdirectory?.ref.pointer ?? ffi.nullptr,
        inBundleWithURL.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLsForResourcesWithExtension:subdirectory:inBundleWithURL:
  static objc.NSArray? URLsForResourcesWithExtension(objc.NSString? ext,
      {objc.NSString? subdirectory, required objc.NSURL inBundleWithURL}) {
    objc.checkOsVersionInternal(
        'NSBundle.URLsForResourcesWithExtension:subdirectory:inBundleWithURL:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_11spmsz(
        _class_NSBundle,
        _sel_URLsForResourcesWithExtension_subdirectory_inBundleWithURL_,
        ext?.ref.pointer ?? ffi.nullptr,
        subdirectory?.ref.pointer ?? ffi.nullptr,
        inBundleWithURL.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLForResource:withExtension:
  objc.NSURL? URLForResource$1(objc.NSString? name,
      {objc.NSString? withExtension}) {
    objc.checkOsVersionInternal('NSBundle.URLForResource:withExtension:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_URLForResource_withExtension_,
        name?.ref.pointer ?? ffi.nullptr,
        withExtension?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLForResource:withExtension:subdirectory:
  objc.NSURL? URLForResource$2(objc.NSString? name,
      {objc.NSString? withExtension, objc.NSString? subdirectory}) {
    objc.checkOsVersionInternal(
        'NSBundle.URLForResource:withExtension:subdirectory:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_11spmsz(
        this.ref.pointer,
        _sel_URLForResource_withExtension_subdirectory_,
        name?.ref.pointer ?? ffi.nullptr,
        withExtension?.ref.pointer ?? ffi.nullptr,
        subdirectory?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLForResource:withExtension:subdirectory:localization:
  objc.NSURL? URLForResource$3(objc.NSString? name,
      {objc.NSString? withExtension,
      objc.NSString? subdirectory,
      objc.NSString? localization}) {
    objc.checkOsVersionInternal(
        'NSBundle.URLForResource:withExtension:subdirectory:localization:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_s92gih(
        this.ref.pointer,
        _sel_URLForResource_withExtension_subdirectory_localization_,
        name?.ref.pointer ?? ffi.nullptr,
        withExtension?.ref.pointer ?? ffi.nullptr,
        subdirectory?.ref.pointer ?? ffi.nullptr,
        localization?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLsForResourcesWithExtension:subdirectory:
  objc.NSArray? URLsForResourcesWithExtension$1(objc.NSString? ext,
      {objc.NSString? subdirectory}) {
    objc.checkOsVersionInternal(
        'NSBundle.URLsForResourcesWithExtension:subdirectory:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_URLsForResourcesWithExtension_subdirectory_,
        ext?.ref.pointer ?? ffi.nullptr,
        subdirectory?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLsForResourcesWithExtension:subdirectory:localization:
  objc.NSArray? URLsForResourcesWithExtension$2(objc.NSString? ext,
      {objc.NSString? subdirectory, objc.NSString? localization}) {
    objc.checkOsVersionInternal(
        'NSBundle.URLsForResourcesWithExtension:subdirectory:localization:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_11spmsz(
        this.ref.pointer,
        _sel_URLsForResourcesWithExtension_subdirectory_localization_,
        ext?.ref.pointer ?? ffi.nullptr,
        subdirectory?.ref.pointer ?? ffi.nullptr,
        localization?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathForResource:ofType:inDirectory:
  static objc.NSString? pathForResource(objc.NSString? name,
      {objc.NSString? ofType, required objc.NSString inDirectory}) {
    final _ret = _objc_msgSend_11spmsz(
        _class_NSBundle,
        _sel_pathForResource_ofType_inDirectory_,
        name?.ref.pointer ?? ffi.nullptr,
        ofType?.ref.pointer ?? ffi.nullptr,
        inDirectory.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathsForResourcesOfType:inDirectory:
  static objc.NSArray pathsForResourcesOfType(objc.NSString? ext,
      {required objc.NSString inDirectory}) {
    final _ret = _objc_msgSend_15qeuct(
        _class_NSBundle,
        _sel_pathsForResourcesOfType_inDirectory_,
        ext?.ref.pointer ?? ffi.nullptr,
        inDirectory.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathForResource:ofType:
  objc.NSString? pathForResource$1(objc.NSString? name,
      {objc.NSString? ofType}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_pathForResource_ofType_,
        name?.ref.pointer ?? ffi.nullptr,
        ofType?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathForResource:ofType:inDirectory:
  objc.NSString? pathForResource$2(objc.NSString? name,
      {objc.NSString? ofType, objc.NSString? inDirectory}) {
    final _ret = _objc_msgSend_11spmsz(
        this.ref.pointer,
        _sel_pathForResource_ofType_inDirectory_,
        name?.ref.pointer ?? ffi.nullptr,
        ofType?.ref.pointer ?? ffi.nullptr,
        inDirectory?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathForResource:ofType:inDirectory:forLocalization:
  objc.NSString? pathForResource$3(objc.NSString? name,
      {objc.NSString? ofType,
      objc.NSString? inDirectory,
      objc.NSString? forLocalization}) {
    final _ret = _objc_msgSend_s92gih(
        this.ref.pointer,
        _sel_pathForResource_ofType_inDirectory_forLocalization_,
        name?.ref.pointer ?? ffi.nullptr,
        ofType?.ref.pointer ?? ffi.nullptr,
        inDirectory?.ref.pointer ?? ffi.nullptr,
        forLocalization?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathsForResourcesOfType:inDirectory:
  objc.NSArray pathsForResourcesOfType$1(objc.NSString? ext,
      {objc.NSString? inDirectory}) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_pathsForResourcesOfType_inDirectory_,
        ext?.ref.pointer ?? ffi.nullptr,
        inDirectory?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathsForResourcesOfType:inDirectory:forLocalization:
  objc.NSArray pathsForResourcesOfType$2(objc.NSString? ext,
      {objc.NSString? inDirectory, objc.NSString? forLocalization}) {
    final _ret = _objc_msgSend_11spmsz(
        this.ref.pointer,
        _sel_pathsForResourcesOfType_inDirectory_forLocalization_,
        ext?.ref.pointer ?? ffi.nullptr,
        inDirectory?.ref.pointer ?? ffi.nullptr,
        forLocalization?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizedStringForKey:value:table:
  objc.NSString localizedStringForKey(objc.NSString key,
      {objc.NSString? value, objc.NSString? table}) {
    final _ret = _objc_msgSend_11spmsz(
        this.ref.pointer,
        _sel_localizedStringForKey_value_table_,
        key.ref.pointer,
        value?.ref.pointer ?? ffi.nullptr,
        table?.ref.pointer ?? ffi.nullptr);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizedAttributedStringForKey:value:table:
  NSAttributedString localizedAttributedStringForKey(objc.NSString key,
      {objc.NSString? value, objc.NSString? table}) {
    objc.checkOsVersionInternal(
        'NSBundle.localizedAttributedStringForKey:value:table:',
        iOS: (false, (15, 0, 0)),
        macOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_11spmsz(
        this.ref.pointer,
        _sel_localizedAttributedStringForKey_value_table_,
        key.ref.pointer,
        value?.ref.pointer ?? ffi.nullptr,
        table?.ref.pointer ?? ffi.nullptr);
    return NSAttributedString.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// localizedStringForKey:value:table:localizations:
  objc.NSString localizedStringForKey$1(objc.NSString key,
      {objc.NSString? value,
      objc.NSString? table,
      required objc.NSArray localizations}) {
    objc.checkOsVersionInternal(
        'NSBundle.localizedStringForKey:value:table:localizations:',
        iOS: (false, (18, 4, 0)),
        macOS: (false, (15, 4, 0)));
    final _ret = _objc_msgSend_s92gih(
        this.ref.pointer,
        _sel_localizedStringForKey_value_table_localizations_,
        key.ref.pointer,
        value?.ref.pointer ?? ffi.nullptr,
        table?.ref.pointer ?? ffi.nullptr,
        localizations.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// bundleIdentifier
  objc.NSString? get bundleIdentifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_bundleIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// infoDictionary
  objc.NSDictionary? get infoDictionary {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_infoDictionary);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizedInfoDictionary
  objc.NSDictionary? get localizedInfoDictionary {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_localizedInfoDictionary);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// objectForInfoDictionaryKey:
  objc.ObjCObjectBase? objectForInfoDictionaryKey(objc.NSString key) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_objectForInfoDictionaryKey_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// classNamed:
  objc.ObjCObjectBase? classNamed(objc.NSString className) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_classNamed_, className.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// principalClass
  objc.ObjCObjectBase? get principalClass {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_principalClass);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// preferredLocalizations
  objc.NSArray get preferredLocalizations {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredLocalizations);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizations
  objc.NSArray get localizations {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_localizations);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// developmentLocalization
  objc.NSString? get developmentLocalization {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_developmentLocalization);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// preferredLocalizationsFromArray:
  static objc.NSArray preferredLocalizationsFromArray(
      objc.NSArray localizationsArray) {
    final _ret = _objc_msgSend_1sotr3r(_class_NSBundle,
        _sel_preferredLocalizationsFromArray_, localizationsArray.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// preferredLocalizationsFromArray:forPreferences:
  static objc.NSArray preferredLocalizationsFromArray$1(
      objc.NSArray localizationsArray,
      {objc.NSArray? forPreferences}) {
    final _ret = _objc_msgSend_15qeuct(
        _class_NSBundle,
        _sel_preferredLocalizationsFromArray_forPreferences_,
        localizationsArray.ref.pointer,
        forPreferences?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// executableArchitectures
  objc.NSArray? get executableArchitectures {
    objc.checkOsVersionInternal('NSBundle.executableArchitectures',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_executableArchitectures);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSBundle init() {
    objc.checkOsVersionInternal('NSBundle.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSBundle.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static NSBundle new$() {
    final _ret = _objc_msgSend_151sglz(_class_NSBundle, _sel_new);
    return NSBundle.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSBundle allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_NSBundle, _sel_allocWithZone_, zone);
    return NSBundle.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSBundle alloc() {
    final _ret = _objc_msgSend_151sglz(_class_NSBundle, _sel_alloc);
    return NSBundle.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  NSBundle self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  NSBundle retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  NSBundle autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of NSBundle constructed with the default `new` method.
  factory NSBundle() => new$();
}

enum NSAttributedStringEnumerationOptions {
  NSAttributedStringEnumerationReverse(2),
  NSAttributedStringEnumerationLongestEffectiveRangeNotRequired(1048576);

  final int value;
  const NSAttributedStringEnumerationOptions(this.value);

  static NSAttributedStringEnumerationOptions fromValue(int value) =>
      switch (value) {
        2 => NSAttributedStringEnumerationReverse,
        1048576 =>
          NSAttributedStringEnumerationLongestEffectiveRangeNotRequired,
        _ => throw ArgumentError(
            'Unknown value for NSAttributedStringEnumerationOptions: $value'),
      };
}

enum NSAttributedStringMarkdownParsingFailurePolicy {
  NSAttributedStringMarkdownParsingFailureReturnError(0),
  NSAttributedStringMarkdownParsingFailureReturnPartiallyParsedIfPossible(1);

  final int value;
  const NSAttributedStringMarkdownParsingFailurePolicy(this.value);

  static NSAttributedStringMarkdownParsingFailurePolicy fromValue(int value) =>
      switch (value) {
        0 => NSAttributedStringMarkdownParsingFailureReturnError,
        1 =>
          NSAttributedStringMarkdownParsingFailureReturnPartiallyParsedIfPossible,
        _ => throw ArgumentError(
            'Unknown value for NSAttributedStringMarkdownParsingFailurePolicy: $value'),
      };
}

enum NSAttributedStringMarkdownInterpretedSyntax {
  NSAttributedStringMarkdownInterpretedSyntaxFull(0),
  NSAttributedStringMarkdownInterpretedSyntaxInlineOnly(1),
  NSAttributedStringMarkdownInterpretedSyntaxInlineOnlyPreservingWhitespace(2);

  final int value;
  const NSAttributedStringMarkdownInterpretedSyntax(this.value);

  static NSAttributedStringMarkdownInterpretedSyntax fromValue(int value) =>
      switch (value) {
        0 => NSAttributedStringMarkdownInterpretedSyntaxFull,
        1 => NSAttributedStringMarkdownInterpretedSyntaxInlineOnly,
        2 =>
          NSAttributedStringMarkdownInterpretedSyntaxInlineOnlyPreservingWhitespace,
        _ => throw ArgumentError(
            'Unknown value for NSAttributedStringMarkdownInterpretedSyntax: $value'),
      };
}

enum NSAttributedStringFormattingOptions {
  NSAttributedStringFormattingInsertArgumentAttributesWithoutMerging(1),
  NSAttributedStringFormattingApplyReplacementIndexAttribute(2);

  final int value;
  const NSAttributedStringFormattingOptions(this.value);

  static NSAttributedStringFormattingOptions fromValue(int value) =>
      switch (value) {
        1 => NSAttributedStringFormattingInsertArgumentAttributesWithoutMerging,
        2 => NSAttributedStringFormattingApplyReplacementIndexAttribute,
        _ => throw ArgumentError(
            'Unknown value for NSAttributedStringFormattingOptions: $value'),
      };
}

enum NSSearchPathDirectory {
  NSApplicationDirectory(1),
  NSDemoApplicationDirectory(2),
  NSDeveloperApplicationDirectory(3),
  NSAdminApplicationDirectory(4),
  NSLibraryDirectory(5),
  NSDeveloperDirectory(6),
  NSUserDirectory(7),
  NSDocumentationDirectory(8),
  NSDocumentDirectory(9),
  NSCoreServiceDirectory(10),
  NSAutosavedInformationDirectory(11),
  NSDesktopDirectory(12),
  NSCachesDirectory(13),
  NSApplicationSupportDirectory(14),
  NSDownloadsDirectory(15),
  NSInputMethodsDirectory(16),
  NSMoviesDirectory(17),
  NSMusicDirectory(18),
  NSPicturesDirectory(19),
  NSPrinterDescriptionDirectory(20),
  NSSharedPublicDirectory(21),
  NSPreferencePanesDirectory(22),
  NSApplicationScriptsDirectory(23),
  NSItemReplacementDirectory(99),
  NSAllApplicationsDirectory(100),
  NSAllLibrariesDirectory(101),
  NSTrashDirectory(102);

  final int value;
  const NSSearchPathDirectory(this.value);

  static NSSearchPathDirectory fromValue(int value) => switch (value) {
        1 => NSApplicationDirectory,
        2 => NSDemoApplicationDirectory,
        3 => NSDeveloperApplicationDirectory,
        4 => NSAdminApplicationDirectory,
        5 => NSLibraryDirectory,
        6 => NSDeveloperDirectory,
        7 => NSUserDirectory,
        8 => NSDocumentationDirectory,
        9 => NSDocumentDirectory,
        10 => NSCoreServiceDirectory,
        11 => NSAutosavedInformationDirectory,
        12 => NSDesktopDirectory,
        13 => NSCachesDirectory,
        14 => NSApplicationSupportDirectory,
        15 => NSDownloadsDirectory,
        16 => NSInputMethodsDirectory,
        17 => NSMoviesDirectory,
        18 => NSMusicDirectory,
        19 => NSPicturesDirectory,
        20 => NSPrinterDescriptionDirectory,
        21 => NSSharedPublicDirectory,
        22 => NSPreferencePanesDirectory,
        23 => NSApplicationScriptsDirectory,
        99 => NSItemReplacementDirectory,
        100 => NSAllApplicationsDirectory,
        101 => NSAllLibrariesDirectory,
        102 => NSTrashDirectory,
        _ => throw ArgumentError(
            'Unknown value for NSSearchPathDirectory: $value'),
      };
}

enum NSSearchPathDomainMask {
  NSUserDomainMask(1),
  NSLocalDomainMask(2),
  NSNetworkDomainMask(4),
  NSSystemDomainMask(8),
  NSAllDomainsMask(65535);

  final int value;
  const NSSearchPathDomainMask(this.value);

  static NSSearchPathDomainMask fromValue(int value) => switch (value) {
        1 => NSUserDomainMask,
        2 => NSLocalDomainMask,
        4 => NSNetworkDomainMask,
        8 => NSSystemDomainMask,
        65535 => NSAllDomainsMask,
        _ => throw ArgumentError(
            'Unknown value for NSSearchPathDomainMask: $value'),
      };
}

late final _class_NSURL = objc.getClass("NSURL");
late final _sel_getPromisedItemResourceValue_forKey_error_ =
    objc.registerName("getPromisedItemResourceValue:forKey:error:");
final _objc_msgSend_1j9bhml = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_promisedItemResourceValuesForKeys_error_ =
    objc.registerName("promisedItemResourceValuesForKeys:error:");
final _objc_msgSend_1lhpu4m = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_checkPromisedItemIsReachableAndReturnError_ =
    objc.registerName("checkPromisedItemIsReachableAndReturnError:");

/// NSPromisedItems
extension NSPromisedItems on objc.NSURL {
  /// getPromisedItemResourceValue:forKey:error:
  bool getPromisedItemResourceValue(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> value,
      {required objc.NSString forKey,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSURL.getPromisedItemResourceValue:forKey:error:',
        iOS: (false, (8, 0, 0)),
        macOS: (false, (10, 10, 0)));
    return _objc_msgSend_1j9bhml(
        this.ref.pointer,
        _sel_getPromisedItemResourceValue_forKey_error_,
        value,
        forKey.ref.pointer,
        error);
  }

  /// promisedItemResourceValuesForKeys:error:
  objc.NSDictionary? promisedItemResourceValuesForKeys(objc.NSArray keys,
      {required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSURL.promisedItemResourceValuesForKeys:error:',
        iOS: (false, (8, 0, 0)),
        macOS: (false, (10, 10, 0)));
    final _ret = _objc_msgSend_1lhpu4m(this.ref.pointer,
        _sel_promisedItemResourceValuesForKeys_error_, keys.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// checkPromisedItemIsReachableAndReturnError:
  bool checkPromisedItemIsReachableAndReturnError(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal(
        'NSURL.checkPromisedItemIsReachableAndReturnError:',
        iOS: (false, (8, 0, 0)),
        macOS: (false, (10, 10, 0)));
    return _objc_msgSend_1dom33q(this.ref.pointer,
        _sel_checkPromisedItemIsReachableAndReturnError_, error);
  }
}

late final _sel_readableTypeIdentifiersForItemProvider =
    objc.registerName("readableTypeIdentifiersForItemProvider");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSArray_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSArray_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSArray_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSArray_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSArray_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_NSArray_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.NSArray Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSArray_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSArray_ffiVoid_CallExtension
    on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0) => objc.NSArray.castFromPointer(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_objectWithItemProviderData_typeIdentifier_error_ =
    objc.registerName("objectWithItemProviderData:typeIdentifier:error:");
final _objc_msgSend_1pnyuds = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
instancetype
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        instancetype Function(
                            ffi.Pointer<ffi.Void> arg0,
                            ffi.Pointer<objc.ObjCObject> arg1,
                            ffi.Pointer<objc.ObjCObject> arg2,
                            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>>()
                .asFunction<
                    instancetype Function(
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>()(
            arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
            _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrTrampoline)
        .cast();
instancetype
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) =>
        (objc.getBlockClosure(block) as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
            _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
              ffi.Pointer<ffi.Void>,
              objc.NSData,
              objc.NSString,
              ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Pointer<objc.ObjCObject>? Function(
                  ffi.Pointer<ffi.Void>,
                  objc.NSData,
                  objc.NSString,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
              ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>,
                      objc.NSData,
                      objc.NSString,
                      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
              objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>
      fromFunction(Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) =>
                      fn(arg0, objc.NSData.castFromPointer(arg1, retain: true, release: true), objc.NSString.castFromPointer(arg2, retain: true, release: true), arg3)?.ref.retainAndAutorelease() ?? ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>`.
extension ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
            ffi.Pointer<ffi.Void>,
            objc.NSData,
            objc.NSString,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSData arg1, objc.NSString arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) => ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>>()
              .asFunction<
                  instancetype Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>()
              (ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>>().asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3),
          retain: true,
          release: true);
}

late final _sel_writableTypeIdentifiersForItemProvider =
    objc.registerName("writableTypeIdentifiersForItemProvider");
late final _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_ =
    objc.registerName(
        "itemProviderVisibilityForRepresentationWithTypeIdentifier:");
final _objc_msgSend_16fy0up = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
int _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Long Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            int Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrTrampoline,
            0)
        .cast();
int _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as int Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureTrampoline,
            0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Long Function(ffi.Pointer<ffi.Void>,
                  objc.NSString)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
          objc.newPointerBlock(
              _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunction(
          objc.NSItemProviderRepresentationVisibility Function(
                  ffi.Pointer<ffi.Void>, objc.NSString)
              fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
          objc.newClosureBlock(
              _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true)).value,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  objc.NSItemProviderRepresentationVisibility call(
          ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>
      objc.NSItemProviderRepresentationVisibility.fromValue(ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Long Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer));
}

void _ObjCBlock_ffiVoid_NSData_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSData_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSData_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSData_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSData_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_NSError_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSData_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSData_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_NSError_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSData_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_NSError_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSData_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSData_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunction(
          void Function(objc.NSData?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSData_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0.address == 0
                      ? null
                      : objc.NSData.castFromPointer(arg0, retain: true, release: true),
                  arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
      listener(void Function(objc.NSData?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_NSError_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _FoundationFFI_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
      blocking(void Function(objc.NSData?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_NSError_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _FoundationFFI_wrapBlockingBlock_pfv6jd(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> {
  void call(objc.NSData? arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>)>()(ref.pointer,
      arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_ =
    objc.registerName(
        "loadDataWithTypeIdentifier:forItemProviderCompletionHandler:");
final _objc_msgSend_r0bo0s = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
              objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
                      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
              objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>> ptr) =>
          objc.ObjCBlock<
                  NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
                      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(
              objc.newPointerBlock(_ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>
      fromFunction(NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
                      fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true), ObjCBlock_ffiVoid_NSData_NSError.castFromPointer(arg2, retain: true, release: true))?.ref.retainAndAutorelease() ??
                      ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
extension ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_CallExtension
    on objc.ObjCBlock<
        NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
            objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)> {
  NSProgress? call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> arg2) =>
      ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCBlockImpl>)>()
                  (ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
                  .address ==
              0
          ? null
          : NSProgress.castFromPointer(
              ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>>().asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCBlockImpl>)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
              retain: true,
              release: true);
}

/// NSItemProvider
extension NSItemProvider on objc.NSURL {
  /// readableTypeIdentifiersForItemProvider
  static objc.NSArray getReadableTypeIdentifiersForItemProvider() {
    objc.checkOsVersionInternal('NSURL.readableTypeIdentifiersForItemProvider',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSURL, _sel_readableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// objectWithItemProviderData:typeIdentifier:error:
  static objc.NSURL? objectWithItemProviderData(objc.NSData data,
      {required objc.NSString typeIdentifier,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSURL.objectWithItemProviderData:typeIdentifier:error:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1pnyuds(
        _class_NSURL,
        _sel_objectWithItemProviderData_typeIdentifier_error_,
        data.ref.pointer,
        typeIdentifier.ref.pointer,
        error);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  static objc.NSArray getWritableTypeIdentifiersForItemProvider() {
    objc.checkOsVersionInternal('NSURL.writableTypeIdentifiersForItemProvider',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(
        _class_NSURL, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  objc.NSArray get writableTypeIdentifiersForItemProvider$1 {
    objc.checkOsVersionInternal('NSURL.writableTypeIdentifiersForItemProvider',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider)) {
      throw objc.UnimplementedOptionalMethodException(
          'NSURL', 'writableTypeIdentifiersForItemProvider');
    }
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static objc.NSItemProviderRepresentationVisibility
      itemProviderVisibilityForRepresentationWithTypeIdentifier(
          objc.NSString typeIdentifier) {
    objc.checkOsVersionInternal(
        'NSURL.itemProviderVisibilityForRepresentationWithTypeIdentifier:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(_class_NSURL,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSURL',
          'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    final _ret = _objc_msgSend_16fy0up(
        _class_NSURL,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        typeIdentifier.ref.pointer);
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  objc.NSItemProviderRepresentationVisibility
      itemProviderVisibilityForRepresentationWithTypeIdentifier$1(
          objc.NSString typeIdentifier) {
    objc.checkOsVersionInternal(
        'NSURL.itemProviderVisibilityForRepresentationWithTypeIdentifier:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    if (!objc.respondsToSelector(this.ref.pointer,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSURL',
          'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    final _ret = _objc_msgSend_16fy0up(
        this.ref.pointer,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        typeIdentifier.ref.pointer);
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  NSProgress? loadDataWithTypeIdentifier(objc.NSString typeIdentifier,
      {required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
          forItemProviderCompletionHandler}) {
    objc.checkOsVersionInternal(
        'NSURL.loadDataWithTypeIdentifier:forItemProviderCompletionHandler:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_r0bo0s(
        this.ref.pointer,
        _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
        typeIdentifier.ref.pointer,
        forItemProviderCompletionHandler.ref.pointer);
    return _ret.address == 0
        ? null
        : NSProgress.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_fileURLWithPathComponents_ =
    objc.registerName("fileURLWithPathComponents:");
late final _sel_pathComponents = objc.registerName("pathComponents");
late final _sel_lastPathComponent = objc.registerName("lastPathComponent");
late final _sel_pathExtension = objc.registerName("pathExtension");
late final _sel_URLByAppendingPathComponent_ =
    objc.registerName("URLByAppendingPathComponent:");
late final _sel_URLByAppendingPathComponent_isDirectory_ =
    objc.registerName("URLByAppendingPathComponent:isDirectory:");
final _objc_msgSend_17amj0z = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_URLByDeletingLastPathComponent =
    objc.registerName("URLByDeletingLastPathComponent");
late final _sel_URLByAppendingPathExtension_ =
    objc.registerName("URLByAppendingPathExtension:");
late final _sel_URLByDeletingPathExtension =
    objc.registerName("URLByDeletingPathExtension");
late final _sel_checkResourceIsReachableAndReturnError_ =
    objc.registerName("checkResourceIsReachableAndReturnError:");
late final _sel_URLByStandardizingPath =
    objc.registerName("URLByStandardizingPath");
late final _sel_URLByResolvingSymlinksInPath =
    objc.registerName("URLByResolvingSymlinksInPath");

/// NSURLPathUtilities
extension NSURLPathUtilities on objc.NSURL {
  /// fileURLWithPathComponents:
  static objc.NSURL? fileURLWithPathComponents(objc.NSArray components) {
    objc.checkOsVersionInternal('NSURL.fileURLWithPathComponents:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSURL, _sel_fileURLWithPathComponents_, components.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathComponents
  objc.NSArray? get pathComponents {
    objc.checkOsVersionInternal('NSURL.pathComponents',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_pathComponents);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// lastPathComponent
  objc.NSString? get lastPathComponent {
    objc.checkOsVersionInternal('NSURL.lastPathComponent',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_lastPathComponent);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathExtension
  objc.NSString? get pathExtension {
    objc.checkOsVersionInternal('NSURL.pathExtension',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_pathExtension);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLByAppendingPathComponent:
  objc.NSURL? URLByAppendingPathComponent(objc.NSString pathComponent) {
    objc.checkOsVersionInternal('NSURL.URLByAppendingPathComponent:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_URLByAppendingPathComponent_, pathComponent.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLByAppendingPathComponent:isDirectory:
  objc.NSURL? URLByAppendingPathComponent$1(objc.NSString pathComponent,
      {required bool isDirectory}) {
    objc.checkOsVersionInternal(
        'NSURL.URLByAppendingPathComponent:isDirectory:',
        iOS: (false, (5, 0, 0)),
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_17amj0z(
        this.ref.pointer,
        _sel_URLByAppendingPathComponent_isDirectory_,
        pathComponent.ref.pointer,
        isDirectory);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLByDeletingLastPathComponent
  objc.NSURL? get URLByDeletingLastPathComponent {
    objc.checkOsVersionInternal('NSURL.URLByDeletingLastPathComponent',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_URLByDeletingLastPathComponent);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLByAppendingPathExtension:
  objc.NSURL? URLByAppendingPathExtension(objc.NSString pathExtension$1) {
    objc.checkOsVersionInternal('NSURL.URLByAppendingPathExtension:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_URLByAppendingPathExtension_, pathExtension$1.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLByDeletingPathExtension
  objc.NSURL? get URLByDeletingPathExtension {
    objc.checkOsVersionInternal('NSURL.URLByDeletingPathExtension',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_URLByDeletingPathExtension);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// checkResourceIsReachableAndReturnError:
  bool checkResourceIsReachableAndReturnError(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal('NSURL.checkResourceIsReachableAndReturnError:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    return _objc_msgSend_1dom33q(
        this.ref.pointer, _sel_checkResourceIsReachableAndReturnError_, error);
  }

  /// URLByStandardizingPath
  objc.NSURL? get URLByStandardizingPath {
    objc.checkOsVersionInternal('NSURL.URLByStandardizingPath',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_URLByStandardizingPath);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLByResolvingSymlinksInPath
  objc.NSURL? get URLByResolvingSymlinksInPath {
    objc.checkOsVersionInternal('NSURL.URLByResolvingSymlinksInPath',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_URLByResolvingSymlinksInPath);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_resourceDataUsingCache_ =
    objc.registerName("resourceDataUsingCache:");
final _objc_msgSend_1t6aok9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_loadResourceDataNotifyingClient_usingCache_ =
    objc.registerName("loadResourceDataNotifyingClient:usingCache:");
final _objc_msgSend_6p7ndb = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_propertyForKey_ = objc.registerName("propertyForKey:");
late final _sel_setResourceData_ = objc.registerName("setResourceData:");
late final _sel_setProperty_forKey_ = objc.registerName("setProperty:forKey:");
final _objc_msgSend_1lsax7n = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_URLHandleUsingCache_ =
    objc.registerName("URLHandleUsingCache:");

/// NSURLLoading
extension NSURLLoading on objc.NSURL {
  /// resourceDataUsingCache:
  objc.NSData? resourceDataUsingCache(bool shouldUseCache) {
    objc.checkOsVersionInternal('NSURL.resourceDataUsingCache:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1t6aok9(
        this.ref.pointer, _sel_resourceDataUsingCache_, shouldUseCache);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// loadResourceDataNotifyingClient:usingCache:
  void loadResourceDataNotifyingClient(objc.ObjCObjectBase client,
      {required bool usingCache}) {
    objc.checkOsVersionInternal(
        'NSURL.loadResourceDataNotifyingClient:usingCache:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 0, 0)));
    _objc_msgSend_6p7ndb(
        this.ref.pointer,
        _sel_loadResourceDataNotifyingClient_usingCache_,
        client.ref.pointer,
        usingCache);
  }

  /// propertyForKey:
  objc.ObjCObjectBase? propertyForKey(objc.NSString propertyKey) {
    objc.checkOsVersionInternal('NSURL.propertyForKey:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_propertyForKey_, propertyKey.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setResourceData:
  bool setResourceData(objc.NSData data) {
    objc.checkOsVersionInternal('NSURL.setResourceData:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_setResourceData_, data.ref.pointer);
  }

  /// setProperty:forKey:
  bool setProperty(objc.ObjCObjectBase property,
      {required objc.NSString forKey}) {
    objc.checkOsVersionInternal('NSURL.setProperty:forKey:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1lsax7n(this.ref.pointer, _sel_setProperty_forKey_,
        property.ref.pointer, forKey.ref.pointer);
  }

  /// URLHandleUsingCache:
  objc.NSURLHandle? URLHandleUsingCache(bool shouldUseCache) {
    objc.checkOsVersionInternal('NSURL.URLHandleUsingCache:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1t6aok9(
        this.ref.pointer, _sel_URLHandleUsingCache_, shouldUseCache);
    return _ret.address == 0
        ? null
        : objc.NSURLHandle.castFromPointer(_ret, retain: true, release: true);
  }
}

enum NSVolumeEnumerationOptions {
  NSVolumeEnumerationSkipHiddenVolumes(2),
  NSVolumeEnumerationProduceFileReferenceURLs(4);

  final int value;
  const NSVolumeEnumerationOptions(this.value);

  static NSVolumeEnumerationOptions fromValue(int value) => switch (value) {
        2 => NSVolumeEnumerationSkipHiddenVolumes,
        4 => NSVolumeEnumerationProduceFileReferenceURLs,
        _ => throw ArgumentError(
            'Unknown value for NSVolumeEnumerationOptions: $value'),
      };
}

enum NSDirectoryEnumerationOptions {
  NSDirectoryEnumerationSkipsSubdirectoryDescendants(1),
  NSDirectoryEnumerationSkipsPackageDescendants(2),
  NSDirectoryEnumerationSkipsHiddenFiles(4),
  NSDirectoryEnumerationIncludesDirectoriesPostOrder(8),
  NSDirectoryEnumerationProducesRelativePathURLs(16);

  final int value;
  const NSDirectoryEnumerationOptions(this.value);

  static NSDirectoryEnumerationOptions fromValue(int value) => switch (value) {
        1 => NSDirectoryEnumerationSkipsSubdirectoryDescendants,
        2 => NSDirectoryEnumerationSkipsPackageDescendants,
        4 => NSDirectoryEnumerationSkipsHiddenFiles,
        8 => NSDirectoryEnumerationIncludesDirectoriesPostOrder,
        16 => NSDirectoryEnumerationProducesRelativePathURLs,
        _ => throw ArgumentError(
            'Unknown value for NSDirectoryEnumerationOptions: $value'),
      };
}

enum NSFileManagerItemReplacementOptions {
  NSFileManagerItemReplacementUsingNewMetadataOnly(1),
  NSFileManagerItemReplacementWithoutDeletingBackupItem(2);

  final int value;
  const NSFileManagerItemReplacementOptions(this.value);

  static NSFileManagerItemReplacementOptions fromValue(int value) =>
      switch (value) {
        1 => NSFileManagerItemReplacementUsingNewMetadataOnly,
        2 => NSFileManagerItemReplacementWithoutDeletingBackupItem,
        _ => throw ArgumentError(
            'Unknown value for NSFileManagerItemReplacementOptions: $value'),
      };
}

enum NSURLRelationship {
  NSURLRelationshipContains(0),
  NSURLRelationshipSame(1),
  NSURLRelationshipOther(2);

  final int value;
  const NSURLRelationship(this.value);

  static NSURLRelationship fromValue(int value) => switch (value) {
        0 => NSURLRelationshipContains,
        1 => NSURLRelationshipSame,
        2 => NSURLRelationshipOther,
        _ => throw ArgumentError('Unknown value for NSURLRelationship: $value'),
      };
}

enum NSFileManagerUnmountOptions {
  NSFileManagerUnmountAllPartitionsAndEjectDisk(1),
  NSFileManagerUnmountWithoutUI(2);

  final int value;
  const NSFileManagerUnmountOptions(this.value);

  static NSFileManagerUnmountOptions fromValue(int value) => switch (value) {
        1 => NSFileManagerUnmountAllPartitionsAndEjectDisk,
        2 => NSFileManagerUnmountWithoutUI,
        _ => throw ArgumentError(
            'Unknown value for NSFileManagerUnmountOptions: $value'),
      };
}

late final _class_NSFileManager = objc.getClass("NSFileManager");
late final _sel_homeDirectoryForCurrentUser =
    objc.registerName("homeDirectoryForCurrentUser");
late final _sel_temporaryDirectory = objc.registerName("temporaryDirectory");
late final _sel_homeDirectoryForUser_ =
    objc.registerName("homeDirectoryForUser:");

/// NSUserInformation
extension NSUserInformation on NSFileManager {
  /// homeDirectoryForCurrentUser
  objc.NSURL get homeDirectoryForCurrentUser {
    objc.checkOsVersionInternal('NSFileManager.homeDirectoryForCurrentUser',
        iOS: (true, null), macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_homeDirectoryForCurrentUser);
    return objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// temporaryDirectory
  objc.NSURL get temporaryDirectory {
    objc.checkOsVersionInternal('NSFileManager.temporaryDirectory',
        iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_temporaryDirectory);
    return objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// homeDirectoryForUser:
  objc.NSURL? homeDirectoryForUser(objc.NSString userName) {
    objc.checkOsVersionInternal('NSFileManager.homeDirectoryForUser:',
        iOS: (true, null), macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_homeDirectoryForUser_, userName.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_defaultManager = objc.registerName("defaultManager");
late final _sel_mountedVolumeURLsIncludingResourceValuesForKeys_options_ = objc
    .registerName("mountedVolumeURLsIncludingResourceValuesForKeys:options:");
final _objc_msgSend_74a1at = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
void _ObjCBlock_ffiVoid_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSError_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSError_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSError_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunction(
          void Function(objc.NSError?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                  ? null
                  : objc.NSError.castFromPointer(arg0,
                      retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> listener(
      void Function(objc.NSError?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSError_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSError.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _FoundationFFI_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> blocking(
      void Function(objc.NSError?) fn,
      {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSError_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSError.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSError_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSError.castFromPointer(arg0, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _FoundationFFI_wrapBlockingBlock_xtuoz7(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSError?)> {
  void call(objc.NSError? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_unmountVolumeAtURL_options_completionHandler_ =
    objc.registerName("unmountVolumeAtURL:options:completionHandler:");
final _objc_msgSend_5yys50 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_contentsOfDirectoryAtURL_includingPropertiesForKeys_options_error_ =
    objc.registerName(
        "contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:");
final _objc_msgSend_1axzbp9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_URLsForDirectory_inDomains_ =
    objc.registerName("URLsForDirectory:inDomains:");
final _objc_msgSend_12kqj12 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, int)>();
late final _sel_URLForDirectory_inDomain_appropriateForURL_create_error_ = objc
    .registerName("URLForDirectory:inDomain:appropriateForURL:create:error:");
final _objc_msgSend_1crui9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            int,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_getRelationship_ofDirectoryAtURL_toItemAtURL_error_ =
    objc.registerName("getRelationship:ofDirectoryAtURL:toItemAtURL:error:");
final _objc_msgSend_gvucxc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Long>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Long>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_getRelationship_ofDirectory_inDomain_toItemAtURL_error_ = objc
    .registerName("getRelationship:ofDirectory:inDomain:toItemAtURL:error:");
final _objc_msgSend_n2wx31 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Long>,
                ffi.UnsignedLong,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Long>,
            int,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_createDirectoryAtURL_withIntermediateDirectories_attributes_error_ =
    objc.registerName(
        "createDirectoryAtURL:withIntermediateDirectories:attributes:error:");
final _objc_msgSend_k3avh6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_createSymbolicLinkAtURL_withDestinationURL_error_ =
    objc.registerName("createSymbolicLinkAtURL:withDestinationURL:error:");
final _objc_msgSend_6z4k82 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();

/// WARNING: NSFileManagerDelegate is a stub. To generate bindings for this class, include
/// NSFileManagerDelegate in your config's objc-protocols list.
///
/// NSFileManagerDelegate
interface class NSFileManagerDelegate extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  NSFileManagerDelegate._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSFileManagerDelegate] that points to the same underlying object as [other].
  NSFileManagerDelegate.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSFileManagerDelegate] that wraps the given raw object pointer.
  NSFileManagerDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_delegate = objc.registerName("delegate");
late final _sel_setDelegate_ = objc.registerName("setDelegate:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setAttributes_ofItemAtPath_error_ =
    objc.registerName("setAttributes:ofItemAtPath:error:");
late final _sel_createDirectoryAtPath_withIntermediateDirectories_attributes_error_ =
    objc.registerName(
        "createDirectoryAtPath:withIntermediateDirectories:attributes:error:");
late final _sel_contentsOfDirectoryAtPath_error_ =
    objc.registerName("contentsOfDirectoryAtPath:error:");
late final _sel_subpathsOfDirectoryAtPath_error_ =
    objc.registerName("subpathsOfDirectoryAtPath:error:");
late final _sel_attributesOfItemAtPath_error_ =
    objc.registerName("attributesOfItemAtPath:error:");
late final _sel_attributesOfFileSystemForPath_error_ =
    objc.registerName("attributesOfFileSystemForPath:error:");
late final _sel_createSymbolicLinkAtPath_withDestinationPath_error_ =
    objc.registerName("createSymbolicLinkAtPath:withDestinationPath:error:");
late final _sel_destinationOfSymbolicLinkAtPath_error_ =
    objc.registerName("destinationOfSymbolicLinkAtPath:error:");
late final _sel_copyItemAtPath_toPath_error_ =
    objc.registerName("copyItemAtPath:toPath:error:");
late final _sel_moveItemAtPath_toPath_error_ =
    objc.registerName("moveItemAtPath:toPath:error:");
late final _sel_linkItemAtPath_toPath_error_ =
    objc.registerName("linkItemAtPath:toPath:error:");
late final _sel_removeItemAtPath_error_ =
    objc.registerName("removeItemAtPath:error:");
final _objc_msgSend_l9p60w = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_copyItemAtURL_toURL_error_ =
    objc.registerName("copyItemAtURL:toURL:error:");
late final _sel_moveItemAtURL_toURL_error_ =
    objc.registerName("moveItemAtURL:toURL:error:");
late final _sel_linkItemAtURL_toURL_error_ =
    objc.registerName("linkItemAtURL:toURL:error:");
late final _sel_removeItemAtURL_error_ =
    objc.registerName("removeItemAtURL:error:");
late final _sel_trashItemAtURL_resultingItemURL_error_ =
    objc.registerName("trashItemAtURL:resultingItemURL:error:");
final _objc_msgSend_tyshih = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_fileAttributesAtPath_traverseLink_ =
    objc.registerName("fileAttributesAtPath:traverseLink:");
late final _sel_changeFileAttributes_atPath_ =
    objc.registerName("changeFileAttributes:atPath:");
late final _sel_directoryContentsAtPath_ =
    objc.registerName("directoryContentsAtPath:");
late final _sel_fileSystemAttributesAtPath_ =
    objc.registerName("fileSystemAttributesAtPath:");
late final _sel_pathContentOfSymbolicLinkAtPath_ =
    objc.registerName("pathContentOfSymbolicLinkAtPath:");
late final _sel_createSymbolicLinkAtPath_pathContent_ =
    objc.registerName("createSymbolicLinkAtPath:pathContent:");
late final _sel_createDirectoryAtPath_attributes_ =
    objc.registerName("createDirectoryAtPath:attributes:");
late final _sel_linkPath_toPath_handler_ =
    objc.registerName("linkPath:toPath:handler:");
final _objc_msgSend_gtxojt = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_copyPath_toPath_handler_ =
    objc.registerName("copyPath:toPath:handler:");
late final _sel_movePath_toPath_handler_ =
    objc.registerName("movePath:toPath:handler:");
late final _sel_removeFileAtPath_handler_ =
    objc.registerName("removeFileAtPath:handler:");
late final _sel_currentDirectoryPath =
    objc.registerName("currentDirectoryPath");
late final _sel_changeCurrentDirectoryPath_ =
    objc.registerName("changeCurrentDirectoryPath:");
late final _sel_fileExistsAtPath_ = objc.registerName("fileExistsAtPath:");
late final _sel_fileExistsAtPath_isDirectory_ =
    objc.registerName("fileExistsAtPath:isDirectory:");
final _objc_msgSend_1fuj22f = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>)>();
late final _sel_isReadableFileAtPath_ =
    objc.registerName("isReadableFileAtPath:");
late final _sel_isWritableFileAtPath_ =
    objc.registerName("isWritableFileAtPath:");
late final _sel_isExecutableFileAtPath_ =
    objc.registerName("isExecutableFileAtPath:");
late final _sel_isDeletableFileAtPath_ =
    objc.registerName("isDeletableFileAtPath:");
late final _sel_contentsEqualAtPath_andPath_ =
    objc.registerName("contentsEqualAtPath:andPath:");
late final _sel_displayNameAtPath_ = objc.registerName("displayNameAtPath:");
late final _sel_componentsToDisplayForPath_ =
    objc.registerName("componentsToDisplayForPath:");

/// WARNING: NSDirectoryEnumerator is a stub. To generate bindings for this class, include
/// NSDirectoryEnumerator in your config's objc-interfaces list.
///
/// NSDirectoryEnumerator
class NSDirectoryEnumerator extends objc.NSEnumerator {
  NSDirectoryEnumerator._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSDirectoryEnumerator] that points to the same underlying object as [other].
  NSDirectoryEnumerator.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSDirectoryEnumerator] that wraps the given raw object pointer.
  NSDirectoryEnumerator.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_enumeratorAtPath_ = objc.registerName("enumeratorAtPath:");
bool _ObjCBlock_bool_NSURL_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_NSURL_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_NSURL_NSError_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_NSURL_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_NSURL_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_NSURL_NSError_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(objc.NSURL, objc.NSError)>`.
abstract final class ObjCBlock_bool_NSURL_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(objc.NSURL, objc.NSError)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Bool Function(objc.NSURL, objc.NSError)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(objc.NSURL, objc.NSError)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Bool Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Bool Function(objc.NSURL, objc.NSError)>(
          objc.newPointerBlock(_ObjCBlock_bool_NSURL_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(objc.NSURL, objc.NSError)> fromFunction(
          bool Function(objc.NSURL, objc.NSError) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(objc.NSURL, objc.NSError)>(
          objc.newClosureBlock(
              _ObjCBlock_bool_NSURL_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  objc.NSURL.castFromPointer(arg0, retain: true, release: true),
                  objc.NSError.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(objc.NSURL, objc.NSError)>`.
extension ObjCBlock_bool_NSURL_NSError_CallExtension
    on objc.ObjCBlock<ffi.Bool Function(objc.NSURL, objc.NSError)> {
  bool call(objc.NSURL arg0, objc.NSError arg1) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              bool Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

late final _sel_enumeratorAtURL_includingPropertiesForKeys_options_errorHandler_ =
    objc.registerName(
        "enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:");
final _objc_msgSend_fx4ekv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_subpathsAtPath_ = objc.registerName("subpathsAtPath:");
late final _sel_contentsAtPath_ = objc.registerName("contentsAtPath:");
late final _sel_createFileAtPath_contents_attributes_ =
    objc.registerName("createFileAtPath:contents:attributes:");
late final _sel_fileSystemRepresentationWithPath_ =
    objc.registerName("fileSystemRepresentationWithPath:");
final _objc_msgSend_uffm97 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<ffi.Char> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<ffi.Char> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_stringWithFileSystemRepresentation_length_ =
    objc.registerName("stringWithFileSystemRepresentation:length:");
final _objc_msgSend_erqryg = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Char>,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>, int)>();
late final _sel_replaceItemAtURL_withItemAtURL_backupItemName_options_resultingItemURL_error_ =
    objc.registerName(
        "replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:");
final _objc_msgSend_4w6uxs = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_setUbiquitous_itemAtURL_destinationURL_error_ =
    objc.registerName("setUbiquitous:itemAtURL:destinationURL:error:");
final _objc_msgSend_70y61a = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            bool,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_isUbiquitousItemAtURL_ =
    objc.registerName("isUbiquitousItemAtURL:");
late final _sel_startDownloadingUbiquitousItemAtURL_error_ =
    objc.registerName("startDownloadingUbiquitousItemAtURL:error:");
late final _sel_evictUbiquitousItemAtURL_error_ =
    objc.registerName("evictUbiquitousItemAtURL:error:");
late final _sel_URLForUbiquityContainerIdentifier_ =
    objc.registerName("URLForUbiquityContainerIdentifier:");
late final _sel_URLForPublishingUbiquitousItemAtURL_expirationDate_error_ = objc
    .registerName("URLForPublishingUbiquitousItemAtURL:expirationDate:error:");
final _objc_msgSend_b99g2z = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_ubiquityIdentityToken =
    objc.registerName("ubiquityIdentityToken");
void _ObjCBlock_ffiVoid_NSDictionary_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSDictionary_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSDictionary_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSDictionary_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSDictionary_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSDictionary_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSDictionary_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSDictionary_NSError_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSDictionary_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSDictionary_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSDictionary_NSError_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSDictionary_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSDictionary_NSError_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSDictionary_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSDictionary_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSDictionary_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)> fromFunction(
          void Function(objc.NSDictionary?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSDictionary_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0.address == 0
                      ? null
                      : objc.NSDictionary.castFromPointer(arg0, retain: true, release: true),
                  arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)>
      listener(void Function(objc.NSDictionary?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSDictionary_NSError_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSDictionary.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _FoundationFFI_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)>
      blocking(void Function(objc.NSDictionary?, objc.NSError?) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSDictionary_NSError_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSDictionary.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSDictionary_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSDictionary.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _FoundationFFI_wrapBlockingBlock_pfv6jd(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSDictionary_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)> {
  void call(objc.NSDictionary? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer,
          arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_getFileProviderServicesForItemAtURL_completionHandler_ =
    objc.registerName("getFileProviderServicesForItemAtURL:completionHandler:");
final _objc_msgSend_o762yo = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_containerURLForSecurityApplicationGroupIdentifier_ =
    objc.registerName("containerURLForSecurityApplicationGroupIdentifier:");

/// NSFileManager
class NSFileManager extends objc.NSObject {
  NSFileManager._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSFileManager] that points to the same underlying object as [other].
  NSFileManager.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSFileManager] that wraps the given raw object pointer.
  NSFileManager.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSFileManager].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSFileManager);
  }

  /// defaultManager
  static NSFileManager getDefaultManager() {
    final _ret =
        _objc_msgSend_151sglz(_class_NSFileManager, _sel_defaultManager);
    return NSFileManager.castFromPointer(_ret, retain: true, release: true);
  }

  /// mountedVolumeURLsIncludingResourceValuesForKeys:options:
  objc.NSArray? mountedVolumeURLsIncludingResourceValuesForKeys(
      objc.NSArray? propertyKeys,
      {required NSVolumeEnumerationOptions options}) {
    objc.checkOsVersionInternal(
        'NSFileManager.mountedVolumeURLsIncludingResourceValuesForKeys:options:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_74a1at(
        this.ref.pointer,
        _sel_mountedVolumeURLsIncludingResourceValuesForKeys_options_,
        propertyKeys?.ref.pointer ?? ffi.nullptr,
        options.value);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// unmountVolumeAtURL:options:completionHandler:
  void unmountVolumeAtURL(objc.NSURL url,
      {required NSFileManagerUnmountOptions options,
      required objc.ObjCBlock<ffi.Void Function(objc.NSError?)>
          completionHandler}) {
    objc.checkOsVersionInternal(
        'NSFileManager.unmountVolumeAtURL:options:completionHandler:',
        iOS: (true, null),
        macOS: (false, (10, 11, 0)));
    _objc_msgSend_5yys50(
        this.ref.pointer,
        _sel_unmountVolumeAtURL_options_completionHandler_,
        url.ref.pointer,
        options.value,
        completionHandler.ref.pointer);
  }

  /// contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:
  objc.NSArray? contentsOfDirectoryAtURL(objc.NSURL url,
      {objc.NSArray? includingPropertiesForKeys,
      required NSDirectoryEnumerationOptions options,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_1axzbp9(
        this.ref.pointer,
        _sel_contentsOfDirectoryAtURL_includingPropertiesForKeys_options_error_,
        url.ref.pointer,
        includingPropertiesForKeys?.ref.pointer ?? ffi.nullptr,
        options.value,
        error);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLsForDirectory:inDomains:
  objc.NSArray URLsForDirectory(NSSearchPathDirectory directory,
      {required NSSearchPathDomainMask inDomains}) {
    objc.checkOsVersionInternal('NSFileManager.URLsForDirectory:inDomains:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_12kqj12(this.ref.pointer,
        _sel_URLsForDirectory_inDomains_, directory.value, inDomains.value);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLForDirectory:inDomain:appropriateForURL:create:error:
  objc.NSURL? URLForDirectory(NSSearchPathDirectory directory,
      {required NSSearchPathDomainMask inDomain,
      objc.NSURL? appropriateForURL,
      required bool create,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.URLForDirectory:inDomain:appropriateForURL:create:error:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_1crui9(
        this.ref.pointer,
        _sel_URLForDirectory_inDomain_appropriateForURL_create_error_,
        directory.value,
        inDomain.value,
        appropriateForURL?.ref.pointer ?? ffi.nullptr,
        create,
        error);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// getRelationship:ofDirectoryAtURL:toItemAtURL:error:
  bool getRelationship(ffi.Pointer<ffi.Long> outRelationship,
      {required objc.NSURL ofDirectoryAtURL,
      required objc.NSURL toItemAtURL,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.getRelationship:ofDirectoryAtURL:toItemAtURL:error:',
        iOS: (false, (8, 0, 0)),
        macOS: (false, (10, 10, 0)));
    return _objc_msgSend_gvucxc(
        this.ref.pointer,
        _sel_getRelationship_ofDirectoryAtURL_toItemAtURL_error_,
        outRelationship,
        ofDirectoryAtURL.ref.pointer,
        toItemAtURL.ref.pointer,
        error);
  }

  /// getRelationship:ofDirectory:inDomain:toItemAtURL:error:
  bool getRelationship$1(ffi.Pointer<ffi.Long> outRelationship,
      {required NSSearchPathDirectory ofDirectory,
      required NSSearchPathDomainMask inDomain,
      required objc.NSURL toItemAtURL,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.getRelationship:ofDirectory:inDomain:toItemAtURL:error:',
        iOS: (false, (8, 0, 0)),
        macOS: (false, (10, 10, 0)));
    return _objc_msgSend_n2wx31(
        this.ref.pointer,
        _sel_getRelationship_ofDirectory_inDomain_toItemAtURL_error_,
        outRelationship,
        ofDirectory.value,
        inDomain.value,
        toItemAtURL.ref.pointer,
        error);
  }

  /// createDirectoryAtURL:withIntermediateDirectories:attributes:error:
  bool createDirectoryAtURL(objc.NSURL url,
      {required bool withIntermediateDirectories,
      objc.NSDictionary? attributes,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.createDirectoryAtURL:withIntermediateDirectories:attributes:error:',
        iOS: (false, (5, 0, 0)),
        macOS: (false, (10, 7, 0)));
    return _objc_msgSend_k3avh6(
        this.ref.pointer,
        _sel_createDirectoryAtURL_withIntermediateDirectories_attributes_error_,
        url.ref.pointer,
        withIntermediateDirectories,
        attributes?.ref.pointer ?? ffi.nullptr,
        error);
  }

  /// createSymbolicLinkAtURL:withDestinationURL:error:
  bool createSymbolicLinkAtURL(objc.NSURL url,
      {required objc.NSURL withDestinationURL,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.createSymbolicLinkAtURL:withDestinationURL:error:',
        iOS: (false, (5, 0, 0)),
        macOS: (false, (10, 7, 0)));
    return _objc_msgSend_6z4k82(
        this.ref.pointer,
        _sel_createSymbolicLinkAtURL_withDestinationURL_error_,
        url.ref.pointer,
        withDestinationURL.ref.pointer,
        error);
  }

  /// delegate
  NSFileManagerDelegate? get delegate {
    objc.checkOsVersionInternal('NSFileManager.delegate',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : NSFileManagerDelegate.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// setDelegate:
  set delegate(NSFileManagerDelegate? value) {
    objc.checkOsVersionInternal('NSFileManager.setDelegate:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setAttributes:ofItemAtPath:error:
  bool setAttributes(objc.NSDictionary attributes,
      {required objc.NSString ofItemAtPath,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.setAttributes:ofItemAtPath:error:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 5, 0)));
    return _objc_msgSend_6z4k82(
        this.ref.pointer,
        _sel_setAttributes_ofItemAtPath_error_,
        attributes.ref.pointer,
        ofItemAtPath.ref.pointer,
        error);
  }

  /// createDirectoryAtPath:withIntermediateDirectories:attributes:error:
  bool createDirectoryAtPath(objc.NSString path,
      {required bool withIntermediateDirectories,
      objc.NSDictionary? attributes,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.createDirectoryAtPath:withIntermediateDirectories:attributes:error:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 5, 0)));
    return _objc_msgSend_k3avh6(
        this.ref.pointer,
        _sel_createDirectoryAtPath_withIntermediateDirectories_attributes_error_,
        path.ref.pointer,
        withIntermediateDirectories,
        attributes?.ref.pointer ?? ffi.nullptr,
        error);
  }

  /// contentsOfDirectoryAtPath:error:
  objc.NSArray? contentsOfDirectoryAtPath(objc.NSString path,
      {required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.contentsOfDirectoryAtPath:error:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_1lhpu4m(this.ref.pointer,
        _sel_contentsOfDirectoryAtPath_error_, path.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// subpathsOfDirectoryAtPath:error:
  objc.NSArray? subpathsOfDirectoryAtPath(objc.NSString path,
      {required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.subpathsOfDirectoryAtPath:error:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_1lhpu4m(this.ref.pointer,
        _sel_subpathsOfDirectoryAtPath_error_, path.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// attributesOfItemAtPath:error:
  objc.NSDictionary? attributesOfItemAtPath(objc.NSString path,
      {required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal('NSFileManager.attributesOfItemAtPath:error:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_1lhpu4m(this.ref.pointer,
        _sel_attributesOfItemAtPath_error_, path.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// attributesOfFileSystemForPath:error:
  objc.NSDictionary? attributesOfFileSystemForPath(objc.NSString path,
      {required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.attributesOfFileSystemForPath:error:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_1lhpu4m(this.ref.pointer,
        _sel_attributesOfFileSystemForPath_error_, path.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// createSymbolicLinkAtPath:withDestinationPath:error:
  bool createSymbolicLinkAtPath(objc.NSString path,
      {required objc.NSString withDestinationPath,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.createSymbolicLinkAtPath:withDestinationPath:error:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 5, 0)));
    return _objc_msgSend_6z4k82(
        this.ref.pointer,
        _sel_createSymbolicLinkAtPath_withDestinationPath_error_,
        path.ref.pointer,
        withDestinationPath.ref.pointer,
        error);
  }

  /// destinationOfSymbolicLinkAtPath:error:
  objc.NSString? destinationOfSymbolicLinkAtPath(objc.NSString path,
      {required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.destinationOfSymbolicLinkAtPath:error:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_1lhpu4m(this.ref.pointer,
        _sel_destinationOfSymbolicLinkAtPath_error_, path.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// copyItemAtPath:toPath:error:
  bool copyItemAtPath(objc.NSString srcPath,
      {required objc.NSString toPath,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal('NSFileManager.copyItemAtPath:toPath:error:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
    return _objc_msgSend_6z4k82(
        this.ref.pointer,
        _sel_copyItemAtPath_toPath_error_,
        srcPath.ref.pointer,
        toPath.ref.pointer,
        error);
  }

  /// moveItemAtPath:toPath:error:
  bool moveItemAtPath(objc.NSString srcPath,
      {required objc.NSString toPath,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal('NSFileManager.moveItemAtPath:toPath:error:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
    return _objc_msgSend_6z4k82(
        this.ref.pointer,
        _sel_moveItemAtPath_toPath_error_,
        srcPath.ref.pointer,
        toPath.ref.pointer,
        error);
  }

  /// linkItemAtPath:toPath:error:
  bool linkItemAtPath(objc.NSString srcPath,
      {required objc.NSString toPath,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal('NSFileManager.linkItemAtPath:toPath:error:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
    return _objc_msgSend_6z4k82(
        this.ref.pointer,
        _sel_linkItemAtPath_toPath_error_,
        srcPath.ref.pointer,
        toPath.ref.pointer,
        error);
  }

  /// removeItemAtPath:error:
  bool removeItemAtPath(objc.NSString path,
      {required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal('NSFileManager.removeItemAtPath:error:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
    return _objc_msgSend_l9p60w(this.ref.pointer, _sel_removeItemAtPath_error_,
        path.ref.pointer, error);
  }

  /// copyItemAtURL:toURL:error:
  bool copyItemAtURL(objc.NSURL srcURL,
      {required objc.NSURL toURL,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal('NSFileManager.copyItemAtURL:toURL:error:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    return _objc_msgSend_6z4k82(
        this.ref.pointer,
        _sel_copyItemAtURL_toURL_error_,
        srcURL.ref.pointer,
        toURL.ref.pointer,
        error);
  }

  /// moveItemAtURL:toURL:error:
  bool moveItemAtURL(objc.NSURL srcURL,
      {required objc.NSURL toURL,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal('NSFileManager.moveItemAtURL:toURL:error:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    return _objc_msgSend_6z4k82(
        this.ref.pointer,
        _sel_moveItemAtURL_toURL_error_,
        srcURL.ref.pointer,
        toURL.ref.pointer,
        error);
  }

  /// linkItemAtURL:toURL:error:
  bool linkItemAtURL(objc.NSURL srcURL,
      {required objc.NSURL toURL,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal('NSFileManager.linkItemAtURL:toURL:error:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    return _objc_msgSend_6z4k82(
        this.ref.pointer,
        _sel_linkItemAtURL_toURL_error_,
        srcURL.ref.pointer,
        toURL.ref.pointer,
        error);
  }

  /// removeItemAtURL:error:
  bool removeItemAtURL(objc.NSURL URL,
      {required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal('NSFileManager.removeItemAtURL:error:',
        iOS: (false, (4, 0, 0)), macOS: (false, (10, 6, 0)));
    return _objc_msgSend_l9p60w(
        this.ref.pointer, _sel_removeItemAtURL_error_, URL.ref.pointer, error);
  }

  /// trashItemAtURL:resultingItemURL:error:
  bool trashItemAtURL(objc.NSURL url,
      {required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> resultingItemURL,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.trashItemAtURL:resultingItemURL:error:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 8, 0)));
    return _objc_msgSend_tyshih(
        this.ref.pointer,
        _sel_trashItemAtURL_resultingItemURL_error_,
        url.ref.pointer,
        resultingItemURL,
        error);
  }

  /// fileAttributesAtPath:traverseLink:
  objc.NSDictionary? fileAttributesAtPath(objc.NSString path,
      {required bool traverseLink}) {
    objc.checkOsVersionInternal(
        'NSFileManager.fileAttributesAtPath:traverseLink:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_17amj0z(
        this.ref.pointer,
        _sel_fileAttributesAtPath_traverseLink_,
        path.ref.pointer,
        traverseLink);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// changeFileAttributes:atPath:
  bool changeFileAttributes(objc.NSDictionary attributes,
      {required objc.NSString atPath}) {
    objc.checkOsVersionInternal('NSFileManager.changeFileAttributes:atPath:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1lsax7n(
        this.ref.pointer,
        _sel_changeFileAttributes_atPath_,
        attributes.ref.pointer,
        atPath.ref.pointer);
  }

  /// directoryContentsAtPath:
  objc.NSArray? directoryContentsAtPath(objc.NSString path) {
    objc.checkOsVersionInternal('NSFileManager.directoryContentsAtPath:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_directoryContentsAtPath_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// fileSystemAttributesAtPath:
  objc.NSDictionary? fileSystemAttributesAtPath(objc.NSString path) {
    objc.checkOsVersionInternal('NSFileManager.fileSystemAttributesAtPath:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_fileSystemAttributesAtPath_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathContentOfSymbolicLinkAtPath:
  objc.NSString? pathContentOfSymbolicLinkAtPath(objc.NSString path) {
    objc.checkOsVersionInternal(
        'NSFileManager.pathContentOfSymbolicLinkAtPath:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_pathContentOfSymbolicLinkAtPath_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// createSymbolicLinkAtPath:pathContent:
  bool createSymbolicLinkAtPath$1(objc.NSString path,
      {required objc.NSString pathContent}) {
    objc.checkOsVersionInternal(
        'NSFileManager.createSymbolicLinkAtPath:pathContent:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1lsax7n(
        this.ref.pointer,
        _sel_createSymbolicLinkAtPath_pathContent_,
        path.ref.pointer,
        pathContent.ref.pointer);
  }

  /// createDirectoryAtPath:attributes:
  bool createDirectoryAtPath$1(objc.NSString path,
      {required objc.NSDictionary attributes}) {
    objc.checkOsVersionInternal(
        'NSFileManager.createDirectoryAtPath:attributes:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1lsax7n(
        this.ref.pointer,
        _sel_createDirectoryAtPath_attributes_,
        path.ref.pointer,
        attributes.ref.pointer);
  }

  /// linkPath:toPath:handler:
  bool linkPath(objc.NSString src,
      {required objc.NSString toPath, objc.ObjCObjectBase? handler}) {
    objc.checkOsVersionInternal('NSFileManager.linkPath:toPath:handler:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_gtxojt(
        this.ref.pointer,
        _sel_linkPath_toPath_handler_,
        src.ref.pointer,
        toPath.ref.pointer,
        handler?.ref.pointer ?? ffi.nullptr);
  }

  /// copyPath:toPath:handler:
  bool copyPath(objc.NSString src,
      {required objc.NSString toPath, objc.ObjCObjectBase? handler}) {
    objc.checkOsVersionInternal('NSFileManager.copyPath:toPath:handler:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_gtxojt(
        this.ref.pointer,
        _sel_copyPath_toPath_handler_,
        src.ref.pointer,
        toPath.ref.pointer,
        handler?.ref.pointer ?? ffi.nullptr);
  }

  /// movePath:toPath:handler:
  bool movePath(objc.NSString src,
      {required objc.NSString toPath, objc.ObjCObjectBase? handler}) {
    objc.checkOsVersionInternal('NSFileManager.movePath:toPath:handler:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_gtxojt(
        this.ref.pointer,
        _sel_movePath_toPath_handler_,
        src.ref.pointer,
        toPath.ref.pointer,
        handler?.ref.pointer ?? ffi.nullptr);
  }

  /// removeFileAtPath:handler:
  bool removeFileAtPath(objc.NSString path, {objc.ObjCObjectBase? handler}) {
    objc.checkOsVersionInternal('NSFileManager.removeFileAtPath:handler:',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1lsax7n(
        this.ref.pointer,
        _sel_removeFileAtPath_handler_,
        path.ref.pointer,
        handler?.ref.pointer ?? ffi.nullptr);
  }

  /// currentDirectoryPath
  objc.NSString get currentDirectoryPath {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_currentDirectoryPath);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// changeCurrentDirectoryPath:
  bool changeCurrentDirectoryPath(objc.NSString path) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_changeCurrentDirectoryPath_, path.ref.pointer);
  }

  /// fileExistsAtPath:
  bool fileExistsAtPath(objc.NSString path) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_fileExistsAtPath_, path.ref.pointer);
  }

  /// fileExistsAtPath:isDirectory:
  bool fileExistsAtPath$1(objc.NSString path,
      {required ffi.Pointer<ffi.Bool> isDirectory}) {
    return _objc_msgSend_1fuj22f(this.ref.pointer,
        _sel_fileExistsAtPath_isDirectory_, path.ref.pointer, isDirectory);
  }

  /// isReadableFileAtPath:
  bool isReadableFileAtPath(objc.NSString path) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isReadableFileAtPath_, path.ref.pointer);
  }

  /// isWritableFileAtPath:
  bool isWritableFileAtPath(objc.NSString path) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isWritableFileAtPath_, path.ref.pointer);
  }

  /// isExecutableFileAtPath:
  bool isExecutableFileAtPath(objc.NSString path) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isExecutableFileAtPath_, path.ref.pointer);
  }

  /// isDeletableFileAtPath:
  bool isDeletableFileAtPath(objc.NSString path) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isDeletableFileAtPath_, path.ref.pointer);
  }

  /// contentsEqualAtPath:andPath:
  bool contentsEqualAtPath(objc.NSString path1,
      {required objc.NSString andPath}) {
    return _objc_msgSend_1lsax7n(
        this.ref.pointer,
        _sel_contentsEqualAtPath_andPath_,
        path1.ref.pointer,
        andPath.ref.pointer);
  }

  /// displayNameAtPath:
  objc.NSString displayNameAtPath(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_displayNameAtPath_, path.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// componentsToDisplayForPath:
  objc.NSArray? componentsToDisplayForPath(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_componentsToDisplayForPath_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// enumeratorAtPath:
  NSDirectoryEnumerator? enumeratorAtPath(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_enumeratorAtPath_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : NSDirectoryEnumerator.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:
  NSDirectoryEnumerator? enumeratorAtURL(objc.NSURL url,
      {objc.NSArray? includingPropertiesForKeys,
      required NSDirectoryEnumerationOptions options,
      objc.ObjCBlock<ffi.Bool Function(objc.NSURL, objc.NSError)>?
          errorHandler}) {
    objc.checkOsVersionInternal(
        'NSFileManager.enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_fx4ekv(
        this.ref.pointer,
        _sel_enumeratorAtURL_includingPropertiesForKeys_options_errorHandler_,
        url.ref.pointer,
        includingPropertiesForKeys?.ref.pointer ?? ffi.nullptr,
        options.value,
        errorHandler?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSDirectoryEnumerator.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// subpathsAtPath:
  objc.NSArray? subpathsAtPath(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_subpathsAtPath_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// contentsAtPath:
  objc.NSData? contentsAtPath(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_contentsAtPath_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// createFileAtPath:contents:attributes:
  bool createFileAtPath(objc.NSString path,
      {objc.NSData? contents, objc.NSDictionary? attributes}) {
    return _objc_msgSend_gtxojt(
        this.ref.pointer,
        _sel_createFileAtPath_contents_attributes_,
        path.ref.pointer,
        contents?.ref.pointer ?? ffi.nullptr,
        attributes?.ref.pointer ?? ffi.nullptr);
  }

  /// fileSystemRepresentationWithPath:
  ffi.Pointer<ffi.Char> fileSystemRepresentationWithPath(objc.NSString path) {
    return _objc_msgSend_uffm97(this.ref.pointer,
        _sel_fileSystemRepresentationWithPath_, path.ref.pointer);
  }

  /// stringWithFileSystemRepresentation:length:
  objc.NSString stringWithFileSystemRepresentation(ffi.Pointer<ffi.Char> str,
      {required int length}) {
    final _ret = _objc_msgSend_erqryg(this.ref.pointer,
        _sel_stringWithFileSystemRepresentation_length_, str, length);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:
  bool replaceItemAtURL(objc.NSURL originalItemURL,
      {required objc.NSURL withItemAtURL,
      objc.NSString? backupItemName,
      required NSFileManagerItemReplacementOptions options,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> resultingItemURL,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:',
        iOS: (false, (4, 0, 0)),
        macOS: (false, (10, 6, 0)));
    return _objc_msgSend_4w6uxs(
        this.ref.pointer,
        _sel_replaceItemAtURL_withItemAtURL_backupItemName_options_resultingItemURL_error_,
        originalItemURL.ref.pointer,
        withItemAtURL.ref.pointer,
        backupItemName?.ref.pointer ?? ffi.nullptr,
        options.value,
        resultingItemURL,
        error);
  }

  /// setUbiquitous:itemAtURL:destinationURL:error:
  bool setUbiquitous(bool flag,
      {required objc.NSURL itemAtURL,
      required objc.NSURL destinationURL,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.setUbiquitous:itemAtURL:destinationURL:error:',
        iOS: (false, (5, 0, 0)),
        macOS: (false, (10, 7, 0)));
    return _objc_msgSend_70y61a(
        this.ref.pointer,
        _sel_setUbiquitous_itemAtURL_destinationURL_error_,
        flag,
        itemAtURL.ref.pointer,
        destinationURL.ref.pointer,
        error);
  }

  /// isUbiquitousItemAtURL:
  bool isUbiquitousItemAtURL(objc.NSURL url) {
    objc.checkOsVersionInternal('NSFileManager.isUbiquitousItemAtURL:',
        iOS: (false, (5, 0, 0)), macOS: (false, (10, 7, 0)));
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isUbiquitousItemAtURL_, url.ref.pointer);
  }

  /// startDownloadingUbiquitousItemAtURL:error:
  bool startDownloadingUbiquitousItemAtURL(objc.NSURL url,
      {required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.startDownloadingUbiquitousItemAtURL:error:',
        iOS: (false, (5, 0, 0)),
        macOS: (false, (10, 7, 0)));
    return _objc_msgSend_l9p60w(
        this.ref.pointer,
        _sel_startDownloadingUbiquitousItemAtURL_error_,
        url.ref.pointer,
        error);
  }

  /// evictUbiquitousItemAtURL:error:
  bool evictUbiquitousItemAtURL(objc.NSURL url,
      {required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal('NSFileManager.evictUbiquitousItemAtURL:error:',
        iOS: (false, (5, 0, 0)), macOS: (false, (10, 7, 0)));
    return _objc_msgSend_l9p60w(this.ref.pointer,
        _sel_evictUbiquitousItemAtURL_error_, url.ref.pointer, error);
  }

  /// URLForUbiquityContainerIdentifier:
  objc.NSURL? URLForUbiquityContainerIdentifier(
      objc.NSString? containerIdentifier) {
    objc.checkOsVersionInternal(
        'NSFileManager.URLForUbiquityContainerIdentifier:',
        iOS: (false, (5, 0, 0)),
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer,
        _sel_URLForUbiquityContainerIdentifier_,
        containerIdentifier?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLForPublishingUbiquitousItemAtURL:expirationDate:error:
  objc.NSURL? URLForPublishingUbiquitousItemAtURL(objc.NSURL url,
      {required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> expirationDate,
      required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error}) {
    objc.checkOsVersionInternal(
        'NSFileManager.URLForPublishingUbiquitousItemAtURL:expirationDate:error:',
        iOS: (false, (5, 0, 0)),
        macOS: (false, (10, 7, 0)));
    final _ret = _objc_msgSend_b99g2z(
        this.ref.pointer,
        _sel_URLForPublishingUbiquitousItemAtURL_expirationDate_error_,
        url.ref.pointer,
        expirationDate,
        error);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// ubiquityIdentityToken
  objc.NSObjectProtocol? get ubiquityIdentityToken {
    objc.checkOsVersionInternal('NSFileManager.ubiquityIdentityToken',
        iOS: (false, (6, 0, 0)), macOS: (false, (10, 8, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_ubiquityIdentityToken);
    return _ret.address == 0
        ? null
        : objc.NSObjectProtocol.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// getFileProviderServicesForItemAtURL:completionHandler:
  void getFileProviderServicesForItemAtURL(objc.NSURL url,
      {required objc
          .ObjCBlock<ffi.Void Function(objc.NSDictionary?, objc.NSError?)>
          completionHandler}) {
    objc.checkOsVersionInternal(
        'NSFileManager.getFileProviderServicesForItemAtURL:completionHandler:',
        iOS: (false, (11, 0, 0)),
        macOS: (false, (10, 13, 0)));
    _objc_msgSend_o762yo(
        this.ref.pointer,
        _sel_getFileProviderServicesForItemAtURL_completionHandler_,
        url.ref.pointer,
        completionHandler.ref.pointer);
  }

  /// containerURLForSecurityApplicationGroupIdentifier:
  objc.NSURL? containerURLForSecurityApplicationGroupIdentifier(
      objc.NSString groupIdentifier) {
    objc.checkOsVersionInternal(
        'NSFileManager.containerURLForSecurityApplicationGroupIdentifier:',
        iOS: (false, (7, 0, 0)),
        macOS: (false, (10, 8, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer,
        _sel_containerURLForSecurityApplicationGroupIdentifier_,
        groupIdentifier.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSFileManager init() {
    objc.checkOsVersionInternal('NSFileManager.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSFileManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static NSFileManager new$() {
    final _ret = _objc_msgSend_151sglz(_class_NSFileManager, _sel_new);
    return NSFileManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSFileManager allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_NSFileManager, _sel_allocWithZone_, zone);
    return NSFileManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSFileManager alloc() {
    final _ret = _objc_msgSend_151sglz(_class_NSFileManager, _sel_alloc);
    return NSFileManager.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of NSFileManager constructed with the default `new` method.
  factory NSFileManager() => new$();
}
