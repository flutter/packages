// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.6.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
import WebKit
import UIKit

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PigeonError {
  return PigeonError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}
/// Handles the callback when an object is deallocated.
protocol WebKitLibraryPigeonInternalFinalizerDelegate: AnyObject {
  /// Invoked when the strong reference of an object is deallocated in an `InstanceManager`.
  func onDeinit(identifier: Int64)
}


// Attaches to an object to receive a callback when the object is deallocated.
internal final class WebKitLibraryPigeonInternalFinalizer {
  private static let associatedObjectKey = malloc(1)!

  private let identifier: Int64
  // Reference to the delegate is weak because the callback should be ignored if the
  // `InstanceManager` is deallocated.
  private weak var delegate: WebKitLibraryPigeonInternalFinalizerDelegate?

  private init(identifier: Int64, delegate: WebKitLibraryPigeonInternalFinalizerDelegate) {
    self.identifier = identifier
    self.delegate = delegate
  }

  internal static func attach(
    to instance: AnyObject, identifier: Int64, delegate: WebKitLibraryPigeonInternalFinalizerDelegate
  ) {
    let finalizer = WebKitLibraryPigeonInternalFinalizer(identifier: identifier, delegate: delegate)
    objc_setAssociatedObject(instance, associatedObjectKey, finalizer, .OBJC_ASSOCIATION_RETAIN)
  }

  static func detach(from instance: AnyObject) {
    objc_setAssociatedObject(instance, associatedObjectKey, nil, .OBJC_ASSOCIATION_ASSIGN)
  }

  deinit {
    delegate?.onDeinit(identifier: identifier)
  }
}


/// Maintains instances used to communicate with the corresponding objects in Dart.
///
/// Objects stored in this container are represented by an object in Dart that is also stored in
/// an InstanceManager with the same identifier.
///
/// When an instance is added with an identifier, either can be used to retrieve the other.
///
/// Added instances are added as a weak reference and a strong reference. When the strong
/// reference is removed and the weak reference is deallocated,`WebKitLibraryPigeonInternalFinalizerDelegate.onDeinit`
/// is called with the instance's identifier. However, if the strong reference is removed and then the identifier is
/// retrieved with the intention to pass the identifier to Dart (e.g. by calling `identifierWithStrongReference`),
/// the strong reference to the instance is re-added. The strong reference will then need to be removed manually
/// again.
///
/// Accessing and inserting to an InstanceManager is thread safe.
final class WebKitLibraryPigeonInstanceManager {
  // Identifiers are locked to a specific range to avoid collisions with objects
  // created simultaneously from Dart.
  // Host uses identifiers >= 2^16 and Dart is expected to use values n where,
  // 0 <= n < 2^16.
  private static let minHostCreatedIdentifier: Int64 = 65536

  private let lockQueue = DispatchQueue(label: "WebKitLibraryPigeonInstanceManager")
  private let identifiers: NSMapTable<AnyObject, NSNumber> = NSMapTable(
    keyOptions: [.weakMemory, .objectPointerPersonality], valueOptions: .strongMemory)
  private let weakInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.weakMemory, .objectPointerPersonality])
  private let strongInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.strongMemory, .objectPointerPersonality])
  private let finalizerDelegate: WebKitLibraryPigeonInternalFinalizerDelegate
  private var nextIdentifier: Int64 = minHostCreatedIdentifier

  public init(finalizerDelegate: WebKitLibraryPigeonInternalFinalizerDelegate) {
    self.finalizerDelegate = finalizerDelegate
  }

  /// Adds a new instance that was instantiated from Dart.
  ///
  /// The same instance can be added multiple times, but each identifier must be unique. This allows
  /// two objects that are equivalent (e.g. conforms to `Equatable`)  to both be added.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored
  ///   - identifier: the identifier to be paired with instance. This value must be >= 0 and unique
  func addDartCreatedInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    lockQueue.async {
      self.addInstance(instance, withIdentifier: identifier)
    }
  }

  /// Adds a new instance that was instantiated from the host platform.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored. This must be unique to all other added instances.
  /// - Returns: the unique identifier (>= 0) stored with instance
  func addHostCreatedInstance(_ instance: AnyObject) -> Int64 {
    assert(!containsInstance(instance), "Instance of \(instance) has already been added.")
    var identifier: Int64 = -1
    lockQueue.sync {
      identifier = nextIdentifier
      nextIdentifier += 1
      self.addInstance(instance, withIdentifier: identifier)
    }
    return identifier
  }

  /// Removes `instanceIdentifier` and its associated strongly referenced instance, if present, from the manager.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier paired to an instance.
  /// - Returns: removed instance if the manager contains the given identifier, otherwise `nil` if
  ///   the manager doesn't contain the value
  func removeInstance<T: AnyObject>(withIdentifier instanceIdentifier: Int64) throws -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = strongInstances.object(forKey: NSNumber(value: instanceIdentifier))
      strongInstances.removeObject(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  /// Retrieves the instance associated with identifier.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier associated with an instance
  /// - Returns: the instance associated with `instanceIdentifier` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func instance<T: AnyObject>(forIdentifier instanceIdentifier: Int64) -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = weakInstances.object(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  private func addInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    assert(identifier >= 0)
    assert(
      weakInstances.object(forKey: identifier as NSNumber) == nil,
      "Identifier has already been added: \(identifier)")
    identifiers.setObject(NSNumber(value: identifier), forKey: instance)
    weakInstances.setObject(instance, forKey: NSNumber(value: identifier))
    strongInstances.setObject(instance, forKey: NSNumber(value: identifier))
    WebKitLibraryPigeonInternalFinalizer.attach(to: instance, identifier: identifier, delegate: finalizerDelegate)
  }

  /// Retrieves the identifier paired with an instance.
  ///
  /// If the manager contains a strong reference to `instance`, it will return the identifier
  /// associated with `instance`. If the manager contains only a weak reference to `instance`, a new
  /// strong reference to `instance` will be added and will need to be removed again with `removeInstance`.
  ///
  /// If this method returns a nonnull identifier, this method also expects the Dart
  /// `WebKitLibraryPigeonInstanceManager` to have, or recreate, a weak reference to the Dart instance the
  /// identifier is associated with.
  ///
  /// - Parameters:
  ///   - instance: an instance that may be stored in the manager
  /// - Returns: the identifier associated with `instance` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func identifierWithStrongReference(forInstance instance: AnyObject) -> Int64? {
    var identifier: Int64? = nil
    lockQueue.sync {
      if let existingIdentifier = identifiers.object(forKey: instance)?.int64Value {
        strongInstances.setObject(instance, forKey: NSNumber(value: existingIdentifier))
        identifier = existingIdentifier
      }
    }
    return identifier
  }

  /// Whether this manager contains the given `instance`.
  ///
  /// - Parameters:
  ///   - instance: the instance whose presence in this manager is to be tested
  /// - Returns: whether this manager contains the given `instance`
  func containsInstance(_ instance: AnyObject) -> Bool {
    var containsInstance = false
    lockQueue.sync {
      containsInstance = identifiers.object(forKey: instance) != nil
    }
    return containsInstance
  }

  /// Removes all of the instances from this manager.
  ///
  /// The manager will be empty after this call returns.
  func removeAllObjects() throws {
    lockQueue.sync {
      identifiers.removeAllObjects()
      weakInstances.removeAllObjects()
      strongInstances.removeAllObjects()
      nextIdentifier = WebKitLibraryPigeonInstanceManager.minHostCreatedIdentifier
    }
  }

  /// The number of instances stored as a strong reference.
  ///
  /// For debugging and testing purposes.
  internal var strongInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = strongInstances.count
    }
    return count
  }

  /// The number of instances stored as a weak reference.
  ///
  /// For debugging and testing purposes. NSMapTables that store keys or objects as weak
  /// reference will be reclaimed non-deterministically.
  internal var weakInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = weakInstances.count
    }
    return count
  }
}


private class WebKitLibraryPigeonInstanceManagerApi {
  /// The codec used for serializing messages.
  var codec: FlutterStandardMessageCodec { WebKitLibraryPigeonCodec.shared }

  /// Handles sending and receiving messages with Dart.
  unowned let binaryMessenger: FlutterBinaryMessenger

  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }

  /// Sets up an instance of `WebKitLibraryPigeonInstanceManagerApi` to handle messages through the `binaryMessenger`.
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, instanceManager: WebKitLibraryPigeonInstanceManager?) {
    let codec = WebKitLibraryPigeonCodec.shared
    let removeStrongReferenceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.PigeonInternalInstanceManager.removeStrongReference", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      removeStrongReferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! Int64
        do {
          let _: AnyObject? = try instanceManager.removeInstance(withIdentifier: identifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeStrongReferenceChannel.setMessageHandler(nil)
    }
    let clearChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.PigeonInternalInstanceManager.clear", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      clearChannel.setMessageHandler { _, reply in
        do {
          try instanceManager.removeAllObjects()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearChannel.setMessageHandler(nil)
    }
  }

  /// Sends a message to the Dart `InstanceManager` to remove the strong reference of the instance associated with `identifier`.
  func removeStrongReference(identifier identifierArg: Int64, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.PigeonInternalInstanceManager.removeStrongReference"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([identifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol WebKitLibraryPigeonProxyApiDelegate {
  /// An implementation of [PigeonApiURLRequest] used to add a new Dart instance of
  /// `URLRequest` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiURLRequest(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiURLRequest
  /// An implementation of [PigeonApiHTTPURLResponse] used to add a new Dart instance of
  /// `HTTPURLResponse` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiHTTPURLResponse(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiHTTPURLResponse
  /// An implementation of [PigeonApiWKUserScript] used to add a new Dart instance of
  /// `WKUserScript` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKUserScript(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKUserScript
  /// An implementation of [PigeonApiWKNavigationAction] used to add a new Dart instance of
  /// `WKNavigationAction` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKNavigationAction(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKNavigationAction
  /// An implementation of [PigeonApiWKNavigationResponse] used to add a new Dart instance of
  /// `WKNavigationResponse` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKNavigationResponse(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKNavigationResponse
  /// An implementation of [PigeonApiWKFrameInfo] used to add a new Dart instance of
  /// `WKFrameInfo` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKFrameInfo(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKFrameInfo
  /// An implementation of [PigeonApiNSError] used to add a new Dart instance of
  /// `NSError` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiNSError(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiNSError
  /// An implementation of [PigeonApiWKScriptMessage] used to add a new Dart instance of
  /// `WKScriptMessage` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKScriptMessage(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKScriptMessage
  /// An implementation of [PigeonApiWKSecurityOrigin] used to add a new Dart instance of
  /// `WKSecurityOrigin` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKSecurityOrigin(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKSecurityOrigin
  /// An implementation of [PigeonApiHTTPCookie] used to add a new Dart instance of
  /// `HTTPCookie` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiHTTPCookie(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiHTTPCookie
  /// An implementation of [PigeonApiAuthenticationChallengeResponse] used to add a new Dart instance of
  /// `AuthenticationChallengeResponse` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAuthenticationChallengeResponse(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiAuthenticationChallengeResponse
  /// An implementation of [PigeonApiWKWebsiteDataStore] used to add a new Dart instance of
  /// `WKWebsiteDataStore` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKWebsiteDataStore(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKWebsiteDataStore
  /// An implementation of [PigeonApiUIView] used to add a new Dart instance of
  /// `UIView` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiUIView(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiUIView
  /// An implementation of [PigeonApiUIScrollView] used to add a new Dart instance of
  /// `UIScrollView` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiUIScrollView(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiUIScrollView
  /// An implementation of [PigeonApiWKWebViewConfiguration] used to add a new Dart instance of
  /// `WKWebViewConfiguration` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKWebViewConfiguration(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKWebViewConfiguration
  /// An implementation of [PigeonApiWKUserContentController] used to add a new Dart instance of
  /// `WKUserContentController` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKUserContentController(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKUserContentController
  /// An implementation of [PigeonApiWKPreferences] used to add a new Dart instance of
  /// `WKPreferences` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKPreferences(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKPreferences
  /// An implementation of [PigeonApiWKScriptMessageHandler] used to add a new Dart instance of
  /// `WKScriptMessageHandler` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKScriptMessageHandler(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKScriptMessageHandler
  /// An implementation of [PigeonApiWKNavigationDelegate] used to add a new Dart instance of
  /// `WKNavigationDelegate` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKNavigationDelegate(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKNavigationDelegate
  /// An implementation of [PigeonApiNSObject] used to add a new Dart instance of
  /// `NSObject` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiNSObject(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiNSObject
  /// An implementation of [PigeonApiWKWebViewUIExtensions] used to add a new Dart instance of
  /// `WKWebViewUIExtensions` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKWebViewUIExtensions(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKWebViewUIExtensions
  /// An implementation of [PigeonApiWKWebViewNSExtensions] used to add a new Dart instance of
  /// `WKWebViewNSExtensions` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKWebViewNSExtensions(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKWebViewNSExtensions
  /// An implementation of [PigeonApiWKWebView] used to add a new Dart instance of
  /// `WKWebView` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKWebView(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKWebView
  /// An implementation of [PigeonApiWKUIDelegate] used to add a new Dart instance of
  /// `WKUIDelegate` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKUIDelegate(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKUIDelegate
  /// An implementation of [PigeonApiWKHTTPCookieStore] used to add a new Dart instance of
  /// `WKHTTPCookieStore` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKHTTPCookieStore(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKHTTPCookieStore
  /// An implementation of [PigeonApiUIScrollViewDelegate] used to add a new Dart instance of
  /// `UIScrollViewDelegate` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiUIScrollViewDelegate(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiUIScrollViewDelegate
  /// An implementation of [PigeonApiURLCredential] used to add a new Dart instance of
  /// `URLCredential` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiURLCredential(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiURLCredential
  /// An implementation of [PigeonApiURLProtectionSpace] used to add a new Dart instance of
  /// `URLProtectionSpace` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiURLProtectionSpace(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiURLProtectionSpace
  /// An implementation of [PigeonApiURLAuthenticationChallenge] used to add a new Dart instance of
  /// `URLAuthenticationChallenge` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiURLAuthenticationChallenge(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiURLAuthenticationChallenge
  /// An implementation of [PigeonApiURL] used to add a new Dart instance of
  /// `URL` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiURL(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiURL
}

extension WebKitLibraryPigeonProxyApiDelegate {
  func pigeonApiWKWebViewNSExtensions(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKWebViewNSExtensions {
    return PigeonApiWKWebViewNSExtensions(pigeonRegistrar: registrar, delegate: PigeonApiDelegateWKWebViewNSExtensions())
  }
}

open class WebKitLibraryPigeonProxyApiRegistrar {
  let binaryMessenger: FlutterBinaryMessenger
  let apiDelegate: WebKitLibraryPigeonProxyApiDelegate
  let instanceManager: WebKitLibraryPigeonInstanceManager
  /// Whether APIs should ignore calling to Dart.
  public var ignoreCallsToDart = false
  private var _codec: FlutterStandardMessageCodec?
  var codec: FlutterStandardMessageCodec {
    if _codec == nil {
      _codec = FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: self))
    }
    return _codec!
  }

  private class InstanceManagerApiFinalizerDelegate: WebKitLibraryPigeonInternalFinalizerDelegate {
    let api: WebKitLibraryPigeonInstanceManagerApi

    init(_ api: WebKitLibraryPigeonInstanceManagerApi) {
      self.api = api
    }

    public func onDeinit(identifier: Int64) {
      api.removeStrongReference(identifier: identifier) {
        _ in
      }
    }
  }

  init(binaryMessenger: FlutterBinaryMessenger, apiDelegate: WebKitLibraryPigeonProxyApiDelegate) {
    self.binaryMessenger = binaryMessenger
    self.apiDelegate = apiDelegate
    self.instanceManager = WebKitLibraryPigeonInstanceManager(
      finalizerDelegate: InstanceManagerApiFinalizerDelegate(
        WebKitLibraryPigeonInstanceManagerApi(binaryMessenger: binaryMessenger)))
  }

  func setUp() {
    WebKitLibraryPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: instanceManager)
    PigeonApiURLRequest.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiURLRequest(self))
    PigeonApiWKUserScript.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKUserScript(self))
    PigeonApiHTTPCookie.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiHTTPCookie(self))
    PigeonApiAuthenticationChallengeResponse.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiAuthenticationChallengeResponse(self))
    PigeonApiWKWebsiteDataStore.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKWebsiteDataStore(self))
    PigeonApiUIView.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiUIView(self))
    PigeonApiUIScrollView.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiUIScrollView(self))
    PigeonApiWKWebViewConfiguration.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKWebViewConfiguration(self))
    PigeonApiWKUserContentController.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKUserContentController(self))
    PigeonApiWKPreferences.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKPreferences(self))
    PigeonApiWKScriptMessageHandler.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKScriptMessageHandler(self))
    PigeonApiWKNavigationDelegate.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKNavigationDelegate(self))
    PigeonApiNSObject.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiNSObject(self))
    PigeonApiWKWebViewUIExtensions.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKWebViewUIExtensions(self))
    PigeonApiWKWebView.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKWebView(self))
    PigeonApiWKUIDelegate.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKUIDelegate(self))
    PigeonApiWKHTTPCookieStore.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKHTTPCookieStore(self))
    PigeonApiUIScrollViewDelegate.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiUIScrollViewDelegate(self))
    PigeonApiURLCredential.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiURLCredential(self))
    PigeonApiURLAuthenticationChallenge.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiURLAuthenticationChallenge(self))
    PigeonApiURL.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiURL(self))
  }
  func tearDown() {
    WebKitLibraryPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: nil)
    PigeonApiURLRequest.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKUserScript.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiHTTPCookie.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiAuthenticationChallengeResponse.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKWebsiteDataStore.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiUIView.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiUIScrollView.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKWebViewConfiguration.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKUserContentController.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKPreferences.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKScriptMessageHandler.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKNavigationDelegate.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiNSObject.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKWebViewUIExtensions.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKWebView.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKUIDelegate.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKHTTPCookieStore.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiUIScrollViewDelegate.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiURLCredential.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiURLAuthenticationChallenge.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiURL.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
  }
}
private class WebKitLibraryPigeonInternalProxyApiCodecReaderWriter: FlutterStandardReaderWriter {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar

  private class WebKitLibraryPigeonInternalProxyApiCodecReader: WebKitLibraryPigeonCodecReader {
    unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar

    init(data: Data, pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func readValue(ofType type: UInt8) -> Any? {
      switch type {
      case 128:
        let identifier = self.readValue()
        let instance: AnyObject? = pigeonRegistrar.instanceManager.instance(
          forIdentifier: identifier is Int64 ? identifier as! Int64 : Int64(identifier as! Int32))
        return instance
      default:
        return super.readValue(ofType: type)
      }
    }
  }

  private class WebKitLibraryPigeonInternalProxyApiCodecWriter: WebKitLibraryPigeonCodecWriter {
    unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar

    init(data: NSMutableData, pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func writeValue(_ value: Any) {
      if value is [Any] || value is Bool || value is Data || value is [AnyHashable: Any] || value is Double || value is FlutterStandardTypedData || value is Int64 || value is String || value is KeyValueObservingOptions || value is KeyValueChange || value is KeyValueChangeKey || value is UserScriptInjectionTime || value is AudiovisualMediaType || value is WebsiteDataType || value is NavigationActionPolicy || value is NavigationResponsePolicy || value is HttpCookiePropertyKey || value is NavigationType || value is PermissionDecision || value is MediaCaptureType || value is UrlSessionAuthChallengeDisposition || value is UrlCredentialPersistence {
        super.writeValue(value)
        return
      }


      if let instance = value as? URLRequestWrapper {
        pigeonRegistrar.apiDelegate.pigeonApiURLRequest(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? HTTPURLResponse {
        pigeonRegistrar.apiDelegate.pigeonApiHTTPURLResponse(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKUserScript {
        pigeonRegistrar.apiDelegate.pigeonApiWKUserScript(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKNavigationAction {
        pigeonRegistrar.apiDelegate.pigeonApiWKNavigationAction(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKNavigationResponse {
        pigeonRegistrar.apiDelegate.pigeonApiWKNavigationResponse(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKFrameInfo {
        pigeonRegistrar.apiDelegate.pigeonApiWKFrameInfo(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? NSError {
        pigeonRegistrar.apiDelegate.pigeonApiNSError(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKScriptMessage {
        pigeonRegistrar.apiDelegate.pigeonApiWKScriptMessage(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKSecurityOrigin {
        pigeonRegistrar.apiDelegate.pigeonApiWKSecurityOrigin(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? HTTPCookie {
        pigeonRegistrar.apiDelegate.pigeonApiHTTPCookie(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AuthenticationChallengeResponse {
        pigeonRegistrar.apiDelegate.pigeonApiAuthenticationChallengeResponse(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKWebsiteDataStore {
        pigeonRegistrar.apiDelegate.pigeonApiWKWebsiteDataStore(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }

      #if !os(macOS)
      if let instance = value as? UIScrollView {
        pigeonRegistrar.apiDelegate.pigeonApiUIScrollView(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }
      #endif

      if let instance = value as? WKWebViewConfiguration {
        pigeonRegistrar.apiDelegate.pigeonApiWKWebViewConfiguration(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKUserContentController {
        pigeonRegistrar.apiDelegate.pigeonApiWKUserContentController(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKPreferences {
        pigeonRegistrar.apiDelegate.pigeonApiWKPreferences(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKScriptMessageHandler {
        pigeonRegistrar.apiDelegate.pigeonApiWKScriptMessageHandler(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKNavigationDelegate {
        pigeonRegistrar.apiDelegate.pigeonApiWKNavigationDelegate(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }

      #if !os(macOS)
      if let instance = value as? WKWebView {
        pigeonRegistrar.apiDelegate.pigeonApiWKWebViewUIExtensions(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }
      #endif
      #if !os(macOS)
      if let instance = value as? UIView {
        pigeonRegistrar.apiDelegate.pigeonApiUIView(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }
      #endif
      #if !os(iOS)
      if let instance = value as? WKWebView {
        pigeonRegistrar.apiDelegate.pigeonApiWKWebViewNSExtensions(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }
      #endif

      if let instance = value as? WKWebView {
        pigeonRegistrar.apiDelegate.pigeonApiWKWebView(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKUIDelegate {
        pigeonRegistrar.apiDelegate.pigeonApiWKUIDelegate(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKHTTPCookieStore {
        pigeonRegistrar.apiDelegate.pigeonApiWKHTTPCookieStore(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }

      #if !os(macOS)
      if let instance = value as? UIScrollViewDelegate {
        pigeonRegistrar.apiDelegate.pigeonApiUIScrollViewDelegate(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }
      #endif

      if let instance = value as? URLCredential {
        pigeonRegistrar.apiDelegate.pigeonApiURLCredential(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? URLProtectionSpace {
        pigeonRegistrar.apiDelegate.pigeonApiURLProtectionSpace(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? URLAuthenticationChallenge {
        pigeonRegistrar.apiDelegate.pigeonApiURLAuthenticationChallenge(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? URLWrapper {
        pigeonRegistrar.apiDelegate.pigeonApiURL(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? NSObject {
        pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as AnyObject?, pigeonRegistrar.instanceManager.containsInstance(instance)
      {
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance)!)
      } else {
        print("Unsupported value: \(value) of \(type(of: value))")
        assert(false, "Unsupported value for WebKitLibraryPigeonInternalProxyApiCodecWriter")
      }

    }
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar) {
    self.pigeonRegistrar = pigeonRegistrar
  }

  override func reader(with data: Data) -> FlutterStandardReader {
    return WebKitLibraryPigeonInternalProxyApiCodecReader(data: data, pigeonRegistrar: pigeonRegistrar)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return WebKitLibraryPigeonInternalProxyApiCodecWriter(data: data, pigeonRegistrar: pigeonRegistrar)
  }
}

/// The values that can be returned in a change dictionary.
///
/// See https://developer.apple.com/documentation/foundation/nskeyvalueobservingoptions.
enum KeyValueObservingOptions: Int {
  /// Indicates that the change dictionary should provide the new attribute
  /// value, if applicable.
  case newValue = 0
  /// Indicates that the change dictionary should contain the old attribute
  /// value, if applicable.
  case oldValue = 1
  /// If specified, a notification should be sent to the observer immediately,
  /// before the observer registration method even returns.
  case initialValue = 2
  /// Whether separate notifications should be sent to the observer before and
  /// after each change, instead of a single notification after the change.
  case priorNotification = 3
}

/// The kinds of changes that can be observed.
///
/// See https://developer.apple.com/documentation/foundation/nskeyvaluechange.
enum KeyValueChange: Int {
  /// Indicates that the value of the observed key path was set to a new value.
  case setting = 0
  /// Indicates that an object has been inserted into the to-many relationship
  /// that is being observed.
  case insertion = 1
  /// Indicates that an object has been removed from the to-many relationship
  /// that is being observed.
  case removal = 2
  /// Indicates that an object has been replaced in the to-many relationship
  /// that is being observed.
  case replacement = 3
  /// The value is not recognized by the wrapper.
  case unknown = 4
}

/// The keys that can appear in the change dictionary.
///
/// See https://developer.apple.com/documentation/foundation/nskeyvaluechangekey.
enum KeyValueChangeKey: Int {
  /// If the value of the `KeyValueChangeKey.kind` entry is
  /// `KeyValueChange.insertion`, `KeyValueChange.removal`, or
  /// `KeyValueChange.replacement`, the value of this key is a Set object that
  /// contains the indexes of the inserted, removed, or replaced objects.
  case indexes = 0
  /// An object that contains a value corresponding to one of the
  /// `KeyValueChange` enum, indicating what sort of change has occurred.
  case kind = 1
  /// If the value of the `KeyValueChange.kind` entry is
  /// `KeyValueChange.setting, and `KeyValueObservingOptions.newValue` was
  /// specified when the observer was registered, the value of this key is the
  /// new value for the attribute.
  case newValue = 2
  /// If the `KeyValueObservingOptions.priorNotification` option was specified
  /// when the observer was registered this notification is sent prior to a
  /// change.
  case notificationIsPrior = 3
  /// If the value of the `KeyValueChange.kind` entry is
  /// `KeyValueChange.setting`, and `KeyValueObservingOptions.old` was specified
  /// when the observer was registered, the value of this key is the value
  /// before the attribute was changed.
  case oldValue = 4
  /// The value is not recognized by the wrapper.
  case unknown = 5
}

/// Constants for the times at which to inject script content into a webpage.
///
/// See https://developer.apple.com/documentation/webkit/wkuserscriptinjectiontime.
enum UserScriptInjectionTime: Int {
  /// A constant to inject the script after the creation of the webpageâ€™s
  /// document element, but before loading any other content.
  case atDocumentStart = 0
  /// A constant to inject the script after the document finishes loading, but
  /// before loading any other subresources.
  case atDocumentEnd = 1
}

/// The media types that require a user gesture to begin playing.
///
/// See https://developer.apple.com/documentation/webkit/wkaudiovisualmediatypes.
enum AudiovisualMediaType: Int {
  /// No media types require a user gesture to begin playing.
  case none = 0
  /// Media types that contain audio require a user gesture to begin playing.
  case audio = 1
  /// Media types that contain video require a user gesture to begin playing.
  case video = 2
  /// All media types require a user gesture to begin playing.
  case all = 3
}

/// A `WKWebsiteDataRecord` object includes these constants in its dataTypes
/// property.
///
/// See https://developer.apple.com/documentation/webkit/wkwebsitedatarecord/data_store_record_types.
enum WebsiteDataType: Int {
  /// Cookies.
  case cookies = 0
  /// In-memory caches.
  case memoryCache = 1
  /// On-disk caches.
  case diskCache = 2
  /// HTML offline web app caches.
  case offlineWebApplicationCache = 3
  /// HTML local storage.
  case localStorage = 4
  /// HTML session storage.
  case sessionStorage = 5
  /// WebSQL databases.
  case webSQLDatabases = 6
  /// IndexedDB databases.
  case indexedDBDatabases = 7
}

/// Constants that indicate whether to allow or cancel navigation to a webpage
/// from an action.
///
/// See https://developer.apple.com/documentation/webkit/wknavigationactionpolicy.
enum NavigationActionPolicy: Int {
  /// Allow the navigation to continue.
  case allow = 0
  /// Cancel the navigation.
  case cancel = 1
  /// Allow the download to proceed.
  case download = 2
}

/// Constants that indicate whether to allow or cancel navigation to a webpage
/// from a response.
///
/// See https://developer.apple.com/documentation/webkit/wknavigationresponsepolicy.
enum NavigationResponsePolicy: Int {
  /// Allow the navigation to continue.
  case allow = 0
  /// Cancel the navigation.
  case cancel = 1
  /// Allow the download to proceed.
  case download = 2
}

/// Constants that define the supported keys in a cookie attributes dictionary.
///
/// See https://developer.apple.com/documentation/foundation/httpcookiepropertykey.
enum HttpCookiePropertyKey: Int {
  /// A String object containing the comment for the cookie.
  case comment = 0
  /// An Uri object or String object containing the comment URL for the cookie.
  case commentUrl = 1
  /// Aa String object stating whether the cookie should be discarded at the end
  /// of the session.
  case discard = 2
  /// An String object containing the domain for the cookie.
  case domain = 3
  /// An Date object or String object specifying the expiration date for the
  /// cookie.
  case expires = 4
  /// An String object containing an integer value stating how long in seconds
  /// the cookie should be kept, at most.
  case maximumAge = 5
  /// An String object containing the name of the cookie (required).
  case name = 6
  /// A URL or String object containing the URL that set this cookie.
  case originUrl = 7
  /// A String object containing the path for the cookie.
  case path = 8
  /// An String object containing comma-separated integer values specifying the
  /// ports for the cookie.
  case port = 9
  /// A string indicating the same-site policy for the cookie.
  case sameSitePolicy = 10
  /// A String object indicating that the cookie should be transmitted only over
  /// secure channels.
  case secure = 11
  /// A String object containing the value of the cookie.
  case value = 12
  /// A String object that specifies the version of the cookie.
  case version = 13
}

/// The type of action that triggered the navigation.
///
/// See https://developer.apple.com/documentation/webkit/wknavigationtype.
enum NavigationType: Int {
  /// A link activation.
  case linkActivated = 0
  /// A request to submit a form.
  case submitted = 1
  /// A request for the frameâ€™s next or previous item.
  case backForward = 2
  /// A request to reload the webpage.
  case reload = 3
  /// A request to resubmit a form.
  case formResubmitted = 4
  /// A navigation request that originates for some other reason.
  case other = 5
  /// The value is not recognized by the wrapper.
  case unknown = 6
}

/// Possible permission decisions for device resource access.
///
/// See https://developer.apple.com/documentation/webkit/wkpermissiondecision.
enum PermissionDecision: Int {
  /// Deny permission for the requested resource.
  case deny = 0
  /// Deny permission for the requested resource.
  case grant = 1
  /// Prompt the user for permission for the requested resource.
  case prompt = 2
}

/// List of the types of media devices that can capture audio, video, or both.
///
/// See https://developer.apple.com/documentation/webkit/wkmediacapturetype.
enum MediaCaptureType: Int {
  /// A media device that can capture video.
  case camera = 0
  /// A media device or devices that can capture audio and video.
  case cameraAndMicrophone = 1
  /// A media device that can capture audio.
  case microphone = 2
  /// The value is not recognized by the wrapper.
  case unknown = 3
}

/// Responses to an authentication challenge.
///
/// See https://developer.apple.com/documentation/foundation/urlsession/authchallengedisposition.
enum UrlSessionAuthChallengeDisposition: Int {
  /// Use the specified credential, which may be nil.
  case useCredential = 0
  /// Use the default handling for the challenge as though this delegate method
  /// were not implemented.
  case performDefaultHandling = 1
  /// Cancel the entire request.
  case cancelAuthenticationChallenge = 2
  /// Reject this challenge, and call the authentication delegate method again
  /// with the next authentication protection space.
  case rejectProtectionSpace = 3
}

/// Specifies how long a credential will be kept.
///
/// See https://developer.apple.com/documentation/foundation/nsurlcredentialpersistence.
enum UrlCredentialPersistence: Int {
  /// The credential should not be stored.
  case none = 0
  /// The credential should be stored only for this session.
  case session = 1
  /// The credential should be stored in the keychain.
  case permanent = 2
  /// The credential should be stored permanently in the keychain, and in
  /// addition should be distributed to other devices based on the owning Apple
  /// ID.
  case synchronizable = 3
}

private class WebKitLibraryPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return KeyValueObservingOptions(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return KeyValueChange(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return KeyValueChangeKey(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return UserScriptInjectionTime(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AudiovisualMediaType(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return WebsiteDataType(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return NavigationActionPolicy(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return NavigationResponsePolicy(rawValue: enumResultAsInt)
      }
      return nil
    case 137:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return HttpCookiePropertyKey(rawValue: enumResultAsInt)
      }
      return nil
    case 138:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return NavigationType(rawValue: enumResultAsInt)
      }
      return nil
    case 139:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PermissionDecision(rawValue: enumResultAsInt)
      }
      return nil
    case 140:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return MediaCaptureType(rawValue: enumResultAsInt)
      }
      return nil
    case 141:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return UrlSessionAuthChallengeDisposition(rawValue: enumResultAsInt)
      }
      return nil
    case 142:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return UrlCredentialPersistence(rawValue: enumResultAsInt)
      }
      return nil
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class WebKitLibraryPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? KeyValueObservingOptions {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? KeyValueChange {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? KeyValueChangeKey {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? UserScriptInjectionTime {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? AudiovisualMediaType {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? WebsiteDataType {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? NavigationActionPolicy {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? NavigationResponsePolicy {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? HttpCookiePropertyKey {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? NavigationType {
      super.writeByte(138)
      super.writeValue(value.rawValue)
    } else if let value = value as? PermissionDecision {
      super.writeByte(139)
      super.writeValue(value.rawValue)
    } else if let value = value as? MediaCaptureType {
      super.writeByte(140)
      super.writeValue(value.rawValue)
    } else if let value = value as? UrlSessionAuthChallengeDisposition {
      super.writeByte(141)
      super.writeValue(value.rawValue)
    } else if let value = value as? UrlCredentialPersistence {
      super.writeByte(142)
      super.writeValue(value.rawValue)
    } else {
      super.writeValue(value)
    }
  }
}

private class WebKitLibraryPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return WebKitLibraryPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return WebKitLibraryPigeonCodecWriter(data: data)
  }
}

class WebKitLibraryPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = WebKitLibraryPigeonCodec(readerWriter: WebKitLibraryPigeonCodecReaderWriter())
}

protocol PigeonApiDelegateURLRequest {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiURLRequest, url: String) throws -> URLRequestWrapper
  /// The URL being requested.
  func getUrl(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper) throws -> String?
  /// The HTTP request method.
  func setHttpMethod(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper, method: String?) throws
  /// The HTTP request method.
  func getHttpMethod(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper) throws -> String?
  /// The request body.
  func setHttpBody(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper, body: FlutterStandardTypedData?) throws
  /// The request body.
  func getHttpBody(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper) throws -> FlutterStandardTypedData?
  /// A dictionary containing all of the HTTP header fields for a request.
  func setAllHttpHeaderFields(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper, fields: [String: String]?) throws
  /// A dictionary containing all of the HTTP header fields for a request.
  func getAllHttpHeaderFields(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper) throws -> [String: String]?
}

protocol PigeonApiProtocolURLRequest {
}

final class PigeonApiURLRequest: PigeonApiProtocolURLRequest  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateURLRequest
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateURLRequest) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiURLRequest?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.URLRequest.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let urlArg = args[1] as! String
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, url: urlArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let getUrlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.URLRequest.getUrl", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getUrlChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! URLRequestWrapper
        do {
          let result = try api.pigeonDelegate.getUrl(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getUrlChannel.setMessageHandler(nil)
    }
    let setHttpMethodChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.URLRequest.setHttpMethod", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setHttpMethodChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! URLRequestWrapper
        let methodArg: String? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setHttpMethod(pigeonApi: api, pigeonInstance: pigeonInstanceArg, method: methodArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setHttpMethodChannel.setMessageHandler(nil)
    }
    let getHttpMethodChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.URLRequest.getHttpMethod", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getHttpMethodChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! URLRequestWrapper
        do {
          let result = try api.pigeonDelegate.getHttpMethod(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getHttpMethodChannel.setMessageHandler(nil)
    }
    let setHttpBodyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.URLRequest.setHttpBody", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setHttpBodyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! URLRequestWrapper
        let bodyArg: FlutterStandardTypedData? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setHttpBody(pigeonApi: api, pigeonInstance: pigeonInstanceArg, body: bodyArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setHttpBodyChannel.setMessageHandler(nil)
    }
    let getHttpBodyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.URLRequest.getHttpBody", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getHttpBodyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! URLRequestWrapper
        do {
          let result = try api.pigeonDelegate.getHttpBody(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getHttpBodyChannel.setMessageHandler(nil)
    }
    let setAllHttpHeaderFieldsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.URLRequest.setAllHttpHeaderFields", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAllHttpHeaderFieldsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! URLRequestWrapper
        let fieldsArg: [String: String]? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setAllHttpHeaderFields(pigeonApi: api, pigeonInstance: pigeonInstanceArg, fields: fieldsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAllHttpHeaderFieldsChannel.setMessageHandler(nil)
    }
    let getAllHttpHeaderFieldsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.URLRequest.getAllHttpHeaderFields", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAllHttpHeaderFieldsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! URLRequestWrapper
        do {
          let result = try api.pigeonDelegate.getAllHttpHeaderFields(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAllHttpHeaderFieldsChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of URLRequest and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: URLRequestWrapper, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.URLRequest.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation



/// ProxyApi implementation for [URLRequest].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class RequestProxyAPIDelegate : PigeonApiDelegateURLRequest {
  func pigeon_defaultConstructor(pigeonApi: PigeonApiURLRequest, url: String) throws -> URLRequestWrapper {
    return URLRequest(,url: url)
  }

  func getUrl(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper) throws -> String? {
    return pigeonInstance.getUrl()
  }

  func setHttpMethod(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper, method: String?) throws {
    pigeonInstance.setHttpMethod(method: method)
  }

  func getHttpMethod(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper) throws -> String? {
    return pigeonInstance.getHttpMethod()
  }

  func setHttpBody(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper, body: FlutterStandardTypedData?) throws {
    pigeonInstance.setHttpBody(body: body)
  }

  func getHttpBody(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper) throws -> FlutterStandardTypedData? {
    return pigeonInstance.getHttpBody()
  }

  func setAllHttpHeaderFields(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper, fields: [String: String]?) throws {
    pigeonInstance.setAllHttpHeaderFields(fields: fields)
  }

  func getAllHttpHeaderFields(pigeonApi: PigeonApiURLRequest, pigeonInstance: URLRequestWrapper) throws -> [String: String]? {
    return pigeonInstance.getAllHttpHeaderFields()
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class RequestProxyApiTests: XCTestCase {
  func testPigeonDefaultConstructor() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLRequest(registrar)

    let instance = try? api.pigeonDefaultConstructor(pigeonApi: api, url: "myString")
    XCTAssertNotNil(instance)
  }

  func testGetUrl() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLRequest(registrar)

    let instance = TestRequest()
    let value = api.pigeonDelegate.getUrl(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getUrlCalled)
    XCTAssertEqual(value, instance.getUrl())
  }

  func testSetHttpMethod() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLRequest(registrar)

    let instance = TestRequest()
    let method = "myString"
    api.pigeonDelegate.setHttpMethod(pigeonApi: api, pigeonInstance: instance, method: method)

    XCTAssertEqual(instance.setHttpMethodArgs, [method])
  }

  func testGetHttpMethod() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLRequest(registrar)

    let instance = TestRequest()
    let value = api.pigeonDelegate.getHttpMethod(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getHttpMethodCalled)
    XCTAssertEqual(value, instance.getHttpMethod())
  }

  func testSetHttpBody() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLRequest(registrar)

    let instance = TestRequest()
    let body = byteArrayOf(0xA1.toByte())
    api.pigeonDelegate.setHttpBody(pigeonApi: api, pigeonInstance: instance, body: body)

    XCTAssertEqual(instance.setHttpBodyArgs, [body])
  }

  func testGetHttpBody() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLRequest(registrar)

    let instance = TestRequest()
    let value = api.pigeonDelegate.getHttpBody(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getHttpBodyCalled)
    XCTAssertEqual(value, instance.getHttpBody())
  }

  func testSetAllHttpHeaderFields() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLRequest(registrar)

    let instance = TestRequest()
    let fields = ["myString": "myString"]
    api.pigeonDelegate.setAllHttpHeaderFields(pigeonApi: api, pigeonInstance: instance, fields: fields)

    XCTAssertEqual(instance.setAllHttpHeaderFieldsArgs, [fields])
  }

  func testGetAllHttpHeaderFields() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLRequest(registrar)

    let instance = TestRequest()
    let value = api.pigeonDelegate.getAllHttpHeaderFields(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getAllHttpHeaderFieldsCalled)
    XCTAssertEqual(value, instance.getAllHttpHeaderFields())
  }

}
class TestRequest: URLRequest {
  var getUrlCalled = false
  var setHttpMethodArgs: [AnyHashable?]? = nil
  var getHttpMethodCalled = false
  var setHttpBodyArgs: [AnyHashable?]? = nil
  var getHttpBodyCalled = false
  var setAllHttpHeaderFieldsArgs: [AnyHashable?]? = nil
  var getAllHttpHeaderFieldsCalled = false


  override func getUrl() {
    getUrlCalled = true
  }
  override func setHttpMethod() {
    setHttpMethodArgs = [method]
  }
  override func getHttpMethod() {
    getHttpMethodCalled = true
  }
  override func setHttpBody() {
    setHttpBodyArgs = [body]
  }
  override func getHttpBody() {
    getHttpBodyCalled = true
  }
  override func setAllHttpHeaderFields() {
    setAllHttpHeaderFieldsArgs = [fields]
  }
  override func getAllHttpHeaderFields() {
    getAllHttpHeaderFieldsCalled = true
  }
}
*/

protocol PigeonApiDelegateHTTPURLResponse {
  /// The responseâ€™s HTTP status code.
  func statusCode(pigeonApi: PigeonApiHTTPURLResponse, pigeonInstance: HTTPURLResponse) throws -> Int64
}

protocol PigeonApiProtocolHTTPURLResponse {
}

final class PigeonApiHTTPURLResponse: PigeonApiProtocolHTTPURLResponse  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateHTTPURLResponse
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateHTTPURLResponse) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of HTTPURLResponse and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: HTTPURLResponse, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let statusCodeArg = try! pigeonDelegate.statusCode(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.HTTPURLResponse.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, statusCodeArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation



/// ProxyApi implementation for [HTTPURLResponse].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class ResponseProxyAPIDelegate : PigeonApiDelegateHTTPURLResponse {
  func statusCode(pigeonApi: PigeonApiHTTPURLResponse, pigeonInstance: HTTPURLResponse) throws -> Int64 {
    return pigeon_instance.statusCode
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class ResponseProxyApiTests: XCTestCase {
  func testStatusCode() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiHTTPURLResponse(registrar)

    let instance = TestResponse()
    let value = try? api.pigeonDelegate.statusCode(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.statusCode)
  }

}
*/

protocol PigeonApiDelegateWKUserScript {
  /// Creates a user script object that contains the specified source code and
  /// attributes.
  func pigeonDefaultConstructor(pigeonApi: PigeonApiWKUserScript, source: String, injectionTime: UserScriptInjectionTime, isMainFrameOnly: Bool) throws -> WKUserScript
  /// The scriptâ€™s source code.
  func source(pigeonApi: PigeonApiWKUserScript, pigeonInstance: WKUserScript) throws -> String
  /// The time at which to inject the script into the webpage.
  func injectionTime(pigeonApi: PigeonApiWKUserScript, pigeonInstance: WKUserScript) throws -> UserScriptInjectionTime
  /// A Boolean value that indicates whether to inject the script into the main
  /// frame or all frames.
  func isMainFrameOnly(pigeonApi: PigeonApiWKUserScript, pigeonInstance: WKUserScript) throws -> Bool
}

protocol PigeonApiProtocolWKUserScript {
}

final class PigeonApiWKUserScript: PigeonApiProtocolWKUserScript  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKUserScript
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKUserScript) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKUserScript?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserScript.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let sourceArg = args[1] as! String
        let injectionTimeArg = args[2] as! UserScriptInjectionTime
        let isMainFrameOnlyArg = args[3] as! Bool
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, source: sourceArg, injectionTime: injectionTimeArg, isMainFrameOnly: isMainFrameOnlyArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKUserScript and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKUserScript, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let sourceArg = try! pigeonDelegate.source(pigeonApi: self, pigeonInstance: pigeonInstance)
    let injectionTimeArg = try! pigeonDelegate.injectionTime(pigeonApi: self, pigeonInstance: pigeonInstance)
    let isMainFrameOnlyArg = try! pigeonDelegate.isMainFrameOnly(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserScript.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, sourceArg, injectionTimeArg, isMainFrameOnlyArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit


/// ProxyApi implementation for [WKUserScript].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class UserScriptProxyAPIDelegate : PigeonApiDelegateWKUserScript {
  func pigeon_defaultConstructor(pigeonApi: PigeonApiWKUserScript, source: String, injectionTime: UserScriptInjectionTime, isMainFrameOnly: Bool) throws -> WKUserScript {
    return WKUserScript()
  }

  func source(pigeonApi: PigeonApiWKUserScript, pigeonInstance: WKUserScript) throws -> String {
    return pigeon_instance.source
  }

  func injectionTime(pigeonApi: PigeonApiWKUserScript, pigeonInstance: WKUserScript) throws -> UserScriptInjectionTime {
    switch pigeon_instance.injectionTime {
      case .atDocumentStart
        return .atDocumentStart
            case .atDocumentEnd
        return .atDocumentEnd
            @unknown default:
        return .unknown
      
    }
  }

  func isMainFrameOnly(pigeonApi: PigeonApiWKUserScript, pigeonInstance: WKUserScript) throws -> Bool {
    return pigeon_instance.isMainFrameOnly
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class UserScriptProxyApiTests: XCTestCase {
  func testPigeonDefaultConstructor() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKUserScript(registrar)

    let instance = try? api.pigeonDefaultConstructor(pigeonApi: api source: "myString", injectionTime: .atDocumentStart, isMainFrameOnly: true)
    XCTAssertNotNil(instance)
  }

  func testSource() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKUserScript(registrar)

    let instance = TestUserScript()
    let value = try? api.pigeonDelegate.source(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.source)
  }

  func testInjectionTime() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKUserScript(registrar)

    let instance = TestUserScript()
    let value = try? api.pigeonDelegate.injectionTime(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.injectionTime)
  }

  func testIsMainFrameOnly() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKUserScript(registrar)

    let instance = TestUserScript()
    let value = try? api.pigeonDelegate.isMainFrameOnly(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.isMainFrameOnly)
  }

}
*/

protocol PigeonApiDelegateWKNavigationAction {
  /// The URL request object associated with the navigation action.
  func request(pigeonApi: PigeonApiWKNavigationAction, pigeonInstance: WKNavigationAction) throws -> URLRequestWrapper
  /// The frame in which to display the new content.
  func targetFrame(pigeonApi: PigeonApiWKNavigationAction, pigeonInstance: WKNavigationAction) throws -> WKFrameInfo
  /// The type of action that triggered the navigation.
  func navigationType(pigeonApi: PigeonApiWKNavigationAction, pigeonInstance: WKNavigationAction) throws -> NavigationType
}

protocol PigeonApiProtocolWKNavigationAction {
}

final class PigeonApiWKNavigationAction: PigeonApiProtocolWKNavigationAction  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKNavigationAction
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKNavigationAction) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of WKNavigationAction and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKNavigationAction, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let requestArg = try! pigeonDelegate.request(pigeonApi: self, pigeonInstance: pigeonInstance)
    let targetFrameArg = try! pigeonDelegate.targetFrame(pigeonApi: self, pigeonInstance: pigeonInstance)
    let navigationTypeArg = try! pigeonDelegate.navigationType(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationAction.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, requestArg, targetFrameArg, navigationTypeArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit
import WebKit


/// ProxyApi implementation for [WKNavigationAction].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class NavigationActionProxyAPIDelegate : PigeonApiDelegateWKNavigationAction {
  func request(pigeonApi: PigeonApiWKNavigationAction, pigeonInstance: WKNavigationAction) throws -> URLRequestWrapper {
    return pigeon_instance.request
  }

  func targetFrame(pigeonApi: PigeonApiWKNavigationAction, pigeonInstance: WKNavigationAction) throws -> WKFrameInfo {
    return pigeon_instance.targetFrame
  }

  func navigationType(pigeonApi: PigeonApiWKNavigationAction, pigeonInstance: WKNavigationAction) throws -> NavigationType {
    switch pigeon_instance.navigationType {
      case .linkActivated
        return .linkActivated
            case .submitted
        return .submitted
            case .backForward
        return .backForward
            case .reload
        return .reload
            case .formResubmitted
        return .formResubmitted
            case .other
        return .other
            @unknown default:
        return .unknown
      
    }
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class NavigationActionProxyApiTests: XCTestCase {
  func testRequest() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKNavigationAction(registrar)

    let instance = TestNavigationAction()
    let value = try? api.pigeonDelegate.request(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.request)
  }

  func testTargetFrame() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKNavigationAction(registrar)

    let instance = TestNavigationAction()
    let value = try? api.pigeonDelegate.targetFrame(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.targetFrame)
  }

  func testNavigationType() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKNavigationAction(registrar)

    let instance = TestNavigationAction()
    let value = try? api.pigeonDelegate.navigationType(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.navigationType)
  }

}
*/

protocol PigeonApiDelegateWKNavigationResponse {
  /// The frameâ€™s response.
  func response(pigeonApi: PigeonApiWKNavigationResponse, pigeonInstance: WKNavigationResponse) throws -> HTTPURLResponse
  /// A Boolean value that indicates whether the response targets the web viewâ€™s
  /// main frame.
  func forMainFrame(pigeonApi: PigeonApiWKNavigationResponse, pigeonInstance: WKNavigationResponse) throws -> Bool
}

protocol PigeonApiProtocolWKNavigationResponse {
}

final class PigeonApiWKNavigationResponse: PigeonApiProtocolWKNavigationResponse  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKNavigationResponse
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKNavigationResponse) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of WKNavigationResponse and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKNavigationResponse, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let responseArg = try! pigeonDelegate.response(pigeonApi: self, pigeonInstance: pigeonInstance)
    let forMainFrameArg = try! pigeonDelegate.forMainFrame(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationResponse.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, responseArg, forMainFrameArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit


/// ProxyApi implementation for [WKNavigationResponse].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class NavigationResponseProxyAPIDelegate : PigeonApiDelegateWKNavigationResponse {
  func response(pigeonApi: PigeonApiWKNavigationResponse, pigeonInstance: WKNavigationResponse) throws -> HTTPURLResponse {
    return pigeon_instance.response
  }

  func forMainFrame(pigeonApi: PigeonApiWKNavigationResponse, pigeonInstance: WKNavigationResponse) throws -> Bool {
    return pigeon_instance.forMainFrame
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class NavigationResponseProxyApiTests: XCTestCase {
  func testResponse() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKNavigationResponse(registrar)

    let instance = TestNavigationResponse()
    let value = try? api.pigeonDelegate.response(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.response)
  }

  func testForMainFrame() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKNavigationResponse(registrar)

    let instance = TestNavigationResponse()
    let value = try? api.pigeonDelegate.forMainFrame(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.forMainFrame)
  }

}
*/

protocol PigeonApiDelegateWKFrameInfo {
  /// A Boolean value indicating whether the frame is the web site's main frame
  /// or a subframe.
  func isMainFrame(pigeonApi: PigeonApiWKFrameInfo, pigeonInstance: WKFrameInfo) throws -> Bool
  /// The frameâ€™s current request.
  func request(pigeonApi: PigeonApiWKFrameInfo, pigeonInstance: WKFrameInfo) throws -> URLRequestWrapper
}

protocol PigeonApiProtocolWKFrameInfo {
}

final class PigeonApiWKFrameInfo: PigeonApiProtocolWKFrameInfo  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKFrameInfo
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKFrameInfo) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of WKFrameInfo and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKFrameInfo, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let isMainFrameArg = try! pigeonDelegate.isMainFrame(pigeonApi: self, pigeonInstance: pigeonInstance)
    let requestArg = try! pigeonDelegate.request(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKFrameInfo.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, isMainFrameArg, requestArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit


/// ProxyApi implementation for [WKFrameInfo].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class FrameInfoProxyAPIDelegate : PigeonApiDelegateWKFrameInfo {
  func isMainFrame(pigeonApi: PigeonApiWKFrameInfo, pigeonInstance: WKFrameInfo) throws -> Bool {
    return pigeon_instance.isMainFrame
  }

  func request(pigeonApi: PigeonApiWKFrameInfo, pigeonInstance: WKFrameInfo) throws -> URLRequestWrapper {
    return pigeon_instance.request
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class FrameInfoProxyApiTests: XCTestCase {
  func testIsMainFrame() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKFrameInfo(registrar)

    let instance = TestFrameInfo()
    let value = try? api.pigeonDelegate.isMainFrame(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.isMainFrame)
  }

  func testRequest() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKFrameInfo(registrar)

    let instance = TestFrameInfo()
    let value = try? api.pigeonDelegate.request(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.request)
  }

}
*/

protocol PigeonApiDelegateNSError {
  /// The error code.
  func code(pigeonApi: PigeonApiNSError, pigeonInstance: NSError) throws -> Int64
  /// A string containing the error domain.
  func domain(pigeonApi: PigeonApiNSError, pigeonInstance: NSError) throws -> String
  /// The user info dictionary.
  func userInfo(pigeonApi: PigeonApiNSError, pigeonInstance: NSError) throws -> [String: Any?]
}

protocol PigeonApiProtocolNSError {
}

final class PigeonApiNSError: PigeonApiProtocolNSError  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateNSError
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateNSError) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of NSError and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: NSError, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let codeArg = try! pigeonDelegate.code(pigeonApi: self, pigeonInstance: pigeonInstance)
    let domainArg = try! pigeonDelegate.domain(pigeonApi: self, pigeonInstance: pigeonInstance)
    let userInfoArg = try! pigeonDelegate.userInfo(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.NSError.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, codeArg, domainArg, userInfoArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation



/// ProxyApi implementation for [NSError].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class ErrorProxyAPIDelegate : PigeonApiDelegateNSError {
  func code(pigeonApi: PigeonApiNSError, pigeonInstance: NSError) throws -> Int64 {
    return pigeon_instance.code
  }

  func domain(pigeonApi: PigeonApiNSError, pigeonInstance: NSError) throws -> String {
    return pigeon_instance.domain
  }

  func userInfo(pigeonApi: PigeonApiNSError, pigeonInstance: NSError) throws -> [String: Any?] {
    return pigeon_instance.userInfo
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class ErrorProxyApiTests: XCTestCase {
  func testCode() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiNSError(registrar)

    let instance = TestError()
    let value = try? api.pigeonDelegate.code(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.code)
  }

  func testDomain() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiNSError(registrar)

    let instance = TestError()
    let value = try? api.pigeonDelegate.domain(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.domain)
  }

  func testUserInfo() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiNSError(registrar)

    let instance = TestError()
    let value = try? api.pigeonDelegate.userInfo(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.userInfo)
  }

}
*/

protocol PigeonApiDelegateWKScriptMessage {
  /// The name of the message handler to which the message is sent.
  func name(pigeonApi: PigeonApiWKScriptMessage, pigeonInstance: WKScriptMessage) throws -> String
  /// The body of the message.
  func body(pigeonApi: PigeonApiWKScriptMessage, pigeonInstance: WKScriptMessage) throws -> Any?
}

protocol PigeonApiProtocolWKScriptMessage {
}

final class PigeonApiWKScriptMessage: PigeonApiProtocolWKScriptMessage  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKScriptMessage
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKScriptMessage) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of WKScriptMessage and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKScriptMessage, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let nameArg = try! pigeonDelegate.name(pigeonApi: self, pigeonInstance: pigeonInstance)
    let bodyArg = try! pigeonDelegate.body(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKScriptMessage.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, nameArg, bodyArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit


/// ProxyApi implementation for [WKScriptMessage].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class ScriptMessageProxyAPIDelegate : PigeonApiDelegateWKScriptMessage {
  func name(pigeonApi: PigeonApiWKScriptMessage, pigeonInstance: WKScriptMessage) throws -> String {
    return pigeon_instance.name
  }

  func body(pigeonApi: PigeonApiWKScriptMessage, pigeonInstance: WKScriptMessage) throws -> Any? {
    return pigeon_instance.body
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class ScriptMessageProxyApiTests: XCTestCase {
  func testName() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKScriptMessage(registrar)

    let instance = TestScriptMessage()
    let value = try? api.pigeonDelegate.name(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.name)
  }

  func testBody() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKScriptMessage(registrar)

    let instance = TestScriptMessage()
    let value = try? api.pigeonDelegate.body(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.body)
  }

}
*/

protocol PigeonApiDelegateWKSecurityOrigin {
  /// The security originâ€™s host.
  func host(pigeonApi: PigeonApiWKSecurityOrigin, pigeonInstance: WKSecurityOrigin) throws -> String
  /// The security origin's port.
  func port(pigeonApi: PigeonApiWKSecurityOrigin, pigeonInstance: WKSecurityOrigin) throws -> Int64
  /// The security origin's protocol.
  func securityProtocol(pigeonApi: PigeonApiWKSecurityOrigin, pigeonInstance: WKSecurityOrigin) throws -> String
}

protocol PigeonApiProtocolWKSecurityOrigin {
}

final class PigeonApiWKSecurityOrigin: PigeonApiProtocolWKSecurityOrigin  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKSecurityOrigin
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKSecurityOrigin) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of WKSecurityOrigin and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKSecurityOrigin, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let hostArg = try! pigeonDelegate.host(pigeonApi: self, pigeonInstance: pigeonInstance)
    let portArg = try! pigeonDelegate.port(pigeonApi: self, pigeonInstance: pigeonInstance)
    let securityProtocolArg = try! pigeonDelegate.securityProtocol(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKSecurityOrigin.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, hostArg, portArg, securityProtocolArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit


/// ProxyApi implementation for [WKSecurityOrigin].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class SecurityOriginProxyAPIDelegate : PigeonApiDelegateWKSecurityOrigin {
  func host(pigeonApi: PigeonApiWKSecurityOrigin, pigeonInstance: WKSecurityOrigin) throws -> String {
    return pigeon_instance.host
  }

  func port(pigeonApi: PigeonApiWKSecurityOrigin, pigeonInstance: WKSecurityOrigin) throws -> Int64 {
    return pigeon_instance.port
  }

  func securityProtocol(pigeonApi: PigeonApiWKSecurityOrigin, pigeonInstance: WKSecurityOrigin) throws -> String {
    return pigeon_instance.securityProtocol
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class SecurityOriginProxyApiTests: XCTestCase {
  func testHost() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKSecurityOrigin(registrar)

    let instance = TestSecurityOrigin()
    let value = try? api.pigeonDelegate.host(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.host)
  }

  func testPort() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKSecurityOrigin(registrar)

    let instance = TestSecurityOrigin()
    let value = try? api.pigeonDelegate.port(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.port)
  }

  func testSecurityProtocol() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKSecurityOrigin(registrar)

    let instance = TestSecurityOrigin()
    let value = try? api.pigeonDelegate.securityProtocol(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.securityProtocol)
  }

}
*/

protocol PigeonApiDelegateHTTPCookie {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiHTTPCookie, properties: [HttpCookiePropertyKey: Any?]) throws -> HTTPCookie
  /// The cookieâ€™s properties.
  func properties(pigeonApi: PigeonApiHTTPCookie, pigeonInstance: HTTPCookie) throws -> [HttpCookiePropertyKey: Any?]
}

protocol PigeonApiProtocolHTTPCookie {
}

final class PigeonApiHTTPCookie: PigeonApiProtocolHTTPCookie  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateHTTPCookie
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateHTTPCookie) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiHTTPCookie?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.HTTPCookie.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let propertiesArg = args[1] as? [HttpCookiePropertyKey: Any?]
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, properties: propertiesArg!),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of HTTPCookie and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: HTTPCookie, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let propertiesArg = try! pigeonDelegate.properties(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.HTTPCookie.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, propertiesArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation



/// ProxyApi implementation for [HTTPCookie].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class CookieProxyAPIDelegate : PigeonApiDelegateHTTPCookie {
  func pigeon_defaultConstructor(pigeonApi: PigeonApiHTTPCookie, properties: [HttpCookiePropertyKey: Any?]) throws -> HTTPCookie {
    return HTTPCookie()
  }

  func properties(pigeonApi: PigeonApiHTTPCookie, pigeonInstance: HTTPCookie) throws -> [HttpCookiePropertyKey: Any?] {
    return pigeon_instance.properties
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class CookieProxyApiTests: XCTestCase {
  func testPigeonDefaultConstructor() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiHTTPCookie(registrar)

    let instance = try? api.pigeonDefaultConstructor(pigeonApi: api properties: [.comment: -1])
    XCTAssertNotNil(instance)
  }

  func testProperties() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiHTTPCookie(registrar)

    let instance = TestCookie()
    let value = try? api.pigeonDelegate.properties(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.properties)
  }

}
*/

protocol PigeonApiDelegateAuthenticationChallengeResponse {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiAuthenticationChallengeResponse, disposition: UrlSessionAuthChallengeDisposition, credential: URLCredential?) throws -> AuthenticationChallengeResponse
  /// The option to use to handle the challenge.
  func disposition(pigeonApi: PigeonApiAuthenticationChallengeResponse, pigeonInstance: AuthenticationChallengeResponse) throws -> UrlSessionAuthChallengeDisposition
  /// The credential to use for authentication when the disposition parameter
  /// contains the value URLSession.AuthChallengeDisposition.useCredential.
  func credential(pigeonApi: PigeonApiAuthenticationChallengeResponse, pigeonInstance: AuthenticationChallengeResponse) throws -> URLCredential?
}

protocol PigeonApiProtocolAuthenticationChallengeResponse {
}

final class PigeonApiAuthenticationChallengeResponse: PigeonApiProtocolAuthenticationChallengeResponse  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAuthenticationChallengeResponse
  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAuthenticationChallengeResponse) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiAuthenticationChallengeResponse?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.AuthenticationChallengeResponse.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let dispositionArg = args[1] as! UrlSessionAuthChallengeDisposition
        let credentialArg: URLCredential? = nilOrValue(args[2])
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, disposition: dispositionArg, credential: credentialArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of AuthenticationChallengeResponse and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AuthenticationChallengeResponse, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let dispositionArg = try! pigeonDelegate.disposition(pigeonApi: self, pigeonInstance: pigeonInstance)
    let credentialArg = try! pigeonDelegate.credential(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.AuthenticationChallengeResponse.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, dispositionArg, credentialArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation



/// ProxyApi implementation for [AuthenticationChallengeResponse].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class AuthenticationChallengeResponseProxyAPIDelegate : PigeonApiDelegateAuthenticationChallengeResponse {
  func pigeon_defaultConstructor(pigeonApi: PigeonApiAuthenticationChallengeResponse, disposition: UrlSessionAuthChallengeDisposition, credential: URLCredential?) throws -> AuthenticationChallengeResponse {
    return AuthenticationChallengeResponse()
  }

  func disposition(pigeonApi: PigeonApiAuthenticationChallengeResponse, pigeonInstance: AuthenticationChallengeResponse) throws -> UrlSessionAuthChallengeDisposition {
    switch pigeon_instance.disposition {
      case .useCredential
        return .useCredential
            case .performDefaultHandling
        return .performDefaultHandling
            case .cancelAuthenticationChallenge
        return .cancelAuthenticationChallenge
            case .rejectProtectionSpace
        return .rejectProtectionSpace
            @unknown default:
        return .unknown
      
    }
  }

  func credential(pigeonApi: PigeonApiAuthenticationChallengeResponse, pigeonInstance: AuthenticationChallengeResponse) throws -> URLCredential? {
    return pigeon_instance.credential
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class AuthenticationChallengeResponseProxyApiTests: XCTestCase {
  func testPigeonDefaultConstructor() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiAuthenticationChallengeResponse(registrar)

    let instance = try? api.pigeonDefaultConstructor(pigeonApi: api disposition: .useCredential, credential: TestCredential)
    XCTAssertNotNil(instance)
  }

  func testDisposition() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiAuthenticationChallengeResponse(registrar)

    let instance = TestAuthenticationChallengeResponse()
    let value = try? api.pigeonDelegate.disposition(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.disposition)
  }

  func testCredential() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiAuthenticationChallengeResponse(registrar)

    let instance = TestAuthenticationChallengeResponse()
    let value = try? api.pigeonDelegate.credential(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.credential)
  }

}
*/

protocol PigeonApiDelegateWKWebsiteDataStore {
  /// The default data store, which stores data persistently to disk.
  func defaultDataStore(pigeonApi: PigeonApiWKWebsiteDataStore) throws -> WKWebsiteDataStore
  /// The object that manages the HTTP cookies for your website.
  func httpCookieStore(pigeonApi: PigeonApiWKWebsiteDataStore, pigeonInstance: WKWebsiteDataStore) throws -> WKHTTPCookieStore
  /// Removes the specified types of website data from one or more data records.
  func removeDataOfTypes(pigeonApi: PigeonApiWKWebsiteDataStore, pigeonInstance: WKWebsiteDataStore, dataTypes: [WebsiteDataType], modificationTimeInSecondsSinceEpoch: Double, completion: @escaping (Result<Bool, Error>) -> Void)
}

protocol PigeonApiProtocolWKWebsiteDataStore {
}

final class PigeonApiWKWebsiteDataStore: PigeonApiProtocolWKWebsiteDataStore  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKWebsiteDataStore
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKWebsiteDataStore) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKWebsiteDataStore?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let defaultDataStoreChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebsiteDataStore.defaultDataStore", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      defaultDataStoreChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.defaultDataStore(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      defaultDataStoreChannel.setMessageHandler(nil)
    }
    let httpCookieStoreChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebsiteDataStore.httpCookieStore", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      httpCookieStoreChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebsiteDataStore
        let pigeonIdentifierArg = args[1] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.httpCookieStore(pigeonApi: api, pigeonInstance: pigeonInstanceArg), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      httpCookieStoreChannel.setMessageHandler(nil)
    }
    let removeDataOfTypesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebsiteDataStore.removeDataOfTypes", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeDataOfTypesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebsiteDataStore
        let dataTypesArg = args[1] as! [WebsiteDataType]
        let modificationTimeInSecondsSinceEpochArg = args[2] as! Double
        api.pigeonDelegate.removeDataOfTypes(pigeonApi: api, pigeonInstance: pigeonInstanceArg, dataTypes: dataTypesArg, modificationTimeInSecondsSinceEpoch: modificationTimeInSecondsSinceEpochArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeDataOfTypesChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKWebsiteDataStore and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKWebsiteDataStore, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebsiteDataStore.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit
import WebKit


/// ProxyApi implementation for [WKWebsiteDataStore].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class WebsiteDataStoreProxyAPIDelegate : PigeonApiDelegateWKWebsiteDataStore {
  func defaultDataStore(pigeonApi: PigeonApiWKWebsiteDataStore): WKWebsiteDataStore {
    return WKWebsiteDataStore.defaultDataStore
  }

  func httpCookieStore(pigeonApi: PigeonApiWKWebsiteDataStore, pigeon_instance: WKWebsiteDataStore): WKHTTPCookieStore {
    return pigeon_instance.httpCookieStore
  }

  func removeDataOfTypes(pigeonApi: PigeonApiWKWebsiteDataStore, pigeonInstance: WKWebsiteDataStore, dataTypes: [WebsiteDataType], modificationTimeInSecondsSinceEpoch: Double, completion: @escaping (Result<Bool, Error>) -> Void) {
    return pigeonInstance.removeDataOfTypes(dataTypes: dataTypes, modificationTimeInSecondsSinceEpoch: modificationTimeInSecondsSinceEpoch)
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class WebsiteDataStoreProxyApiTests: XCTestCase {
  func testHttpCookieStore() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebsiteDataStore(registrar)

    let instance = TestWebsiteDataStore()
    let value = try? api.pigeonDelegate.httpCookieStore(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.httpCookieStore)
  }

  func testRemoveDataOfTypes() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebsiteDataStore(registrar)

    let instance = TestWebsiteDataStore()
    let dataTypes = [.cookies]
    let modificationTimeInSecondsSinceEpoch = 1.0
    let value = api.pigeonDelegate.removeDataOfTypes(pigeonApi: api, pigeonInstance: instance, dataTypes: dataTypes, modificationTimeInSecondsSinceEpoch: modificationTimeInSecondsSinceEpoch)

    XCTAssertEqual(instance.removeDataOfTypesArgs, [dataTypes, modificationTimeInSecondsSinceEpoch])
    XCTAssertEqual(value, instance.removeDataOfTypes(dataTypes: dataTypes, modificationTimeInSecondsSinceEpoch: modificationTimeInSecondsSinceEpoch))
  }

}
class TestWebsiteDataStore: WKWebsiteDataStore {
  private var httpCookieStoreTestValue = TestCookieStore
  var removeDataOfTypesArgs: [AnyHashable?]? = nil

  override var httpCookieStore: WKHTTPCookieStore {
    return httpCookieStoreTestValue
  }

  override func removeDataOfTypes() {
    removeDataOfTypesArgs = [dataTypes, modificationTimeInSecondsSinceEpoch]
    return true
  }
}
*/

protocol PigeonApiDelegateUIView {
  #if !os(macOS)
  /// The viewâ€™s background color.
  func setBackgroundColor(pigeonApi: PigeonApiUIView, pigeonInstance: UIView, value: Int64?) throws
  #endif
  #if !os(macOS)
  /// A Boolean value that determines whether the view is opaque.
  func setOpaque(pigeonApi: PigeonApiUIView, pigeonInstance: UIView, opaque: Bool) throws
  #endif
}

protocol PigeonApiProtocolUIView {
}

final class PigeonApiUIView: PigeonApiProtocolUIView  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateUIView
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateUIView) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiUIView?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    #if !os(macOS)
    let setBackgroundColorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.UIView.setBackgroundColor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setBackgroundColorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! UIView
        let valueArg: Int64? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setBackgroundColor(pigeonApi: api, pigeonInstance: pigeonInstanceArg, value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setBackgroundColorChannel.setMessageHandler(nil)
    }
    #endif
    #if !os(macOS)
    let setOpaqueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.UIView.setOpaque", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setOpaqueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! UIView
        let opaqueArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setOpaque(pigeonApi: api, pigeonInstance: pigeonInstanceArg, opaque: opaqueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setOpaqueChannel.setMessageHandler(nil)
    }
    #endif
  }

  #if !os(macOS)
  ///Creates a Dart instance of UIView and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: UIView, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.UIView.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  #endif
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import UIKit


/// ProxyApi implementation for [UIView].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class ViewProxyAPIDelegate : PigeonApiDelegateUIView {
  func setBackgroundColor(pigeonApi: PigeonApiUIView, pigeonInstance: UIView, value: Int64?) throws {
    pigeonInstance.setBackgroundColor(value: value)
  }

  func setOpaque(pigeonApi: PigeonApiUIView, pigeonInstance: UIView, opaque: Bool) throws {
    pigeonInstance.setOpaque(opaque: opaque)
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import UIKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class ViewProxyApiTests: XCTestCase {
  func testSetBackgroundColor() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiUIView(registrar)

    let instance = TestView()
    let value = 0
    api.pigeonDelegate.setBackgroundColor(pigeonApi: api, pigeonInstance: instance, value: value)

    XCTAssertEqual(instance.setBackgroundColorArgs, [value])
  }

  func testSetOpaque() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiUIView(registrar)

    let instance = TestView()
    let opaque = true
    api.pigeonDelegate.setOpaque(pigeonApi: api, pigeonInstance: instance, opaque: opaque)

    XCTAssertEqual(instance.setOpaqueArgs, [opaque])
  }

}
class TestView: UIView {
  var setBackgroundColorArgs: [AnyHashable?]? = nil
  var setOpaqueArgs: [AnyHashable?]? = nil


  override func setBackgroundColor() {
    setBackgroundColorArgs = [value]
  }
  override func setOpaque() {
    setOpaqueArgs = [opaque]
  }
}
*/

protocol PigeonApiDelegateUIScrollView {
  #if !os(macOS)
  /// The point at which the origin of the content view is offset from the
  /// origin of the scroll view.
  func getContentOffset(pigeonApi: PigeonApiUIScrollView, pigeonInstance: UIScrollView) throws -> [Double]
  #endif
  #if !os(macOS)
  /// Move the scrolled position of your view.
  ///
  /// Convenience method to synchronize change to the x and y scroll position.
  func scrollBy(pigeonApi: PigeonApiUIScrollView, pigeonInstance: UIScrollView, x: Double, y: Double) throws
  #endif
  #if !os(macOS)
  /// The point at which the origin of the content view is offset from the
  /// origin of the scroll view.
  func setContentOffset(pigeonApi: PigeonApiUIScrollView, pigeonInstance: UIScrollView, x: Double, y: Double) throws
  #endif
  #if !os(macOS)
  /// The delegate of the scroll view.
  func setDelegate(pigeonApi: PigeonApiUIScrollView, pigeonInstance: UIScrollView, delegate: UIScrollViewDelegate?) throws
  #endif
}

protocol PigeonApiProtocolUIScrollView {
}

final class PigeonApiUIScrollView: PigeonApiProtocolUIScrollView  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateUIScrollView
  ///An implementation of [UIView] used to access callback methods
  var pigeonApiUIView: PigeonApiUIView {
    return pigeonRegistrar.apiDelegate.pigeonApiUIView(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateUIScrollView) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiUIScrollView?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    #if !os(macOS)
    let getContentOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollView.getContentOffset", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getContentOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! UIScrollView
        do {
          let result = try api.pigeonDelegate.getContentOffset(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getContentOffsetChannel.setMessageHandler(nil)
    }
    #endif
    #if !os(macOS)
    let scrollByChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollView.scrollBy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      scrollByChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! UIScrollView
        let xArg = args[1] as! Double
        let yArg = args[2] as! Double
        do {
          try api.pigeonDelegate.scrollBy(pigeonApi: api, pigeonInstance: pigeonInstanceArg, x: xArg, y: yArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      scrollByChannel.setMessageHandler(nil)
    }
    #endif
    #if !os(macOS)
    let setContentOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollView.setContentOffset", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setContentOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! UIScrollView
        let xArg = args[1] as! Double
        let yArg = args[2] as! Double
        do {
          try api.pigeonDelegate.setContentOffset(pigeonApi: api, pigeonInstance: pigeonInstanceArg, x: xArg, y: yArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setContentOffsetChannel.setMessageHandler(nil)
    }
    #endif
    #if !os(macOS)
    let setDelegateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollView.setDelegate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setDelegateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! UIScrollView
        let delegateArg: UIScrollViewDelegate? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setDelegate(pigeonApi: api, pigeonInstance: pigeonInstanceArg, delegate: delegateArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setDelegateChannel.setMessageHandler(nil)
    }
    #endif
  }

  #if !os(macOS)
  ///Creates a Dart instance of UIScrollView and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: UIScrollView, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollView.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  #endif
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import UIKit
import UIKit


/// ProxyApi implementation for [UIScrollView].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class ScrollViewProxyAPIDelegate : PigeonApiDelegateUIScrollView {
  func getContentOffset(pigeonApi: PigeonApiUIScrollView, pigeonInstance: UIScrollView) throws -> [Double] {
    return pigeonInstance.getContentOffset()
  }

  func scrollBy(pigeonApi: PigeonApiUIScrollView, pigeonInstance: UIScrollView, x: Double, y: Double) throws {
    pigeonInstance.scrollBy(x: x, y: y)
  }

  func setContentOffset(pigeonApi: PigeonApiUIScrollView, pigeonInstance: UIScrollView, x: Double, y: Double) throws {
    pigeonInstance.setContentOffset(x: x, y: y)
  }

  func setDelegate(pigeonApi: PigeonApiUIScrollView, pigeonInstance: UIScrollView, delegate: UIScrollViewDelegate?) throws {
    pigeonInstance.setDelegate(delegate: delegate)
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import UIKit
import UIKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class ScrollViewProxyApiTests: XCTestCase {
  func testGetContentOffset() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiUIScrollView(registrar)

    let instance = TestScrollView()
    let value = api.pigeonDelegate.getContentOffset(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getContentOffsetCalled)
    XCTAssertEqual(value, instance.getContentOffset())
  }

  func testScrollBy() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiUIScrollView(registrar)

    let instance = TestScrollView()
    let x = 1.0
    let y = 1.0
    api.pigeonDelegate.scrollBy(pigeonApi: api, pigeonInstance: instance, x: x, y: y)

    XCTAssertEqual(instance.scrollByArgs, [x, y])
  }

  func testSetContentOffset() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiUIScrollView(registrar)

    let instance = TestScrollView()
    let x = 1.0
    let y = 1.0
    api.pigeonDelegate.setContentOffset(pigeonApi: api, pigeonInstance: instance, x: x, y: y)

    XCTAssertEqual(instance.setContentOffsetArgs, [x, y])
  }

  func testSetDelegate() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiUIScrollView(registrar)

    let instance = TestScrollView()
    let delegate = TestScrollViewDelegate
    api.pigeonDelegate.setDelegate(pigeonApi: api, pigeonInstance: instance, delegate: delegate)

    XCTAssertEqual(instance.setDelegateArgs, [delegate])
  }

}
class TestScrollView: UIScrollView {
  var getContentOffsetCalled = false
  var scrollByArgs: [AnyHashable?]? = nil
  var setContentOffsetArgs: [AnyHashable?]? = nil
  var setDelegateArgs: [AnyHashable?]? = nil


  override func getContentOffset() {
    getContentOffsetCalled = true
  }
  override func scrollBy() {
    scrollByArgs = [x, y]
  }
  override func setContentOffset() {
    setContentOffsetArgs = [x, y]
  }
  override func setDelegate() {
    setDelegateArgs = [delegate]
  }
}
*/

protocol PigeonApiDelegateWKWebViewConfiguration {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiWKWebViewConfiguration) throws -> WKWebViewConfiguration
  /// The object that coordinates interactions between your appâ€™s native code
  /// and the webpageâ€™s scripts and other content.
  func setUserContentController(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, controller: WKUserContentController) throws
  /// The object that coordinates interactions between your appâ€™s native code
  /// and the webpageâ€™s scripts and other content.
  func getUserContentController(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration) throws -> WKUserContentController
  /// The object you use to get and set the siteâ€™s cookies and to track the
  /// cached data objects.
  func setWebsiteDataStore(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, dataStore: WKWebsiteDataStore) throws
  /// The object you use to get and set the siteâ€™s cookies and to track the
  /// cached data objects.
  func getWebsiteDataStore(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration) throws -> WKWebsiteDataStore
  /// The object that manages the preference-related settings for the web view.
  func setPreferences(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, controller: WKPreferences) throws
  /// The object that manages the preference-related settings for the web view.
  func getUserPreferences(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration) throws -> WKPreferences
  /// A Boolean value that indicates whether HTML5 videos play inline or use the
  /// native full-screen controller.
  func setAllowsInlineMediaPlayback(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, allow: Bool) throws
  /// A Boolean value that indicates whether the web view limits navigation to
  /// pages within the appâ€™s domain.
  func setLimitsNavigationsToAppBoundDomains(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, limit: Bool) throws
  /// The media types that require a user gesture to begin playing.
  func setMediaTypesRequiringUserActionForPlayback(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, types: [AudiovisualMediaType]) throws
}

protocol PigeonApiProtocolWKWebViewConfiguration {
}

final class PigeonApiWKWebViewConfiguration: PigeonApiProtocolWKWebViewConfiguration  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKWebViewConfiguration
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKWebViewConfiguration) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKWebViewConfiguration?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let setUserContentControllerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.setUserContentController", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setUserContentControllerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebViewConfiguration
        let controllerArg = args[1] as! WKUserContentController
        do {
          try api.pigeonDelegate.setUserContentController(pigeonApi: api, pigeonInstance: pigeonInstanceArg, controller: controllerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setUserContentControllerChannel.setMessageHandler(nil)
    }
    let getUserContentControllerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.getUserContentController", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getUserContentControllerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebViewConfiguration
        do {
          let result = try api.pigeonDelegate.getUserContentController(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getUserContentControllerChannel.setMessageHandler(nil)
    }
    let setWebsiteDataStoreChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.setWebsiteDataStore", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setWebsiteDataStoreChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebViewConfiguration
        let dataStoreArg = args[1] as! WKWebsiteDataStore
        do {
          try api.pigeonDelegate.setWebsiteDataStore(pigeonApi: api, pigeonInstance: pigeonInstanceArg, dataStore: dataStoreArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setWebsiteDataStoreChannel.setMessageHandler(nil)
    }
    let getWebsiteDataStoreChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.getWebsiteDataStore", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getWebsiteDataStoreChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebViewConfiguration
        do {
          let result = try api.pigeonDelegate.getWebsiteDataStore(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getWebsiteDataStoreChannel.setMessageHandler(nil)
    }
    let setPreferencesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.setPreferences", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPreferencesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebViewConfiguration
        let controllerArg = args[1] as! WKPreferences
        do {
          try api.pigeonDelegate.setPreferences(pigeonApi: api, pigeonInstance: pigeonInstanceArg, controller: controllerArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPreferencesChannel.setMessageHandler(nil)
    }
    let getUserPreferencesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.getUserPreferences", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getUserPreferencesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebViewConfiguration
        do {
          let result = try api.pigeonDelegate.getUserPreferences(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getUserPreferencesChannel.setMessageHandler(nil)
    }
    let setAllowsInlineMediaPlaybackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.setAllowsInlineMediaPlayback", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAllowsInlineMediaPlaybackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebViewConfiguration
        let allowArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setAllowsInlineMediaPlayback(pigeonApi: api, pigeonInstance: pigeonInstanceArg, allow: allowArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAllowsInlineMediaPlaybackChannel.setMessageHandler(nil)
    }
    let setLimitsNavigationsToAppBoundDomainsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.setLimitsNavigationsToAppBoundDomains", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLimitsNavigationsToAppBoundDomainsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebViewConfiguration
        let limitArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setLimitsNavigationsToAppBoundDomains(pigeonApi: api, pigeonInstance: pigeonInstanceArg, limit: limitArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLimitsNavigationsToAppBoundDomainsChannel.setMessageHandler(nil)
    }
    let setMediaTypesRequiringUserActionForPlaybackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.setMediaTypesRequiringUserActionForPlayback", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setMediaTypesRequiringUserActionForPlaybackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebViewConfiguration
        let typesArg = args[1] as! [AudiovisualMediaType]
        do {
          try api.pigeonDelegate.setMediaTypesRequiringUserActionForPlayback(pigeonApi: api, pigeonInstance: pigeonInstanceArg, types: typesArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMediaTypesRequiringUserActionForPlaybackChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKWebViewConfiguration and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKWebViewConfiguration, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit
import WebKit
import WebKit
import WebKit


/// ProxyApi implementation for [WKWebViewConfiguration].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class WebViewConfigurationProxyAPIDelegate : PigeonApiDelegateWKWebViewConfiguration {
  func pigeon_defaultConstructor(pigeonApi: PigeonApiWKWebViewConfiguration) throws -> WKWebViewConfiguration {
    return WKWebViewConfiguration()
  }

  func setUserContentController(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, controller: WKUserContentController) throws {
    pigeonInstance.setUserContentController(controller: controller)
  }

  func getUserContentController(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration) throws -> WKUserContentController {
    return pigeonInstance.getUserContentController()
  }

  func setWebsiteDataStore(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, dataStore: WKWebsiteDataStore) throws {
    pigeonInstance.setWebsiteDataStore(dataStore: dataStore)
  }

  func getWebsiteDataStore(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration) throws -> WKWebsiteDataStore {
    return pigeonInstance.getWebsiteDataStore()
  }

  func setPreferences(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, controller: WKPreferences) throws {
    pigeonInstance.setPreferences(controller: controller)
  }

  func getUserPreferences(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration) throws -> WKPreferences {
    return pigeonInstance.getUserPreferences()
  }

  func setAllowsInlineMediaPlayback(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, allow: Bool) throws {
    pigeonInstance.setAllowsInlineMediaPlayback(allow: allow)
  }

  func setLimitsNavigationsToAppBoundDomains(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, limit: Bool) throws {
    pigeonInstance.setLimitsNavigationsToAppBoundDomains(limit: limit)
  }

  func setMediaTypesRequiringUserActionForPlayback(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, types: [AudiovisualMediaType]) throws {
    pigeonInstance.setMediaTypesRequiringUserActionForPlayback(types: types)
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import WebKit
import WebKit
import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class WebViewConfigurationProxyApiTests: XCTestCase {
  func testPigeonDefaultConstructor() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebViewConfiguration(registrar)

    let instance = try? api.pigeonDefaultConstructor(pigeonApi: api )
    XCTAssertNotNil(instance)
  }

  func testSetUserContentController() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebViewConfiguration(registrar)

    let instance = TestWebViewConfiguration()
    let controller = TestUserContentController
    api.pigeonDelegate.setUserContentController(pigeonApi: api, pigeonInstance: instance, controller: controller)

    XCTAssertEqual(instance.setUserContentControllerArgs, [controller])
  }

  func testGetUserContentController() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebViewConfiguration(registrar)

    let instance = TestWebViewConfiguration()
    let value = api.pigeonDelegate.getUserContentController(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getUserContentControllerCalled)
    XCTAssertEqual(value, instance.getUserContentController())
  }

  func testSetWebsiteDataStore() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebViewConfiguration(registrar)

    let instance = TestWebViewConfiguration()
    let dataStore = TestWebsiteDataStore
    api.pigeonDelegate.setWebsiteDataStore(pigeonApi: api, pigeonInstance: instance, dataStore: dataStore)

    XCTAssertEqual(instance.setWebsiteDataStoreArgs, [dataStore])
  }

  func testGetWebsiteDataStore() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebViewConfiguration(registrar)

    let instance = TestWebViewConfiguration()
    let value = api.pigeonDelegate.getWebsiteDataStore(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getWebsiteDataStoreCalled)
    XCTAssertEqual(value, instance.getWebsiteDataStore())
  }

  func testSetPreferences() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebViewConfiguration(registrar)

    let instance = TestWebViewConfiguration()
    let controller = TestPreferences
    api.pigeonDelegate.setPreferences(pigeonApi: api, pigeonInstance: instance, controller: controller)

    XCTAssertEqual(instance.setPreferencesArgs, [controller])
  }

  func testGetUserPreferences() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebViewConfiguration(registrar)

    let instance = TestWebViewConfiguration()
    let value = api.pigeonDelegate.getUserPreferences(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getUserPreferencesCalled)
    XCTAssertEqual(value, instance.getUserPreferences())
  }

  func testSetAllowsInlineMediaPlayback() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebViewConfiguration(registrar)

    let instance = TestWebViewConfiguration()
    let allow = true
    api.pigeonDelegate.setAllowsInlineMediaPlayback(pigeonApi: api, pigeonInstance: instance, allow: allow)

    XCTAssertEqual(instance.setAllowsInlineMediaPlaybackArgs, [allow])
  }

  func testSetLimitsNavigationsToAppBoundDomains() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebViewConfiguration(registrar)

    let instance = TestWebViewConfiguration()
    let limit = true
    api.pigeonDelegate.setLimitsNavigationsToAppBoundDomains(pigeonApi: api, pigeonInstance: instance, limit: limit)

    XCTAssertEqual(instance.setLimitsNavigationsToAppBoundDomainsArgs, [limit])
  }

  func testSetMediaTypesRequiringUserActionForPlayback() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebViewConfiguration(registrar)

    let instance = TestWebViewConfiguration()
    let types = [.none]
    api.pigeonDelegate.setMediaTypesRequiringUserActionForPlayback(pigeonApi: api, pigeonInstance: instance, types: types)

    XCTAssertEqual(instance.setMediaTypesRequiringUserActionForPlaybackArgs, [types])
  }

}
class TestWebViewConfiguration: WKWebViewConfiguration {
  var setUserContentControllerArgs: [AnyHashable?]? = nil
  var getUserContentControllerCalled = false
  var setWebsiteDataStoreArgs: [AnyHashable?]? = nil
  var getWebsiteDataStoreCalled = false
  var setPreferencesArgs: [AnyHashable?]? = nil
  var getUserPreferencesCalled = false
  var setAllowsInlineMediaPlaybackArgs: [AnyHashable?]? = nil
  var setLimitsNavigationsToAppBoundDomainsArgs: [AnyHashable?]? = nil
  var setMediaTypesRequiringUserActionForPlaybackArgs: [AnyHashable?]? = nil


  override func setUserContentController() {
    setUserContentControllerArgs = [controller]
  }
  override func getUserContentController() {
    getUserContentControllerCalled = true
  }
  override func setWebsiteDataStore() {
    setWebsiteDataStoreArgs = [dataStore]
  }
  override func getWebsiteDataStore() {
    getWebsiteDataStoreCalled = true
  }
  override func setPreferences() {
    setPreferencesArgs = [controller]
  }
  override func getUserPreferences() {
    getUserPreferencesCalled = true
  }
  override func setAllowsInlineMediaPlayback() {
    setAllowsInlineMediaPlaybackArgs = [allow]
  }
  override func setLimitsNavigationsToAppBoundDomains() {
    setLimitsNavigationsToAppBoundDomainsArgs = [limit]
  }
  override func setMediaTypesRequiringUserActionForPlayback() {
    setMediaTypesRequiringUserActionForPlaybackArgs = [types]
  }
}
*/

protocol PigeonApiDelegateWKUserContentController {
  /// Installs a message handler that you can call from your JavaScript code.
  func addScriptMessageHandler(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController, handler: WKScriptMessageHandler, name: String) throws
  /// Uninstalls the custom message handler with the specified name from your
  /// JavaScript code.
  func removeScriptMessageHandler(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController, name: String) throws
  /// Uninstalls all custom message handlers associated with the user content
  /// controller.
  func removeAllScriptMessageHandlers(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController) throws
  /// Injects the specified script into the webpageâ€™s content.
  func addUserScript(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController, userScript: WKUserScript) throws
  /// Removes all user scripts from the web view.
  func removeAllUserScripts(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController) throws
}

protocol PigeonApiProtocolWKUserContentController {
}

final class PigeonApiWKUserContentController: PigeonApiProtocolWKUserContentController  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKUserContentController
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKUserContentController) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKUserContentController?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let addScriptMessageHandlerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserContentController.addScriptMessageHandler", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addScriptMessageHandlerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKUserContentController
        let handlerArg = args[1] as! WKScriptMessageHandler
        let nameArg = args[2] as! String
        do {
          try api.pigeonDelegate.addScriptMessageHandler(pigeonApi: api, pigeonInstance: pigeonInstanceArg, handler: handlerArg, name: nameArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addScriptMessageHandlerChannel.setMessageHandler(nil)
    }
    let removeScriptMessageHandlerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserContentController.removeScriptMessageHandler", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeScriptMessageHandlerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKUserContentController
        let nameArg = args[1] as! String
        do {
          try api.pigeonDelegate.removeScriptMessageHandler(pigeonApi: api, pigeonInstance: pigeonInstanceArg, name: nameArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeScriptMessageHandlerChannel.setMessageHandler(nil)
    }
    let removeAllScriptMessageHandlersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserContentController.removeAllScriptMessageHandlers", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeAllScriptMessageHandlersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKUserContentController
        do {
          try api.pigeonDelegate.removeAllScriptMessageHandlers(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeAllScriptMessageHandlersChannel.setMessageHandler(nil)
    }
    let addUserScriptChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserContentController.addUserScript", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addUserScriptChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKUserContentController
        let userScriptArg = args[1] as! WKUserScript
        do {
          try api.pigeonDelegate.addUserScript(pigeonApi: api, pigeonInstance: pigeonInstanceArg, userScript: userScriptArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addUserScriptChannel.setMessageHandler(nil)
    }
    let removeAllUserScriptsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserContentController.removeAllUserScripts", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeAllUserScriptsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKUserContentController
        do {
          try api.pigeonDelegate.removeAllUserScripts(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeAllUserScriptsChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKUserContentController and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKUserContentController, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserContentController.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit
import WebKit
import WebKit


/// ProxyApi implementation for [WKUserContentController].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class UserContentControllerProxyAPIDelegate : PigeonApiDelegateWKUserContentController {
  func addScriptMessageHandler(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController, handler: WKScriptMessageHandler, name: String) throws {
    pigeonInstance.addScriptMessageHandler(handler: handler, name: name)
  }

  func removeScriptMessageHandler(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController, name: String) throws {
    pigeonInstance.removeScriptMessageHandler(name: name)
  }

  func removeAllScriptMessageHandlers(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController) throws {
    pigeonInstance.removeAllScriptMessageHandlers()
  }

  func addUserScript(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController, userScript: WKUserScript) throws {
    pigeonInstance.addUserScript(userScript: userScript)
  }

  func removeAllUserScripts(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController) throws {
    pigeonInstance.removeAllUserScripts()
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import WebKit
import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class UserContentControllerProxyApiTests: XCTestCase {
  func testAddScriptMessageHandler() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKUserContentController(registrar)

    let instance = TestUserContentController()
    let handler = TestScriptMessageHandler
    let name = "myString"
    api.pigeonDelegate.addScriptMessageHandler(pigeonApi: api, pigeonInstance: instance, handler: handler, name: name)

    XCTAssertEqual(instance.addScriptMessageHandlerArgs, [handler, name])
  }

  func testRemoveScriptMessageHandler() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKUserContentController(registrar)

    let instance = TestUserContentController()
    let name = "myString"
    api.pigeonDelegate.removeScriptMessageHandler(pigeonApi: api, pigeonInstance: instance, name: name)

    XCTAssertEqual(instance.removeScriptMessageHandlerArgs, [name])
  }

  func testRemoveAllScriptMessageHandlers() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKUserContentController(registrar)

    let instance = TestUserContentController()
    api.pigeonDelegate.removeAllScriptMessageHandlers(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.removeAllScriptMessageHandlersCalled)
  }

  func testAddUserScript() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKUserContentController(registrar)

    let instance = TestUserContentController()
    let userScript = TestUserScript
    api.pigeonDelegate.addUserScript(pigeonApi: api, pigeonInstance: instance, userScript: userScript)

    XCTAssertEqual(instance.addUserScriptArgs, [userScript])
  }

  func testRemoveAllUserScripts() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKUserContentController(registrar)

    let instance = TestUserContentController()
    api.pigeonDelegate.removeAllUserScripts(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.removeAllUserScriptsCalled)
  }

}
class TestUserContentController: WKUserContentController {
  var addScriptMessageHandlerArgs: [AnyHashable?]? = nil
  var removeScriptMessageHandlerArgs: [AnyHashable?]? = nil
  var removeAllScriptMessageHandlersCalled = false
  var addUserScriptArgs: [AnyHashable?]? = nil
  var removeAllUserScriptsCalled = false


  override func addScriptMessageHandler() {
    addScriptMessageHandlerArgs = [handler, name]
  }
  override func removeScriptMessageHandler() {
    removeScriptMessageHandlerArgs = [name]
  }
  override func removeAllScriptMessageHandlers() {
    removeAllScriptMessageHandlersCalled = true
  }
  override func addUserScript() {
    addUserScriptArgs = [userScript]
  }
  override func removeAllUserScripts() {
    removeAllUserScriptsCalled = true
  }
}
*/

protocol PigeonApiDelegateWKPreferences {
  /// A Boolean value that indicates whether JavaScript is enabled.
  func setJavaScriptEnabled(pigeonApi: PigeonApiWKPreferences, pigeonInstance: WKPreferences, enabled: Bool) throws
}

protocol PigeonApiProtocolWKPreferences {
}

final class PigeonApiWKPreferences: PigeonApiProtocolWKPreferences  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKPreferences
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKPreferences) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKPreferences?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let setJavaScriptEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKPreferences.setJavaScriptEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setJavaScriptEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKPreferences
        let enabledArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setJavaScriptEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setJavaScriptEnabledChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKPreferences and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKPreferences, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKPreferences.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit


/// ProxyApi implementation for [WKPreferences].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class PreferencesProxyAPIDelegate : PigeonApiDelegateWKPreferences {
  func setJavaScriptEnabled(pigeonApi: PigeonApiWKPreferences, pigeonInstance: WKPreferences, enabled: Bool) throws {
    pigeonInstance.setJavaScriptEnabled(enabled: enabled)
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class PreferencesProxyApiTests: XCTestCase {
  func testSetJavaScriptEnabled() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKPreferences(registrar)

    let instance = TestPreferences()
    let enabled = true
    api.pigeonDelegate.setJavaScriptEnabled(pigeonApi: api, pigeonInstance: instance, enabled: enabled)

    XCTAssertEqual(instance.setJavaScriptEnabledArgs, [enabled])
  }

}
class TestPreferences: WKPreferences {
  var setJavaScriptEnabledArgs: [AnyHashable?]? = nil


  override func setJavaScriptEnabled() {
    setJavaScriptEnabledArgs = [enabled]
  }
}
*/

protocol PigeonApiDelegateWKScriptMessageHandler {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiWKScriptMessageHandler) throws -> WKScriptMessageHandler
}

protocol PigeonApiProtocolWKScriptMessageHandler {
  /// Tells the handler that a webpage sent a script message.
  func didReceiveScriptMessage(pigeonInstance pigeonInstanceArg: WKScriptMessageHandler, controller controllerArg: WKUserContentController, message messageArg: WKScriptMessage, completion: @escaping (Result<Void, PigeonError>) -> Void)
}

final class PigeonApiWKScriptMessageHandler: PigeonApiProtocolWKScriptMessageHandler  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKScriptMessageHandler
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKScriptMessageHandler) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKScriptMessageHandler?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKScriptMessageHandler.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKScriptMessageHandler and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKScriptMessageHandler, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    print("Error: Attempting to create a new Dart instance of WKScriptMessageHandler, but the class has a nonnull callback method.")
  }
  /// Tells the handler that a webpage sent a script message.
  func didReceiveScriptMessage(pigeonInstance pigeonInstanceArg: WKScriptMessageHandler, controller controllerArg: WKUserContentController, message messageArg: WKScriptMessage, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKScriptMessageHandler.didReceiveScriptMessage"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, controllerArg, messageArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit
import WebKit
import WebKit

/// Implementation of `WKScriptMessageHandler` that calls to Dart in callback methods.
class ScriptMessageHandlerImpl: WKScriptMessageHandler {
  let api: PigeonApiProtocolWKScriptMessageHandler

  init(api: PigeonApiProtocolWKScriptMessageHandler) {
    self.api = api
  }

  func fixMe() {
    api.didReceiveScriptMessage(pigeonInstance: self, controller: controller, message: message) {  _ in }
  }
}

/// ProxyApi implementation for [WKScriptMessageHandler].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class ScriptMessageHandlerProxyAPIDelegate : PigeonApiDelegateWKScriptMessageHandler {
  func pigeon_defaultConstructor(pigeonApi: PigeonApiWKScriptMessageHandler) throws -> WKScriptMessageHandler {
    return WKScriptMessageHandlerImpl(api: pigeonApi)
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import WebKit
import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class ScriptMessageHandlerProxyApiTests: XCTestCase {
  func testPigeonDefaultConstructor() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKScriptMessageHandler(registrar)

    let instance = try? api.pigeonDefaultConstructor(pigeonApi: api )
    XCTAssertNotNil(instance)
  }

  func testDidReceiveScriptMessage() {
    let api = TestScriptMessageHandlerApi()
    let instance = ScriptMessageHandlerImpl(api: api)
    let controller = TestUserContentController
    let message = TestScriptMessage
    instance.didReceiveScriptMessage(controller: controller, message: message)

    XCTAssertEqual(api.didReceiveScriptMessageArgs, [controller, message])
  }

}
class TestScriptMessageHandlerApi: PigeonApiProtocolWKScriptMessageHandler {
  var didReceiveScriptMessageArgs: [AnyHashable?]? = nil

  func didReceiveScriptMessage(controller: WKUserContentController, message: WKScriptMessage) throws {
    didReceiveScriptMessageArgs = [controllerArg, messageArg]
  }
}
*/

protocol PigeonApiDelegateWKNavigationDelegate {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiWKNavigationDelegate) throws -> WKNavigationDelegate
}

protocol PigeonApiProtocolWKNavigationDelegate {
  /// Tells the delegate that navigation is complete.
  func didFinishNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, url urlArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Tells the delegate that navigation from the main frame has started.
  func didStartProvisionalNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, url urlArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Asks the delegate for permission to navigate to new content based on the
  /// specified action information.
  func decidePolicyForNavigationAction(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, navigationAction navigationActionArg: WKNavigationAction, completion: @escaping (Result<NavigationActionPolicy, PigeonError>) -> Void)
  /// Asks the delegate for permission to navigate to new content after the
  /// response to the navigation request is known.
  func decidePolicyForNavigationResponse(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, navigationResponse navigationResponseArg: WKNavigationResponse, completion: @escaping (Result<NavigationResponsePolicy, PigeonError>) -> Void)
  /// Tells the delegate that an error occurred during navigation.
  func didFailNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, error errorArg: NSError, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Tells the delegate that an error occurred during the early navigation
  /// process.
  func didFailProvisionalNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, error errorArg: NSError, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Tells the delegate that the web viewâ€™s content process was terminated.
  func webViewWebContentProcessDidTerminate(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Asks the delegate to respond to an authentication challenge.
  func didReceiveAuthenticationChallenge(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, challenge challengeArg: URLAuthenticationChallenge, completion: @escaping (Result<AuthenticationChallengeResponse, PigeonError>) -> Void)
}

final class PigeonApiWKNavigationDelegate: PigeonApiProtocolWKNavigationDelegate  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKNavigationDelegate
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKNavigationDelegate) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKNavigationDelegate?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKNavigationDelegate and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKNavigationDelegate, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  /// Tells the delegate that navigation is complete.
  func didFinishNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, url urlArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.didFinishNavigation"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, urlArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Tells the delegate that navigation from the main frame has started.
  func didStartProvisionalNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, url urlArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.didStartProvisionalNavigation"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, urlArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Asks the delegate for permission to navigate to new content based on the
  /// specified action information.
  func decidePolicyForNavigationAction(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, navigationAction navigationActionArg: WKNavigationAction, completion: @escaping (Result<NavigationActionPolicy, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.decidePolicyForNavigationAction"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, navigationActionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(PigeonError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! NavigationActionPolicy
        completion(.success(result))
      }
    }
  }

  /// Asks the delegate for permission to navigate to new content after the
  /// response to the navigation request is known.
  func decidePolicyForNavigationResponse(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, navigationResponse navigationResponseArg: WKNavigationResponse, completion: @escaping (Result<NavigationResponsePolicy, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.decidePolicyForNavigationResponse"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, navigationResponseArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(PigeonError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! NavigationResponsePolicy
        completion(.success(result))
      }
    }
  }

  /// Tells the delegate that an error occurred during navigation.
  func didFailNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, error errorArg: NSError, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.didFailNavigation"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Tells the delegate that an error occurred during the early navigation
  /// process.
  func didFailProvisionalNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, error errorArg: NSError, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.didFailProvisionalNavigation"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Tells the delegate that the web viewâ€™s content process was terminated.
  func webViewWebContentProcessDidTerminate(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.webViewWebContentProcessDidTerminate"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Asks the delegate to respond to an authentication challenge.
  func didReceiveAuthenticationChallenge(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, challenge challengeArg: URLAuthenticationChallenge, completion: @escaping (Result<AuthenticationChallengeResponse, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.didReceiveAuthenticationChallenge"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, challengeArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(PigeonError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! AuthenticationChallengeResponse
        completion(.success(result))
      }
    }
  }

}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit
import WebKit
import WebKit
import WebKit

/// Implementation of `WKNavigationDelegate` that calls to Dart in callback methods.
class NavigationDelegateImpl: WKNavigationDelegate {
  let api: PigeonApiProtocolWKNavigationDelegate

  init(api: PigeonApiProtocolWKNavigationDelegate) {
    self.api = api
  }

  func fixMe() {
    api.didFinishNavigation(pigeonInstance: self, webView: webView, url: url) {  _ in }
  }

  func fixMe() {
    api.didStartProvisionalNavigation(pigeonInstance: self, webView: webView, url: url) {  _ in }
  }

  func fixMe() {
    api.decidePolicyForNavigationAction(pigeonInstance: self, webView: webView, navigationAction: navigationAction) {  _ in }
  }

  func fixMe() {
    api.decidePolicyForNavigationResponse(pigeonInstance: self, webView: webView, navigationResponse: navigationResponse) {  _ in }
  }

  func fixMe() {
    api.didFailNavigation(pigeonInstance: self, webView: webView, error: error) {  _ in }
  }

  func fixMe() {
    api.didFailProvisionalNavigation(pigeonInstance: self, webView: webView, error: error) {  _ in }
  }

  func fixMe() {
    api.webViewWebContentProcessDidTerminate(pigeonInstance: self, webView: webView) {  _ in }
  }

  func fixMe() {
    api.didReceiveAuthenticationChallenge(pigeonInstance: self, webView: webView, challenge: challenge) {  _ in }
  }
}

/// ProxyApi implementation for [WKNavigationDelegate].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class NavigationDelegateProxyAPIDelegate : PigeonApiDelegateWKNavigationDelegate {
  func pigeon_defaultConstructor(pigeonApi: PigeonApiWKNavigationDelegate) throws -> WKNavigationDelegate {
    return WKNavigationDelegateImpl(api: pigeonApi)
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import WebKit
import WebKit
import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class NavigationDelegateProxyApiTests: XCTestCase {
  func testPigeonDefaultConstructor() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKNavigationDelegate(registrar)

    let instance = try? api.pigeonDefaultConstructor(pigeonApi: api )
    XCTAssertNotNil(instance)
  }

  func testDidFinishNavigation() {
    let api = TestNavigationDelegateApi()
    let instance = NavigationDelegateImpl(api: api)
    let webView = TestWebView
    let url = "myString"
    instance.didFinishNavigation(webView: webView, url: url)

    XCTAssertEqual(api.didFinishNavigationArgs, [webView, url])
  }

  func testDidStartProvisionalNavigation() {
    let api = TestNavigationDelegateApi()
    let instance = NavigationDelegateImpl(api: api)
    let webView = TestWebView
    let url = "myString"
    instance.didStartProvisionalNavigation(webView: webView, url: url)

    XCTAssertEqual(api.didStartProvisionalNavigationArgs, [webView, url])
  }

  func testDecidePolicyForNavigationAction() {
    let api = TestNavigationDelegateApi()
    let instance = NavigationDelegateImpl(api: api)
    let webView = TestWebView
    let navigationAction = TestNavigationAction
    instance.decidePolicyForNavigationAction(webView: webView, navigationAction: navigationAction)

    XCTAssertEqual(api.decidePolicyForNavigationActionArgs, [webView, navigationAction])
  }

  func testDecidePolicyForNavigationResponse() {
    let api = TestNavigationDelegateApi()
    let instance = NavigationDelegateImpl(api: api)
    let webView = TestWebView
    let navigationResponse = TestNavigationResponse
    instance.decidePolicyForNavigationResponse(webView: webView, navigationResponse: navigationResponse)

    XCTAssertEqual(api.decidePolicyForNavigationResponseArgs, [webView, navigationResponse])
  }

  func testDidFailNavigation() {
    let api = TestNavigationDelegateApi()
    let instance = NavigationDelegateImpl(api: api)
    let webView = TestWebView
    let error = TestError
    instance.didFailNavigation(webView: webView, error: error)

    XCTAssertEqual(api.didFailNavigationArgs, [webView, error])
  }

  func testDidFailProvisionalNavigation() {
    let api = TestNavigationDelegateApi()
    let instance = NavigationDelegateImpl(api: api)
    let webView = TestWebView
    let error = TestError
    instance.didFailProvisionalNavigation(webView: webView, error: error)

    XCTAssertEqual(api.didFailProvisionalNavigationArgs, [webView, error])
  }

  func testWebViewWebContentProcessDidTerminate() {
    let api = TestNavigationDelegateApi()
    let instance = NavigationDelegateImpl(api: api)
    let webView = TestWebView
    instance.webViewWebContentProcessDidTerminate(webView: webView)

    XCTAssertEqual(api.webViewWebContentProcessDidTerminateArgs, [webView])
  }

  func testDidReceiveAuthenticationChallenge() {
    let api = TestNavigationDelegateApi()
    let instance = NavigationDelegateImpl(api: api)
    let webView = TestWebView
    let challenge = TestAuthenticationChallenge
    instance.didReceiveAuthenticationChallenge(webView: webView, challenge: challenge)

    XCTAssertEqual(api.didReceiveAuthenticationChallengeArgs, [webView, challenge])
  }

}
class TestNavigationDelegateApi: PigeonApiProtocolWKNavigationDelegate {
  var didFinishNavigationArgs: [AnyHashable?]? = nil
  var didStartProvisionalNavigationArgs: [AnyHashable?]? = nil
  var decidePolicyForNavigationActionArgs: [AnyHashable?]? = nil
  var decidePolicyForNavigationResponseArgs: [AnyHashable?]? = nil
  var didFailNavigationArgs: [AnyHashable?]? = nil
  var didFailProvisionalNavigationArgs: [AnyHashable?]? = nil
  var webViewWebContentProcessDidTerminateArgs: [AnyHashable?]? = nil
  var didReceiveAuthenticationChallengeArgs: [AnyHashable?]? = nil

  func didFinishNavigation(webView: WKWebView, url: String?) throws {
    didFinishNavigationArgs = [webViewArg, urlArg]
  }
  func didStartProvisionalNavigation(webView: WKWebView, url: String?) throws {
    didStartProvisionalNavigationArgs = [webViewArg, urlArg]
  }
  func decidePolicyForNavigationAction(webView: WKWebView, navigationAction: WKNavigationAction) throws -> NavigationActionPolicy {
    decidePolicyForNavigationActionArgs = [webViewArg, navigationActionArg]
  }
  func decidePolicyForNavigationResponse(webView: WKWebView, navigationResponse: WKNavigationResponse) throws -> NavigationResponsePolicy {
    decidePolicyForNavigationResponseArgs = [webViewArg, navigationResponseArg]
  }
  func didFailNavigation(webView: WKWebView, error: NSError) throws {
    didFailNavigationArgs = [webViewArg, errorArg]
  }
  func didFailProvisionalNavigation(webView: WKWebView, error: NSError) throws {
    didFailProvisionalNavigationArgs = [webViewArg, errorArg]
  }
  func webViewWebContentProcessDidTerminate(webView: WKWebView) throws {
    webViewWebContentProcessDidTerminateArgs = [webViewArg]
  }
  func didReceiveAuthenticationChallenge(webView: WKWebView, challenge: URLAuthenticationChallenge) throws -> AuthenticationChallengeResponse {
    didReceiveAuthenticationChallengeArgs = [webViewArg, challengeArg]
  }
}
*/

protocol PigeonApiDelegateNSObject {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiNSObject) throws -> NSObject
  /// Registers the observer object to receive KVO notifications for the key
  /// path relative to the object receiving this message.
  func addObserver(pigeonApi: PigeonApiNSObject, pigeonInstance: NSObject, observer: NSObject, keyPath: String, options: [KeyValueObservingOptions]) throws
  /// Stops the observer object from receiving change notifications for the
  /// property specified by the key path relative to the object receiving this
  /// message.
  func removeObserver(pigeonApi: PigeonApiNSObject, pigeonInstance: NSObject, object: NSObject, keyPath: String) throws
}

protocol PigeonApiProtocolNSObject {
  /// Informs the observing object when the value at the specified key path
  /// relative to the observed object has changed.
  func observeValue(pigeonInstance pigeonInstanceArg: NSObject, keyPath keyPathArg: String, object objectArg: NSObject, change changeArg: [KeyValueChangeKey: Any?], completion: @escaping (Result<Void, PigeonError>) -> Void)
}

final class PigeonApiNSObject: PigeonApiProtocolNSObject  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateNSObject
  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateNSObject) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiNSObject?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.NSObject.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let addObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.NSObject.addObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! NSObject
        let observerArg = args[1] as! NSObject
        let keyPathArg = args[2] as! String
        let optionsArg = args[3] as! [KeyValueObservingOptions]
        do {
          try api.pigeonDelegate.addObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg, keyPath: keyPathArg, options: optionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addObserverChannel.setMessageHandler(nil)
    }
    let removeObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.NSObject.removeObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! NSObject
        let objectArg = args[1] as! NSObject
        let keyPathArg = args[2] as! String
        do {
          try api.pigeonDelegate.removeObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, object: objectArg, keyPath: keyPathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeObserverChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of NSObject and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: NSObject, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.NSObject.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  /// Informs the observing object when the value at the specified key path
  /// relative to the observed object has changed.
  func observeValue(pigeonInstance pigeonInstanceArg: NSObject, keyPath keyPathArg: String, object objectArg: NSObject, change changeArg: [KeyValueChangeKey: Any?], completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.NSObject.observeValue"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, keyPathArg, objectArg, changeArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation


/// Implementation of `NSObject` that calls to Dart in callback methods.
class ObjectImpl: NSObject {
  let api: PigeonApiProtocolNSObject

  init(api: PigeonApiProtocolNSObject) {
    self.api = api
  }

  func fixMe() {
    api.observeValue(pigeonInstance: self, keyPath: keyPath, object: object, change: change) {  _ in }
  }
}

/// ProxyApi implementation for [NSObject].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class ObjectProxyAPIDelegate : PigeonApiDelegateNSObject {
  func pigeon_defaultConstructor(pigeonApi: PigeonApiNSObject) throws -> NSObject {
    return NSObjectImpl(api: pigeonApi)
  }

  func addObserver(pigeonApi: PigeonApiNSObject, pigeonInstance: NSObject, observer: NSObject, keyPath: String, options: [KeyValueObservingOptions]) throws {
    pigeonInstance.addObserver(observer: observer, keyPath: keyPath, options: options)
  }

  func removeObserver(pigeonApi: PigeonApiNSObject, pigeonInstance: NSObject, object: NSObject, keyPath: String) throws {
    pigeonInstance.removeObserver(object: object, keyPath: keyPath)
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class ObjectProxyApiTests: XCTestCase {
  func testPigeonDefaultConstructor() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiNSObject(registrar)

    let instance = try? api.pigeonDefaultConstructor(pigeonApi: api )
    XCTAssertNotNil(instance)
  }

  func testAddObserver() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiNSObject(registrar)

    let instance = TestObject()
    let observer = TestObject
    let keyPath = "myString"
    let options = [.newValue]
    api.pigeonDelegate.addObserver(pigeonApi: api, pigeonInstance: instance, observer: observer, keyPath: keyPath, options: options)

    XCTAssertEqual(instance.addObserverArgs, [observer, keyPath, options])
  }

  func testRemoveObserver() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiNSObject(registrar)

    let instance = TestObject()
    let object = TestObject
    let keyPath = "myString"
    api.pigeonDelegate.removeObserver(pigeonApi: api, pigeonInstance: instance, object: object, keyPath: keyPath)

    XCTAssertEqual(instance.removeObserverArgs, [object, keyPath])
  }

  func testObserveValue() {
    let api = TestObjectApi()
    let instance = ObjectImpl(api: api)
    let keyPath = "myString"
    let object = TestObject
    let change = [.indexes: -1]
    instance.observeValue(keyPath: keyPath, object: object, change: change)

    XCTAssertEqual(api.observeValueArgs, [keyPath, object, change])
  }

}
class TestObject: NSObject {
  var addObserverArgs: [AnyHashable?]? = nil
  var removeObserverArgs: [AnyHashable?]? = nil


  override func addObserver() {
    addObserverArgs = [observer, keyPath, options]
  }
  override func removeObserver() {
    removeObserverArgs = [object, keyPath]
  }
}
class TestObjectApi: PigeonApiProtocolNSObject {
  var observeValueArgs: [AnyHashable?]? = nil

  func observeValue(keyPath: String, object: NSObject, change: [KeyValueChangeKey: Any?]) throws {
    observeValueArgs = [keyPathArg, objectArg, changeArg]
  }
}
*/

protocol PigeonApiDelegateWKWebViewUIExtensions {
  #if !os(macOS)
  /// The scroll view associated with the web view.
  func scrollView(pigeonApi: PigeonApiWKWebViewUIExtensions, pigeonInstance: WKWebView) throws -> UIScrollView
  #endif
}

protocol PigeonApiProtocolWKWebViewUIExtensions {
}

final class PigeonApiWKWebViewUIExtensions: PigeonApiProtocolWKWebViewUIExtensions  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKWebViewUIExtensions
  ///An implementation of [UIView] used to access callback methods
  var pigeonApiUIView: PigeonApiUIView {
    return pigeonRegistrar.apiDelegate.pigeonApiUIView(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKWebViewUIExtensions) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKWebViewUIExtensions?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    #if !os(macOS)
    let scrollViewChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewUIExtensions.scrollView", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      scrollViewChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let pigeonIdentifierArg = args[1] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.scrollView(pigeonApi: api, pigeonInstance: pigeonInstanceArg), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      scrollViewChannel.setMessageHandler(nil)
    }
    #endif
  }

  #if !os(macOS)
  ///Creates a Dart instance of WKWebViewUIExtensions and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKWebView, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewUIExtensions.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  #endif
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit
import UIKit


/// ProxyApi implementation for [WKWebViewUIExtensions].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class WebViewUIExtensionsProxyAPIDelegate : PigeonApiDelegateWKWebViewUIExtensions {
  func scrollView(pigeonApi: PigeonApiWKWebViewUIExtensions, pigeon_instance: WKWebViewUIExtensions): UIScrollView {
    return pigeon_instance.scrollView
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import UIKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class WebViewUIExtensionsProxyApiTests: XCTestCase {
  func testScrollView() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebViewUIExtensions(registrar)

    let instance = TestWebViewUIExtensions()
    let value = try? api.pigeonDelegate.scrollView(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.scrollView)
  }

}
class TestWebViewUIExtensions: WKWebViewUIExtensions {
  private var scrollViewTestValue = TestScrollView

  override var scrollView: UIScrollView {
    return scrollViewTestValue
  }

}
*/

open class PigeonApiDelegateWKWebViewNSExtensions {
}

protocol PigeonApiProtocolWKWebViewNSExtensions {
}

final class PigeonApiWKWebViewNSExtensions: PigeonApiProtocolWKWebViewNSExtensions  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKWebViewNSExtensions
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKWebViewNSExtensions) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  #if !os(iOS)
  ///Creates a Dart instance of WKWebViewNSExtensions and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKWebView, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewNSExtensions.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  #endif
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit


/// ProxyApi implementation for [WKWebViewNSExtensions].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class WebViewNSExtensionsProxyAPIDelegate : PigeonApiDelegateWKWebViewNSExtensions {
}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class WebViewNSExtensionsProxyApiTests: XCTestCase {
}
*/

protocol PigeonApiDelegateWKWebView {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiWKWebView, initialConfiguration: WKWebViewConfiguration) throws -> WKWebView
  /// The object that contains the configuration details for the web view.
  func configuration(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> WKWebViewConfiguration
  #if !os(macOS)
  func UIWebViewExtensions(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> WKWebView
  #endif
  #if !os(iOS)
  func NSWebViewExtensions(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> WKWebView
  #endif
  /// The object you use to integrate custom user interface elements, such as
  /// contextual menus or panels, into web view interactions.
  func setUIDelegate(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, delegate: WKUIDelegate) throws
  /// The object you use to manage navigation behavior for the web view.
  func setNavigationDelegate(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, delegate: WKNavigationDelegate) throws
  /// The URL for the current webpage.
  func getUrl(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> String?
  /// An estimate of what fraction of the current navigation has been loaded.
  func getEstimatedProgress(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> Double
  /// Loads the web content that the specified URL request object references and
  /// navigates to that content.
  func load(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, request: URLRequestWrapper) throws
  /// Loads the contents of the specified HTML string and navigates to it.
  func loadHtmlString(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, string: String, baseUrl: String?) throws
  /// Loads the web content from the specified file and navigates to it.
  func loadFileUrl(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, url: String, readAccessUrl: String) throws
  /// Convenience method to load a Flutter asset.
  func loadFlutterAsset(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, key: String) throws
  /// A Boolean value that indicates whether there is a valid back item in the
  /// back-forward list.
  func canGoBack(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> Bool
  /// A Boolean value that indicates whether there is a valid forward item in
  /// the back-forward list.
  func canGoForward(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> Bool
  /// Navigates to the back item in the back-forward list.
  func goBack(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws
  /// Navigates to the forward item in the back-forward list.
  func goForward(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws
  /// Reloads the current webpage.
  func reload(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws
  /// The page title.
  func getTitle(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> String?
  /// A Boolean value that indicates whether horizontal swipe gestures trigger
  /// backward and forward page navigation.
  func setAllowsBackForwardNavigationGestures(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, allow: Bool) throws
  /// The custom user agent string.
  func setCustomUserAgent(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, userAgent: String?) throws
  /// Evaluates the specified JavaScript string.
  func evaluateJavaScript(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, javaScriptString: String, completion: @escaping (Result<Any?, Error>) -> Void)
  /// A Boolean value that indicates whether you can inspect the view with
  /// Safari Web Inspector.
  func setInspectable(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, inspectable: Bool) throws
  /// The custom user agent string.
  func getCustomUserAgent(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> String?
}

protocol PigeonApiProtocolWKWebView {
}

final class PigeonApiWKWebView: PigeonApiProtocolWKWebView  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKWebView
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKWebView) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKWebView?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let initialConfigurationArg = args[1] as! WKWebViewConfiguration
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, initialConfiguration: initialConfigurationArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let configurationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.configuration", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      configurationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let pigeonIdentifierArg = args[1] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.configuration(pigeonApi: api, pigeonInstance: pigeonInstanceArg), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      configurationChannel.setMessageHandler(nil)
    }
    #if !os(macOS)
    let UIWebViewExtensionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.UIWebViewExtensions", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      UIWebViewExtensionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let pigeonIdentifierArg = args[1] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.UIWebViewExtensions(pigeonApi: api, pigeonInstance: pigeonInstanceArg), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      UIWebViewExtensionsChannel.setMessageHandler(nil)
    }
    #endif
    #if !os(iOS)
    let NSWebViewExtensionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.NSWebViewExtensions", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      NSWebViewExtensionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let pigeonIdentifierArg = args[1] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.NSWebViewExtensions(pigeonApi: api, pigeonInstance: pigeonInstanceArg), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      NSWebViewExtensionsChannel.setMessageHandler(nil)
    }
    #endif
    let setUIDelegateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.setUIDelegate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setUIDelegateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let delegateArg = args[1] as! WKUIDelegate
        do {
          try api.pigeonDelegate.setUIDelegate(pigeonApi: api, pigeonInstance: pigeonInstanceArg, delegate: delegateArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setUIDelegateChannel.setMessageHandler(nil)
    }
    let setNavigationDelegateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.setNavigationDelegate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setNavigationDelegateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let delegateArg = args[1] as! WKNavigationDelegate
        do {
          try api.pigeonDelegate.setNavigationDelegate(pigeonApi: api, pigeonInstance: pigeonInstanceArg, delegate: delegateArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setNavigationDelegateChannel.setMessageHandler(nil)
    }
    let getUrlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.getUrl", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getUrlChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          let result = try api.pigeonDelegate.getUrl(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getUrlChannel.setMessageHandler(nil)
    }
    let getEstimatedProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.getEstimatedProgress", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getEstimatedProgressChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          let result = try api.pigeonDelegate.getEstimatedProgress(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getEstimatedProgressChannel.setMessageHandler(nil)
    }
    let loadChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.load", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let requestArg = args[1] as! URLRequestWrapper
        do {
          try api.pigeonDelegate.load(pigeonApi: api, pigeonInstance: pigeonInstanceArg, request: requestArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      loadChannel.setMessageHandler(nil)
    }
    let loadHtmlStringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.loadHtmlString", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadHtmlStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let stringArg = args[1] as! String
        let baseUrlArg: String? = nilOrValue(args[2])
        do {
          try api.pigeonDelegate.loadHtmlString(pigeonApi: api, pigeonInstance: pigeonInstanceArg, string: stringArg, baseUrl: baseUrlArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      loadHtmlStringChannel.setMessageHandler(nil)
    }
    let loadFileUrlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.loadFileUrl", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadFileUrlChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let urlArg = args[1] as! String
        let readAccessUrlArg = args[2] as! String
        do {
          try api.pigeonDelegate.loadFileUrl(pigeonApi: api, pigeonInstance: pigeonInstanceArg, url: urlArg, readAccessUrl: readAccessUrlArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      loadFileUrlChannel.setMessageHandler(nil)
    }
    let loadFlutterAssetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.loadFlutterAsset", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadFlutterAssetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let keyArg = args[1] as! String
        do {
          try api.pigeonDelegate.loadFlutterAsset(pigeonApi: api, pigeonInstance: pigeonInstanceArg, key: keyArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      loadFlutterAssetChannel.setMessageHandler(nil)
    }
    let canGoBackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.canGoBack", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      canGoBackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          let result = try api.pigeonDelegate.canGoBack(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      canGoBackChannel.setMessageHandler(nil)
    }
    let canGoForwardChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.canGoForward", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      canGoForwardChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          let result = try api.pigeonDelegate.canGoForward(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      canGoForwardChannel.setMessageHandler(nil)
    }
    let goBackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.goBack", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      goBackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          try api.pigeonDelegate.goBack(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      goBackChannel.setMessageHandler(nil)
    }
    let goForwardChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.goForward", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      goForwardChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          try api.pigeonDelegate.goForward(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      goForwardChannel.setMessageHandler(nil)
    }
    let reloadChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.reload", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      reloadChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          try api.pigeonDelegate.reload(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      reloadChannel.setMessageHandler(nil)
    }
    let getTitleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.getTitle", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTitleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          let result = try api.pigeonDelegate.getTitle(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTitleChannel.setMessageHandler(nil)
    }
    let setAllowsBackForwardNavigationGesturesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.setAllowsBackForwardNavigationGestures", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAllowsBackForwardNavigationGesturesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let allowArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setAllowsBackForwardNavigationGestures(pigeonApi: api, pigeonInstance: pigeonInstanceArg, allow: allowArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAllowsBackForwardNavigationGesturesChannel.setMessageHandler(nil)
    }
    let setCustomUserAgentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.setCustomUserAgent", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCustomUserAgentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let userAgentArg: String? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setCustomUserAgent(pigeonApi: api, pigeonInstance: pigeonInstanceArg, userAgent: userAgentArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCustomUserAgentChannel.setMessageHandler(nil)
    }
    let evaluateJavaScriptChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.evaluateJavaScript", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      evaluateJavaScriptChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let javaScriptStringArg = args[1] as! String
        api.pigeonDelegate.evaluateJavaScript(pigeonApi: api, pigeonInstance: pigeonInstanceArg, javaScriptString: javaScriptStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      evaluateJavaScriptChannel.setMessageHandler(nil)
    }
    let setInspectableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.setInspectable", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setInspectableChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let inspectableArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setInspectable(pigeonApi: api, pigeonInstance: pigeonInstanceArg, inspectable: inspectableArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setInspectableChannel.setMessageHandler(nil)
    }
    let getCustomUserAgentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.getCustomUserAgent", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCustomUserAgentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          let result = try api.pigeonDelegate.getCustomUserAgent(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCustomUserAgentChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKWebView and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKWebView, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit
import WebKit
import WebKit
import WebKit
import WebKit
import WebKit


/// ProxyApi implementation for [WKWebView].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class WebViewProxyAPIDelegate : PigeonApiDelegateWKWebView {
  func pigeon_defaultConstructor(pigeonApi: PigeonApiWKWebView, initialConfiguration: WKWebViewConfiguration) throws -> WKWebView {
    return WKWebView(,initialConfiguration: initialConfiguration)
  }

  func configuration(pigeonApi: PigeonApiWKWebView, pigeon_instance: WKWebView): WKWebViewConfiguration {
    return pigeon_instance.configuration
  }

  func UIWebViewExtensions(pigeonApi: PigeonApiWKWebView, pigeon_instance: WKWebView): WKWebView {
    return pigeon_instance.UIWebViewExtensions
  }

  func NSWebViewExtensions(pigeonApi: PigeonApiWKWebView, pigeon_instance: WKWebView): WKWebView {
    return pigeon_instance.NSWebViewExtensions
  }

  func setUIDelegate(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, delegate: WKUIDelegate) throws {
    pigeonInstance.setUIDelegate(delegate: delegate)
  }

  func setNavigationDelegate(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, delegate: WKNavigationDelegate) throws {
    pigeonInstance.setNavigationDelegate(delegate: delegate)
  }

  func getUrl(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> String? {
    return pigeonInstance.getUrl()
  }

  func getEstimatedProgress(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> Double {
    return pigeonInstance.getEstimatedProgress()
  }

  func load(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, request: URLRequestWrapper) throws {
    pigeonInstance.load(request: request)
  }

  func loadHtmlString(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, string: String, baseUrl: String?) throws {
    pigeonInstance.loadHtmlString(string: string, baseUrl: baseUrl)
  }

  func loadFileUrl(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, url: String, readAccessUrl: String) throws {
    pigeonInstance.loadFileUrl(url: url, readAccessUrl: readAccessUrl)
  }

  func loadFlutterAsset(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, key: String) throws {
    pigeonInstance.loadFlutterAsset(key: key)
  }

  func canGoBack(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> Bool {
    return pigeonInstance.canGoBack()
  }

  func canGoForward(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> Bool {
    return pigeonInstance.canGoForward()
  }

  func goBack(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws {
    pigeonInstance.goBack()
  }

  func goForward(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws {
    pigeonInstance.goForward()
  }

  func reload(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws {
    pigeonInstance.reload()
  }

  func getTitle(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> String? {
    return pigeonInstance.getTitle()
  }

  func setAllowsBackForwardNavigationGestures(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, allow: Bool) throws {
    pigeonInstance.setAllowsBackForwardNavigationGestures(allow: allow)
  }

  func setCustomUserAgent(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, userAgent: String?) throws {
    pigeonInstance.setCustomUserAgent(userAgent: userAgent)
  }

  func evaluateJavaScript(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, javaScriptString: String, completion: @escaping (Result<Any?, Error>) -> Void) {
    return pigeonInstance.evaluateJavaScript(javaScriptString: javaScriptString)
  }

  func setInspectable(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, inspectable: Bool) throws {
    pigeonInstance.setInspectable(inspectable: inspectable)
  }

  func getCustomUserAgent(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> String? {
    return pigeonInstance.getCustomUserAgent()
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import WebKit
import WebKit
import WebKit
import WebKit
import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class WebViewProxyApiTests: XCTestCase {
  func testPigeonDefaultConstructor() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = try? api.pigeonDefaultConstructor(pigeonApi: api, initialConfiguration: TestWebViewConfiguration)
    XCTAssertNotNil(instance)
  }

  func testConfiguration() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let value = try? api.pigeonDelegate.configuration(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.configuration)
  }

  func testUIWebViewExtensions() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let value = try? api.pigeonDelegate.UIWebViewExtensions(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.UIWebViewExtensions)
  }

  func testNSWebViewExtensions() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let value = try? api.pigeonDelegate.NSWebViewExtensions(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.NSWebViewExtensions)
  }

  func testSetUIDelegate() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let delegate = TestDelegate
    api.pigeonDelegate.setUIDelegate(pigeonApi: api, pigeonInstance: instance, delegate: delegate)

    XCTAssertEqual(instance.setUIDelegateArgs, [delegate])
  }

  func testSetNavigationDelegate() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let delegate = TestNavigationDelegate
    api.pigeonDelegate.setNavigationDelegate(pigeonApi: api, pigeonInstance: instance, delegate: delegate)

    XCTAssertEqual(instance.setNavigationDelegateArgs, [delegate])
  }

  func testGetUrl() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let value = api.pigeonDelegate.getUrl(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getUrlCalled)
    XCTAssertEqual(value, instance.getUrl())
  }

  func testGetEstimatedProgress() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let value = api.pigeonDelegate.getEstimatedProgress(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getEstimatedProgressCalled)
    XCTAssertEqual(value, instance.getEstimatedProgress())
  }

  func testLoad() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let request = TestRequest
    api.pigeonDelegate.load(pigeonApi: api, pigeonInstance: instance, request: request)

    XCTAssertEqual(instance.loadArgs, [request])
  }

  func testLoadHtmlString() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let string = "myString"
    let baseUrl = "myString"
    api.pigeonDelegate.loadHtmlString(pigeonApi: api, pigeonInstance: instance, string: string, baseUrl: baseUrl)

    XCTAssertEqual(instance.loadHtmlStringArgs, [string, baseUrl])
  }

  func testLoadFileUrl() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let url = "myString"
    let readAccessUrl = "myString"
    api.pigeonDelegate.loadFileUrl(pigeonApi: api, pigeonInstance: instance, url: url, readAccessUrl: readAccessUrl)

    XCTAssertEqual(instance.loadFileUrlArgs, [url, readAccessUrl])
  }

  func testLoadFlutterAsset() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let key = "myString"
    api.pigeonDelegate.loadFlutterAsset(pigeonApi: api, pigeonInstance: instance, key: key)

    XCTAssertEqual(instance.loadFlutterAssetArgs, [key])
  }

  func testCanGoBack() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let value = api.pigeonDelegate.canGoBack(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.canGoBackCalled)
    XCTAssertEqual(value, instance.canGoBack())
  }

  func testCanGoForward() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let value = api.pigeonDelegate.canGoForward(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.canGoForwardCalled)
    XCTAssertEqual(value, instance.canGoForward())
  }

  func testGoBack() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    api.pigeonDelegate.goBack(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.goBackCalled)
  }

  func testGoForward() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    api.pigeonDelegate.goForward(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.goForwardCalled)
  }

  func testReload() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    api.pigeonDelegate.reload(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.reloadCalled)
  }

  func testGetTitle() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let value = api.pigeonDelegate.getTitle(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getTitleCalled)
    XCTAssertEqual(value, instance.getTitle())
  }

  func testSetAllowsBackForwardNavigationGestures() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let allow = true
    api.pigeonDelegate.setAllowsBackForwardNavigationGestures(pigeonApi: api, pigeonInstance: instance, allow: allow)

    XCTAssertEqual(instance.setAllowsBackForwardNavigationGesturesArgs, [allow])
  }

  func testSetCustomUserAgent() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let userAgent = "myString"
    api.pigeonDelegate.setCustomUserAgent(pigeonApi: api, pigeonInstance: instance, userAgent: userAgent)

    XCTAssertEqual(instance.setCustomUserAgentArgs, [userAgent])
  }

  func testEvaluateJavaScript() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let javaScriptString = "myString"
    let value = api.pigeonDelegate.evaluateJavaScript(pigeonApi: api, pigeonInstance: instance, javaScriptString: javaScriptString)

    XCTAssertEqual(instance.evaluateJavaScriptArgs, [javaScriptString])
    XCTAssertEqual(value, instance.evaluateJavaScript(javaScriptString: javaScriptString))
  }

  func testSetInspectable() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let inspectable = true
    api.pigeonDelegate.setInspectable(pigeonApi: api, pigeonInstance: instance, inspectable: inspectable)

    XCTAssertEqual(instance.setInspectableArgs, [inspectable])
  }

  func testGetCustomUserAgent() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKWebView(registrar)

    let instance = TestWebView()
    let value = api.pigeonDelegate.getCustomUserAgent(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getCustomUserAgentCalled)
    XCTAssertEqual(value, instance.getCustomUserAgent())
  }

}
class TestWebView: WKWebView {
  private var configurationTestValue = TestWebViewConfiguration
  private var UIWebViewExtensionsTestValue = TestWebViewUIExtensions
  private var NSWebViewExtensionsTestValue = TestWebViewNSExtensions
  var setUIDelegateArgs: [AnyHashable?]? = nil
  var setNavigationDelegateArgs: [AnyHashable?]? = nil
  var getUrlCalled = false
  var getEstimatedProgressCalled = false
  var loadArgs: [AnyHashable?]? = nil
  var loadHtmlStringArgs: [AnyHashable?]? = nil
  var loadFileUrlArgs: [AnyHashable?]? = nil
  var loadFlutterAssetArgs: [AnyHashable?]? = nil
  var canGoBackCalled = false
  var canGoForwardCalled = false
  var goBackCalled = false
  var goForwardCalled = false
  var reloadCalled = false
  var getTitleCalled = false
  var setAllowsBackForwardNavigationGesturesArgs: [AnyHashable?]? = nil
  var setCustomUserAgentArgs: [AnyHashable?]? = nil
  var evaluateJavaScriptArgs: [AnyHashable?]? = nil
  var setInspectableArgs: [AnyHashable?]? = nil
  var getCustomUserAgentCalled = false

  override var configuration: WKWebViewConfiguration {
    return configurationTestValue
  }
  override var UIWebViewExtensions: WKWebView {
    return UIWebViewExtensionsTestValue
  }
  override var NSWebViewExtensions: WKWebView {
    return NSWebViewExtensionsTestValue
  }

  override func setUIDelegate() {
    setUIDelegateArgs = [delegate]
  }
  override func setNavigationDelegate() {
    setNavigationDelegateArgs = [delegate]
  }
  override func getUrl() {
    getUrlCalled = true
  }
  override func getEstimatedProgress() {
    getEstimatedProgressCalled = true
  }
  override func load() {
    loadArgs = [request]
  }
  override func loadHtmlString() {
    loadHtmlStringArgs = [string, baseUrl]
  }
  override func loadFileUrl() {
    loadFileUrlArgs = [url, readAccessUrl]
  }
  override func loadFlutterAsset() {
    loadFlutterAssetArgs = [key]
  }
  override func canGoBack() {
    canGoBackCalled = true
  }
  override func canGoForward() {
    canGoForwardCalled = true
  }
  override func goBack() {
    goBackCalled = true
  }
  override func goForward() {
    goForwardCalled = true
  }
  override func reload() {
    reloadCalled = true
  }
  override func getTitle() {
    getTitleCalled = true
  }
  override func setAllowsBackForwardNavigationGestures() {
    setAllowsBackForwardNavigationGesturesArgs = [allow]
  }
  override func setCustomUserAgent() {
    setCustomUserAgentArgs = [userAgent]
  }
  override func evaluateJavaScript() {
    evaluateJavaScriptArgs = [javaScriptString]
    return -1
  }
  override func setInspectable() {
    setInspectableArgs = [inspectable]
  }
  override func getCustomUserAgent() {
    getCustomUserAgentCalled = true
  }
}
*/

protocol PigeonApiDelegateWKUIDelegate {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiWKUIDelegate) throws -> WKUIDelegate
}

protocol PigeonApiProtocolWKUIDelegate {
  /// Creates a new web view.
  func onCreateWebView(pigeonInstance pigeonInstanceArg: WKUIDelegate, webView webViewArg: WKWebView, configuration configurationArg: WKWebViewConfiguration, navigationAction navigationActionArg: WKNavigationAction, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Determines whether a web resource, which the security origin object
  /// describes, can access to the deviceâ€™s microphone audio and camera video.
  func requestMediaCapturePermission(pigeonInstance pigeonInstanceArg: WKUIDelegate, webView webViewArg: WKWebView, origin originArg: WKSecurityOrigin, frame frameArg: WKFrameInfo, type typeArg: MediaCaptureType, completion: @escaping (Result<PermissionDecision, PigeonError>) -> Void)
  /// Displays a JavaScript alert panel.
  func runJavaScriptAlertPanel(pigeonInstance pigeonInstanceArg: WKUIDelegate, message messageArg: String, frame frameArg: WKFrameInfo, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Displays a JavaScript confirm panel.
  func runJavaScriptConfirmPanel(pigeonInstance pigeonInstanceArg: WKUIDelegate, message messageArg: String, frame frameArg: WKFrameInfo, completion: @escaping (Result<Bool, PigeonError>) -> Void)
  /// Displays a JavaScript text input panel.
  func runJavaScriptTextInputPanel(pigeonInstance pigeonInstanceArg: WKUIDelegate, prompt promptArg: String, defaultText defaultTextArg: String, frame frameArg: WKFrameInfo, completion: @escaping (Result<String, PigeonError>) -> Void)
}

final class PigeonApiWKUIDelegate: PigeonApiProtocolWKUIDelegate  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKUIDelegate
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKUIDelegate) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKUIDelegate?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKUIDelegate and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKUIDelegate, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  /// Creates a new web view.
  func onCreateWebView(pigeonInstance pigeonInstanceArg: WKUIDelegate, webView webViewArg: WKWebView, configuration configurationArg: WKWebViewConfiguration, navigationAction navigationActionArg: WKNavigationAction, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.onCreateWebView"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, configurationArg, navigationActionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Determines whether a web resource, which the security origin object
  /// describes, can access to the deviceâ€™s microphone audio and camera video.
  func requestMediaCapturePermission(pigeonInstance pigeonInstanceArg: WKUIDelegate, webView webViewArg: WKWebView, origin originArg: WKSecurityOrigin, frame frameArg: WKFrameInfo, type typeArg: MediaCaptureType, completion: @escaping (Result<PermissionDecision, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.requestMediaCapturePermission"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, originArg, frameArg, typeArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(PigeonError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! PermissionDecision
        completion(.success(result))
      }
    }
  }

  /// Displays a JavaScript alert panel.
  func runJavaScriptAlertPanel(pigeonInstance pigeonInstanceArg: WKUIDelegate, message messageArg: String, frame frameArg: WKFrameInfo, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.runJavaScriptAlertPanel"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, messageArg, frameArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Displays a JavaScript confirm panel.
  func runJavaScriptConfirmPanel(pigeonInstance pigeonInstanceArg: WKUIDelegate, message messageArg: String, frame frameArg: WKFrameInfo, completion: @escaping (Result<Bool, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.runJavaScriptConfirmPanel"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, messageArg, frameArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(PigeonError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! Bool
        completion(.success(result))
      }
    }
  }

  /// Displays a JavaScript text input panel.
  func runJavaScriptTextInputPanel(pigeonInstance pigeonInstanceArg: WKUIDelegate, prompt promptArg: String, defaultText defaultTextArg: String, frame frameArg: WKFrameInfo, completion: @escaping (Result<String, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.runJavaScriptTextInputPanel"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, promptArg, defaultTextArg, frameArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(PigeonError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! String
        completion(.success(result))
      }
    }
  }

}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit
import WebKit
import WebKit
import WebKit
import WebKit
import WebKit

/// Implementation of `WKUIDelegate` that calls to Dart in callback methods.
class DelegateImpl: WKUIDelegate {
  let api: PigeonApiProtocolWKUIDelegate

  init(api: PigeonApiProtocolWKUIDelegate) {
    self.api = api
  }

  func fixMe() {
    api.onCreateWebView(pigeonInstance: self, webView: webView, configuration: configuration, navigationAction: navigationAction) {  _ in }
  }

  func fixMe() {
    api.requestMediaCapturePermission(pigeonInstance: self, webView: webView, origin: origin, frame: frame, type: type) {  _ in }
  }

  func fixMe() {
    api.runJavaScriptAlertPanel(pigeonInstance: self, message: message, frame: frame) {  _ in }
  }

  func fixMe() {
    api.runJavaScriptConfirmPanel(pigeonInstance: self, message: message, frame: frame) {  _ in }
  }

  func fixMe() {
    api.runJavaScriptTextInputPanel(pigeonInstance: self, prompt: prompt, defaultText: defaultText, frame: frame) {  _ in }
  }
}

/// ProxyApi implementation for [WKUIDelegate].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class DelegateProxyAPIDelegate : PigeonApiDelegateWKUIDelegate {
  func pigeon_defaultConstructor(pigeonApi: PigeonApiWKUIDelegate) throws -> WKUIDelegate {
    return WKUIDelegateImpl(api: pigeonApi)
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import WebKit
import WebKit
import WebKit
import WebKit
import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class DelegateProxyApiTests: XCTestCase {
  func testPigeonDefaultConstructor() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKUIDelegate(registrar)

    let instance = try? api.pigeonDefaultConstructor(pigeonApi: api )
    XCTAssertNotNil(instance)
  }

  func testOnCreateWebView() {
    let api = TestDelegateApi()
    let instance = DelegateImpl(api: api)
    let webView = TestWebView
    let configuration = TestWebViewConfiguration
    let navigationAction = TestNavigationAction
    instance.onCreateWebView(webView: webView, configuration: configuration, navigationAction: navigationAction)

    XCTAssertEqual(api.onCreateWebViewArgs, [webView, configuration, navigationAction])
  }

  func testRequestMediaCapturePermission() {
    let api = TestDelegateApi()
    let instance = DelegateImpl(api: api)
    let webView = TestWebView
    let origin = TestSecurityOrigin
    let frame = TestFrameInfo
    let type = .camera
    instance.requestMediaCapturePermission(webView: webView, origin: origin, frame: frame, type: type)

    XCTAssertEqual(api.requestMediaCapturePermissionArgs, [webView, origin, frame, type])
  }

  func testRunJavaScriptAlertPanel() {
    let api = TestDelegateApi()
    let instance = DelegateImpl(api: api)
    let message = "myString"
    let frame = TestFrameInfo
    instance.runJavaScriptAlertPanel(message: message, frame: frame)

    XCTAssertEqual(api.runJavaScriptAlertPanelArgs, [message, frame])
  }

  func testRunJavaScriptConfirmPanel() {
    let api = TestDelegateApi()
    let instance = DelegateImpl(api: api)
    let message = "myString"
    let frame = TestFrameInfo
    instance.runJavaScriptConfirmPanel(message: message, frame: frame)

    XCTAssertEqual(api.runJavaScriptConfirmPanelArgs, [message, frame])
  }

  func testRunJavaScriptTextInputPanel() {
    let api = TestDelegateApi()
    let instance = DelegateImpl(api: api)
    let prompt = "myString"
    let defaultText = "myString"
    let frame = TestFrameInfo
    instance.runJavaScriptTextInputPanel(prompt: prompt, defaultText: defaultText, frame: frame)

    XCTAssertEqual(api.runJavaScriptTextInputPanelArgs, [prompt, defaultText, frame])
  }

}
class TestDelegateApi: PigeonApiProtocolWKUIDelegate {
  var onCreateWebViewArgs: [AnyHashable?]? = nil
  var requestMediaCapturePermissionArgs: [AnyHashable?]? = nil
  var runJavaScriptAlertPanelArgs: [AnyHashable?]? = nil
  var runJavaScriptConfirmPanelArgs: [AnyHashable?]? = nil
  var runJavaScriptTextInputPanelArgs: [AnyHashable?]? = nil

  func onCreateWebView(webView: WKWebView, configuration: WKWebViewConfiguration, navigationAction: WKNavigationAction) throws {
    onCreateWebViewArgs = [webViewArg, configurationArg, navigationActionArg]
  }
  func requestMediaCapturePermission(webView: WKWebView, origin: WKSecurityOrigin, frame: WKFrameInfo, type: MediaCaptureType) throws -> PermissionDecision {
    requestMediaCapturePermissionArgs = [webViewArg, originArg, frameArg, typeArg]
  }
  func runJavaScriptAlertPanel(message: String, frame: WKFrameInfo) throws {
    runJavaScriptAlertPanelArgs = [messageArg, frameArg]
  }
  func runJavaScriptConfirmPanel(message: String, frame: WKFrameInfo) throws -> Bool {
    runJavaScriptConfirmPanelArgs = [messageArg, frameArg]
  }
  func runJavaScriptTextInputPanel(prompt: String, defaultText: String, frame: WKFrameInfo) throws -> String {
    runJavaScriptTextInputPanelArgs = [promptArg, defaultTextArg, frameArg]
  }
}
*/

protocol PigeonApiDelegateWKHTTPCookieStore {
  /// Sets a cookie policy that indicates whether the cookie store allows cookie
  /// storage.
  func setCookie(pigeonApi: PigeonApiWKHTTPCookieStore, pigeonInstance: WKHTTPCookieStore, cookie: HTTPCookie, completion: @escaping (Result<Void, Error>) -> Void)
}

protocol PigeonApiProtocolWKHTTPCookieStore {
}

final class PigeonApiWKHTTPCookieStore: PigeonApiProtocolWKHTTPCookieStore  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKHTTPCookieStore
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKHTTPCookieStore) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKHTTPCookieStore?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let setCookieChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKHTTPCookieStore.setCookie", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCookieChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKHTTPCookieStore
        let cookieArg = args[1] as! HTTPCookie
        api.pigeonDelegate.setCookie(pigeonApi: api, pigeonInstance: pigeonInstanceArg, cookie: cookieArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setCookieChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKHTTPCookieStore and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKHTTPCookieStore, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKHTTPCookieStore.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import WebKit


/// ProxyApi implementation for [WKHTTPCookieStore].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class CookieStoreProxyAPIDelegate : PigeonApiDelegateWKHTTPCookieStore {
  func setCookie(pigeonApi: PigeonApiWKHTTPCookieStore, pigeonInstance: WKHTTPCookieStore, cookie: HTTPCookie, completion: @escaping (Result<Void, Error>) -> Void) {
    pigeonInstance.setCookie(cookie: cookie)
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import WebKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class CookieStoreProxyApiTests: XCTestCase {
  func testSetCookie() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiWKHTTPCookieStore(registrar)

    let instance = TestCookieStore()
    let cookie = TestCookie
    api.pigeonDelegate.setCookie(pigeonApi: api, pigeonInstance: instance, cookie: cookie)

    XCTAssertEqual(instance.setCookieArgs, [cookie])
  }

}
class TestCookieStore: WKHTTPCookieStore {
  var setCookieArgs: [AnyHashable?]? = nil


  override func setCookie() {
    setCookieArgs = [cookie]
  }
}
*/

protocol PigeonApiDelegateUIScrollViewDelegate {
  #if !os(macOS)
  func pigeonDefaultConstructor(pigeonApi: PigeonApiUIScrollViewDelegate) throws -> UIScrollViewDelegate
  #endif
}

protocol PigeonApiProtocolUIScrollViewDelegate {
  #if !os(macOS)
  /// Tells the delegate when the user scrolls the content view within the
  /// scroll view.
  ///
  /// Note that this is a convenient method that includes the `contentOffset` of
  /// the `scrollView`.
  func scrollViewDidScroll(pigeonInstance pigeonInstanceArg: UIScrollViewDelegate, scrollView scrollViewArg: UIScrollView, x xArg: Double, y yArg: Double, completion: @escaping (Result<Void, PigeonError>) -> Void)  #endif

}

final class PigeonApiUIScrollViewDelegate: PigeonApiProtocolUIScrollViewDelegate  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateUIScrollViewDelegate
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateUIScrollViewDelegate) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiUIScrollViewDelegate?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    #if !os(macOS)
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollViewDelegate.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    #endif
  }

  #if !os(macOS)
  ///Creates a Dart instance of UIScrollViewDelegate and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: UIScrollViewDelegate, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollViewDelegate.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  #endif
  #if !os(macOS)
  /// Tells the delegate when the user scrolls the content view within the
  /// scroll view.
  ///
  /// Note that this is a convenient method that includes the `contentOffset` of
  /// the `scrollView`.
  func scrollViewDidScroll(pigeonInstance pigeonInstanceArg: UIScrollViewDelegate, scrollView scrollViewArg: UIScrollView, x xArg: Double, y yArg: Double, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollViewDelegate.scrollViewDidScroll"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, scrollViewArg, xArg, yArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  #endif

}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation
import UIKit
import UIKit

/// Implementation of `UIScrollViewDelegate` that calls to Dart in callback methods.
class ScrollViewDelegateImpl: UIScrollViewDelegate {
  let api: PigeonApiProtocolUIScrollViewDelegate

  init(api: PigeonApiProtocolUIScrollViewDelegate) {
    self.api = api
  }

  func fixMe() {
    api.scrollViewDidScroll(pigeonInstance: self, scrollView: scrollView, x: x, y: y) {  _ in }
  }
}

/// ProxyApi implementation for [UIScrollViewDelegate].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class ScrollViewDelegateProxyAPIDelegate : PigeonApiDelegateUIScrollViewDelegate {
  func pigeon_defaultConstructor(pigeonApi: PigeonApiUIScrollViewDelegate) throws -> UIScrollViewDelegate {
    return UIScrollViewDelegateImpl(api: pigeonApi)
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import UIKit
import UIKit
import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class ScrollViewDelegateProxyApiTests: XCTestCase {
  func testPigeonDefaultConstructor() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiUIScrollViewDelegate(registrar)

    let instance = try? api.pigeonDefaultConstructor(pigeonApi: api )
    XCTAssertNotNil(instance)
  }

  func testScrollViewDidScroll() {
    let api = TestScrollViewDelegateApi()
    let instance = ScrollViewDelegateImpl(api: api)
    let scrollView = TestScrollView
    let x = 1.0
    let y = 1.0
    instance.scrollViewDidScroll(scrollView: scrollView, x: x, y: y)

    XCTAssertEqual(api.scrollViewDidScrollArgs, [scrollView, x, y])
  }

}
class TestScrollViewDelegateApi: PigeonApiProtocolUIScrollViewDelegate {
  var scrollViewDidScrollArgs: [AnyHashable?]? = nil

  func scrollViewDidScroll(scrollView: UIScrollView, x: Double, y: Double) throws {
    scrollViewDidScrollArgs = [scrollViewArg, xArg, yArg]
  }
}
*/

protocol PigeonApiDelegateURLCredential {
  /// Creates a URL credential instance for internet password authentication
  /// with a given user name and password, using a given persistence setting.
  func withUser(pigeonApi: PigeonApiURLCredential, user: String, password: String, persistence: UrlCredentialPersistence) throws -> URLCredential
}

protocol PigeonApiProtocolURLCredential {
}

final class PigeonApiURLCredential: PigeonApiProtocolURLCredential  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateURLCredential
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateURLCredential) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiURLCredential?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let withUserChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.URLCredential.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      withUserChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let userArg = args[1] as! String
        let passwordArg = args[2] as! String
        let persistenceArg = args[3] as! UrlCredentialPersistence
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.withUser(pigeonApi: api, user: userArg, password: passwordArg, persistence: persistenceArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      withUserChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of URLCredential and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: URLCredential, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.URLCredential.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation



/// ProxyApi implementation for [URLCredential].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class CredentialProxyAPIDelegate : PigeonApiDelegateURLCredential {
  func withUser(pigeonApi: PigeonApiURLCredential, user: String, password: String, persistence: UrlCredentialPersistence) throws -> URLCredential {
    return URLCredential(,user: user, password: password, persistence: persistence)
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class CredentialProxyApiTests: XCTestCase {
  func testWithUser() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLCredential(registrar)

    let instance = try? api.withUser(pigeonApi: api, user: "myString", password: "myString", persistence: .none)
    XCTAssertNotNil(instance)
  }

}
*/

protocol PigeonApiDelegateURLProtectionSpace {
  /// The receiverâ€™s host.
  func host(pigeonApi: PigeonApiURLProtectionSpace, pigeonInstance: URLProtectionSpace) throws -> String
  /// The receiverâ€™s port.
  func port(pigeonApi: PigeonApiURLProtectionSpace, pigeonInstance: URLProtectionSpace) throws -> Int64
  /// The receiverâ€™s authentication realm.
  func realm(pigeonApi: PigeonApiURLProtectionSpace, pigeonInstance: URLProtectionSpace) throws -> String?
  /// The authentication method used by the receiver.
  func authenticationMethod(pigeonApi: PigeonApiURLProtectionSpace, pigeonInstance: URLProtectionSpace) throws -> String?
}

protocol PigeonApiProtocolURLProtectionSpace {
}

final class PigeonApiURLProtectionSpace: PigeonApiProtocolURLProtectionSpace  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateURLProtectionSpace
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateURLProtectionSpace) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of URLProtectionSpace and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: URLProtectionSpace, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let hostArg = try! pigeonDelegate.host(pigeonApi: self, pigeonInstance: pigeonInstance)
    let portArg = try! pigeonDelegate.port(pigeonApi: self, pigeonInstance: pigeonInstance)
    let realmArg = try! pigeonDelegate.realm(pigeonApi: self, pigeonInstance: pigeonInstance)
    let authenticationMethodArg = try! pigeonDelegate.authenticationMethod(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.URLProtectionSpace.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, hostArg, portArg, realmArg, authenticationMethodArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation



/// ProxyApi implementation for [URLProtectionSpace].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class ProtectionSpaceProxyAPIDelegate : PigeonApiDelegateURLProtectionSpace {
  func host(pigeonApi: PigeonApiURLProtectionSpace, pigeonInstance: URLProtectionSpace) throws -> String {
    return pigeon_instance.host
  }

  func port(pigeonApi: PigeonApiURLProtectionSpace, pigeonInstance: URLProtectionSpace) throws -> Int64 {
    return pigeon_instance.port
  }

  func realm(pigeonApi: PigeonApiURLProtectionSpace, pigeonInstance: URLProtectionSpace) throws -> String? {
    return pigeon_instance.realm
  }

  func authenticationMethod(pigeonApi: PigeonApiURLProtectionSpace, pigeonInstance: URLProtectionSpace) throws -> String? {
    return pigeon_instance.authenticationMethod
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class ProtectionSpaceProxyApiTests: XCTestCase {
  func testHost() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLProtectionSpace(registrar)

    let instance = TestProtectionSpace()
    let value = try? api.pigeonDelegate.host(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.host)
  }

  func testPort() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLProtectionSpace(registrar)

    let instance = TestProtectionSpace()
    let value = try? api.pigeonDelegate.port(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.port)
  }

  func testRealm() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLProtectionSpace(registrar)

    let instance = TestProtectionSpace()
    let value = try? api.pigeonDelegate.realm(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.realm)
  }

  func testAuthenticationMethod() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLProtectionSpace(registrar)

    let instance = TestProtectionSpace()
    let value = try? api.pigeonDelegate.authenticationMethod(pigeonApi: api, pigeonInstance: instance)

    XCTAssertEqual(value, instance.authenticationMethod)
  }

}
*/

protocol PigeonApiDelegateURLAuthenticationChallenge {
  /// The receiverâ€™s protection space.
  func getProtectionSpace(pigeonApi: PigeonApiURLAuthenticationChallenge, pigeonInstance: URLAuthenticationChallenge) throws -> URLProtectionSpace
}

protocol PigeonApiProtocolURLAuthenticationChallenge {
}

final class PigeonApiURLAuthenticationChallenge: PigeonApiProtocolURLAuthenticationChallenge  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateURLAuthenticationChallenge
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateURLAuthenticationChallenge) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiURLAuthenticationChallenge?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getProtectionSpaceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.URLAuthenticationChallenge.getProtectionSpace", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getProtectionSpaceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! URLAuthenticationChallenge
        do {
          let result = try api.pigeonDelegate.getProtectionSpace(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getProtectionSpaceChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of URLAuthenticationChallenge and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: URLAuthenticationChallenge, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.URLAuthenticationChallenge.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation



/// ProxyApi implementation for [URLAuthenticationChallenge].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class AuthenticationChallengeProxyAPIDelegate : PigeonApiDelegateURLAuthenticationChallenge {
  func getProtectionSpace(pigeonApi: PigeonApiURLAuthenticationChallenge, pigeonInstance: URLAuthenticationChallenge) throws -> URLProtectionSpace {
    return pigeonInstance.getProtectionSpace()
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class AuthenticationChallengeProxyApiTests: XCTestCase {
  func testGetProtectionSpace() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURLAuthenticationChallenge(registrar)

    let instance = TestAuthenticationChallenge()
    let value = api.pigeonDelegate.getProtectionSpace(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getProtectionSpaceCalled)
    XCTAssertEqual(value, instance.getProtectionSpace())
  }

}
class TestAuthenticationChallenge: URLAuthenticationChallenge {
  var getProtectionSpaceCalled = false


  override func getProtectionSpace() {
    getProtectionSpaceCalled = true
  }
}
*/

protocol PigeonApiDelegateURL {
  /// The absolute string for the URL.
  func getAbsoluteString(pigeonApi: PigeonApiURL, pigeonInstance: URLWrapper) throws -> String
}

protocol PigeonApiProtocolURL {
}

final class PigeonApiURL: PigeonApiProtocolURL  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateURL
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateURL) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiURL?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getAbsoluteStringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.URL.getAbsoluteString", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAbsoluteStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! URLWrapper
        do {
          let result = try api.pigeonDelegate.getAbsoluteString(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAbsoluteStringChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of URL and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: URLWrapper, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.URL.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import Foundation



/// ProxyApi implementation for [URL].
///
/// This class may handle instantiating native object instances that are attached to a Dart instance
/// or handle method calls on the associated native class or an instance of that class.
class LProxyAPIDelegate : PigeonApiDelegateURL {
  func getAbsoluteString(pigeonApi: PigeonApiURL, pigeonInstance: URLWrapper) throws -> String {
    return pigeonInstance.getAbsoluteString()
  }

}
*/

/*
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


import Flutter
import XCTest

@testable import webview_flutter_wkwebview

class LProxyApiTests: XCTestCase {
  func testGetAbsoluteString() {
    let registrar = TestProxyApiRegistrar()
    let api = registrar.apiDelegate.pigeonApiURL(registrar)

    let instance = TestL()
    let value = api.pigeonDelegate.getAbsoluteString(pigeonApi: api, pigeonInstance: instance )

    XCTAssertTrue(instance.getAbsoluteStringCalled)
    XCTAssertEqual(value, instance.getAbsoluteString())
  }

}
class TestL: URL {
  var getAbsoluteStringCalled = false


  override func getAbsoluteString() {
    getAbsoluteStringCalled = true
  }
}
*/

