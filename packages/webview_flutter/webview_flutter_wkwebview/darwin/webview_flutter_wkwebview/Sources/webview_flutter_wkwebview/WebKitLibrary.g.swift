// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.6.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
import WebKit
import UIKit

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PigeonError {
  return PigeonError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}
/// Handles the callback when an object is deallocated.
protocol WebKitLibraryPigeonInternalFinalizerDelegate: AnyObject {
  /// Invoked when the strong reference of an object is deallocated in an `InstanceManager`.
  func onDeinit(identifier: Int64)
}


// Attaches to an object to receive a callback when the object is deallocated.
internal final class WebKitLibraryPigeonInternalFinalizer {
  private static let associatedObjectKey = malloc(1)!

  private let identifier: Int64
  // Reference to the delegate is weak because the callback should be ignored if the
  // `InstanceManager` is deallocated.
  private weak var delegate: WebKitLibraryPigeonInternalFinalizerDelegate?

  private init(identifier: Int64, delegate: WebKitLibraryPigeonInternalFinalizerDelegate) {
    self.identifier = identifier
    self.delegate = delegate
  }

  internal static func attach(
    to instance: AnyObject, identifier: Int64, delegate: WebKitLibraryPigeonInternalFinalizerDelegate
  ) {
    let finalizer = WebKitLibraryPigeonInternalFinalizer(identifier: identifier, delegate: delegate)
    objc_setAssociatedObject(instance, associatedObjectKey, finalizer, .OBJC_ASSOCIATION_RETAIN)
  }

  static func detach(from instance: AnyObject) {
    objc_setAssociatedObject(instance, associatedObjectKey, nil, .OBJC_ASSOCIATION_ASSIGN)
  }

  deinit {
    delegate?.onDeinit(identifier: identifier)
  }
}


/// Maintains instances used to communicate with the corresponding objects in Dart.
///
/// Objects stored in this container are represented by an object in Dart that is also stored in
/// an InstanceManager with the same identifier.
///
/// When an instance is added with an identifier, either can be used to retrieve the other.
///
/// Added instances are added as a weak reference and a strong reference. When the strong
/// reference is removed and the weak reference is deallocated,`WebKitLibraryPigeonInternalFinalizerDelegate.onDeinit`
/// is called with the instance's identifier. However, if the strong reference is removed and then the identifier is
/// retrieved with the intention to pass the identifier to Dart (e.g. by calling `identifierWithStrongReference`),
/// the strong reference to the instance is re-added. The strong reference will then need to be removed manually
/// again.
///
/// Accessing and inserting to an InstanceManager is thread safe.
final class WebKitLibraryPigeonInstanceManager {
  // Identifiers are locked to a specific range to avoid collisions with objects
  // created simultaneously from Dart.
  // Host uses identifiers >= 2^16 and Dart is expected to use values n where,
  // 0 <= n < 2^16.
  private static let minHostCreatedIdentifier: Int64 = 65536

  private let lockQueue = DispatchQueue(label: "WebKitLibraryPigeonInstanceManager")
  private let identifiers: NSMapTable<AnyObject, NSNumber> = NSMapTable(
    keyOptions: [.weakMemory, .objectPointerPersonality], valueOptions: .strongMemory)
  private let weakInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.weakMemory, .objectPointerPersonality])
  private let strongInstances: NSMapTable<NSNumber, AnyObject> = NSMapTable(
    keyOptions: .strongMemory, valueOptions: [.strongMemory, .objectPointerPersonality])
  private let finalizerDelegate: WebKitLibraryPigeonInternalFinalizerDelegate
  private var nextIdentifier: Int64 = minHostCreatedIdentifier

  public init(finalizerDelegate: WebKitLibraryPigeonInternalFinalizerDelegate) {
    self.finalizerDelegate = finalizerDelegate
  }

  /// Adds a new instance that was instantiated from Dart.
  ///
  /// The same instance can be added multiple times, but each identifier must be unique. This allows
  /// two objects that are equivalent (e.g. conforms to `Equatable`)  to both be added.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored
  ///   - identifier: the identifier to be paired with instance. This value must be >= 0 and unique
  func addDartCreatedInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    lockQueue.async {
      self.addInstance(instance, withIdentifier: identifier)
    }
  }

  /// Adds a new instance that was instantiated from the host platform.
  ///
  /// - Parameters:
  ///   - instance: the instance to be stored. This must be unique to all other added instances.
  /// - Returns: the unique identifier (>= 0) stored with instance
  func addHostCreatedInstance(_ instance: AnyObject) -> Int64 {
    assert(!containsInstance(instance), "Instance of \(instance) has already been added.")
    var identifier: Int64 = -1
    lockQueue.sync {
      identifier = nextIdentifier
      nextIdentifier += 1
      self.addInstance(instance, withIdentifier: identifier)
    }
    return identifier
  }

  /// Removes `instanceIdentifier` and its associated strongly referenced instance, if present, from the manager.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier paired to an instance.
  /// - Returns: removed instance if the manager contains the given identifier, otherwise `nil` if
  ///   the manager doesn't contain the value
  func removeInstance<T: AnyObject>(withIdentifier instanceIdentifier: Int64) throws -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = strongInstances.object(forKey: NSNumber(value: instanceIdentifier))
      strongInstances.removeObject(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  /// Retrieves the instance associated with identifier.
  ///
  /// - Parameters:
  ///   - instanceIdentifier: the identifier associated with an instance
  /// - Returns: the instance associated with `instanceIdentifier` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func instance<T: AnyObject>(forIdentifier instanceIdentifier: Int64) -> T? {
    var instance: AnyObject? = nil
    lockQueue.sync {
      instance = weakInstances.object(forKey: NSNumber(value: instanceIdentifier))
    }
    return instance as? T
  }

  private func addInstance(_ instance: AnyObject, withIdentifier identifier: Int64) {
    assert(identifier >= 0)
    assert(
      weakInstances.object(forKey: identifier as NSNumber) == nil,
      "Identifier has already been added: \(identifier)")
    identifiers.setObject(NSNumber(value: identifier), forKey: instance)
    weakInstances.setObject(instance, forKey: NSNumber(value: identifier))
    strongInstances.setObject(instance, forKey: NSNumber(value: identifier))
    WebKitLibraryPigeonInternalFinalizer.attach(to: instance, identifier: identifier, delegate: finalizerDelegate)
  }

  /// Retrieves the identifier paired with an instance.
  ///
  /// If the manager contains a strong reference to `instance`, it will return the identifier
  /// associated with `instance`. If the manager contains only a weak reference to `instance`, a new
  /// strong reference to `instance` will be added and will need to be removed again with `removeInstance`.
  ///
  /// If this method returns a nonnull identifier, this method also expects the Dart
  /// `WebKitLibraryPigeonInstanceManager` to have, or recreate, a weak reference to the Dart instance the
  /// identifier is associated with.
  ///
  /// - Parameters:
  ///   - instance: an instance that may be stored in the manager
  /// - Returns: the identifier associated with `instance` if the manager contains the value, otherwise
  ///   `nil` if the manager doesn't contain the value
  func identifierWithStrongReference(forInstance instance: AnyObject) -> Int64? {
    var identifier: Int64? = nil
    lockQueue.sync {
      if let existingIdentifier = identifiers.object(forKey: instance)?.int64Value {
        strongInstances.setObject(instance, forKey: NSNumber(value: existingIdentifier))
        identifier = existingIdentifier
      }
    }
    return identifier
  }

  /// Whether this manager contains the given `instance`.
  ///
  /// - Parameters:
  ///   - instance: the instance whose presence in this manager is to be tested
  /// - Returns: whether this manager contains the given `instance`
  func containsInstance(_ instance: AnyObject) -> Bool {
    var containsInstance = false
    lockQueue.sync {
      containsInstance = identifiers.object(forKey: instance) != nil
    }
    return containsInstance
  }

  /// Removes all of the instances from this manager.
  ///
  /// The manager will be empty after this call returns.
  func removeAllObjects() throws {
    lockQueue.sync {
      identifiers.removeAllObjects()
      weakInstances.removeAllObjects()
      strongInstances.removeAllObjects()
      nextIdentifier = WebKitLibraryPigeonInstanceManager.minHostCreatedIdentifier
    }
  }

  /// The number of instances stored as a strong reference.
  ///
  /// For debugging and testing purposes.
  internal var strongInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = strongInstances.count
    }
    return count
  }

  /// The number of instances stored as a weak reference.
  ///
  /// For debugging and testing purposes. NSMapTables that store keys or objects as weak
  /// reference will be reclaimed non-deterministically.
  internal var weakInstanceCount: Int {
    var count: Int = 0
    lockQueue.sync {
      count = weakInstances.count
    }
    return count
  }
}


private class WebKitLibraryPigeonInstanceManagerApi {
  /// The codec used for serializing messages.
  var codec: FlutterStandardMessageCodec { WebKitLibraryPigeonCodec.shared }

  /// Handles sending and receiving messages with Dart.
  unowned let binaryMessenger: FlutterBinaryMessenger

  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }

  /// Sets up an instance of `WebKitLibraryPigeonInstanceManagerApi` to handle messages through the `binaryMessenger`.
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, instanceManager: WebKitLibraryPigeonInstanceManager?) {
    let codec = WebKitLibraryPigeonCodec.shared
    let removeStrongReferenceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.PigeonInternalInstanceManager.removeStrongReference", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      removeStrongReferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! Int64
        do {
          let _: AnyObject? = try instanceManager.removeInstance(withIdentifier: identifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeStrongReferenceChannel.setMessageHandler(nil)
    }
    let clearChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.PigeonInternalInstanceManager.clear", binaryMessenger: binaryMessenger, codec: codec)
    if let instanceManager = instanceManager {
      clearChannel.setMessageHandler { _, reply in
        do {
          try instanceManager.removeAllObjects()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      clearChannel.setMessageHandler(nil)
    }
  }

  /// Sends a message to the Dart `InstanceManager` to remove the strong reference of the instance associated with `identifier`.
  func removeStrongReference(identifier identifierArg: Int64, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.PigeonInternalInstanceManager.removeStrongReference"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([identifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol WebKitLibraryPigeonProxyApiDelegate {
  /// An implementation of [PigeonApiNSURLRequest] used to add a new Dart instance of
  /// `NSURLRequest` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiNSURLRequest(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiNSURLRequest
  /// An implementation of [PigeonApiNSHTTPURLResponse] used to add a new Dart instance of
  /// `NSHTTPURLResponse` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiNSHTTPURLResponse(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiNSHTTPURLResponse
  /// An implementation of [PigeonApiWKUserScript] used to add a new Dart instance of
  /// `WKUserScript` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKUserScript(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKUserScript
  /// An implementation of [PigeonApiWKNavigationAction] used to add a new Dart instance of
  /// `WKNavigationAction` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKNavigationAction(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKNavigationAction
  /// An implementation of [PigeonApiWKNavigationResponse] used to add a new Dart instance of
  /// `WKNavigationResponse` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKNavigationResponse(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKNavigationResponse
  /// An implementation of [PigeonApiWKFrameInfo] used to add a new Dart instance of
  /// `WKFrameInfo` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKFrameInfo(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKFrameInfo
  /// An implementation of [PigeonApiNSError] used to add a new Dart instance of
  /// `NSError` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiNSError(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiNSError
  /// An implementation of [PigeonApiWKScriptMessage] used to add a new Dart instance of
  /// `WKScriptMessage` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKScriptMessage(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKScriptMessage
  /// An implementation of [PigeonApiWKSecurityOrigin] used to add a new Dart instance of
  /// `WKSecurityOrigin` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKSecurityOrigin(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKSecurityOrigin
  /// An implementation of [PigeonApiNSHTTPCookie] used to add a new Dart instance of
  /// `NSHTTPCookie` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiNSHTTPCookie(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiNSHTTPCookie
  /// An implementation of [PigeonApiAuthenticationChallengeResponse] used to add a new Dart instance of
  /// `AuthenticationChallengeResponse` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiAuthenticationChallengeResponse(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiAuthenticationChallengeResponse
  /// An implementation of [PigeonApiWKWebsiteDataStore] used to add a new Dart instance of
  /// `WKWebsiteDataStore` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKWebsiteDataStore(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKWebsiteDataStore
  /// An implementation of [PigeonApiUIView] used to add a new Dart instance of
  /// `UIView` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiUIView(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiUIView
  /// An implementation of [PigeonApiUIScrollView] used to add a new Dart instance of
  /// `UIScrollView` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiUIScrollView(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiUIScrollView
  /// An implementation of [PigeonApiWKWebViewConfiguration] used to add a new Dart instance of
  /// `WKWebViewConfiguration` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKWebViewConfiguration(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKWebViewConfiguration
  /// An implementation of [PigeonApiWKUserContentController] used to add a new Dart instance of
  /// `WKUserContentController` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKUserContentController(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKUserContentController
  /// An implementation of [PigeonApiWKPreferences] used to add a new Dart instance of
  /// `WKPreferences` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKPreferences(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKPreferences
  /// An implementation of [PigeonApiWKScriptMessageHandler] used to add a new Dart instance of
  /// `WKScriptMessageHandler` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKScriptMessageHandler(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKScriptMessageHandler
  /// An implementation of [PigeonApiWKNavigationDelegate] used to add a new Dart instance of
  /// `WKNavigationDelegate` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKNavigationDelegate(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKNavigationDelegate
  /// An implementation of [PigeonApiNSObject] used to add a new Dart instance of
  /// `NSObject` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiNSObject(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiNSObject
  /// An implementation of [PigeonApiWKWebView] used to add a new Dart instance of
  /// `WKWebView` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKWebView(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKWebView
  /// An implementation of [PigeonApiWKUIDelegate] used to add a new Dart instance of
  /// `WKUIDelegate` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKUIDelegate(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKUIDelegate
  /// An implementation of [PigeonApiWKHTTPCookieStore] used to add a new Dart instance of
  /// `WKHTTPCookieStore` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiWKHTTPCookieStore(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiWKHTTPCookieStore
  /// An implementation of [PigeonApiNSURL] used to add a new Dart instance of
  /// `NSURL` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiNSURL(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiNSURL
  /// An implementation of [PigeonApiUIScrollViewDelegate] used to add a new Dart instance of
  /// `UIScrollViewDelegate` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiUIScrollViewDelegate(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiUIScrollViewDelegate
  /// An implementation of [PigeonApiNSURLCredential] used to add a new Dart instance of
  /// `NSURLCredential` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiNSURLCredential(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiNSURLCredential
  /// An implementation of [PigeonApiNSURLProtectionSpace] used to add a new Dart instance of
  /// `NSURLProtectionSpace` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiNSURLProtectionSpace(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiNSURLProtectionSpace
  /// An implementation of [PigeonApiNSURLAuthenticationChallenge] used to add a new Dart instance of
  /// `NSURLAuthenticationChallenge` to the Dart `InstanceManager` and make calls to Dart.
  func pigeonApiNSURLAuthenticationChallenge(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiNSURLAuthenticationChallenge
}

extension WebKitLibraryPigeonProxyApiDelegate {
  func pigeonApiUIScrollViewDelegate(_ registrar: WebKitLibraryPigeonProxyApiRegistrar) -> PigeonApiUIScrollViewDelegate {
    return PigeonApiUIScrollViewDelegate(pigeonRegistrar: registrar, delegate: PigeonApiDelegateUIScrollViewDelegate())
  }
}

open class WebKitLibraryPigeonProxyApiRegistrar {
  let binaryMessenger: FlutterBinaryMessenger
  let apiDelegate: WebKitLibraryPigeonProxyApiDelegate
  let instanceManager: WebKitLibraryPigeonInstanceManager
  /// Whether APIs should ignore calling to Dart.
  public var ignoreCallsToDart = false
  private var _codec: FlutterStandardMessageCodec?
  var codec: FlutterStandardMessageCodec {
    if _codec == nil {
      _codec = FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: self))
    }
    return _codec!
  }

  private class InstanceManagerApiFinalizerDelegate: WebKitLibraryPigeonInternalFinalizerDelegate {
    let api: WebKitLibraryPigeonInstanceManagerApi

    init(_ api: WebKitLibraryPigeonInstanceManagerApi) {
      self.api = api
    }

    public func onDeinit(identifier: Int64) {
      api.removeStrongReference(identifier: identifier) {
        _ in
      }
    }
  }

  init(binaryMessenger: FlutterBinaryMessenger, apiDelegate: WebKitLibraryPigeonProxyApiDelegate) {
    self.binaryMessenger = binaryMessenger
    self.apiDelegate = apiDelegate
    self.instanceManager = WebKitLibraryPigeonInstanceManager(
      finalizerDelegate: InstanceManagerApiFinalizerDelegate(
        WebKitLibraryPigeonInstanceManagerApi(binaryMessenger: binaryMessenger)))
  }

  func setUp() {
    WebKitLibraryPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: instanceManager)
    PigeonApiNSURLRequest.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiNSURLRequest(self))
    PigeonApiWKUserScript.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKUserScript(self))
    PigeonApiWKWebsiteDataStore.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKWebsiteDataStore(self))
    PigeonApiUIView.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiUIView(self))
    PigeonApiUIScrollView.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiUIScrollView(self))
    PigeonApiWKWebViewConfiguration.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKWebViewConfiguration(self))
    PigeonApiWKUserContentController.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKUserContentController(self))
    PigeonApiWKPreferences.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKPreferences(self))
    PigeonApiWKScriptMessageHandler.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKScriptMessageHandler(self))
    PigeonApiWKNavigationDelegate.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKNavigationDelegate(self))
    PigeonApiNSObject.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiNSObject(self))
    PigeonApiWKWebView.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKWebView(self))
    PigeonApiWKUIDelegate.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKUIDelegate(self))
    PigeonApiWKHTTPCookieStore.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiWKHTTPCookieStore(self))
    PigeonApiNSURL.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiNSURL(self))
    PigeonApiNSURLCredential.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiNSURLCredential(self))
    PigeonApiNSURLAuthenticationChallenge.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: apiDelegate.pigeonApiNSURLAuthenticationChallenge(self))
  }
  func tearDown() {
    WebKitLibraryPigeonInstanceManagerApi.setUpMessageHandlers(binaryMessenger: binaryMessenger, instanceManager: nil)
    PigeonApiNSURLRequest.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKUserScript.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKWebsiteDataStore.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiUIView.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiUIScrollView.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKWebViewConfiguration.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKUserContentController.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKPreferences.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKScriptMessageHandler.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKNavigationDelegate.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiNSObject.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKWebView.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKUIDelegate.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiWKHTTPCookieStore.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiNSURL.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiNSURLCredential.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
    PigeonApiNSURLAuthenticationChallenge.setUpMessageHandlers(binaryMessenger: binaryMessenger, api: nil)
  }
}
private class WebKitLibraryPigeonInternalProxyApiCodecReaderWriter: FlutterStandardReaderWriter {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar

  private class WebKitLibraryPigeonInternalProxyApiCodecReader: WebKitLibraryPigeonCodecReader {
    unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar

    init(data: Data, pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func readValue(ofType type: UInt8) -> Any? {
      switch type {
      case 128:
        let identifier = self.readValue()
        let instance: AnyObject? = pigeonRegistrar.instanceManager.instance(
          forIdentifier: identifier is Int64 ? identifier as! Int64 : Int64(identifier as! Int32))
        return instance
      default:
        return super.readValue(ofType: type)
      }
    }
  }

  private class WebKitLibraryPigeonInternalProxyApiCodecWriter: WebKitLibraryPigeonCodecWriter {
    unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar

    init(data: NSMutableData, pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar) {
      self.pigeonRegistrar = pigeonRegistrar
      super.init(data: data)
    }

    override func writeValue(_ value: Any) {
      if value is [Any] || value is Bool || value is Data || value is [AnyHashable: Any] || value is Double || value is FlutterStandardTypedData || value is Int64 || value is String || value is KeyValueObservingOptions || value is KeyValueChange || value is KeyValueChangeKey || value is UserScriptInjectionTime || value is AudiovisualMediaType || value is WebsiteDataType || value is NavigationActionPolicy || value is NavigationResponsePolicy || value is HttpCookiePropertyKey || value is NavigationType || value is PermissionDecision || value is MediaCaptureType || value is UrlSessionAuthChallengeDisposition || value is UrlCredentialPersistence {
        super.writeValue(value)
        return
      }


      if let instance = value as? NSURLRequest {
        pigeonRegistrar.apiDelegate.pigeonApiNSURLRequest(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? NSHTTPURLResponse {
        pigeonRegistrar.apiDelegate.pigeonApiNSHTTPURLResponse(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKUserScript {
        pigeonRegistrar.apiDelegate.pigeonApiWKUserScript(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKNavigationAction {
        pigeonRegistrar.apiDelegate.pigeonApiWKNavigationAction(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKNavigationResponse {
        pigeonRegistrar.apiDelegate.pigeonApiWKNavigationResponse(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKFrameInfo {
        pigeonRegistrar.apiDelegate.pigeonApiWKFrameInfo(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? NSError {
        pigeonRegistrar.apiDelegate.pigeonApiNSError(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKScriptMessage {
        pigeonRegistrar.apiDelegate.pigeonApiWKScriptMessage(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKSecurityOrigin {
        pigeonRegistrar.apiDelegate.pigeonApiWKSecurityOrigin(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? NSHTTPCookie {
        pigeonRegistrar.apiDelegate.pigeonApiNSHTTPCookie(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? AuthenticationChallengeResponse {
        pigeonRegistrar.apiDelegate.pigeonApiAuthenticationChallengeResponse(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKWebsiteDataStore {
        pigeonRegistrar.apiDelegate.pigeonApiWKWebsiteDataStore(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }

      #if !os(macOS)
      if let instance = value as? UIScrollView {
        pigeonRegistrar.apiDelegate.pigeonApiUIScrollView(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }
      #endif
      #if !os(macOS)
      if let instance = value as? UIView {
        pigeonRegistrar.apiDelegate.pigeonApiUIView(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }
      #endif

      if let instance = value as? WKWebViewConfiguration {
        pigeonRegistrar.apiDelegate.pigeonApiWKWebViewConfiguration(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKUserContentController {
        pigeonRegistrar.apiDelegate.pigeonApiWKUserContentController(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKPreferences {
        pigeonRegistrar.apiDelegate.pigeonApiWKPreferences(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKScriptMessageHandler {
        pigeonRegistrar.apiDelegate.pigeonApiWKScriptMessageHandler(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKNavigationDelegate {
        pigeonRegistrar.apiDelegate.pigeonApiWKNavigationDelegate(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKWebView {
        pigeonRegistrar.apiDelegate.pigeonApiWKWebView(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKUIDelegate {
        pigeonRegistrar.apiDelegate.pigeonApiWKUIDelegate(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? WKHTTPCookieStore {
        pigeonRegistrar.apiDelegate.pigeonApiWKHTTPCookieStore(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? NSURL {
        pigeonRegistrar.apiDelegate.pigeonApiNSURL(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? UIScrollViewDelegate {
        pigeonRegistrar.apiDelegate.pigeonApiUIScrollViewDelegate(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? NSObject {
        pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? NSURLCredential {
        pigeonRegistrar.apiDelegate.pigeonApiNSURLCredential(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? NSURLProtectionSpace {
        pigeonRegistrar.apiDelegate.pigeonApiNSURLProtectionSpace(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as? NSURLAuthenticationChallenge {
        pigeonRegistrar.apiDelegate.pigeonApiNSURLAuthenticationChallenge(pigeonRegistrar).pigeonNewInstance(
          pigeonInstance: instance
        ) { _ in }
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance as AnyObject)!)
        return
      }


      if let instance = value as AnyObject?, pigeonRegistrar.instanceManager.containsInstance(instance)
      {
        super.writeByte(128)
        super.writeValue(
          pigeonRegistrar.instanceManager.identifierWithStrongReference(forInstance: instance)!)
      } else {
        print("Unsupported value: \(value) of \(type(of: value))")
        assert(false, "Unsupported value for WebKitLibraryPigeonInternalProxyApiCodecWriter")
      }

    }
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar) {
    self.pigeonRegistrar = pigeonRegistrar
  }

  override func reader(with data: Data) -> FlutterStandardReader {
    return WebKitLibraryPigeonInternalProxyApiCodecReader(data: data, pigeonRegistrar: pigeonRegistrar)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return WebKitLibraryPigeonInternalProxyApiCodecWriter(data: data, pigeonRegistrar: pigeonRegistrar)
  }
}

/// The values that can be returned in a change dictionary.
///
/// See https://developer.apple.com/documentation/foundation/nskeyvalueobservingoptions?language=objc.
enum KeyValueObservingOptions: Int {
  /// Indicates that the change dictionary should provide the new attribute
  /// value, if applicable.
  case newValue = 0
  /// Indicates that the change dictionary should contain the old attribute
  /// value, if applicable.
  case oldValue = 1
  /// If specified, a notification should be sent to the observer immediately,
  /// before the observer registration method even returns.
  case initialValue = 2
  /// Whether separate notifications should be sent to the observer before and
  /// after each change, instead of a single notification after the change.
  case priorNotification = 3
}

/// The kinds of changes that can be observed.
///
/// See https://developer.apple.com/documentation/foundation/nskeyvaluechange?language=objc.
enum KeyValueChange: Int {
  /// Indicates that the value of the observed key path was set to a new value.
  case setting = 0
  /// Indicates that an object has been inserted into the to-many relationship
  /// that is being observed.
  case insertion = 1
  /// Indicates that an object has been removed from the to-many relationship
  /// that is being observed.
  case removal = 2
  /// Indicates that an object has been replaced in the to-many relationship
  /// that is being observed.
  case replacement = 3
  /// The value is not recognized by the wrapper.
  case unknown = 4
}

/// The keys that can appear in the change dictionary.
///
/// See https://developer.apple.com/documentation/foundation/nskeyvaluechangekey?language=objc.
enum KeyValueChangeKey: Int {
  /// If the value of the `KeyValueChangeKey.kind` entry is
  /// `KeyValueChange.insertion`, `KeyValueChange.removal`, or
  /// `KeyValueChange.replacement`, the value of this key is a Set object that
  /// contains the indexes of the inserted, removed, or replaced objects.
  case indexes = 0
  /// An object that contains a value corresponding to one of the
  /// `KeyValueChange` enum, indicating what sort of change has occurred.
  case kind = 1
  /// If the value of the `KeyValueChange.kind` entry is
  /// `KeyValueChange.setting, and `KeyValueObservingOptions.newValue` was
  /// specified when the observer was registered, the value of this key is the
  /// new value for the attribute.
  case newValue = 2
  /// If the `KeyValueObservingOptions.priorNotification` option was specified
  /// when the observer was registered this notification is sent prior to a
  /// change.
  case notificationIsPrior = 3
  /// If the value of the `KeyValueChange.kind` entry is
  /// `KeyValueChange.setting`, and `KeyValueObservingOptions.old` was specified
  /// when the observer was registered, the value of this key is the value
  /// before the attribute was changed.
  case oldValue = 4
  /// The value is not recognized by the wrapper.
  case unknown = 5
}

/// Constants for the times at which to inject script content into a webpage.
///
/// See https://developer.apple.com/documentation/webkit/wkuserscriptinjectiontime?language=objc.
enum UserScriptInjectionTime: Int {
  /// A constant to inject the script after the creation of the webpage’s
  /// document element, but before loading any other content.
  case atDocumentStart = 0
  /// A constant to inject the script after the document finishes loading, but
  /// before loading any other subresources.
  case atDocumentEnd = 1
}

/// The media types that require a user gesture to begin playing.
///
/// See https://developer.apple.com/documentation/webkit/wkaudiovisualmediatypes?language=objc.
enum AudiovisualMediaType: Int {
  /// No media types require a user gesture to begin playing.
  case none = 0
  /// Media types that contain audio require a user gesture to begin playing.
  case audio = 1
  /// Media types that contain video require a user gesture to begin playing.
  case video = 2
  /// All media types require a user gesture to begin playing.
  case all = 3
}

/// A `WKWebsiteDataRecord` object includes these constants in its dataTypes
/// property.
///
/// See https://developer.apple.com/documentation/webkit/wkwebsitedatarecord/data_store_record_types?language=objc.
enum WebsiteDataType: Int {
  /// Cookies.
  case cookies = 0
  /// In-memory caches.
  case memoryCache = 1
  /// On-disk caches.
  case diskCache = 2
  /// HTML offline web app caches.
  case offlineWebApplicationCache = 3
  /// HTML local storage.
  case localStorage = 4
  /// HTML session storage.
  case sessionStorage = 5
  /// WebSQL databases.
  case webSQLDatabases = 6
  /// IndexedDB databases.
  case indexedDBDatabases = 7
}

/// Constants that indicate whether to allow or cancel navigation to a webpage
/// from an action.
///
/// See https://developer.apple.com/documentation/webkit/wknavigationactionpolicy?language=objc.
enum NavigationActionPolicy: Int {
  /// Allow the navigation to continue.
  case allow = 0
  /// Cancel the navigation.
  case cancel = 1
  /// Allow the download to proceed.
  case download = 2
}

/// Constants that indicate whether to allow or cancel navigation to a webpage
/// from a response.
///
/// See https://developer.apple.com/documentation/webkit/wknavigationresponsepolicy.
enum NavigationResponsePolicy: Int {
  /// Allow the navigation to continue.
  case allow = 0
  /// Cancel the navigation.
  case cancel = 1
  /// Allow the download to proceed.
  case download = 2
}

/// Constants that define the supported keys in a cookie attributes dictionary.
///
/// See https://developer.apple.com/documentation/foundation/httpcookiepropertykey.
enum HttpCookiePropertyKey: Int {
  /// A String object containing the comment for the cookie.
  case comment = 0
  /// An Uri object or String object containing the comment URL for the cookie.
  case commentUrl = 1
  /// Aa String object stating whether the cookie should be discarded at the end
  /// of the session.
  case discard = 2
  /// An String object containing the domain for the cookie.
  case domain = 3
  /// An Date object or String object specifying the expiration date for the
  /// cookie.
  case expires = 4
  /// An String object containing an integer value stating how long in seconds
  /// the cookie should be kept, at most.
  case maximumAge = 5
  /// An String object containing the name of the cookie (required).
  case name = 6
  /// A URL or String object containing the URL that set this cookie.
  case originUrl = 7
  /// A String object containing the path for the cookie.
  case path = 8
  /// An String object containing comma-separated integer values specifying the
  /// ports for the cookie.
  case port = 9
  /// A string indicating the same-site policy for the cookie.
  case sameSitePolicy = 10
  /// A String object indicating that the cookie should be transmitted only over
  /// secure channels.
  case secure = 11
  /// A String object containing the value of the cookie.
  case value = 12
  /// A String object that specifies the version of the cookie.
  case version = 13
}

/// The type of action that triggered the navigation.
///
/// See https://developer.apple.com/documentation/webkit/wknavigationtype.
enum NavigationType: Int {
  /// A link activation.
  case linkActivated = 0
  /// A request to submit a form.
  case submitted = 1
  /// A request for the frame’s next or previous item.
  case backForward = 2
  /// A request to reload the webpage.
  case reload = 3
  /// A request to resubmit a form.
  case formResubmitted = 4
  /// A navigation request that originates for some other reason.
  case other = 5
  /// The value is not recognized by the wrapper.
  case unknown = 6
}

/// Possible permission decisions for device resource access.
///
/// See https://developer.apple.com/documentation/webkit/wkpermissiondecision?language=objc.
enum PermissionDecision: Int {
  /// Deny permission for the requested resource.
  case deny = 0
  /// Deny permission for the requested resource.
  case grant = 1
  /// Prompt the user for permission for the requested resource.
  case prompt = 2
}

/// List of the types of media devices that can capture audio, video, or both.
///
/// See https://developer.apple.com/documentation/webkit/wkmediacapturetype?language=objc.
enum MediaCaptureType: Int {
  /// A media device that can capture video.
  case camera = 0
  /// A media device or devices that can capture audio and video.
  case cameraAndMicrophone = 1
  /// A media device that can capture audio.
  case microphone = 2
  /// The value is not recognized by the wrapper.
  case unknown = 3
}

/// Responses to an authentication challenge.
///
/// See https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition?language=objc.
enum UrlSessionAuthChallengeDisposition: Int {
  /// Use the specified credential, which may be nil.
  case useCredential = 0
  /// Use the default handling for the challenge as though this delegate method
  /// were not implemented.
  case performDefaultHandling = 1
  /// Cancel the entire request.
  case cancelAuthenticationChallenge = 2
  /// Reject this challenge, and call the authentication delegate method again
  /// with the next authentication protection space.
  case rejectProtectionSpace = 3
}

/// Specifies how long a credential will be kept.
///
/// See https://developer.apple.com/documentation/foundation/nsurlcredentialpersistence.
enum UrlCredentialPersistence: Int {
  /// The credential should not be stored.
  case none = 0
  /// The credential should be stored only for this session.
  case session = 1
  /// The credential should be stored in the keychain.
  case permanent = 2
  /// The credential should be stored permanently in the keychain, and in
  /// addition should be distributed to other devices based on the owning Apple
  /// ID.
  case synchronizable = 3
}

private class WebKitLibraryPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return KeyValueObservingOptions(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return KeyValueChange(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return KeyValueChangeKey(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return UserScriptInjectionTime(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AudiovisualMediaType(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return WebsiteDataType(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return NavigationActionPolicy(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return NavigationResponsePolicy(rawValue: enumResultAsInt)
      }
      return nil
    case 137:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return HttpCookiePropertyKey(rawValue: enumResultAsInt)
      }
      return nil
    case 138:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return NavigationType(rawValue: enumResultAsInt)
      }
      return nil
    case 139:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PermissionDecision(rawValue: enumResultAsInt)
      }
      return nil
    case 140:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return MediaCaptureType(rawValue: enumResultAsInt)
      }
      return nil
    case 141:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return UrlSessionAuthChallengeDisposition(rawValue: enumResultAsInt)
      }
      return nil
    case 142:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return UrlCredentialPersistence(rawValue: enumResultAsInt)
      }
      return nil
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class WebKitLibraryPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? KeyValueObservingOptions {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? KeyValueChange {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? KeyValueChangeKey {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? UserScriptInjectionTime {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? AudiovisualMediaType {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? WebsiteDataType {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? NavigationActionPolicy {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? NavigationResponsePolicy {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? HttpCookiePropertyKey {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? NavigationType {
      super.writeByte(138)
      super.writeValue(value.rawValue)
    } else if let value = value as? PermissionDecision {
      super.writeByte(139)
      super.writeValue(value.rawValue)
    } else if let value = value as? MediaCaptureType {
      super.writeByte(140)
      super.writeValue(value.rawValue)
    } else if let value = value as? UrlSessionAuthChallengeDisposition {
      super.writeByte(141)
      super.writeValue(value.rawValue)
    } else if let value = value as? UrlCredentialPersistence {
      super.writeByte(142)
      super.writeValue(value.rawValue)
    } else {
      super.writeValue(value)
    }
  }
}

private class WebKitLibraryPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return WebKitLibraryPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return WebKitLibraryPigeonCodecWriter(data: data)
  }
}

class WebKitLibraryPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = WebKitLibraryPigeonCodec(readerWriter: WebKitLibraryPigeonCodecReaderWriter())
}

protocol PigeonApiDelegateNSURLRequest {
  /// The URL being requested.
  func url(pigeonApi: PigeonApiNSURLRequest, pigeonInstance: NSURLRequest) throws -> String
  /// The HTTP request method.
  func getHttpMethod(pigeonApi: PigeonApiNSURLRequest, pigeonInstance: NSURLRequest) throws -> String?
  /// The request body.
  func getHttpBody(pigeonApi: PigeonApiNSURLRequest, pigeonInstance: NSURLRequest) throws -> FlutterStandardTypedData?
  /// A dictionary containing all of the HTTP header fields for a request.
  func getAllHttpHeaderFields(pigeonApi: PigeonApiNSURLRequest, pigeonInstance: NSURLRequest) throws -> [String?: String?]
}

protocol PigeonApiProtocolNSURLRequest {
}

final class PigeonApiNSURLRequest: PigeonApiProtocolNSURLRequest  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateNSURLRequest
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateNSURLRequest) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiNSURLRequest?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getHttpMethodChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.NSURLRequest.getHttpMethod", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getHttpMethodChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! NSURLRequest
        do {
          let result = try api.pigeonDelegate.getHttpMethod(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getHttpMethodChannel.setMessageHandler(nil)
    }
    let getHttpBodyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.NSURLRequest.getHttpBody", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getHttpBodyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! NSURLRequest
        do {
          let result = try api.pigeonDelegate.getHttpBody(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getHttpBodyChannel.setMessageHandler(nil)
    }
    let getAllHttpHeaderFieldsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.NSURLRequest.getAllHttpHeaderFields", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAllHttpHeaderFieldsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! NSURLRequest
        do {
          let result = try api.pigeonDelegate.getAllHttpHeaderFields(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAllHttpHeaderFieldsChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of NSURLRequest and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: NSURLRequest, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let urlArg = try! pigeonDelegate.url(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.NSURLRequest.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, urlArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateNSHTTPURLResponse {
  /// The response’s HTTP status code.
  func statusCode(pigeonApi: PigeonApiNSHTTPURLResponse, pigeonInstance: NSHTTPURLResponse) throws -> Int64
}

protocol PigeonApiProtocolNSHTTPURLResponse {
}

final class PigeonApiNSHTTPURLResponse: PigeonApiProtocolNSHTTPURLResponse  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateNSHTTPURLResponse
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateNSHTTPURLResponse) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of NSHTTPURLResponse and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: NSHTTPURLResponse, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let statusCodeArg = try! pigeonDelegate.statusCode(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.NSHTTPURLResponse.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, statusCodeArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateWKUserScript {
  /// Creates a user script object that contains the specified source code and
  /// attributes.
  func pigeonDefaultConstructor(pigeonApi: PigeonApiWKUserScript, source: String, injectionTime: UserScriptInjectionTime, isMainFrameOnly: Bool) throws -> WKUserScript
  /// The script’s source code.
  func source(pigeonApi: PigeonApiWKUserScript, pigeonInstance: WKUserScript) throws -> String
  /// The time at which to inject the script into the webpage.
  func injectionTime(pigeonApi: PigeonApiWKUserScript, pigeonInstance: WKUserScript) throws -> UserScriptInjectionTime
  /// A Boolean value that indicates whether to inject the script into the main
  /// frame or all frames.
  func isMainFrameOnly(pigeonApi: PigeonApiWKUserScript, pigeonInstance: WKUserScript) throws -> Bool
}

protocol PigeonApiProtocolWKUserScript {
}

final class PigeonApiWKUserScript: PigeonApiProtocolWKUserScript  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKUserScript
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKUserScript) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKUserScript?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserScript.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let sourceArg = args[1] as! String
        let injectionTimeArg = args[2] as! UserScriptInjectionTime
        let isMainFrameOnlyArg = args[3] as! Bool
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, source: sourceArg, injectionTime: injectionTimeArg, isMainFrameOnly: isMainFrameOnlyArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKUserScript and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKUserScript, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let sourceArg = try! pigeonDelegate.source(pigeonApi: self, pigeonInstance: pigeonInstance)
    let injectionTimeArg = try! pigeonDelegate.injectionTime(pigeonApi: self, pigeonInstance: pigeonInstance)
    let isMainFrameOnlyArg = try! pigeonDelegate.isMainFrameOnly(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserScript.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, sourceArg, injectionTimeArg, isMainFrameOnlyArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateWKNavigationAction {
  /// The URL request object associated with the navigation action.
  func request(pigeonApi: PigeonApiWKNavigationAction, pigeonInstance: WKNavigationAction) throws -> NSURLRequest
  /// The frame in which to display the new content.
  func targetFrame(pigeonApi: PigeonApiWKNavigationAction, pigeonInstance: WKNavigationAction) throws -> WKFrameInfo
  /// The type of action that triggered the navigation.
  func navigationType(pigeonApi: PigeonApiWKNavigationAction, pigeonInstance: WKNavigationAction) throws -> NavigationType
}

protocol PigeonApiProtocolWKNavigationAction {
}

final class PigeonApiWKNavigationAction: PigeonApiProtocolWKNavigationAction  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKNavigationAction
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKNavigationAction) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of WKNavigationAction and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKNavigationAction, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let requestArg = try! pigeonDelegate.request(pigeonApi: self, pigeonInstance: pigeonInstance)
    let targetFrameArg = try! pigeonDelegate.targetFrame(pigeonApi: self, pigeonInstance: pigeonInstance)
    let navigationTypeArg = try! pigeonDelegate.navigationType(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationAction.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, requestArg, targetFrameArg, navigationTypeArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateWKNavigationResponse {
  /// The frame’s response.
  func response(pigeonApi: PigeonApiWKNavigationResponse, pigeonInstance: WKNavigationResponse) throws -> NSHTTPURLResponse
  /// A Boolean value that indicates whether the response targets the web view’s
  /// main frame.
  func forMainFrame(pigeonApi: PigeonApiWKNavigationResponse, pigeonInstance: WKNavigationResponse) throws -> Bool
}

protocol PigeonApiProtocolWKNavigationResponse {
}

final class PigeonApiWKNavigationResponse: PigeonApiProtocolWKNavigationResponse  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKNavigationResponse
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKNavigationResponse) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of WKNavigationResponse and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKNavigationResponse, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let responseArg = try! pigeonDelegate.response(pigeonApi: self, pigeonInstance: pigeonInstance)
    let forMainFrameArg = try! pigeonDelegate.forMainFrame(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationResponse.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, responseArg, forMainFrameArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateWKFrameInfo {
  /// A Boolean value indicating whether the frame is the web site's main frame
  /// or a subframe.
  func isMainFrame(pigeonApi: PigeonApiWKFrameInfo, pigeonInstance: WKFrameInfo) throws -> Bool
  /// The frame’s current request.
  func request(pigeonApi: PigeonApiWKFrameInfo, pigeonInstance: WKFrameInfo) throws -> NSURLRequest
}

protocol PigeonApiProtocolWKFrameInfo {
}

final class PigeonApiWKFrameInfo: PigeonApiProtocolWKFrameInfo  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKFrameInfo
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKFrameInfo) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of WKFrameInfo and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKFrameInfo, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let isMainFrameArg = try! pigeonDelegate.isMainFrame(pigeonApi: self, pigeonInstance: pigeonInstance)
    let requestArg = try! pigeonDelegate.request(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKFrameInfo.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, isMainFrameArg, requestArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateNSError {
  /// The error code.
  func code(pigeonApi: PigeonApiNSError, pigeonInstance: NSError) throws -> Int64
  /// A string containing the error domain.
  func domain(pigeonApi: PigeonApiNSError, pigeonInstance: NSError) throws -> String
  /// The user info dictionary.
  func userInfo(pigeonApi: PigeonApiNSError, pigeonInstance: NSError) throws -> [String: Any?]
}

protocol PigeonApiProtocolNSError {
}

final class PigeonApiNSError: PigeonApiProtocolNSError  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateNSError
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateNSError) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of NSError and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: NSError, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let codeArg = try! pigeonDelegate.code(pigeonApi: self, pigeonInstance: pigeonInstance)
    let domainArg = try! pigeonDelegate.domain(pigeonApi: self, pigeonInstance: pigeonInstance)
    let userInfoArg = try! pigeonDelegate.userInfo(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.NSError.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, codeArg, domainArg, userInfoArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateWKScriptMessage {
  /// The name of the message handler to which the message is sent.
  func name(pigeonApi: PigeonApiWKScriptMessage, pigeonInstance: WKScriptMessage) throws -> String
  /// The body of the message.
  func body(pigeonApi: PigeonApiWKScriptMessage, pigeonInstance: WKScriptMessage) throws -> Any?
}

protocol PigeonApiProtocolWKScriptMessage {
}

final class PigeonApiWKScriptMessage: PigeonApiProtocolWKScriptMessage  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKScriptMessage
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKScriptMessage) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of WKScriptMessage and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKScriptMessage, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let nameArg = try! pigeonDelegate.name(pigeonApi: self, pigeonInstance: pigeonInstance)
    let bodyArg = try! pigeonDelegate.body(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKScriptMessage.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, nameArg, bodyArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateWKSecurityOrigin {
  /// The security origin’s host.
  func host(pigeonApi: PigeonApiWKSecurityOrigin, pigeonInstance: WKSecurityOrigin) throws -> String
  /// The security origin's port.
  func port(pigeonApi: PigeonApiWKSecurityOrigin, pigeonInstance: WKSecurityOrigin) throws -> Int64
  /// The security origin's protocol.
  func protocol(pigeonApi: PigeonApiWKSecurityOrigin, pigeonInstance: WKSecurityOrigin) throws -> String
}

protocol PigeonApiProtocolWKSecurityOrigin {
}

final class PigeonApiWKSecurityOrigin: PigeonApiProtocolWKSecurityOrigin  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKSecurityOrigin
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKSecurityOrigin) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of WKSecurityOrigin and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKSecurityOrigin, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let hostArg = try! pigeonDelegate.host(pigeonApi: self, pigeonInstance: pigeonInstance)
    let portArg = try! pigeonDelegate.port(pigeonApi: self, pigeonInstance: pigeonInstance)
    let protocolArg = try! pigeonDelegate.protocol(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKSecurityOrigin.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, hostArg, portArg, protocolArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateNSHTTPCookie {
  /// The cookie’s properties.
  func properties(pigeonApi: PigeonApiNSHTTPCookie, pigeonInstance: NSHTTPCookie) throws -> [HttpCookiePropertyKey: Any?]
}

protocol PigeonApiProtocolNSHTTPCookie {
}

final class PigeonApiNSHTTPCookie: PigeonApiProtocolNSHTTPCookie  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateNSHTTPCookie
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateNSHTTPCookie) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of NSHTTPCookie and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: NSHTTPCookie, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let propertiesArg = try! pigeonDelegate.properties(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.NSHTTPCookie.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, propertiesArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateAuthenticationChallengeResponse {
  /// The option to use to handle the challenge.
  func disposition(pigeonApi: PigeonApiAuthenticationChallengeResponse, pigeonInstance: AuthenticationChallengeResponse) throws -> UrlSessionAuthChallengeDisposition
  /// The credential to use for authentication when the disposition parameter
  /// contains the value URLSession.AuthChallengeDisposition.useCredential.
  func credential(pigeonApi: PigeonApiAuthenticationChallengeResponse, pigeonInstance: AuthenticationChallengeResponse) throws -> NSURLCredential?
}

protocol PigeonApiProtocolAuthenticationChallengeResponse {
}

final class PigeonApiAuthenticationChallengeResponse: PigeonApiProtocolAuthenticationChallengeResponse  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateAuthenticationChallengeResponse
  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateAuthenticationChallengeResponse) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of AuthenticationChallengeResponse and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: AuthenticationChallengeResponse, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let dispositionArg = try! pigeonDelegate.disposition(pigeonApi: self, pigeonInstance: pigeonInstance)
    let credentialArg = try! pigeonDelegate.credential(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.AuthenticationChallengeResponse.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, dispositionArg, credentialArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateWKWebsiteDataStore {
  /// The default data store, which stores data persistently to disk.
  func defaultDataStore(pigeonApi: PigeonApiWKWebsiteDataStore) throws -> WKWebsiteDataStore
  /// The object that manages the HTTP cookies for your website.
  func httpCookieStore(pigeonApi: PigeonApiWKWebsiteDataStore, pigeonInstance: WKWebsiteDataStore) throws -> WKHTTPCookieStore
  /// Removes the specified types of website data from one or more data records.
  func removeDataOfTypes(pigeonApi: PigeonApiWKWebsiteDataStore, pigeonInstance: WKWebsiteDataStore, dataTypes: [WebsiteDataType], modificationTimeInSecondsSinceEpoch: Double, completion: @escaping (Result<Bool, Error>) -> Void)
}

protocol PigeonApiProtocolWKWebsiteDataStore {
}

final class PigeonApiWKWebsiteDataStore: PigeonApiProtocolWKWebsiteDataStore  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKWebsiteDataStore
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKWebsiteDataStore) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKWebsiteDataStore?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let defaultDataStoreChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebsiteDataStore.defaultDataStore", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      defaultDataStoreChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.defaultDataStore(pigeonApi: api), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      defaultDataStoreChannel.setMessageHandler(nil)
    }
    let httpCookieStoreChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebsiteDataStore.httpCookieStore", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      httpCookieStoreChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebsiteDataStore
        let pigeonIdentifierArg = args[1] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(try api.pigeonDelegate.httpCookieStore(pigeonApi: api, pigeonInstance: pigeonInstanceArg), withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      httpCookieStoreChannel.setMessageHandler(nil)
    }
    let removeDataOfTypesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebsiteDataStore.removeDataOfTypes", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeDataOfTypesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebsiteDataStore
        let dataTypesArg = args[1] as! [WebsiteDataType]
        let modificationTimeInSecondsSinceEpochArg = args[2] as! Double
        api.pigeonDelegate.removeDataOfTypes(pigeonApi: api, pigeonInstance: pigeonInstanceArg, dataTypes: dataTypesArg, modificationTimeInSecondsSinceEpoch: modificationTimeInSecondsSinceEpochArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeDataOfTypesChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKWebsiteDataStore and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKWebsiteDataStore, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebsiteDataStore.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateUIView {
  #if !os(macOS)
  /// The view’s background color.
  func setBackgroundColor(pigeonApi: PigeonApiUIView, pigeonInstance: UIView, value: Int64?) throws
  #endif
  #if !os(macOS)
  /// A Boolean value that determines whether the view is opaque.
  func setOpaque(pigeonApi: PigeonApiUIView, pigeonInstance: UIView, opaque: Bool) throws
  #endif
}

protocol PigeonApiProtocolUIView {
}

final class PigeonApiUIView: PigeonApiProtocolUIView  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateUIView
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateUIView) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiUIView?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    #if !os(macOS)
    let setBackgroundColorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.UIView.setBackgroundColor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setBackgroundColorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! UIView
        let valueArg: Int64? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setBackgroundColor(pigeonApi: api, pigeonInstance: pigeonInstanceArg, value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setBackgroundColorChannel.setMessageHandler(nil)
    }
    #endif
    #if !os(macOS)
    let setOpaqueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.UIView.setOpaque", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setOpaqueChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! UIView
        let opaqueArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setOpaque(pigeonApi: api, pigeonInstance: pigeonInstanceArg, opaque: opaqueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setOpaqueChannel.setMessageHandler(nil)
    }
    #endif
  }

  #if !os(macOS)
  ///Creates a Dart instance of UIView and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: UIView, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.UIView.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  #endif
}
protocol PigeonApiDelegateUIScrollView {
  #if !os(macOS)
  /// The point at which the origin of the content view is offset from the
  /// origin of the scroll view.
  func getContentOffset(pigeonApi: PigeonApiUIScrollView, pigeonInstance: UIScrollView) throws -> [Double]
  #endif
  #if !os(macOS)
  /// Move the scrolled position of your view.
  ///
  /// Convenience method to synchronize change to the x and y scroll position.
  func scrollBy(pigeonApi: PigeonApiUIScrollView, pigeonInstance: UIScrollView, x: Double, y: Double) throws
  #endif
  #if !os(macOS)
  /// The point at which the origin of the content view is offset from the
  /// origin of the scroll view.
  func setContentOffset(pigeonApi: PigeonApiUIScrollView, pigeonInstance: UIScrollView, x: Double, y: Double) throws
  #endif
  #if !os(macOS)
  /// The delegate of the scroll view.
  func setDelegate(pigeonApi: PigeonApiUIScrollView, pigeonInstance: UIScrollView, delegate: UIScrollViewDelegate?) throws
  #endif
}

protocol PigeonApiProtocolUIScrollView {
}

final class PigeonApiUIScrollView: PigeonApiProtocolUIScrollView  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateUIScrollView
  ///An implementation of [UIView] used to access callback methods
  var pigeonApiUIView: PigeonApiUIView {
    return pigeonRegistrar.apiDelegate.pigeonApiUIView(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateUIScrollView) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiUIScrollView?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    #if !os(macOS)
    let getContentOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollView.getContentOffset", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getContentOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! UIScrollView
        do {
          let result = try api.pigeonDelegate.getContentOffset(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getContentOffsetChannel.setMessageHandler(nil)
    }
    #endif
    #if !os(macOS)
    let scrollByChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollView.scrollBy", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      scrollByChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! UIScrollView
        let xArg = args[1] as! Double
        let yArg = args[2] as! Double
        do {
          try api.pigeonDelegate.scrollBy(pigeonApi: api, pigeonInstance: pigeonInstanceArg, x: xArg, y: yArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      scrollByChannel.setMessageHandler(nil)
    }
    #endif
    #if !os(macOS)
    let setContentOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollView.setContentOffset", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setContentOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! UIScrollView
        let xArg = args[1] as! Double
        let yArg = args[2] as! Double
        do {
          try api.pigeonDelegate.setContentOffset(pigeonApi: api, pigeonInstance: pigeonInstanceArg, x: xArg, y: yArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setContentOffsetChannel.setMessageHandler(nil)
    }
    #endif
    #if !os(macOS)
    let setDelegateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollView.setDelegate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setDelegateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! UIScrollView
        let delegateArg: UIScrollViewDelegate? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setDelegate(pigeonApi: api, pigeonInstance: pigeonInstanceArg, delegate: delegateArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setDelegateChannel.setMessageHandler(nil)
    }
    #endif
  }

  #if !os(macOS)
  ///Creates a Dart instance of UIScrollView and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: UIScrollView, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollView.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  #endif
}
protocol PigeonApiDelegateWKWebViewConfiguration {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiWKWebViewConfiguration) throws -> WKWebViewConfiguration
  /// A Boolean value that indicates whether HTML5 videos play inline or use the
  /// native full-screen controller.
  func setAllowsInlineMediaPlayback(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, allow: Bool) throws
  /// A Boolean value that indicates whether the web view limits navigation to
  /// pages within the app’s domain.
  func setLimitsNavigationsToAppBoundDomains(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, limit: Bool) throws
  /// The media types that require a user gesture to begin playing.
  func setMediaTypesRequiringUserActionForPlayback(pigeonApi: PigeonApiWKWebViewConfiguration, pigeonInstance: WKWebViewConfiguration, types: [AudiovisualMediaType]) throws
}

protocol PigeonApiProtocolWKWebViewConfiguration {
}

final class PigeonApiWKWebViewConfiguration: PigeonApiProtocolWKWebViewConfiguration  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKWebViewConfiguration
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKWebViewConfiguration) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKWebViewConfiguration?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let setAllowsInlineMediaPlaybackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.setAllowsInlineMediaPlayback", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAllowsInlineMediaPlaybackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebViewConfiguration
        let allowArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setAllowsInlineMediaPlayback(pigeonApi: api, pigeonInstance: pigeonInstanceArg, allow: allowArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAllowsInlineMediaPlaybackChannel.setMessageHandler(nil)
    }
    let setLimitsNavigationsToAppBoundDomainsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.setLimitsNavigationsToAppBoundDomains", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLimitsNavigationsToAppBoundDomainsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebViewConfiguration
        let limitArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setLimitsNavigationsToAppBoundDomains(pigeonApi: api, pigeonInstance: pigeonInstanceArg, limit: limitArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLimitsNavigationsToAppBoundDomainsChannel.setMessageHandler(nil)
    }
    let setMediaTypesRequiringUserActionForPlaybackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.setMediaTypesRequiringUserActionForPlayback", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setMediaTypesRequiringUserActionForPlaybackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebViewConfiguration
        let typesArg = args[1] as! [AudiovisualMediaType]
        do {
          try api.pigeonDelegate.setMediaTypesRequiringUserActionForPlayback(pigeonApi: api, pigeonInstance: pigeonInstanceArg, types: typesArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMediaTypesRequiringUserActionForPlaybackChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKWebViewConfiguration and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKWebViewConfiguration, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebViewConfiguration.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateWKUserContentController {
  /// Installs a message handler that you can call from your JavaScript code.
  func addScriptMessageHandler(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController, handler: WKScriptMessageHandler, name: String) throws
  /// Uninstalls the custom message handler with the specified name from your
  /// JavaScript code.
  func removeScriptMessageHandler(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController, name: String) throws
  /// Uninstalls all custom message handlers associated with the user content
  /// controller.
  func removeAllScriptMessageHandlers(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController) throws
  /// Injects the specified script into the webpage’s content.
  func addUserScript(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController, userScript: WKUserScript) throws
  /// Removes all user scripts from the web view.
  func removeAllUserScripts(pigeonApi: PigeonApiWKUserContentController, pigeonInstance: WKUserContentController, identifier: Int64) throws
}

protocol PigeonApiProtocolWKUserContentController {
}

final class PigeonApiWKUserContentController: PigeonApiProtocolWKUserContentController  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKUserContentController
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKUserContentController) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKUserContentController?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let addScriptMessageHandlerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserContentController.addScriptMessageHandler", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addScriptMessageHandlerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKUserContentController
        let handlerArg = args[1] as! WKScriptMessageHandler
        let nameArg = args[2] as! String
        do {
          try api.pigeonDelegate.addScriptMessageHandler(pigeonApi: api, pigeonInstance: pigeonInstanceArg, handler: handlerArg, name: nameArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addScriptMessageHandlerChannel.setMessageHandler(nil)
    }
    let removeScriptMessageHandlerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserContentController.removeScriptMessageHandler", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeScriptMessageHandlerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKUserContentController
        let nameArg = args[1] as! String
        do {
          try api.pigeonDelegate.removeScriptMessageHandler(pigeonApi: api, pigeonInstance: pigeonInstanceArg, name: nameArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeScriptMessageHandlerChannel.setMessageHandler(nil)
    }
    let removeAllScriptMessageHandlersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserContentController.removeAllScriptMessageHandlers", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeAllScriptMessageHandlersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKUserContentController
        do {
          try api.pigeonDelegate.removeAllScriptMessageHandlers(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeAllScriptMessageHandlersChannel.setMessageHandler(nil)
    }
    let addUserScriptChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserContentController.addUserScript", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addUserScriptChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKUserContentController
        let userScriptArg = args[1] as! WKUserScript
        do {
          try api.pigeonDelegate.addUserScript(pigeonApi: api, pigeonInstance: pigeonInstanceArg, userScript: userScriptArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addUserScriptChannel.setMessageHandler(nil)
    }
    let removeAllUserScriptsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserContentController.removeAllUserScripts", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeAllUserScriptsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKUserContentController
        let identifierArg = args[1] as! Int64
        do {
          try api.pigeonDelegate.removeAllUserScripts(pigeonApi: api, pigeonInstance: pigeonInstanceArg, identifier: identifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeAllUserScriptsChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKUserContentController and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKUserContentController, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUserContentController.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateWKPreferences {
  /// A Boolean value that indicates whether JavaScript is enabled.
  func setJavaScriptEnabled(pigeonApi: PigeonApiWKPreferences, pigeonInstance: WKPreferences, enabled: Bool) throws
}

protocol PigeonApiProtocolWKPreferences {
}

final class PigeonApiWKPreferences: PigeonApiProtocolWKPreferences  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKPreferences
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKPreferences) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKPreferences?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let setJavaScriptEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKPreferences.setJavaScriptEnabled", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setJavaScriptEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKPreferences
        let enabledArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setJavaScriptEnabled(pigeonApi: api, pigeonInstance: pigeonInstanceArg, enabled: enabledArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setJavaScriptEnabledChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKPreferences and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKPreferences, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKPreferences.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateWKScriptMessageHandler {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiWKScriptMessageHandler) throws -> WKScriptMessageHandler
}

protocol PigeonApiProtocolWKScriptMessageHandler {
  /// Tells the handler that a webpage sent a script message.
  func didReceiveScriptMessage(pigeonInstance pigeonInstanceArg: WKScriptMessageHandler, controller controllerArg: WKUserContentController, message messageArg: WKScriptMessage, completion: @escaping (Result<Void, PigeonError>) -> Void)
}

final class PigeonApiWKScriptMessageHandler: PigeonApiProtocolWKScriptMessageHandler  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKScriptMessageHandler
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKScriptMessageHandler) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKScriptMessageHandler?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKScriptMessageHandler.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKScriptMessageHandler and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKScriptMessageHandler, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    print("Error: Attempting to create a new Dart instance of WKScriptMessageHandler, but the class has a nonnull callback method.")
  }
  /// Tells the handler that a webpage sent a script message.
  func didReceiveScriptMessage(pigeonInstance pigeonInstanceArg: WKScriptMessageHandler, controller controllerArg: WKUserContentController, message messageArg: WKScriptMessage, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKScriptMessageHandler.didReceiveScriptMessage"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, controllerArg, messageArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

}
protocol PigeonApiDelegateWKNavigationDelegate {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiWKNavigationDelegate) throws -> WKNavigationDelegate
}

protocol PigeonApiProtocolWKNavigationDelegate {
  /// Tells the delegate that navigation is complete.
  func didFinishNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, url urlArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Tells the delegate that navigation from the main frame has started.
  func didStartProvisionalNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, url urlArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Asks the delegate for permission to navigate to new content based on the
  /// specified action information.
  func decidePolicyForNavigationAction(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, navigationAction navigationActionArg: WKNavigationAction, completion: @escaping (Result<NavigationActionPolicy, PigeonError>) -> Void)
  /// Asks the delegate for permission to navigate to new content after the
  /// response to the navigation request is known.
  func decidePolicyForNavigationResponse(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, navigationResponse navigationResponseArg: WKNavigationResponse, completion: @escaping (Result<NavigationResponsePolicy, PigeonError>) -> Void)
  /// Tells the delegate that an error occurred during navigation.
  func didFailNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, error errorArg: NSError, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Tells the delegate that an error occurred during the early navigation
  /// process.
  func didFailProvisionalNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, error errorArg: NSError, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Tells the delegate that the web view’s content process was terminated.
  func webViewWebContentProcessDidTerminate(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Asks the delegate to respond to an authentication challenge.
  func didReceiveAuthenticationChallenge(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, challenge challengeArg: NSURLAuthenticationChallenge, completion: @escaping (Result<AuthenticationChallengeResponse, PigeonError>) -> Void)
}

final class PigeonApiWKNavigationDelegate: PigeonApiProtocolWKNavigationDelegate  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKNavigationDelegate
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKNavigationDelegate) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKNavigationDelegate?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKNavigationDelegate and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKNavigationDelegate, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  /// Tells the delegate that navigation is complete.
  func didFinishNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, url urlArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.didFinishNavigation"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, urlArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Tells the delegate that navigation from the main frame has started.
  func didStartProvisionalNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, url urlArg: String?, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.didStartProvisionalNavigation"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, urlArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Asks the delegate for permission to navigate to new content based on the
  /// specified action information.
  func decidePolicyForNavigationAction(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, navigationAction navigationActionArg: WKNavigationAction, completion: @escaping (Result<NavigationActionPolicy, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.decidePolicyForNavigationAction"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, navigationActionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(PigeonError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! NavigationActionPolicy
        completion(.success(result))
      }
    }
  }

  /// Asks the delegate for permission to navigate to new content after the
  /// response to the navigation request is known.
  func decidePolicyForNavigationResponse(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, navigationResponse navigationResponseArg: WKNavigationResponse, completion: @escaping (Result<NavigationResponsePolicy, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.decidePolicyForNavigationResponse"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, navigationResponseArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(PigeonError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! NavigationResponsePolicy
        completion(.success(result))
      }
    }
  }

  /// Tells the delegate that an error occurred during navigation.
  func didFailNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, error errorArg: NSError, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.didFailNavigation"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Tells the delegate that an error occurred during the early navigation
  /// process.
  func didFailProvisionalNavigation(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, error errorArg: NSError, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.didFailProvisionalNavigation"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, errorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Tells the delegate that the web view’s content process was terminated.
  func webViewWebContentProcessDidTerminate(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.webViewWebContentProcessDidTerminate"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Asks the delegate to respond to an authentication challenge.
  func didReceiveAuthenticationChallenge(pigeonInstance pigeonInstanceArg: WKNavigationDelegate, webView webViewArg: WKWebView, challenge challengeArg: NSURLAuthenticationChallenge, completion: @escaping (Result<AuthenticationChallengeResponse, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKNavigationDelegate.didReceiveAuthenticationChallenge"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, challengeArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(PigeonError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! AuthenticationChallengeResponse
        completion(.success(result))
      }
    }
  }

}
protocol PigeonApiDelegateNSObject {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiNSObject) throws -> NSObject
  /// Registers the observer object to receive KVO notifications for the key
  /// path relative to the object receiving this message.
  func addObserver(pigeonApi: PigeonApiNSObject, pigeonInstance: NSObject, observer: NSObject, keyPath: String, options: [KeyValueObservingOptions]) throws
  /// Stops the observer object from receiving change notifications for the
  /// property specified by the key path relative to the object receiving this
  /// message.
  func removeObserver(pigeonApi: PigeonApiNSObject, pigeonInstance: NSObject, object: NSObject, keyPath: String) throws
}

protocol PigeonApiProtocolNSObject {
  /// Informs the observing object when the value at the specified key path
  /// relative to the observed object has changed.
  func observeValue(pigeonInstance pigeonInstanceArg: NSObject, keyPath keyPathArg: String, object objectArg: NSObject, change changeArg: [KeyValueChangeKey: Any?], completion: @escaping (Result<Void, PigeonError>) -> Void)
}

final class PigeonApiNSObject: PigeonApiProtocolNSObject  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateNSObject
  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateNSObject) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiNSObject?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.NSObject.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let addObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.NSObject.addObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! NSObject
        let observerArg = args[1] as! NSObject
        let keyPathArg = args[2] as! String
        let optionsArg = args[3] as! [KeyValueObservingOptions]
        do {
          try api.pigeonDelegate.addObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, observer: observerArg, keyPath: keyPathArg, options: optionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addObserverChannel.setMessageHandler(nil)
    }
    let removeObserverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.NSObject.removeObserver", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeObserverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! NSObject
        let objectArg = args[1] as! NSObject
        let keyPathArg = args[2] as! String
        do {
          try api.pigeonDelegate.removeObserver(pigeonApi: api, pigeonInstance: pigeonInstanceArg, object: objectArg, keyPath: keyPathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeObserverChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of NSObject and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: NSObject, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.NSObject.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  /// Informs the observing object when the value at the specified key path
  /// relative to the observed object has changed.
  func observeValue(pigeonInstance pigeonInstanceArg: NSObject, keyPath keyPathArg: String, object objectArg: NSObject, change changeArg: [KeyValueChangeKey: Any?], completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.NSObject.observeValue"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, keyPathArg, objectArg, changeArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

}
protocol PigeonApiDelegateWKWebView {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiWKWebView, configuration: WKWebViewConfiguration) throws -> WKWebView
  /// The object you use to integrate custom user interface elements, such as
  /// contextual menus or panels, into web view interactions.
  func setUIDelegate(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, delegate: WKUIDelegate) throws
  /// The object you use to manage navigation behavior for the web view.
  func setNavigationDelegate(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, delegate: WKNavigationDelegate) throws
  /// The URL for the current webpage.
  func getUrl(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> String?
  /// An estimate of what fraction of the current navigation has been loaded.
  func getEstimatedProgress(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> Double
  /// Loads the web content that the specified URL request object references and
  /// navigates to that content.
  func loadRequest(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, request: NSURLRequest) throws
  /// Loads the contents of the specified HTML string and navigates to it.
  func loadHtmlString(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, string: String, baseUrl: String?) throws
  /// Loads the web content from the specified file and navigates to it.
  func loadFileUrl(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, url: String, readAccessUrl: String) throws
  /// Convenience method to load a Flutter asset.
  func loadFlutterAsset(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, key: String) throws
  /// A Boolean value that indicates whether there is a valid back item in the
  /// back-forward list.
  func canGoBack(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> Bool
  /// A Boolean value that indicates whether there is a valid forward item in
  /// the back-forward list.
  func canGoForward(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> Bool
  /// Navigates to the back item in the back-forward list.
  func goBack(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws
  /// Navigates to the forward item in the back-forward list.
  func goForward(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws
  /// Reloads the current webpage.
  func reload(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws
  /// The page title.
  func getTitle(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> String?
  /// A Boolean value that indicates whether horizontal swipe gestures trigger
  /// backward and forward page navigation.
  func setAllowsBackForwardNavigationGestures(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, allow: Bool) throws
  /// The custom user agent string.
  func setCustomUserAgent(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, userAgent: String?) throws
  /// Evaluates the specified JavaScript string.
  func evaluateJavaScript(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, javaScriptString: String, completion: @escaping (Result<Any?, Error>) -> Void)
  /// A Boolean value that indicates whether you can inspect the view with
  /// Safari Web Inspector.
  func setInspectable(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView, inspectable: Bool) throws
  /// The custom user agent string.
  func getCustomUserAgent(pigeonApi: PigeonApiWKWebView, pigeonInstance: WKWebView) throws -> String?
}

protocol PigeonApiProtocolWKWebView {
}

final class PigeonApiWKWebView: PigeonApiProtocolWKWebView  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKWebView
  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKWebView) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKWebView?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let configurationArg = args[1] as! WKWebViewConfiguration
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, configuration: configurationArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
    let setUIDelegateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.setUIDelegate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setUIDelegateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let delegateArg = args[1] as! WKUIDelegate
        do {
          try api.pigeonDelegate.setUIDelegate(pigeonApi: api, pigeonInstance: pigeonInstanceArg, delegate: delegateArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setUIDelegateChannel.setMessageHandler(nil)
    }
    let setNavigationDelegateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.setNavigationDelegate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setNavigationDelegateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let delegateArg = args[1] as! WKNavigationDelegate
        do {
          try api.pigeonDelegate.setNavigationDelegate(pigeonApi: api, pigeonInstance: pigeonInstanceArg, delegate: delegateArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setNavigationDelegateChannel.setMessageHandler(nil)
    }
    let getUrlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.getUrl", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getUrlChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          let result = try api.pigeonDelegate.getUrl(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getUrlChannel.setMessageHandler(nil)
    }
    let getEstimatedProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.getEstimatedProgress", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getEstimatedProgressChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          let result = try api.pigeonDelegate.getEstimatedProgress(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getEstimatedProgressChannel.setMessageHandler(nil)
    }
    let loadRequestChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.loadRequest", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadRequestChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let requestArg = args[1] as! NSURLRequest
        do {
          try api.pigeonDelegate.loadRequest(pigeonApi: api, pigeonInstance: pigeonInstanceArg, request: requestArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      loadRequestChannel.setMessageHandler(nil)
    }
    let loadHtmlStringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.loadHtmlString", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadHtmlStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let stringArg = args[1] as! String
        let baseUrlArg: String? = nilOrValue(args[2])
        do {
          try api.pigeonDelegate.loadHtmlString(pigeonApi: api, pigeonInstance: pigeonInstanceArg, string: stringArg, baseUrl: baseUrlArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      loadHtmlStringChannel.setMessageHandler(nil)
    }
    let loadFileUrlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.loadFileUrl", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadFileUrlChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let urlArg = args[1] as! String
        let readAccessUrlArg = args[2] as! String
        do {
          try api.pigeonDelegate.loadFileUrl(pigeonApi: api, pigeonInstance: pigeonInstanceArg, url: urlArg, readAccessUrl: readAccessUrlArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      loadFileUrlChannel.setMessageHandler(nil)
    }
    let loadFlutterAssetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.loadFlutterAsset", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadFlutterAssetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let keyArg = args[1] as! String
        do {
          try api.pigeonDelegate.loadFlutterAsset(pigeonApi: api, pigeonInstance: pigeonInstanceArg, key: keyArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      loadFlutterAssetChannel.setMessageHandler(nil)
    }
    let canGoBackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.canGoBack", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      canGoBackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          let result = try api.pigeonDelegate.canGoBack(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      canGoBackChannel.setMessageHandler(nil)
    }
    let canGoForwardChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.canGoForward", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      canGoForwardChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          let result = try api.pigeonDelegate.canGoForward(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      canGoForwardChannel.setMessageHandler(nil)
    }
    let goBackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.goBack", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      goBackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          try api.pigeonDelegate.goBack(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      goBackChannel.setMessageHandler(nil)
    }
    let goForwardChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.goForward", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      goForwardChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          try api.pigeonDelegate.goForward(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      goForwardChannel.setMessageHandler(nil)
    }
    let reloadChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.reload", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      reloadChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          try api.pigeonDelegate.reload(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      reloadChannel.setMessageHandler(nil)
    }
    let getTitleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.getTitle", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTitleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          let result = try api.pigeonDelegate.getTitle(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTitleChannel.setMessageHandler(nil)
    }
    let setAllowsBackForwardNavigationGesturesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.setAllowsBackForwardNavigationGestures", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAllowsBackForwardNavigationGesturesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let allowArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setAllowsBackForwardNavigationGestures(pigeonApi: api, pigeonInstance: pigeonInstanceArg, allow: allowArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAllowsBackForwardNavigationGesturesChannel.setMessageHandler(nil)
    }
    let setCustomUserAgentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.setCustomUserAgent", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCustomUserAgentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let userAgentArg: String? = nilOrValue(args[1])
        do {
          try api.pigeonDelegate.setCustomUserAgent(pigeonApi: api, pigeonInstance: pigeonInstanceArg, userAgent: userAgentArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCustomUserAgentChannel.setMessageHandler(nil)
    }
    let evaluateJavaScriptChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.evaluateJavaScript", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      evaluateJavaScriptChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let javaScriptStringArg = args[1] as! String
        api.pigeonDelegate.evaluateJavaScript(pigeonApi: api, pigeonInstance: pigeonInstanceArg, javaScriptString: javaScriptStringArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      evaluateJavaScriptChannel.setMessageHandler(nil)
    }
    let setInspectableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.setInspectable", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setInspectableChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        let inspectableArg = args[1] as! Bool
        do {
          try api.pigeonDelegate.setInspectable(pigeonApi: api, pigeonInstance: pigeonInstanceArg, inspectable: inspectableArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setInspectableChannel.setMessageHandler(nil)
    }
    let getCustomUserAgentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.getCustomUserAgent", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCustomUserAgentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKWebView
        do {
          let result = try api.pigeonDelegate.getCustomUserAgent(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCustomUserAgentChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKWebView and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKWebView, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKWebView.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateWKUIDelegate {
  func pigeonDefaultConstructor(pigeonApi: PigeonApiWKUIDelegate) throws -> WKUIDelegate
}

protocol PigeonApiProtocolWKUIDelegate {
  /// Creates a new web view.
  func onCreateWebView(pigeonInstance pigeonInstanceArg: WKUIDelegate, webView webViewArg: WKWebView, configuration configurationArg: WKWebViewConfiguration, navigationAction navigationActionArg: WKNavigationAction, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Determines whether a web resource, which the security origin object
  /// describes, can access to the device’s microphone audio and camera video.
  func requestMediaCapturePermission(pigeonInstance pigeonInstanceArg: WKUIDelegate, webView webViewArg: WKWebView, origin originArg: WKSecurityOrigin, frame frameArg: WKFrameInfo, type typeArg: MediaCaptureType, completion: @escaping (Result<PermissionDecision, PigeonError>) -> Void)
  /// Displays a JavaScript alert panel.
  func runJavaScriptAlertPanel(pigeonInstance pigeonInstanceArg: WKUIDelegate, message messageArg: String, frame frameArg: WKFrameInfo, completion: @escaping (Result<Void, PigeonError>) -> Void)
  /// Displays a JavaScript confirm panel.
  func runJavaScriptConfirmPanel(pigeonInstance pigeonInstanceArg: WKUIDelegate, message messageArg: String, frame frameArg: WKFrameInfo, completion: @escaping (Result<Bool, PigeonError>) -> Void)
  /// Displays a JavaScript text input panel.
  func runJavaScriptTextInputPanel(pigeonInstance pigeonInstanceArg: WKUIDelegate, prompt promptArg: String, defaultText defaultTextArg: String, frame frameArg: WKFrameInfo, completion: @escaping (Result<String, PigeonError>) -> Void)
}

final class PigeonApiWKUIDelegate: PigeonApiProtocolWKUIDelegate  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKUIDelegate
  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKUIDelegate) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKUIDelegate?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKUIDelegate and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKUIDelegate, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  /// Creates a new web view.
  func onCreateWebView(pigeonInstance pigeonInstanceArg: WKUIDelegate, webView webViewArg: WKWebView, configuration configurationArg: WKWebViewConfiguration, navigationAction navigationActionArg: WKNavigationAction, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.onCreateWebView"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, configurationArg, navigationActionArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Determines whether a web resource, which the security origin object
  /// describes, can access to the device’s microphone audio and camera video.
  func requestMediaCapturePermission(pigeonInstance pigeonInstanceArg: WKUIDelegate, webView webViewArg: WKWebView, origin originArg: WKSecurityOrigin, frame frameArg: WKFrameInfo, type typeArg: MediaCaptureType, completion: @escaping (Result<PermissionDecision, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.requestMediaCapturePermission"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, webViewArg, originArg, frameArg, typeArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(PigeonError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! PermissionDecision
        completion(.success(result))
      }
    }
  }

  /// Displays a JavaScript alert panel.
  func runJavaScriptAlertPanel(pigeonInstance pigeonInstanceArg: WKUIDelegate, message messageArg: String, frame frameArg: WKFrameInfo, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.runJavaScriptAlertPanel"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, messageArg, frameArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

  /// Displays a JavaScript confirm panel.
  func runJavaScriptConfirmPanel(pigeonInstance pigeonInstanceArg: WKUIDelegate, message messageArg: String, frame frameArg: WKFrameInfo, completion: @escaping (Result<Bool, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.runJavaScriptConfirmPanel"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, messageArg, frameArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(PigeonError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! Bool
        completion(.success(result))
      }
    }
  }

  /// Displays a JavaScript text input panel.
  func runJavaScriptTextInputPanel(pigeonInstance pigeonInstanceArg: WKUIDelegate, prompt promptArg: String, defaultText defaultTextArg: String, frame frameArg: WKFrameInfo, completion: @escaping (Result<String, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKUIDelegate.runJavaScriptTextInputPanel"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, promptArg, defaultTextArg, frameArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(.failure(PigeonError(code: "null-error", message: "Flutter api returned null value for non-null return value.", details: "")))
      } else {
        let result = listResponse[0] as! String
        completion(.success(result))
      }
    }
  }

}
protocol PigeonApiDelegateWKHTTPCookieStore {
  /// Sets a cookie policy that indicates whether the cookie store allows cookie
  /// storage.
  func setCookie(pigeonApi: PigeonApiWKHTTPCookieStore, pigeonInstance: WKHTTPCookieStore, cookie: NSHTTPCookie, completion: @escaping (Result<Void, Error>) -> Void)
}

protocol PigeonApiProtocolWKHTTPCookieStore {
}

final class PigeonApiWKHTTPCookieStore: PigeonApiProtocolWKHTTPCookieStore  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateWKHTTPCookieStore
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateWKHTTPCookieStore) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiWKHTTPCookieStore?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let setCookieChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.WKHTTPCookieStore.setCookie", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCookieChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! WKHTTPCookieStore
        let cookieArg = args[1] as! NSHTTPCookie
        api.pigeonDelegate.setCookie(pigeonApi: api, pigeonInstance: pigeonInstanceArg, cookie: cookieArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setCookieChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of WKHTTPCookieStore and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: WKHTTPCookieStore, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.WKHTTPCookieStore.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateNSURL {
  /// The URL string for the receiver as an absolute URL.
  func getAbsoluteString(pigeonApi: PigeonApiNSURL, pigeonInstance: NSURL) throws -> String?
}

protocol PigeonApiProtocolNSURL {
}

final class PigeonApiNSURL: PigeonApiProtocolNSURL  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateNSURL
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateNSURL) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiNSURL?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getAbsoluteStringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.NSURL.getAbsoluteString", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAbsoluteStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! NSURL
        do {
          let result = try api.pigeonDelegate.getAbsoluteString(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAbsoluteStringChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of NSURL and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: NSURL, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.NSURL.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
open class PigeonApiDelegateUIScrollViewDelegate {
}

protocol PigeonApiProtocolUIScrollViewDelegate {
  /// Tells the delegate when the user scrolls the content view within the
  /// scroll view.
  ///
  /// Note that this is a convenient method that includes the `contentOffset` of
  /// the `scrollView`.
  func scrollViewDidScroll(pigeonInstance pigeonInstanceArg: UIScrollViewDelegate, scrollView scrollViewArg: UIScrollViewDelegate, x xArg: Double, y yArg: Double, completion: @escaping (Result<Void, PigeonError>) -> Void)
}

final class PigeonApiUIScrollViewDelegate: PigeonApiProtocolUIScrollViewDelegate  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateUIScrollViewDelegate
  ///An implementation of [NSObject] used to access callback methods
  var pigeonApiNSObject: PigeonApiNSObject {
    return pigeonRegistrar.apiDelegate.pigeonApiNSObject(pigeonRegistrar)
  }

  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateUIScrollViewDelegate) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of UIScrollViewDelegate and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: UIScrollViewDelegate, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollViewDelegate.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  /// Tells the delegate when the user scrolls the content view within the
  /// scroll view.
  ///
  /// Note that this is a convenient method that includes the `contentOffset` of
  /// the `scrollView`.
  func scrollViewDidScroll(pigeonInstance pigeonInstanceArg: UIScrollViewDelegate, scrollView scrollViewArg: UIScrollViewDelegate, x xArg: Double, y yArg: Double, completion: @escaping (Result<Void, PigeonError>) -> Void)   {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.UIScrollViewDelegate.scrollViewDidScroll"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonInstanceArg, scrollViewArg, xArg, yArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }

}
protocol PigeonApiDelegateNSURLCredential {
  /// Creates a URL credential instance for internet password authentication
  /// with a given user name and password, using a given persistence setting.
  func pigeonDefaultConstructor(pigeonApi: PigeonApiNSURLCredential, user: String, password: String, persistence: UrlCredentialPersistence) throws -> NSURLCredential
}

protocol PigeonApiProtocolNSURLCredential {
}

final class PigeonApiNSURLCredential: PigeonApiProtocolNSURLCredential  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateNSURLCredential
  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateNSURLCredential) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiNSURLCredential?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let pigeonDefaultConstructorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.NSURLCredential.pigeon_defaultConstructor", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pigeonDefaultConstructorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonIdentifierArg = args[0] as! Int64
        let userArg = args[1] as! String
        let passwordArg = args[2] as! String
        let persistenceArg = args[3] as! UrlCredentialPersistence
        do {
          api.pigeonRegistrar.instanceManager.addDartCreatedInstance(
try api.pigeonDelegate.pigeonDefaultConstructor(pigeonApi: api, user: userArg, password: passwordArg, persistence: persistenceArg),
withIdentifier: pigeonIdentifierArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pigeonDefaultConstructorChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of NSURLCredential and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: NSURLCredential, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.NSURLCredential.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateNSURLProtectionSpace {
  /// The receiver’s host.
  func host(pigeonApi: PigeonApiNSURLProtectionSpace, pigeonInstance: NSURLProtectionSpace) throws -> String
  /// The receiver’s port.
  func port(pigeonApi: PigeonApiNSURLProtectionSpace, pigeonInstance: NSURLProtectionSpace) throws -> Int64
  /// The receiver’s authentication realm.
  func realm(pigeonApi: PigeonApiNSURLProtectionSpace, pigeonInstance: NSURLProtectionSpace) throws -> Int64?
  /// The authentication method used by the receiver.
  func authenticationMethod(pigeonApi: PigeonApiNSURLProtectionSpace, pigeonInstance: NSURLProtectionSpace) throws -> String?
}

protocol PigeonApiProtocolNSURLProtectionSpace {
}

final class PigeonApiNSURLProtectionSpace: PigeonApiProtocolNSURLProtectionSpace  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateNSURLProtectionSpace
  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateNSURLProtectionSpace) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  ///Creates a Dart instance of NSURLProtectionSpace and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: NSURLProtectionSpace, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let hostArg = try! pigeonDelegate.host(pigeonApi: self, pigeonInstance: pigeonInstance)
    let portArg = try! pigeonDelegate.port(pigeonApi: self, pigeonInstance: pigeonInstance)
    let realmArg = try! pigeonDelegate.realm(pigeonApi: self, pigeonInstance: pigeonInstance)
    let authenticationMethodArg = try! pigeonDelegate.authenticationMethod(pigeonApi: self, pigeonInstance: pigeonInstance)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.NSURLProtectionSpace.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg, hostArg, portArg, realmArg, authenticationMethodArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
protocol PigeonApiDelegateNSURLAuthenticationChallenge {
  /// The receiver’s protection space.
  func getProtectionSpace(pigeonApi: PigeonApiNSURLAuthenticationChallenge, pigeonInstance: NSURLAuthenticationChallenge) throws -> NSURLProtectionSpace
}

protocol PigeonApiProtocolNSURLAuthenticationChallenge {
}

final class PigeonApiNSURLAuthenticationChallenge: PigeonApiProtocolNSURLAuthenticationChallenge  {
  unowned let pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar
  let pigeonDelegate: PigeonApiDelegateNSURLAuthenticationChallenge
  init(pigeonRegistrar: WebKitLibraryPigeonProxyApiRegistrar, delegate: PigeonApiDelegateNSURLAuthenticationChallenge) {
    self.pigeonRegistrar = pigeonRegistrar
    self.pigeonDelegate = delegate
  }
  static func setUpMessageHandlers(binaryMessenger: FlutterBinaryMessenger, api: PigeonApiNSURLAuthenticationChallenge?) {
    let codec: FlutterStandardMessageCodec =
      api != nil
      ? FlutterStandardMessageCodec(
        readerWriter: WebKitLibraryPigeonInternalProxyApiCodecReaderWriter(pigeonRegistrar: api!.pigeonRegistrar))
      : FlutterStandardMessageCodec.sharedInstance()
    let getProtectionSpaceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.webview_flutter_wkwebview.NSURLAuthenticationChallenge.getProtectionSpace", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getProtectionSpaceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pigeonInstanceArg = args[0] as! NSURLAuthenticationChallenge
        do {
          let result = try api.pigeonDelegate.getProtectionSpace(pigeonApi: api, pigeonInstance: pigeonInstanceArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getProtectionSpaceChannel.setMessageHandler(nil)
    }
  }

  ///Creates a Dart instance of NSURLAuthenticationChallenge and attaches it to [pigeonInstance].
  func pigeonNewInstance(pigeonInstance: NSURLAuthenticationChallenge, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    if pigeonRegistrar.ignoreCallsToDart {
      completion(
        .failure(
          PigeonError(
            code: "ignore-calls-error",
            message: "Calls to Dart are being ignored.", details: "")))
      return
    }
    if pigeonRegistrar.instanceManager.containsInstance(pigeonInstance as AnyObject) {
      completion(.success(Void()))
      return
    }
    let pigeonIdentifierArg = pigeonRegistrar.instanceManager.addHostCreatedInstance(pigeonInstance as AnyObject)
    let binaryMessenger = pigeonRegistrar.binaryMessenger
    let codec = pigeonRegistrar.codec
    let channelName: String = "dev.flutter.pigeon.webview_flutter_wkwebview.NSURLAuthenticationChallenge.pigeon_newInstance"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([pigeonIdentifierArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
