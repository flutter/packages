// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.4.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

List<Object?> wrapResponse(
    {Object? result, PlatformException? error, bool empty = false}) {
  if (empty) {
    return <Object?>[];
  }
  if (error == null) {
    return <Object?>[result];
  }
  return <Object?>[error.code, error.message, error.details];
}

/// Pigeon equivalent of MapType
enum PlatformMapType {
  none,
  normal,
  satellite,
  terrain,
  hybrid,
}

enum PlatformRendererType {
  legacy,
  latest,
}

/// Join types for polyline joints.
enum PlatformJointType {
  mitered,
  bevel,
  round,
}

/// Enumeration of possible types of PlatformCap, corresponding to the
/// subclasses of Cap in the Google Maps Android SDK.
/// See https://developers.google.com/maps/documentation/android-sdk/reference/com/google/android/libraries/maps/model/Cap.
enum PlatformCapType {
  buttCap,
  roundCap,
  squareCap,
  customCap,
}

/// Enumeration of possible types for PatternItem.
enum PlatformPatternItemType {
  dot,
  dash,
  gap,
}

/// Pigeon equivalent of [MapBitmapScaling].
enum PlatformMapBitmapScaling {
  auto,
  none,
}

/// Pigeon representatation of a CameraPosition.
class PlatformCameraPosition {
  PlatformCameraPosition({
    required this.bearing,
    required this.target,
    required this.tilt,
    required this.zoom,
  });

  double bearing;

  PlatformLatLng target;

  double tilt;

  double zoom;

  Object encode() {
    return <Object?>[
      bearing,
      target,
      tilt,
      zoom,
    ];
  }

  static PlatformCameraPosition decode(Object result) {
    result as List<Object?>;
    return PlatformCameraPosition(
      bearing: result[0]! as double,
      target: result[1]! as PlatformLatLng,
      tilt: result[2]! as double,
      zoom: result[3]! as double,
    );
  }
}

/// Pigeon representation of a CameraUpdate.
class PlatformCameraUpdate {
  PlatformCameraUpdate({
    required this.cameraUpdate,
  });

  /// This Object shall be any of the below classes prefixed with
  /// PlatformCameraUpdate. Each such class represents a different type of
  /// camera update, and each holds a different set of data, preventing the
  /// use of a single unified class. Pigeon does not support inheritance, which
  /// prevents a more strict type bound.
  /// See https://github.com/flutter/flutter/issues/117819.
  Object cameraUpdate;

  Object encode() {
    return <Object?>[
      cameraUpdate,
    ];
  }

  static PlatformCameraUpdate decode(Object result) {
    result as List<Object?>;
    return PlatformCameraUpdate(
      cameraUpdate: result[0]!,
    );
  }
}

/// Pigeon equivalent of NewCameraPosition
class PlatformCameraUpdateNewCameraPosition {
  PlatformCameraUpdateNewCameraPosition({
    required this.cameraPosition,
  });

  PlatformCameraPosition cameraPosition;

  Object encode() {
    return <Object?>[
      cameraPosition,
    ];
  }

  static PlatformCameraUpdateNewCameraPosition decode(Object result) {
    result as List<Object?>;
    return PlatformCameraUpdateNewCameraPosition(
      cameraPosition: result[0]! as PlatformCameraPosition,
    );
  }
}

/// Pigeon equivalent of NewLatLng
class PlatformCameraUpdateNewLatLng {
  PlatformCameraUpdateNewLatLng({
    required this.latLng,
  });

  PlatformLatLng latLng;

  Object encode() {
    return <Object?>[
      latLng,
    ];
  }

  static PlatformCameraUpdateNewLatLng decode(Object result) {
    result as List<Object?>;
    return PlatformCameraUpdateNewLatLng(
      latLng: result[0]! as PlatformLatLng,
    );
  }
}

/// Pigeon equivalent of NewLatLngBounds
class PlatformCameraUpdateNewLatLngBounds {
  PlatformCameraUpdateNewLatLngBounds({
    required this.bounds,
    required this.padding,
  });

  PlatformLatLngBounds bounds;

  double padding;

  Object encode() {
    return <Object?>[
      bounds,
      padding,
    ];
  }

  static PlatformCameraUpdateNewLatLngBounds decode(Object result) {
    result as List<Object?>;
    return PlatformCameraUpdateNewLatLngBounds(
      bounds: result[0]! as PlatformLatLngBounds,
      padding: result[1]! as double,
    );
  }
}

/// Pigeon equivalent of NewLatLngZoom
class PlatformCameraUpdateNewLatLngZoom {
  PlatformCameraUpdateNewLatLngZoom({
    required this.latLng,
    required this.zoom,
  });

  PlatformLatLng latLng;

  double zoom;

  Object encode() {
    return <Object?>[
      latLng,
      zoom,
    ];
  }

  static PlatformCameraUpdateNewLatLngZoom decode(Object result) {
    result as List<Object?>;
    return PlatformCameraUpdateNewLatLngZoom(
      latLng: result[0]! as PlatformLatLng,
      zoom: result[1]! as double,
    );
  }
}

/// Pigeon equivalent of ScrollBy
class PlatformCameraUpdateScrollBy {
  PlatformCameraUpdateScrollBy({
    required this.dx,
    required this.dy,
  });

  double dx;

  double dy;

  Object encode() {
    return <Object?>[
      dx,
      dy,
    ];
  }

  static PlatformCameraUpdateScrollBy decode(Object result) {
    result as List<Object?>;
    return PlatformCameraUpdateScrollBy(
      dx: result[0]! as double,
      dy: result[1]! as double,
    );
  }
}

/// Pigeon equivalent of ZoomBy
class PlatformCameraUpdateZoomBy {
  PlatformCameraUpdateZoomBy({
    required this.amount,
    this.focus,
  });

  double amount;

  PlatformDoublePair? focus;

  Object encode() {
    return <Object?>[
      amount,
      focus,
    ];
  }

  static PlatformCameraUpdateZoomBy decode(Object result) {
    result as List<Object?>;
    return PlatformCameraUpdateZoomBy(
      amount: result[0]! as double,
      focus: result[1] as PlatformDoublePair?,
    );
  }
}

/// Pigeon equivalent of ZoomIn/ZoomOut
class PlatformCameraUpdateZoom {
  PlatformCameraUpdateZoom({
    required this.out,
  });

  bool out;

  Object encode() {
    return <Object?>[
      out,
    ];
  }

  static PlatformCameraUpdateZoom decode(Object result) {
    result as List<Object?>;
    return PlatformCameraUpdateZoom(
      out: result[0]! as bool,
    );
  }
}

/// Pigeon equivalent of ZoomTo
class PlatformCameraUpdateZoomTo {
  PlatformCameraUpdateZoomTo({
    required this.zoom,
  });

  double zoom;

  Object encode() {
    return <Object?>[
      zoom,
    ];
  }

  static PlatformCameraUpdateZoomTo decode(Object result) {
    result as List<Object?>;
    return PlatformCameraUpdateZoomTo(
      zoom: result[0]! as double,
    );
  }
}

/// Pigeon equivalent of the Circle class.
class PlatformCircle {
  PlatformCircle({
    this.consumeTapEvents = false,
    this.fillColor = 0x00000000,
    this.strokeColor = 0xFF000000,
    this.visible = true,
    this.strokeWidth = 10,
    this.zIndex = 0.0,
    required this.center,
    this.radius = 0,
    required this.circleId,
  });

  bool consumeTapEvents;

  int fillColor;

  int strokeColor;

  bool visible;

  int strokeWidth;

  double zIndex;

  PlatformLatLng center;

  double radius;

  String circleId;

  Object encode() {
    return <Object?>[
      consumeTapEvents,
      fillColor,
      strokeColor,
      visible,
      strokeWidth,
      zIndex,
      center,
      radius,
      circleId,
    ];
  }

  static PlatformCircle decode(Object result) {
    result as List<Object?>;
    return PlatformCircle(
      consumeTapEvents: result[0]! as bool,
      fillColor: result[1]! as int,
      strokeColor: result[2]! as int,
      visible: result[3]! as bool,
      strokeWidth: result[4]! as int,
      zIndex: result[5]! as double,
      center: result[6]! as PlatformLatLng,
      radius: result[7]! as double,
      circleId: result[8]! as String,
    );
  }
}

/// Pigeon equivalent of the Heatmap class.
class PlatformHeatmap {
  PlatformHeatmap({
    required this.json,
  });

  /// The heatmap data, as JSON. This should only be set from
  /// Heatmap.toJson, and the native code must interpret it according to the
  /// internal implementation details of that method.
  Map<String?, Object?> json;

  Object encode() {
    return <Object?>[
      json,
    ];
  }

  static PlatformHeatmap decode(Object result) {
    result as List<Object?>;
    return PlatformHeatmap(
      json: (result[0] as Map<Object?, Object?>?)!.cast<String?, Object?>(),
    );
  }
}

/// Pigeon equivalent of the ClusterManager class.
class PlatformClusterManager {
  PlatformClusterManager({
    required this.identifier,
  });

  String identifier;

  Object encode() {
    return <Object?>[
      identifier,
    ];
  }

  static PlatformClusterManager decode(Object result) {
    result as List<Object?>;
    return PlatformClusterManager(
      identifier: result[0]! as String,
    );
  }
}

/// Pair of double values, such as for an offset or size.
class PlatformDoublePair {
  PlatformDoublePair({
    required this.x,
    required this.y,
  });

  double x;

  double y;

  Object encode() {
    return <Object?>[
      x,
      y,
    ];
  }

  static PlatformDoublePair decode(Object result) {
    result as List<Object?>;
    return PlatformDoublePair(
      x: result[0]! as double,
      y: result[1]! as double,
    );
  }
}

/// Pigeon equivalent of the InfoWindow class.
class PlatformInfoWindow {
  PlatformInfoWindow({
    this.title,
    this.snippet,
    required this.anchor,
  });

  String? title;

  String? snippet;

  PlatformDoublePair anchor;

  Object encode() {
    return <Object?>[
      title,
      snippet,
      anchor,
    ];
  }

  static PlatformInfoWindow decode(Object result) {
    result as List<Object?>;
    return PlatformInfoWindow(
      title: result[0] as String?,
      snippet: result[1] as String?,
      anchor: result[2]! as PlatformDoublePair,
    );
  }
}

/// Pigeon equivalent of the Marker class.
class PlatformMarker {
  PlatformMarker({
    this.alpha = 1.0,
    required this.anchor,
    this.consumeTapEvents = false,
    this.draggable = false,
    this.flat = false,
    required this.icon,
    required this.infoWindow,
    required this.position,
    this.rotation = 0.0,
    this.visible = true,
    this.zIndex = 0.0,
    required this.markerId,
    this.clusterManagerId,
  });

  double alpha;

  PlatformDoublePair anchor;

  bool consumeTapEvents;

  bool draggable;

  bool flat;

  PlatformBitmap icon;

  PlatformInfoWindow infoWindow;

  PlatformLatLng position;

  double rotation;

  bool visible;

  double zIndex;

  String markerId;

  String? clusterManagerId;

  Object encode() {
    return <Object?>[
      alpha,
      anchor,
      consumeTapEvents,
      draggable,
      flat,
      icon,
      infoWindow,
      position,
      rotation,
      visible,
      zIndex,
      markerId,
      clusterManagerId,
    ];
  }

  static PlatformMarker decode(Object result) {
    result as List<Object?>;
    return PlatformMarker(
      alpha: result[0]! as double,
      anchor: result[1]! as PlatformDoublePair,
      consumeTapEvents: result[2]! as bool,
      draggable: result[3]! as bool,
      flat: result[4]! as bool,
      icon: result[5]! as PlatformBitmap,
      infoWindow: result[6]! as PlatformInfoWindow,
      position: result[7]! as PlatformLatLng,
      rotation: result[8]! as double,
      visible: result[9]! as bool,
      zIndex: result[10]! as double,
      markerId: result[11]! as String,
      clusterManagerId: result[12] as String?,
    );
  }
}

/// Pigeon equivalent of the Polygon class.
class PlatformPolygon {
  PlatformPolygon({
    required this.polygonId,
    required this.consumesTapEvents,
    required this.fillColor,
    required this.geodesic,
    required this.points,
    required this.holes,
    required this.visible,
    required this.strokeColor,
    required this.strokeWidth,
    required this.zIndex,
  });

  String polygonId;

  bool consumesTapEvents;

  int fillColor;

  bool geodesic;

  List<PlatformLatLng?> points;

  List<List<PlatformLatLng?>?> holes;

  bool visible;

  int strokeColor;

  int strokeWidth;

  int zIndex;

  Object encode() {
    return <Object?>[
      polygonId,
      consumesTapEvents,
      fillColor,
      geodesic,
      points,
      holes,
      visible,
      strokeColor,
      strokeWidth,
      zIndex,
    ];
  }

  static PlatformPolygon decode(Object result) {
    result as List<Object?>;
    return PlatformPolygon(
      polygonId: result[0]! as String,
      consumesTapEvents: result[1]! as bool,
      fillColor: result[2]! as int,
      geodesic: result[3]! as bool,
      points: (result[4] as List<Object?>?)!.cast<PlatformLatLng?>(),
      holes: (result[5] as List<Object?>?)!.cast<List<PlatformLatLng?>?>(),
      visible: result[6]! as bool,
      strokeColor: result[7]! as int,
      strokeWidth: result[8]! as int,
      zIndex: result[9]! as int,
    );
  }
}

/// Pigeon equivalent of the Polyline class.
class PlatformPolyline {
  PlatformPolyline({
    required this.polylineId,
    required this.consumesTapEvents,
    required this.color,
    required this.geodesic,
    required this.jointType,
    required this.patterns,
    required this.points,
    required this.startCap,
    required this.endCap,
    required this.visible,
    required this.width,
    required this.zIndex,
  });

  String polylineId;

  bool consumesTapEvents;

  int color;

  bool geodesic;

  /// The joint type.
  PlatformJointType jointType;

  /// The pattern data, as a list of pattern items.
  List<PlatformPatternItem?> patterns;

  List<PlatformLatLng?> points;

  /// The cap at the start and end vertex of a polyline.
  /// See https://developers.google.com/maps/documentation/android-sdk/reference/com/google/android/libraries/maps/model/Cap.
  PlatformCap startCap;

  PlatformCap endCap;

  bool visible;

  int width;

  int zIndex;

  Object encode() {
    return <Object?>[
      polylineId,
      consumesTapEvents,
      color,
      geodesic,
      jointType,
      patterns,
      points,
      startCap,
      endCap,
      visible,
      width,
      zIndex,
    ];
  }

  static PlatformPolyline decode(Object result) {
    result as List<Object?>;
    return PlatformPolyline(
      polylineId: result[0]! as String,
      consumesTapEvents: result[1]! as bool,
      color: result[2]! as int,
      geodesic: result[3]! as bool,
      jointType: result[4]! as PlatformJointType,
      patterns: (result[5] as List<Object?>?)!.cast<PlatformPatternItem?>(),
      points: (result[6] as List<Object?>?)!.cast<PlatformLatLng?>(),
      startCap: result[7]! as PlatformCap,
      endCap: result[8]! as PlatformCap,
      visible: result[9]! as bool,
      width: result[10]! as int,
      zIndex: result[11]! as int,
    );
  }
}

/// Pigeon equivalent of Cap from the platform interface.
/// https://github.com/flutter/packages/blob/main/packages/google_maps_flutter/google_maps_flutter_platform_interface/lib/src/types/cap.dart
class PlatformCap {
  PlatformCap({
    required this.type,
    this.bitmapDescriptor,
    this.refWidth,
  });

  PlatformCapType type;

  PlatformBitmap? bitmapDescriptor;

  double? refWidth;

  Object encode() {
    return <Object?>[
      type,
      bitmapDescriptor,
      refWidth,
    ];
  }

  static PlatformCap decode(Object result) {
    result as List<Object?>;
    return PlatformCap(
      type: result[0]! as PlatformCapType,
      bitmapDescriptor: result[1] as PlatformBitmap?,
      refWidth: result[2] as double?,
    );
  }
}

/// Pigeon equivalent of the PatternItem class.
class PlatformPatternItem {
  PlatformPatternItem({
    required this.type,
    this.length,
  });

  PlatformPatternItemType type;

  double? length;

  Object encode() {
    return <Object?>[
      type,
      length,
    ];
  }

  static PlatformPatternItem decode(Object result) {
    result as List<Object?>;
    return PlatformPatternItem(
      type: result[0]! as PlatformPatternItemType,
      length: result[1] as double?,
    );
  }
}

/// Pigeon equivalent of the Tile class.
class PlatformTile {
  PlatformTile({
    required this.width,
    required this.height,
    this.data,
  });

  int width;

  int height;

  Uint8List? data;

  Object encode() {
    return <Object?>[
      width,
      height,
      data,
    ];
  }

  static PlatformTile decode(Object result) {
    result as List<Object?>;
    return PlatformTile(
      width: result[0]! as int,
      height: result[1]! as int,
      data: result[2] as Uint8List?,
    );
  }
}

/// Pigeon equivalent of the TileOverlay class.
class PlatformTileOverlay {
  PlatformTileOverlay({
    required this.tileOverlayId,
    required this.fadeIn,
    required this.transparency,
    required this.zIndex,
    required this.visible,
    required this.tileSize,
  });

  String tileOverlayId;

  bool fadeIn;

  double transparency;

  int zIndex;

  bool visible;

  int tileSize;

  Object encode() {
    return <Object?>[
      tileOverlayId,
      fadeIn,
      transparency,
      zIndex,
      visible,
      tileSize,
    ];
  }

  static PlatformTileOverlay decode(Object result) {
    result as List<Object?>;
    return PlatformTileOverlay(
      tileOverlayId: result[0]! as String,
      fadeIn: result[1]! as bool,
      transparency: result[2]! as double,
      zIndex: result[3]! as int,
      visible: result[4]! as bool,
      tileSize: result[5]! as int,
    );
  }
}

/// Pigeon equivalent of Flutter's EdgeInsets.
class PlatformEdgeInsets {
  PlatformEdgeInsets({
    required this.top,
    required this.bottom,
    required this.left,
    required this.right,
  });

  double top;

  double bottom;

  double left;

  double right;

  Object encode() {
    return <Object?>[
      top,
      bottom,
      left,
      right,
    ];
  }

  static PlatformEdgeInsets decode(Object result) {
    result as List<Object?>;
    return PlatformEdgeInsets(
      top: result[0]! as double,
      bottom: result[1]! as double,
      left: result[2]! as double,
      right: result[3]! as double,
    );
  }
}

/// Pigeon equivalent of LatLng.
class PlatformLatLng {
  PlatformLatLng({
    required this.latitude,
    required this.longitude,
  });

  double latitude;

  double longitude;

  Object encode() {
    return <Object?>[
      latitude,
      longitude,
    ];
  }

  static PlatformLatLng decode(Object result) {
    result as List<Object?>;
    return PlatformLatLng(
      latitude: result[0]! as double,
      longitude: result[1]! as double,
    );
  }
}

/// Pigeon equivalent of LatLngBounds.
class PlatformLatLngBounds {
  PlatformLatLngBounds({
    required this.northeast,
    required this.southwest,
  });

  PlatformLatLng northeast;

  PlatformLatLng southwest;

  Object encode() {
    return <Object?>[
      northeast,
      southwest,
    ];
  }

  static PlatformLatLngBounds decode(Object result) {
    result as List<Object?>;
    return PlatformLatLngBounds(
      northeast: result[0]! as PlatformLatLng,
      southwest: result[1]! as PlatformLatLng,
    );
  }
}

/// Pigeon equivalent of Cluster.
class PlatformCluster {
  PlatformCluster({
    required this.clusterManagerId,
    required this.position,
    required this.bounds,
    required this.markerIds,
  });

  String clusterManagerId;

  PlatformLatLng position;

  PlatformLatLngBounds bounds;

  List<String?> markerIds;

  Object encode() {
    return <Object?>[
      clusterManagerId,
      position,
      bounds,
      markerIds,
    ];
  }

  static PlatformCluster decode(Object result) {
    result as List<Object?>;
    return PlatformCluster(
      clusterManagerId: result[0]! as String,
      position: result[1]! as PlatformLatLng,
      bounds: result[2]! as PlatformLatLngBounds,
      markerIds: (result[3] as List<Object?>?)!.cast<String?>(),
    );
  }
}

/// Pigeon equivalent of CameraTargetBounds.
///
/// As with the Dart version, it exists to distinguish between not setting a
/// a target, and having an explicitly unbounded target (null [bounds]).
class PlatformCameraTargetBounds {
  PlatformCameraTargetBounds({
    this.bounds,
  });

  PlatformLatLngBounds? bounds;

  Object encode() {
    return <Object?>[
      bounds,
    ];
  }

  static PlatformCameraTargetBounds decode(Object result) {
    result as List<Object?>;
    return PlatformCameraTargetBounds(
      bounds: result[0] as PlatformLatLngBounds?,
    );
  }
}

/// Information passed to the platform view creation.
class PlatformMapViewCreationParams {
  PlatformMapViewCreationParams({
    required this.initialCameraPosition,
    required this.mapConfiguration,
    required this.initialCircles,
    required this.initialMarkers,
    required this.initialPolygons,
    required this.initialPolylines,
    required this.initialHeatmaps,
    required this.initialTileOverlays,
    required this.initialClusterManagers,
  });

  PlatformCameraPosition initialCameraPosition;

  PlatformMapConfiguration mapConfiguration;

  List<PlatformCircle?> initialCircles;

  List<PlatformMarker?> initialMarkers;

  List<PlatformPolygon?> initialPolygons;

  List<PlatformPolyline?> initialPolylines;

  List<PlatformHeatmap?> initialHeatmaps;

  List<PlatformTileOverlay?> initialTileOverlays;

  List<PlatformClusterManager?> initialClusterManagers;

  Object encode() {
    return <Object?>[
      initialCameraPosition,
      mapConfiguration,
      initialCircles,
      initialMarkers,
      initialPolygons,
      initialPolylines,
      initialHeatmaps,
      initialTileOverlays,
      initialClusterManagers,
    ];
  }

  static PlatformMapViewCreationParams decode(Object result) {
    result as List<Object?>;
    return PlatformMapViewCreationParams(
      initialCameraPosition: result[0]! as PlatformCameraPosition,
      mapConfiguration: result[1]! as PlatformMapConfiguration,
      initialCircles: (result[2] as List<Object?>?)!.cast<PlatformCircle?>(),
      initialMarkers: (result[3] as List<Object?>?)!.cast<PlatformMarker?>(),
      initialPolygons: (result[4] as List<Object?>?)!.cast<PlatformPolygon?>(),
      initialPolylines:
          (result[5] as List<Object?>?)!.cast<PlatformPolyline?>(),
      initialHeatmaps: (result[6] as List<Object?>?)!.cast<PlatformHeatmap?>(),
      initialTileOverlays:
          (result[7] as List<Object?>?)!.cast<PlatformTileOverlay?>(),
      initialClusterManagers:
          (result[8] as List<Object?>?)!.cast<PlatformClusterManager?>(),
    );
  }
}

/// Pigeon equivalent of MapConfiguration.
class PlatformMapConfiguration {
  PlatformMapConfiguration({
    this.compassEnabled,
    this.cameraTargetBounds,
    this.mapType,
    this.minMaxZoomPreference,
    this.mapToolbarEnabled,
    this.rotateGesturesEnabled,
    this.scrollGesturesEnabled,
    this.tiltGesturesEnabled,
    this.trackCameraPosition,
    this.zoomControlsEnabled,
    this.zoomGesturesEnabled,
    this.myLocationEnabled,
    this.myLocationButtonEnabled,
    this.padding,
    this.indoorViewEnabled,
    this.trafficEnabled,
    this.buildingsEnabled,
    this.liteModeEnabled,
    this.cloudMapId,
    this.style,
  });

  bool? compassEnabled;

  PlatformCameraTargetBounds? cameraTargetBounds;

  PlatformMapType? mapType;

  PlatformZoomRange? minMaxZoomPreference;

  bool? mapToolbarEnabled;

  bool? rotateGesturesEnabled;

  bool? scrollGesturesEnabled;

  bool? tiltGesturesEnabled;

  bool? trackCameraPosition;

  bool? zoomControlsEnabled;

  bool? zoomGesturesEnabled;

  bool? myLocationEnabled;

  bool? myLocationButtonEnabled;

  PlatformEdgeInsets? padding;

  bool? indoorViewEnabled;

  bool? trafficEnabled;

  bool? buildingsEnabled;

  bool? liteModeEnabled;

  String? cloudMapId;

  String? style;

  Object encode() {
    return <Object?>[
      compassEnabled,
      cameraTargetBounds,
      mapType,
      minMaxZoomPreference,
      mapToolbarEnabled,
      rotateGesturesEnabled,
      scrollGesturesEnabled,
      tiltGesturesEnabled,
      trackCameraPosition,
      zoomControlsEnabled,
      zoomGesturesEnabled,
      myLocationEnabled,
      myLocationButtonEnabled,
      padding,
      indoorViewEnabled,
      trafficEnabled,
      buildingsEnabled,
      liteModeEnabled,
      cloudMapId,
      style,
    ];
  }

  static PlatformMapConfiguration decode(Object result) {
    result as List<Object?>;
    return PlatformMapConfiguration(
      compassEnabled: result[0] as bool?,
      cameraTargetBounds: result[1] as PlatformCameraTargetBounds?,
      mapType: result[2] as PlatformMapType?,
      minMaxZoomPreference: result[3] as PlatformZoomRange?,
      mapToolbarEnabled: result[4] as bool?,
      rotateGesturesEnabled: result[5] as bool?,
      scrollGesturesEnabled: result[6] as bool?,
      tiltGesturesEnabled: result[7] as bool?,
      trackCameraPosition: result[8] as bool?,
      zoomControlsEnabled: result[9] as bool?,
      zoomGesturesEnabled: result[10] as bool?,
      myLocationEnabled: result[11] as bool?,
      myLocationButtonEnabled: result[12] as bool?,
      padding: result[13] as PlatformEdgeInsets?,
      indoorViewEnabled: result[14] as bool?,
      trafficEnabled: result[15] as bool?,
      buildingsEnabled: result[16] as bool?,
      liteModeEnabled: result[17] as bool?,
      cloudMapId: result[18] as String?,
      style: result[19] as String?,
    );
  }
}

/// Pigeon representation of an x,y coordinate.
class PlatformPoint {
  PlatformPoint({
    required this.x,
    required this.y,
  });

  int x;

  int y;

  Object encode() {
    return <Object?>[
      x,
      y,
    ];
  }

  static PlatformPoint decode(Object result) {
    result as List<Object?>;
    return PlatformPoint(
      x: result[0]! as int,
      y: result[1]! as int,
    );
  }
}

/// Pigeon equivalent of native TileOverlay properties.
class PlatformTileLayer {
  PlatformTileLayer({
    required this.visible,
    required this.fadeIn,
    required this.transparency,
    required this.zIndex,
  });

  bool visible;

  bool fadeIn;

  double transparency;

  double zIndex;

  Object encode() {
    return <Object?>[
      visible,
      fadeIn,
      transparency,
      zIndex,
    ];
  }

  static PlatformTileLayer decode(Object result) {
    result as List<Object?>;
    return PlatformTileLayer(
      visible: result[0]! as bool,
      fadeIn: result[1]! as bool,
      transparency: result[2]! as double,
      zIndex: result[3]! as double,
    );
  }
}

/// Possible outcomes of launching a URL.
class PlatformZoomRange {
  PlatformZoomRange({
    this.min,
    this.max,
  });

  double? min;

  double? max;

  Object encode() {
    return <Object?>[
      min,
      max,
    ];
  }

  static PlatformZoomRange decode(Object result) {
    result as List<Object?>;
    return PlatformZoomRange(
      min: result[0] as double?,
      max: result[1] as double?,
    );
  }
}

/// Pigeon equivalent of [BitmapDescriptor]. As there are multiple disjoint
/// types of [BitmapDescriptor], [PlatformBitmap] contains a single field which
/// may hold the pigeon equivalent type of any of them.
class PlatformBitmap {
  PlatformBitmap({
    required this.bitmap,
  });

  /// One of [PlatformBitmapAssetMap], [PlatformBitmapAsset],
  /// [PlatformBitmapAssetImage], [PlatformBitmapBytesMap],
  /// [PlatformBitmapBytes], or [PlatformBitmapDefaultMarker].
  /// As Pigeon does not currently support data class inheritance, this
  /// approach allows for the different bitmap implementations to be valid
  /// argument and return types of the API methods. See
  /// https://github.com/flutter/flutter/issues/117819.
  Object bitmap;

  Object encode() {
    return <Object?>[
      bitmap,
    ];
  }

  static PlatformBitmap decode(Object result) {
    result as List<Object?>;
    return PlatformBitmap(
      bitmap: result[0]!,
    );
  }
}

/// Pigeon equivalent of [DefaultMarker]. See
/// https://developers.google.com/maps/documentation/android-sdk/reference/com/google/android/libraries/maps/model/BitmapDescriptorFactory#defaultMarker(float)
class PlatformBitmapDefaultMarker {
  PlatformBitmapDefaultMarker({
    this.hue,
  });

  double? hue;

  Object encode() {
    return <Object?>[
      hue,
    ];
  }

  static PlatformBitmapDefaultMarker decode(Object result) {
    result as List<Object?>;
    return PlatformBitmapDefaultMarker(
      hue: result[0] as double?,
    );
  }
}

/// Pigeon equivalent of [BytesBitmap]. See
/// https://developers.google.com/maps/documentation/android-sdk/reference/com/google/android/libraries/maps/model/BitmapDescriptorFactory#fromBitmap(android.graphics.Bitmap)
class PlatformBitmapBytes {
  PlatformBitmapBytes({
    required this.byteData,
    this.size,
  });

  Uint8List byteData;

  PlatformDoublePair? size;

  Object encode() {
    return <Object?>[
      byteData,
      size,
    ];
  }

  static PlatformBitmapBytes decode(Object result) {
    result as List<Object?>;
    return PlatformBitmapBytes(
      byteData: result[0]! as Uint8List,
      size: result[1] as PlatformDoublePair?,
    );
  }
}

/// Pigeon equivalent of [AssetBitmap]. See
/// https://developers.google.com/maps/documentation/android-sdk/reference/com/google/android/libraries/maps/model/BitmapDescriptorFactory#public-static-bitmapdescriptor-fromasset-string-assetname
class PlatformBitmapAsset {
  PlatformBitmapAsset({
    required this.name,
    this.pkg,
  });

  String name;

  String? pkg;

  Object encode() {
    return <Object?>[
      name,
      pkg,
    ];
  }

  static PlatformBitmapAsset decode(Object result) {
    result as List<Object?>;
    return PlatformBitmapAsset(
      name: result[0]! as String,
      pkg: result[1] as String?,
    );
  }
}

/// Pigeon equivalent of [AssetImageBitmap]. See
/// https://developers.google.com/maps/documentation/android-sdk/reference/com/google/android/libraries/maps/model/BitmapDescriptorFactory#public-static-bitmapdescriptor-fromasset-string-assetname
class PlatformBitmapAssetImage {
  PlatformBitmapAssetImage({
    required this.name,
    required this.scale,
    this.size,
  });

  String name;

  double scale;

  PlatformDoublePair? size;

  Object encode() {
    return <Object?>[
      name,
      scale,
      size,
    ];
  }

  static PlatformBitmapAssetImage decode(Object result) {
    result as List<Object?>;
    return PlatformBitmapAssetImage(
      name: result[0]! as String,
      scale: result[1]! as double,
      size: result[2] as PlatformDoublePair?,
    );
  }
}

/// Pigeon equivalent of [AssetMapBitmap]. See
/// https://developers.google.com/maps/documentation/android-sdk/reference/com/google/android/libraries/maps/model/BitmapDescriptorFactory#public-static-bitmapdescriptor-fromasset-string-assetname
class PlatformBitmapAssetMap {
  PlatformBitmapAssetMap({
    required this.assetName,
    required this.bitmapScaling,
    required this.imagePixelRatio,
    this.width,
    this.height,
  });

  String assetName;

  PlatformMapBitmapScaling bitmapScaling;

  double imagePixelRatio;

  double? width;

  double? height;

  Object encode() {
    return <Object?>[
      assetName,
      bitmapScaling,
      imagePixelRatio,
      width,
      height,
    ];
  }

  static PlatformBitmapAssetMap decode(Object result) {
    result as List<Object?>;
    return PlatformBitmapAssetMap(
      assetName: result[0]! as String,
      bitmapScaling: result[1]! as PlatformMapBitmapScaling,
      imagePixelRatio: result[2]! as double,
      width: result[3] as double?,
      height: result[4] as double?,
    );
  }
}

/// Pigeon equivalent of [BytesMapBitmap]. See
/// https://developers.google.com/maps/documentation/android-sdk/reference/com/google/android/libraries/maps/model/BitmapDescriptorFactory#public-static-bitmapdescriptor-frombitmap-bitmap-image
class PlatformBitmapBytesMap {
  PlatformBitmapBytesMap({
    required this.byteData,
    required this.bitmapScaling,
    required this.imagePixelRatio,
    this.width,
    this.height,
  });

  Uint8List byteData;

  PlatformMapBitmapScaling bitmapScaling;

  double imagePixelRatio;

  double? width;

  double? height;

  Object encode() {
    return <Object?>[
      byteData,
      bitmapScaling,
      imagePixelRatio,
      width,
      height,
    ];
  }

  static PlatformBitmapBytesMap decode(Object result) {
    result as List<Object?>;
    return PlatformBitmapBytesMap(
      byteData: result[0]! as Uint8List,
      bitmapScaling: result[1]! as PlatformMapBitmapScaling,
      imagePixelRatio: result[2]! as double,
      width: result[3] as double?,
      height: result[4] as double?,
    );
  }
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is PlatformMapType) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    } else if (value is PlatformRendererType) {
      buffer.putUint8(130);
      writeValue(buffer, value.index);
    } else if (value is PlatformJointType) {
      buffer.putUint8(131);
      writeValue(buffer, value.index);
    } else if (value is PlatformCapType) {
      buffer.putUint8(132);
      writeValue(buffer, value.index);
    } else if (value is PlatformPatternItemType) {
      buffer.putUint8(133);
      writeValue(buffer, value.index);
    } else if (value is PlatformMapBitmapScaling) {
      buffer.putUint8(134);
      writeValue(buffer, value.index);
    } else if (value is PlatformCameraPosition) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else if (value is PlatformCameraUpdate) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    } else if (value is PlatformCameraUpdateNewCameraPosition) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    } else if (value is PlatformCameraUpdateNewLatLng) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    } else if (value is PlatformCameraUpdateNewLatLngBounds) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    } else if (value is PlatformCameraUpdateNewLatLngZoom) {
      buffer.putUint8(140);
      writeValue(buffer, value.encode());
    } else if (value is PlatformCameraUpdateScrollBy) {
      buffer.putUint8(141);
      writeValue(buffer, value.encode());
    } else if (value is PlatformCameraUpdateZoomBy) {
      buffer.putUint8(142);
      writeValue(buffer, value.encode());
    } else if (value is PlatformCameraUpdateZoom) {
      buffer.putUint8(143);
      writeValue(buffer, value.encode());
    } else if (value is PlatformCameraUpdateZoomTo) {
      buffer.putUint8(144);
      writeValue(buffer, value.encode());
    } else if (value is PlatformCircle) {
      buffer.putUint8(145);
      writeValue(buffer, value.encode());
    } else if (value is PlatformHeatmap) {
      buffer.putUint8(146);
      writeValue(buffer, value.encode());
    } else if (value is PlatformClusterManager) {
      buffer.putUint8(147);
      writeValue(buffer, value.encode());
    } else if (value is PlatformDoublePair) {
      buffer.putUint8(148);
      writeValue(buffer, value.encode());
    } else if (value is PlatformInfoWindow) {
      buffer.putUint8(149);
      writeValue(buffer, value.encode());
    } else if (value is PlatformMarker) {
      buffer.putUint8(150);
      writeValue(buffer, value.encode());
    } else if (value is PlatformPolygon) {
      buffer.putUint8(151);
      writeValue(buffer, value.encode());
    } else if (value is PlatformPolyline) {
      buffer.putUint8(152);
      writeValue(buffer, value.encode());
    } else if (value is PlatformCap) {
      buffer.putUint8(153);
      writeValue(buffer, value.encode());
    } else if (value is PlatformPatternItem) {
      buffer.putUint8(154);
      writeValue(buffer, value.encode());
    } else if (value is PlatformTile) {
      buffer.putUint8(155);
      writeValue(buffer, value.encode());
    } else if (value is PlatformTileOverlay) {
      buffer.putUint8(156);
      writeValue(buffer, value.encode());
    } else if (value is PlatformEdgeInsets) {
      buffer.putUint8(157);
      writeValue(buffer, value.encode());
    } else if (value is PlatformLatLng) {
      buffer.putUint8(158);
      writeValue(buffer, value.encode());
    } else if (value is PlatformLatLngBounds) {
      buffer.putUint8(159);
      writeValue(buffer, value.encode());
    } else if (value is PlatformCluster) {
      buffer.putUint8(160);
      writeValue(buffer, value.encode());
    } else if (value is PlatformCameraTargetBounds) {
      buffer.putUint8(161);
      writeValue(buffer, value.encode());
    } else if (value is PlatformMapViewCreationParams) {
      buffer.putUint8(162);
      writeValue(buffer, value.encode());
    } else if (value is PlatformMapConfiguration) {
      buffer.putUint8(163);
      writeValue(buffer, value.encode());
    } else if (value is PlatformPoint) {
      buffer.putUint8(164);
      writeValue(buffer, value.encode());
    } else if (value is PlatformTileLayer) {
      buffer.putUint8(165);
      writeValue(buffer, value.encode());
    } else if (value is PlatformZoomRange) {
      buffer.putUint8(166);
      writeValue(buffer, value.encode());
    } else if (value is PlatformBitmap) {
      buffer.putUint8(167);
      writeValue(buffer, value.encode());
    } else if (value is PlatformBitmapDefaultMarker) {
      buffer.putUint8(168);
      writeValue(buffer, value.encode());
    } else if (value is PlatformBitmapBytes) {
      buffer.putUint8(169);
      writeValue(buffer, value.encode());
    } else if (value is PlatformBitmapAsset) {
      buffer.putUint8(170);
      writeValue(buffer, value.encode());
    } else if (value is PlatformBitmapAssetImage) {
      buffer.putUint8(171);
      writeValue(buffer, value.encode());
    } else if (value is PlatformBitmapAssetMap) {
      buffer.putUint8(172);
      writeValue(buffer, value.encode());
    } else if (value is PlatformBitmapBytesMap) {
      buffer.putUint8(173);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : PlatformMapType.values[value];
      case 130:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : PlatformRendererType.values[value];
      case 131:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : PlatformJointType.values[value];
      case 132:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : PlatformCapType.values[value];
      case 133:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : PlatformPatternItemType.values[value];
      case 134:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : PlatformMapBitmapScaling.values[value];
      case 135:
        return PlatformCameraPosition.decode(readValue(buffer)!);
      case 136:
        return PlatformCameraUpdate.decode(readValue(buffer)!);
      case 137:
        return PlatformCameraUpdateNewCameraPosition.decode(readValue(buffer)!);
      case 138:
        return PlatformCameraUpdateNewLatLng.decode(readValue(buffer)!);
      case 139:
        return PlatformCameraUpdateNewLatLngBounds.decode(readValue(buffer)!);
      case 140:
        return PlatformCameraUpdateNewLatLngZoom.decode(readValue(buffer)!);
      case 141:
        return PlatformCameraUpdateScrollBy.decode(readValue(buffer)!);
      case 142:
        return PlatformCameraUpdateZoomBy.decode(readValue(buffer)!);
      case 143:
        return PlatformCameraUpdateZoom.decode(readValue(buffer)!);
      case 144:
        return PlatformCameraUpdateZoomTo.decode(readValue(buffer)!);
      case 145:
        return PlatformCircle.decode(readValue(buffer)!);
      case 146:
        return PlatformHeatmap.decode(readValue(buffer)!);
      case 147:
        return PlatformClusterManager.decode(readValue(buffer)!);
      case 148:
        return PlatformDoublePair.decode(readValue(buffer)!);
      case 149:
        return PlatformInfoWindow.decode(readValue(buffer)!);
      case 150:
        return PlatformMarker.decode(readValue(buffer)!);
      case 151:
        return PlatformPolygon.decode(readValue(buffer)!);
      case 152:
        return PlatformPolyline.decode(readValue(buffer)!);
      case 153:
        return PlatformCap.decode(readValue(buffer)!);
      case 154:
        return PlatformPatternItem.decode(readValue(buffer)!);
      case 155:
        return PlatformTile.decode(readValue(buffer)!);
      case 156:
        return PlatformTileOverlay.decode(readValue(buffer)!);
      case 157:
        return PlatformEdgeInsets.decode(readValue(buffer)!);
      case 158:
        return PlatformLatLng.decode(readValue(buffer)!);
      case 159:
        return PlatformLatLngBounds.decode(readValue(buffer)!);
      case 160:
        return PlatformCluster.decode(readValue(buffer)!);
      case 161:
        return PlatformCameraTargetBounds.decode(readValue(buffer)!);
      case 162:
        return PlatformMapViewCreationParams.decode(readValue(buffer)!);
      case 163:
        return PlatformMapConfiguration.decode(readValue(buffer)!);
      case 164:
        return PlatformPoint.decode(readValue(buffer)!);
      case 165:
        return PlatformTileLayer.decode(readValue(buffer)!);
      case 166:
        return PlatformZoomRange.decode(readValue(buffer)!);
      case 167:
        return PlatformBitmap.decode(readValue(buffer)!);
      case 168:
        return PlatformBitmapDefaultMarker.decode(readValue(buffer)!);
      case 169:
        return PlatformBitmapBytes.decode(readValue(buffer)!);
      case 170:
        return PlatformBitmapAsset.decode(readValue(buffer)!);
      case 171:
        return PlatformBitmapAssetImage.decode(readValue(buffer)!);
      case 172:
        return PlatformBitmapAssetMap.decode(readValue(buffer)!);
      case 173:
        return PlatformBitmapBytesMap.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// Interface for non-test interactions with the native SDK.
///
/// For test-only state queries, see [MapsInspectorApi].
class MapsApi {
  /// Constructor for [MapsApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MapsApi({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Returns once the map instance is available.
  Future<void> waitForMap() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.waitForMap$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Updates the map's configuration options.
  ///
  /// Only non-null configuration values will result in updates; options with
  /// null values will remain unchanged.
  Future<void> updateMapConfiguration(
      PlatformMapConfiguration configuration) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.updateMapConfiguration$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[configuration]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Updates the set of circles on the map.
  Future<void> updateCircles(List<PlatformCircle?> toAdd,
      List<PlatformCircle?> toChange, List<String?> idsToRemove) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.updateCircles$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[toAdd, toChange, idsToRemove]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Updates the set of heatmaps on the map.
  Future<void> updateHeatmaps(List<PlatformHeatmap?> toAdd,
      List<PlatformHeatmap?> toChange, List<String?> idsToRemove) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.updateHeatmaps$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[toAdd, toChange, idsToRemove]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Updates the set of custer managers for clusters on the map.
  Future<void> updateClusterManagers(
      List<PlatformClusterManager?> toAdd, List<String?> idsToRemove) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.updateClusterManagers$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[toAdd, idsToRemove]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Updates the set of markers on the map.
  Future<void> updateMarkers(List<PlatformMarker?> toAdd,
      List<PlatformMarker?> toChange, List<String?> idsToRemove) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.updateMarkers$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[toAdd, toChange, idsToRemove]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Updates the set of polygonss on the map.
  Future<void> updatePolygons(List<PlatformPolygon?> toAdd,
      List<PlatformPolygon?> toChange, List<String?> idsToRemove) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.updatePolygons$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[toAdd, toChange, idsToRemove]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Updates the set of polylines on the map.
  Future<void> updatePolylines(List<PlatformPolyline?> toAdd,
      List<PlatformPolyline?> toChange, List<String?> idsToRemove) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.updatePolylines$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[toAdd, toChange, idsToRemove]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Updates the set of tile overlays on the map.
  Future<void> updateTileOverlays(List<PlatformTileOverlay?> toAdd,
      List<PlatformTileOverlay?> toChange, List<String?> idsToRemove) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.updateTileOverlays$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[toAdd, toChange, idsToRemove]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Gets the screen coordinate for the given map location.
  Future<PlatformPoint> getScreenCoordinate(PlatformLatLng latLng) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.getScreenCoordinate$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[latLng]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as PlatformPoint?)!;
    }
  }

  /// Gets the map location for the given screen coordinate.
  Future<PlatformLatLng> getLatLng(PlatformPoint screenCoordinate) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.getLatLng$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[screenCoordinate]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as PlatformLatLng?)!;
    }
  }

  /// Gets the map region currently displayed on the map.
  Future<PlatformLatLngBounds> getVisibleRegion() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.getVisibleRegion$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as PlatformLatLngBounds?)!;
    }
  }

  /// Moves the camera according to [cameraUpdate] immediately, with no
  /// animation.
  Future<void> moveCamera(PlatformCameraUpdate cameraUpdate) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.moveCamera$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[cameraUpdate]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Moves the camera according to [cameraUpdate], animating the update.
  Future<void> animateCamera(PlatformCameraUpdate cameraUpdate) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.animateCamera$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[cameraUpdate]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Gets the current map zoom level.
  Future<double> getZoomLevel() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.getZoomLevel$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as double?)!;
    }
  }

  /// Show the info window for the marker with the given ID.
  Future<void> showInfoWindow(String markerId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.showInfoWindow$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[markerId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Hide the info window for the marker with the given ID.
  Future<void> hideInfoWindow(String markerId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.hideInfoWindow$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[markerId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns true if the marker with the given ID is currently displaying its
  /// info window.
  Future<bool> isInfoWindowShown(String markerId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.isInfoWindowShown$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[markerId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Sets the style to the given map style string, where an empty string
  /// indicates that the style should be cleared.
  ///
  /// Returns false if there was an error setting the style, such as an invalid
  /// style string.
  Future<bool> setStyle(String style) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.setStyle$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[style]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Returns true if the last attempt to set a style, either via initial map
  /// style or setMapStyle, succeeded.
  ///
  /// This allows checking asynchronously for initial style failures, as there
  /// is no way to return failures from map initialization.
  Future<bool> didLastStyleSucceed() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.didLastStyleSucceed$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Clears the cache of tiles previously requseted from the tile provider.
  Future<void> clearTileCache(String tileOverlayId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.clearTileCache$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[tileOverlayId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Takes a snapshot of the map and returns its image data.
  Future<Uint8List> takeSnapshot() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsApi.takeSnapshot$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as Uint8List?)!;
    }
  }
}

abstract class MapsCallbackApi {
  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  /// Called when the map camera starts moving.
  void onCameraMoveStarted();

  /// Called when the map camera moves.
  void onCameraMove(PlatformCameraPosition cameraPosition);

  /// Called when the map camera stops moving.
  void onCameraIdle();

  /// Called when the map, not a specifc map object, is tapped.
  void onTap(PlatformLatLng position);

  /// Called when the map, not a specifc map object, is long pressed.
  void onLongPress(PlatformLatLng position);

  /// Called when a marker is tapped.
  void onMarkerTap(String markerId);

  /// Called when a marker drag starts.
  void onMarkerDragStart(String markerId, PlatformLatLng position);

  /// Called when a marker drag updates.
  void onMarkerDrag(String markerId, PlatformLatLng position);

  /// Called when a marker drag ends.
  void onMarkerDragEnd(String markerId, PlatformLatLng position);

  /// Called when a marker's info window is tapped.
  void onInfoWindowTap(String markerId);

  /// Called when a circle is tapped.
  void onCircleTap(String circleId);

  /// Called when a marker cluster is tapped.
  void onClusterTap(PlatformCluster cluster);

  /// Called when a polygon is tapped.
  void onPolygonTap(String polygonId);

  /// Called when a polyline is tapped.
  void onPolylineTap(String polylineId);

  /// Called to get data for a map tile.
  Future<PlatformTile> getTileOverlayTile(
      String tileOverlayId, PlatformPoint location, int zoom);

  static void setUp(
    MapsCallbackApi? api, {
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) {
    messageChannelSuffix =
        messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onCameraMoveStarted$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          try {
            api.onCameraMoveStarted();
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onCameraMove$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onCameraMove was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final PlatformCameraPosition? arg_cameraPosition =
              (args[0] as PlatformCameraPosition?);
          assert(arg_cameraPosition != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onCameraMove was null, expected non-null PlatformCameraPosition.');
          try {
            api.onCameraMove(arg_cameraPosition!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onCameraIdle$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          try {
            api.onCameraIdle();
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onTap$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onTap was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final PlatformLatLng? arg_position = (args[0] as PlatformLatLng?);
          assert(arg_position != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onTap was null, expected non-null PlatformLatLng.');
          try {
            api.onTap(arg_position!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onLongPress$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onLongPress was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final PlatformLatLng? arg_position = (args[0] as PlatformLatLng?);
          assert(arg_position != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onLongPress was null, expected non-null PlatformLatLng.');
          try {
            api.onLongPress(arg_position!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerTap$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerTap was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_markerId = (args[0] as String?);
          assert(arg_markerId != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerTap was null, expected non-null String.');
          try {
            api.onMarkerTap(arg_markerId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerDragStart$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerDragStart was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_markerId = (args[0] as String?);
          assert(arg_markerId != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerDragStart was null, expected non-null String.');
          final PlatformLatLng? arg_position = (args[1] as PlatformLatLng?);
          assert(arg_position != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerDragStart was null, expected non-null PlatformLatLng.');
          try {
            api.onMarkerDragStart(arg_markerId!, arg_position!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerDrag$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerDrag was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_markerId = (args[0] as String?);
          assert(arg_markerId != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerDrag was null, expected non-null String.');
          final PlatformLatLng? arg_position = (args[1] as PlatformLatLng?);
          assert(arg_position != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerDrag was null, expected non-null PlatformLatLng.');
          try {
            api.onMarkerDrag(arg_markerId!, arg_position!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerDragEnd$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerDragEnd was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_markerId = (args[0] as String?);
          assert(arg_markerId != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerDragEnd was null, expected non-null String.');
          final PlatformLatLng? arg_position = (args[1] as PlatformLatLng?);
          assert(arg_position != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onMarkerDragEnd was null, expected non-null PlatformLatLng.');
          try {
            api.onMarkerDragEnd(arg_markerId!, arg_position!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onInfoWindowTap$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onInfoWindowTap was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_markerId = (args[0] as String?);
          assert(arg_markerId != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onInfoWindowTap was null, expected non-null String.');
          try {
            api.onInfoWindowTap(arg_markerId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onCircleTap$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onCircleTap was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_circleId = (args[0] as String?);
          assert(arg_circleId != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onCircleTap was null, expected non-null String.');
          try {
            api.onCircleTap(arg_circleId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onClusterTap$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onClusterTap was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final PlatformCluster? arg_cluster = (args[0] as PlatformCluster?);
          assert(arg_cluster != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onClusterTap was null, expected non-null PlatformCluster.');
          try {
            api.onClusterTap(arg_cluster!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onPolygonTap$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onPolygonTap was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_polygonId = (args[0] as String?);
          assert(arg_polygonId != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onPolygonTap was null, expected non-null String.');
          try {
            api.onPolygonTap(arg_polygonId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onPolylineTap$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onPolylineTap was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_polylineId = (args[0] as String?);
          assert(arg_polylineId != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.onPolylineTap was null, expected non-null String.');
          try {
            api.onPolylineTap(arg_polylineId!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.getTileOverlayTile$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.getTileOverlayTile was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_tileOverlayId = (args[0] as String?);
          assert(arg_tileOverlayId != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.getTileOverlayTile was null, expected non-null String.');
          final PlatformPoint? arg_location = (args[1] as PlatformPoint?);
          assert(arg_location != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.getTileOverlayTile was null, expected non-null PlatformPoint.');
          final int? arg_zoom = (args[2] as int?);
          assert(arg_zoom != null,
              'Argument for dev.flutter.pigeon.google_maps_flutter_android.MapsCallbackApi.getTileOverlayTile was null, expected non-null int.');
          try {
            final PlatformTile output = await api.getTileOverlayTile(
                arg_tileOverlayId!, arg_location!, arg_zoom!);
            return wrapResponse(result: output);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}

/// Interface for global SDK initialization.
class MapsInitializerApi {
  /// Constructor for [MapsInitializerApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MapsInitializerApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Initializes the Google Maps SDK with the given renderer preference.
  ///
  /// A null renderer preference will result in the default renderer.
  ///
  /// Calling this more than once in the lifetime of an application will result
  /// in an error.
  Future<PlatformRendererType> initializeWithPreferredRenderer(
      PlatformRendererType? type) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInitializerApi.initializeWithPreferredRenderer$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[type]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as PlatformRendererType?)!;
    }
  }
}

/// Dummy interface to force generation of the platform view creation params,
/// which are not used in any Pigeon calls, only the platform view creation
/// call made internally by Flutter.
class MapsPlatformViewApi {
  /// Constructor for [MapsPlatformViewApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MapsPlatformViewApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<void> createView(PlatformMapViewCreationParams? type) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsPlatformViewApi.createView$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[type]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }
}

/// Inspector API only intended for use in integration tests.
class MapsInspectorApi {
  /// Constructor for [MapsInspectorApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MapsInspectorApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<bool> areBuildingsEnabled() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.areBuildingsEnabled$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  Future<bool> areRotateGesturesEnabled() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.areRotateGesturesEnabled$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  Future<bool> areZoomControlsEnabled() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.areZoomControlsEnabled$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  Future<bool> areScrollGesturesEnabled() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.areScrollGesturesEnabled$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  Future<bool> areTiltGesturesEnabled() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.areTiltGesturesEnabled$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  Future<bool> areZoomGesturesEnabled() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.areZoomGesturesEnabled$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  Future<bool> isCompassEnabled() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.isCompassEnabled$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  Future<bool?> isLiteModeEnabled() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.isLiteModeEnabled$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as bool?);
    }
  }

  Future<bool> isMapToolbarEnabled() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.isMapToolbarEnabled$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  Future<bool> isMyLocationButtonEnabled() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.isMyLocationButtonEnabled$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  Future<bool> isTrafficEnabled() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.isTrafficEnabled$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  Future<PlatformTileLayer?> getTileOverlayInfo(String tileOverlayId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.getTileOverlayInfo$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[tileOverlayId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as PlatformTileLayer?);
    }
  }

  Future<PlatformZoomRange> getZoomRange() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.getZoomRange$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as PlatformZoomRange?)!;
    }
  }

  Future<List<PlatformCluster?>> getClusters(String clusterManagerId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.google_maps_flutter_android.MapsInspectorApi.getClusters$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[clusterManagerId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<PlatformCluster?>();
    }
  }
}
