// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.6.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import "messages.g.h"

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSArray<id> *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}

static FlutterError *createConnectionError(NSString *channelName) {
  return [FlutterError
      errorWithCode:@"channel-error"
            message:[NSString stringWithFormat:@"%@/%@/%@",
                                               @"Unable to establish connection on channel: '",
                                               channelName, @"'."]
            details:@""];
}

static id GetNullableObjectAtIndex(NSArray<id> *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

/// Pigeon equivalent of MapType
@implementation FGMPlatformMapTypeBox
- (instancetype)initWithValue:(FGMPlatformMapType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Join types for polyline joints.
@implementation FGMPlatformJointTypeBox
- (instancetype)initWithValue:(FGMPlatformJointType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Enumeration of possible types for PatternItem.
@implementation FGMPlatformPatternItemTypeBox
- (instancetype)initWithValue:(FGMPlatformPatternItemType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Pigeon equivalent of [MapBitmapScaling].
@implementation FGMPlatformMapBitmapScalingBox
- (instancetype)initWithValue:(FGMPlatformMapBitmapScaling)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@interface FGMPlatformCameraPosition ()
+ (FGMPlatformCameraPosition *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraPosition *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCameraUpdate ()
+ (FGMPlatformCameraUpdate *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraUpdate *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCameraUpdateNewCameraPosition ()
+ (FGMPlatformCameraUpdateNewCameraPosition *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraUpdateNewCameraPosition *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCameraUpdateNewLatLng ()
+ (FGMPlatformCameraUpdateNewLatLng *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraUpdateNewLatLng *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCameraUpdateNewLatLngBounds ()
+ (FGMPlatformCameraUpdateNewLatLngBounds *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraUpdateNewLatLngBounds *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCameraUpdateNewLatLngZoom ()
+ (FGMPlatformCameraUpdateNewLatLngZoom *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraUpdateNewLatLngZoom *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCameraUpdateScrollBy ()
+ (FGMPlatformCameraUpdateScrollBy *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraUpdateScrollBy *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCameraUpdateZoomBy ()
+ (FGMPlatformCameraUpdateZoomBy *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraUpdateZoomBy *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCameraUpdateZoom ()
+ (FGMPlatformCameraUpdateZoom *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraUpdateZoom *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCameraUpdateZoomTo ()
+ (FGMPlatformCameraUpdateZoomTo *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraUpdateZoomTo *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCircle ()
+ (FGMPlatformCircle *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCircle *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformHeatmap ()
+ (FGMPlatformHeatmap *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformHeatmap *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformInfoWindow ()
+ (FGMPlatformInfoWindow *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformInfoWindow *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCluster ()
+ (FGMPlatformCluster *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCluster *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformClusterManager ()
+ (FGMPlatformClusterManager *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformClusterManager *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformMarker ()
+ (FGMPlatformMarker *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformMarker *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformPolygon ()
+ (FGMPlatformPolygon *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformPolygon *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformPolyline ()
+ (FGMPlatformPolyline *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformPolyline *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformPatternItem ()
+ (FGMPlatformPatternItem *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformPatternItem *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformTile ()
+ (FGMPlatformTile *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformTile *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformTileOverlay ()
+ (FGMPlatformTileOverlay *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformTileOverlay *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformEdgeInsets ()
+ (FGMPlatformEdgeInsets *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformEdgeInsets *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformLatLng ()
+ (FGMPlatformLatLng *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformLatLng *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformLatLngBounds ()
+ (FGMPlatformLatLngBounds *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformLatLngBounds *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCameraTargetBounds ()
+ (FGMPlatformCameraTargetBounds *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraTargetBounds *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformMapViewCreationParams ()
+ (FGMPlatformMapViewCreationParams *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformMapViewCreationParams *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformMapConfiguration ()
+ (FGMPlatformMapConfiguration *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformMapConfiguration *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformPoint ()
+ (FGMPlatformPoint *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformPoint *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformSize ()
+ (FGMPlatformSize *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformSize *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformTileLayer ()
+ (FGMPlatformTileLayer *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformTileLayer *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformZoomRange ()
+ (FGMPlatformZoomRange *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformZoomRange *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformBitmap ()
+ (FGMPlatformBitmap *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformBitmap *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformBitmapDefaultMarker ()
+ (FGMPlatformBitmapDefaultMarker *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformBitmapDefaultMarker *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformBitmapBytes ()
+ (FGMPlatformBitmapBytes *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformBitmapBytes *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformBitmapAsset ()
+ (FGMPlatformBitmapAsset *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformBitmapAsset *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformBitmapAssetImage ()
+ (FGMPlatformBitmapAssetImage *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformBitmapAssetImage *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformBitmapAssetMap ()
+ (FGMPlatformBitmapAssetMap *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformBitmapAssetMap *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformBitmapBytesMap ()
+ (FGMPlatformBitmapBytesMap *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformBitmapBytesMap *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@implementation FGMPlatformCameraPosition
+ (instancetype)makeWithBearing:(double)bearing
                         target:(FGMPlatformLatLng *)target
                           tilt:(double)tilt
                           zoom:(double)zoom {
  FGMPlatformCameraPosition *pigeonResult = [[FGMPlatformCameraPosition alloc] init];
  pigeonResult.bearing = bearing;
  pigeonResult.target = target;
  pigeonResult.tilt = tilt;
  pigeonResult.zoom = zoom;
  return pigeonResult;
}
+ (FGMPlatformCameraPosition *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraPosition *pigeonResult = [[FGMPlatformCameraPosition alloc] init];
  pigeonResult.bearing = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.target = GetNullableObjectAtIndex(list, 1);
  pigeonResult.tilt = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.zoom = [GetNullableObjectAtIndex(list, 3) doubleValue];
  return pigeonResult;
}
+ (nullable FGMPlatformCameraPosition *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraPosition fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.bearing),
    self.target ?: [NSNull null],
    @(self.tilt),
    @(self.zoom),
  ];
}
@end

@implementation FGMPlatformCameraUpdate
+ (instancetype)makeWithCameraUpdate:(id)cameraUpdate {
  FGMPlatformCameraUpdate *pigeonResult = [[FGMPlatformCameraUpdate alloc] init];
  pigeonResult.cameraUpdate = cameraUpdate;
  return pigeonResult;
}
+ (FGMPlatformCameraUpdate *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraUpdate *pigeonResult = [[FGMPlatformCameraUpdate alloc] init];
  pigeonResult.cameraUpdate = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformCameraUpdate *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraUpdate fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.cameraUpdate ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformCameraUpdateNewCameraPosition
+ (instancetype)makeWithCameraPosition:(FGMPlatformCameraPosition *)cameraPosition {
  FGMPlatformCameraUpdateNewCameraPosition *pigeonResult =
      [[FGMPlatformCameraUpdateNewCameraPosition alloc] init];
  pigeonResult.cameraPosition = cameraPosition;
  return pigeonResult;
}
+ (FGMPlatformCameraUpdateNewCameraPosition *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraUpdateNewCameraPosition *pigeonResult =
      [[FGMPlatformCameraUpdateNewCameraPosition alloc] init];
  pigeonResult.cameraPosition = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformCameraUpdateNewCameraPosition *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraUpdateNewCameraPosition fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.cameraPosition ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformCameraUpdateNewLatLng
+ (instancetype)makeWithLatLng:(FGMPlatformLatLng *)latLng {
  FGMPlatformCameraUpdateNewLatLng *pigeonResult = [[FGMPlatformCameraUpdateNewLatLng alloc] init];
  pigeonResult.latLng = latLng;
  return pigeonResult;
}
+ (FGMPlatformCameraUpdateNewLatLng *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraUpdateNewLatLng *pigeonResult = [[FGMPlatformCameraUpdateNewLatLng alloc] init];
  pigeonResult.latLng = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformCameraUpdateNewLatLng *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraUpdateNewLatLng fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.latLng ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformCameraUpdateNewLatLngBounds
+ (instancetype)makeWithBounds:(FGMPlatformLatLngBounds *)bounds padding:(double)padding {
  FGMPlatformCameraUpdateNewLatLngBounds *pigeonResult =
      [[FGMPlatformCameraUpdateNewLatLngBounds alloc] init];
  pigeonResult.bounds = bounds;
  pigeonResult.padding = padding;
  return pigeonResult;
}
+ (FGMPlatformCameraUpdateNewLatLngBounds *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraUpdateNewLatLngBounds *pigeonResult =
      [[FGMPlatformCameraUpdateNewLatLngBounds alloc] init];
  pigeonResult.bounds = GetNullableObjectAtIndex(list, 0);
  pigeonResult.padding = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FGMPlatformCameraUpdateNewLatLngBounds *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraUpdateNewLatLngBounds fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.bounds ?: [NSNull null],
    @(self.padding),
  ];
}
@end

@implementation FGMPlatformCameraUpdateNewLatLngZoom
+ (instancetype)makeWithLatLng:(FGMPlatformLatLng *)latLng zoom:(double)zoom {
  FGMPlatformCameraUpdateNewLatLngZoom *pigeonResult =
      [[FGMPlatformCameraUpdateNewLatLngZoom alloc] init];
  pigeonResult.latLng = latLng;
  pigeonResult.zoom = zoom;
  return pigeonResult;
}
+ (FGMPlatformCameraUpdateNewLatLngZoom *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraUpdateNewLatLngZoom *pigeonResult =
      [[FGMPlatformCameraUpdateNewLatLngZoom alloc] init];
  pigeonResult.latLng = GetNullableObjectAtIndex(list, 0);
  pigeonResult.zoom = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FGMPlatformCameraUpdateNewLatLngZoom *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraUpdateNewLatLngZoom fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.latLng ?: [NSNull null],
    @(self.zoom),
  ];
}
@end

@implementation FGMPlatformCameraUpdateScrollBy
+ (instancetype)makeWithDx:(double)dx dy:(double)dy {
  FGMPlatformCameraUpdateScrollBy *pigeonResult = [[FGMPlatformCameraUpdateScrollBy alloc] init];
  pigeonResult.dx = dx;
  pigeonResult.dy = dy;
  return pigeonResult;
}
+ (FGMPlatformCameraUpdateScrollBy *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraUpdateScrollBy *pigeonResult = [[FGMPlatformCameraUpdateScrollBy alloc] init];
  pigeonResult.dx = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.dy = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FGMPlatformCameraUpdateScrollBy *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraUpdateScrollBy fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.dx),
    @(self.dy),
  ];
}
@end

@implementation FGMPlatformCameraUpdateZoomBy
+ (instancetype)makeWithAmount:(double)amount focus:(nullable FGMPlatformPoint *)focus {
  FGMPlatformCameraUpdateZoomBy *pigeonResult = [[FGMPlatformCameraUpdateZoomBy alloc] init];
  pigeonResult.amount = amount;
  pigeonResult.focus = focus;
  return pigeonResult;
}
+ (FGMPlatformCameraUpdateZoomBy *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraUpdateZoomBy *pigeonResult = [[FGMPlatformCameraUpdateZoomBy alloc] init];
  pigeonResult.amount = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.focus = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FGMPlatformCameraUpdateZoomBy *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraUpdateZoomBy fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.amount),
    self.focus ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformCameraUpdateZoom
+ (instancetype)makeWithOut:(BOOL)out {
  FGMPlatformCameraUpdateZoom *pigeonResult = [[FGMPlatformCameraUpdateZoom alloc] init];
  pigeonResult.out = out;
  return pigeonResult;
}
+ (FGMPlatformCameraUpdateZoom *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraUpdateZoom *pigeonResult = [[FGMPlatformCameraUpdateZoom alloc] init];
  pigeonResult.out = [GetNullableObjectAtIndex(list, 0) boolValue];
  return pigeonResult;
}
+ (nullable FGMPlatformCameraUpdateZoom *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraUpdateZoom fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.out),
  ];
}
@end

@implementation FGMPlatformCameraUpdateZoomTo
+ (instancetype)makeWithZoom:(double)zoom {
  FGMPlatformCameraUpdateZoomTo *pigeonResult = [[FGMPlatformCameraUpdateZoomTo alloc] init];
  pigeonResult.zoom = zoom;
  return pigeonResult;
}
+ (FGMPlatformCameraUpdateZoomTo *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraUpdateZoomTo *pigeonResult = [[FGMPlatformCameraUpdateZoomTo alloc] init];
  pigeonResult.zoom = [GetNullableObjectAtIndex(list, 0) doubleValue];
  return pigeonResult;
}
+ (nullable FGMPlatformCameraUpdateZoomTo *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraUpdateZoomTo fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.zoom),
  ];
}
@end

@implementation FGMPlatformCircle
+ (instancetype)makeWithConsumeTapEvents:(BOOL)consumeTapEvents
                               fillColor:(NSInteger)fillColor
                             strokeColor:(NSInteger)strokeColor
                                 visible:(BOOL)visible
                             strokeWidth:(NSInteger)strokeWidth
                                  zIndex:(double)zIndex
                                  center:(FGMPlatformLatLng *)center
                                  radius:(double)radius
                                circleId:(NSString *)circleId {
  FGMPlatformCircle *pigeonResult = [[FGMPlatformCircle alloc] init];
  pigeonResult.consumeTapEvents = consumeTapEvents;
  pigeonResult.fillColor = fillColor;
  pigeonResult.strokeColor = strokeColor;
  pigeonResult.visible = visible;
  pigeonResult.strokeWidth = strokeWidth;
  pigeonResult.zIndex = zIndex;
  pigeonResult.center = center;
  pigeonResult.radius = radius;
  pigeonResult.circleId = circleId;
  return pigeonResult;
}
+ (FGMPlatformCircle *)fromList:(NSArray<id> *)list {
  FGMPlatformCircle *pigeonResult = [[FGMPlatformCircle alloc] init];
  pigeonResult.consumeTapEvents = [GetNullableObjectAtIndex(list, 0) boolValue];
  pigeonResult.fillColor = [GetNullableObjectAtIndex(list, 1) integerValue];
  pigeonResult.strokeColor = [GetNullableObjectAtIndex(list, 2) integerValue];
  pigeonResult.visible = [GetNullableObjectAtIndex(list, 3) boolValue];
  pigeonResult.strokeWidth = [GetNullableObjectAtIndex(list, 4) integerValue];
  pigeonResult.zIndex = [GetNullableObjectAtIndex(list, 5) doubleValue];
  pigeonResult.center = GetNullableObjectAtIndex(list, 6);
  pigeonResult.radius = [GetNullableObjectAtIndex(list, 7) doubleValue];
  pigeonResult.circleId = GetNullableObjectAtIndex(list, 8);
  return pigeonResult;
}
+ (nullable FGMPlatformCircle *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCircle fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.consumeTapEvents),
    @(self.fillColor),
    @(self.strokeColor),
    @(self.visible),
    @(self.strokeWidth),
    @(self.zIndex),
    self.center ?: [NSNull null],
    @(self.radius),
    self.circleId ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformHeatmap
+ (instancetype)makeWithJson:(id)json {
  FGMPlatformHeatmap *pigeonResult = [[FGMPlatformHeatmap alloc] init];
  pigeonResult.json = json;
  return pigeonResult;
}
+ (FGMPlatformHeatmap *)fromList:(NSArray<id> *)list {
  FGMPlatformHeatmap *pigeonResult = [[FGMPlatformHeatmap alloc] init];
  pigeonResult.json = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformHeatmap *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformHeatmap fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.json ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformInfoWindow
+ (instancetype)makeWithTitle:(nullable NSString *)title
                      snippet:(nullable NSString *)snippet
                       anchor:(FGMPlatformPoint *)anchor {
  FGMPlatformInfoWindow *pigeonResult = [[FGMPlatformInfoWindow alloc] init];
  pigeonResult.title = title;
  pigeonResult.snippet = snippet;
  pigeonResult.anchor = anchor;
  return pigeonResult;
}
+ (FGMPlatformInfoWindow *)fromList:(NSArray<id> *)list {
  FGMPlatformInfoWindow *pigeonResult = [[FGMPlatformInfoWindow alloc] init];
  pigeonResult.title = GetNullableObjectAtIndex(list, 0);
  pigeonResult.snippet = GetNullableObjectAtIndex(list, 1);
  pigeonResult.anchor = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable FGMPlatformInfoWindow *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformInfoWindow fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.title ?: [NSNull null],
    self.snippet ?: [NSNull null],
    self.anchor ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformCluster
+ (instancetype)makeWithClusterManagerId:(NSString *)clusterManagerId
                                position:(FGMPlatformLatLng *)position
                                  bounds:(FGMPlatformLatLngBounds *)bounds
                               markerIds:(NSArray<NSString *> *)markerIds {
  FGMPlatformCluster *pigeonResult = [[FGMPlatformCluster alloc] init];
  pigeonResult.clusterManagerId = clusterManagerId;
  pigeonResult.position = position;
  pigeonResult.bounds = bounds;
  pigeonResult.markerIds = markerIds;
  return pigeonResult;
}
+ (FGMPlatformCluster *)fromList:(NSArray<id> *)list {
  FGMPlatformCluster *pigeonResult = [[FGMPlatformCluster alloc] init];
  pigeonResult.clusterManagerId = GetNullableObjectAtIndex(list, 0);
  pigeonResult.position = GetNullableObjectAtIndex(list, 1);
  pigeonResult.bounds = GetNullableObjectAtIndex(list, 2);
  pigeonResult.markerIds = GetNullableObjectAtIndex(list, 3);
  return pigeonResult;
}
+ (nullable FGMPlatformCluster *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCluster fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.clusterManagerId ?: [NSNull null],
    self.position ?: [NSNull null],
    self.bounds ?: [NSNull null],
    self.markerIds ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformClusterManager
+ (instancetype)makeWithIdentifier:(NSString *)identifier {
  FGMPlatformClusterManager *pigeonResult = [[FGMPlatformClusterManager alloc] init];
  pigeonResult.identifier = identifier;
  return pigeonResult;
}
+ (FGMPlatformClusterManager *)fromList:(NSArray<id> *)list {
  FGMPlatformClusterManager *pigeonResult = [[FGMPlatformClusterManager alloc] init];
  pigeonResult.identifier = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformClusterManager *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformClusterManager fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.identifier ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformMarker
+ (instancetype)makeWithAlpha:(double)alpha
                       anchor:(FGMPlatformPoint *)anchor
             consumeTapEvents:(BOOL)consumeTapEvents
                    draggable:(BOOL)draggable
                         flat:(BOOL)flat
                         icon:(FGMPlatformBitmap *)icon
                   infoWindow:(FGMPlatformInfoWindow *)infoWindow
                     position:(FGMPlatformLatLng *)position
                     rotation:(double)rotation
                      visible:(BOOL)visible
                       zIndex:(double)zIndex
                     markerId:(NSString *)markerId
             clusterManagerId:(nullable NSString *)clusterManagerId {
  FGMPlatformMarker *pigeonResult = [[FGMPlatformMarker alloc] init];
  pigeonResult.alpha = alpha;
  pigeonResult.anchor = anchor;
  pigeonResult.consumeTapEvents = consumeTapEvents;
  pigeonResult.draggable = draggable;
  pigeonResult.flat = flat;
  pigeonResult.icon = icon;
  pigeonResult.infoWindow = infoWindow;
  pigeonResult.position = position;
  pigeonResult.rotation = rotation;
  pigeonResult.visible = visible;
  pigeonResult.zIndex = zIndex;
  pigeonResult.markerId = markerId;
  pigeonResult.clusterManagerId = clusterManagerId;
  return pigeonResult;
}
+ (FGMPlatformMarker *)fromList:(NSArray<id> *)list {
  FGMPlatformMarker *pigeonResult = [[FGMPlatformMarker alloc] init];
  pigeonResult.alpha = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.anchor = GetNullableObjectAtIndex(list, 1);
  pigeonResult.consumeTapEvents = [GetNullableObjectAtIndex(list, 2) boolValue];
  pigeonResult.draggable = [GetNullableObjectAtIndex(list, 3) boolValue];
  pigeonResult.flat = [GetNullableObjectAtIndex(list, 4) boolValue];
  pigeonResult.icon = GetNullableObjectAtIndex(list, 5);
  pigeonResult.infoWindow = GetNullableObjectAtIndex(list, 6);
  pigeonResult.position = GetNullableObjectAtIndex(list, 7);
  pigeonResult.rotation = [GetNullableObjectAtIndex(list, 8) doubleValue];
  pigeonResult.visible = [GetNullableObjectAtIndex(list, 9) boolValue];
  pigeonResult.zIndex = [GetNullableObjectAtIndex(list, 10) doubleValue];
  pigeonResult.markerId = GetNullableObjectAtIndex(list, 11);
  pigeonResult.clusterManagerId = GetNullableObjectAtIndex(list, 12);
  return pigeonResult;
}
+ (nullable FGMPlatformMarker *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformMarker fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.alpha),
    self.anchor ?: [NSNull null],
    @(self.consumeTapEvents),
    @(self.draggable),
    @(self.flat),
    self.icon ?: [NSNull null],
    self.infoWindow ?: [NSNull null],
    self.position ?: [NSNull null],
    @(self.rotation),
    @(self.visible),
    @(self.zIndex),
    self.markerId ?: [NSNull null],
    self.clusterManagerId ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformPolygon
+ (instancetype)makeWithPolygonId:(NSString *)polygonId
                consumesTapEvents:(BOOL)consumesTapEvents
                        fillColor:(NSInteger)fillColor
                         geodesic:(BOOL)geodesic
                           points:(NSArray<FGMPlatformLatLng *> *)points
                            holes:(NSArray<NSArray<FGMPlatformLatLng *> *> *)holes
                          visible:(BOOL)visible
                      strokeColor:(NSInteger)strokeColor
                      strokeWidth:(NSInteger)strokeWidth
                           zIndex:(NSInteger)zIndex {
  FGMPlatformPolygon *pigeonResult = [[FGMPlatformPolygon alloc] init];
  pigeonResult.polygonId = polygonId;
  pigeonResult.consumesTapEvents = consumesTapEvents;
  pigeonResult.fillColor = fillColor;
  pigeonResult.geodesic = geodesic;
  pigeonResult.points = points;
  pigeonResult.holes = holes;
  pigeonResult.visible = visible;
  pigeonResult.strokeColor = strokeColor;
  pigeonResult.strokeWidth = strokeWidth;
  pigeonResult.zIndex = zIndex;
  return pigeonResult;
}
+ (FGMPlatformPolygon *)fromList:(NSArray<id> *)list {
  FGMPlatformPolygon *pigeonResult = [[FGMPlatformPolygon alloc] init];
  pigeonResult.polygonId = GetNullableObjectAtIndex(list, 0);
  pigeonResult.consumesTapEvents = [GetNullableObjectAtIndex(list, 1) boolValue];
  pigeonResult.fillColor = [GetNullableObjectAtIndex(list, 2) integerValue];
  pigeonResult.geodesic = [GetNullableObjectAtIndex(list, 3) boolValue];
  pigeonResult.points = GetNullableObjectAtIndex(list, 4);
  pigeonResult.holes = GetNullableObjectAtIndex(list, 5);
  pigeonResult.visible = [GetNullableObjectAtIndex(list, 6) boolValue];
  pigeonResult.strokeColor = [GetNullableObjectAtIndex(list, 7) integerValue];
  pigeonResult.strokeWidth = [GetNullableObjectAtIndex(list, 8) integerValue];
  pigeonResult.zIndex = [GetNullableObjectAtIndex(list, 9) integerValue];
  return pigeonResult;
}
+ (nullable FGMPlatformPolygon *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformPolygon fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.polygonId ?: [NSNull null],
    @(self.consumesTapEvents),
    @(self.fillColor),
    @(self.geodesic),
    self.points ?: [NSNull null],
    self.holes ?: [NSNull null],
    @(self.visible),
    @(self.strokeColor),
    @(self.strokeWidth),
    @(self.zIndex),
  ];
}
@end

@implementation FGMPlatformPolyline
+ (instancetype)makeWithPolylineId:(NSString *)polylineId
                 consumesTapEvents:(BOOL)consumesTapEvents
                             color:(NSInteger)color
                          geodesic:(BOOL)geodesic
                         jointType:(FGMPlatformJointType)jointType
                          patterns:(NSArray<FGMPlatformPatternItem *> *)patterns
                            points:(NSArray<FGMPlatformLatLng *> *)points
                           visible:(BOOL)visible
                             width:(NSInteger)width
                            zIndex:(NSInteger)zIndex {
  FGMPlatformPolyline *pigeonResult = [[FGMPlatformPolyline alloc] init];
  pigeonResult.polylineId = polylineId;
  pigeonResult.consumesTapEvents = consumesTapEvents;
  pigeonResult.color = color;
  pigeonResult.geodesic = geodesic;
  pigeonResult.jointType = jointType;
  pigeonResult.patterns = patterns;
  pigeonResult.points = points;
  pigeonResult.visible = visible;
  pigeonResult.width = width;
  pigeonResult.zIndex = zIndex;
  return pigeonResult;
}
+ (FGMPlatformPolyline *)fromList:(NSArray<id> *)list {
  FGMPlatformPolyline *pigeonResult = [[FGMPlatformPolyline alloc] init];
  pigeonResult.polylineId = GetNullableObjectAtIndex(list, 0);
  pigeonResult.consumesTapEvents = [GetNullableObjectAtIndex(list, 1) boolValue];
  pigeonResult.color = [GetNullableObjectAtIndex(list, 2) integerValue];
  pigeonResult.geodesic = [GetNullableObjectAtIndex(list, 3) boolValue];
  FGMPlatformJointTypeBox *boxedFGMPlatformJointType = GetNullableObjectAtIndex(list, 4);
  pigeonResult.jointType = boxedFGMPlatformJointType.value;
  pigeonResult.patterns = GetNullableObjectAtIndex(list, 5);
  pigeonResult.points = GetNullableObjectAtIndex(list, 6);
  pigeonResult.visible = [GetNullableObjectAtIndex(list, 7) boolValue];
  pigeonResult.width = [GetNullableObjectAtIndex(list, 8) integerValue];
  pigeonResult.zIndex = [GetNullableObjectAtIndex(list, 9) integerValue];
  return pigeonResult;
}
+ (nullable FGMPlatformPolyline *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformPolyline fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.polylineId ?: [NSNull null],
    @(self.consumesTapEvents),
    @(self.color),
    @(self.geodesic),
    [[FGMPlatformJointTypeBox alloc] initWithValue:self.jointType],
    self.patterns ?: [NSNull null],
    self.points ?: [NSNull null],
    @(self.visible),
    @(self.width),
    @(self.zIndex),
  ];
}
@end

@implementation FGMPlatformPatternItem
+ (instancetype)makeWithType:(FGMPlatformPatternItemType)type length:(nullable NSNumber *)length {
  FGMPlatformPatternItem *pigeonResult = [[FGMPlatformPatternItem alloc] init];
  pigeonResult.type = type;
  pigeonResult.length = length;
  return pigeonResult;
}
+ (FGMPlatformPatternItem *)fromList:(NSArray<id> *)list {
  FGMPlatformPatternItem *pigeonResult = [[FGMPlatformPatternItem alloc] init];
  FGMPlatformPatternItemTypeBox *boxedFGMPlatformPatternItemType =
      GetNullableObjectAtIndex(list, 0);
  pigeonResult.type = boxedFGMPlatformPatternItemType.value;
  pigeonResult.length = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FGMPlatformPatternItem *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformPatternItem fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    [[FGMPlatformPatternItemTypeBox alloc] initWithValue:self.type],
    self.length ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformTile
+ (instancetype)makeWithWidth:(NSInteger)width
                       height:(NSInteger)height
                         data:(nullable FlutterStandardTypedData *)data {
  FGMPlatformTile *pigeonResult = [[FGMPlatformTile alloc] init];
  pigeonResult.width = width;
  pigeonResult.height = height;
  pigeonResult.data = data;
  return pigeonResult;
}
+ (FGMPlatformTile *)fromList:(NSArray<id> *)list {
  FGMPlatformTile *pigeonResult = [[FGMPlatformTile alloc] init];
  pigeonResult.width = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.height = [GetNullableObjectAtIndex(list, 1) integerValue];
  pigeonResult.data = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable FGMPlatformTile *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformTile fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.width),
    @(self.height),
    self.data ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformTileOverlay
+ (instancetype)makeWithTileOverlayId:(NSString *)tileOverlayId
                               fadeIn:(BOOL)fadeIn
                         transparency:(double)transparency
                               zIndex:(NSInteger)zIndex
                              visible:(BOOL)visible
                             tileSize:(NSInteger)tileSize {
  FGMPlatformTileOverlay *pigeonResult = [[FGMPlatformTileOverlay alloc] init];
  pigeonResult.tileOverlayId = tileOverlayId;
  pigeonResult.fadeIn = fadeIn;
  pigeonResult.transparency = transparency;
  pigeonResult.zIndex = zIndex;
  pigeonResult.visible = visible;
  pigeonResult.tileSize = tileSize;
  return pigeonResult;
}
+ (FGMPlatformTileOverlay *)fromList:(NSArray<id> *)list {
  FGMPlatformTileOverlay *pigeonResult = [[FGMPlatformTileOverlay alloc] init];
  pigeonResult.tileOverlayId = GetNullableObjectAtIndex(list, 0);
  pigeonResult.fadeIn = [GetNullableObjectAtIndex(list, 1) boolValue];
  pigeonResult.transparency = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.zIndex = [GetNullableObjectAtIndex(list, 3) integerValue];
  pigeonResult.visible = [GetNullableObjectAtIndex(list, 4) boolValue];
  pigeonResult.tileSize = [GetNullableObjectAtIndex(list, 5) integerValue];
  return pigeonResult;
}
+ (nullable FGMPlatformTileOverlay *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformTileOverlay fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.tileOverlayId ?: [NSNull null],
    @(self.fadeIn),
    @(self.transparency),
    @(self.zIndex),
    @(self.visible),
    @(self.tileSize),
  ];
}
@end

@implementation FGMPlatformEdgeInsets
+ (instancetype)makeWithTop:(double)top
                     bottom:(double)bottom
                       left:(double)left
                      right:(double)right {
  FGMPlatformEdgeInsets *pigeonResult = [[FGMPlatformEdgeInsets alloc] init];
  pigeonResult.top = top;
  pigeonResult.bottom = bottom;
  pigeonResult.left = left;
  pigeonResult.right = right;
  return pigeonResult;
}
+ (FGMPlatformEdgeInsets *)fromList:(NSArray<id> *)list {
  FGMPlatformEdgeInsets *pigeonResult = [[FGMPlatformEdgeInsets alloc] init];
  pigeonResult.top = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.bottom = [GetNullableObjectAtIndex(list, 1) doubleValue];
  pigeonResult.left = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.right = [GetNullableObjectAtIndex(list, 3) doubleValue];
  return pigeonResult;
}
+ (nullable FGMPlatformEdgeInsets *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformEdgeInsets fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.top),
    @(self.bottom),
    @(self.left),
    @(self.right),
  ];
}
@end

@implementation FGMPlatformLatLng
+ (instancetype)makeWithLatitude:(double)latitude longitude:(double)longitude {
  FGMPlatformLatLng *pigeonResult = [[FGMPlatformLatLng alloc] init];
  pigeonResult.latitude = latitude;
  pigeonResult.longitude = longitude;
  return pigeonResult;
}
+ (FGMPlatformLatLng *)fromList:(NSArray<id> *)list {
  FGMPlatformLatLng *pigeonResult = [[FGMPlatformLatLng alloc] init];
  pigeonResult.latitude = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.longitude = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FGMPlatformLatLng *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformLatLng fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.latitude),
    @(self.longitude),
  ];
}
@end

@implementation FGMPlatformLatLngBounds
+ (instancetype)makeWithNortheast:(FGMPlatformLatLng *)northeast
                        southwest:(FGMPlatformLatLng *)southwest {
  FGMPlatformLatLngBounds *pigeonResult = [[FGMPlatformLatLngBounds alloc] init];
  pigeonResult.northeast = northeast;
  pigeonResult.southwest = southwest;
  return pigeonResult;
}
+ (FGMPlatformLatLngBounds *)fromList:(NSArray<id> *)list {
  FGMPlatformLatLngBounds *pigeonResult = [[FGMPlatformLatLngBounds alloc] init];
  pigeonResult.northeast = GetNullableObjectAtIndex(list, 0);
  pigeonResult.southwest = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FGMPlatformLatLngBounds *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformLatLngBounds fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.northeast ?: [NSNull null],
    self.southwest ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformCameraTargetBounds
+ (instancetype)makeWithBounds:(nullable FGMPlatformLatLngBounds *)bounds {
  FGMPlatformCameraTargetBounds *pigeonResult = [[FGMPlatformCameraTargetBounds alloc] init];
  pigeonResult.bounds = bounds;
  return pigeonResult;
}
+ (FGMPlatformCameraTargetBounds *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraTargetBounds *pigeonResult = [[FGMPlatformCameraTargetBounds alloc] init];
  pigeonResult.bounds = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformCameraTargetBounds *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraTargetBounds fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.bounds ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformMapViewCreationParams
+ (instancetype)
    makeWithInitialCameraPosition:(FGMPlatformCameraPosition *)initialCameraPosition
                 mapConfiguration:(FGMPlatformMapConfiguration *)mapConfiguration
                   initialCircles:(NSArray<FGMPlatformCircle *> *)initialCircles
                   initialMarkers:(NSArray<FGMPlatformMarker *> *)initialMarkers
                  initialPolygons:(NSArray<FGMPlatformPolygon *> *)initialPolygons
                 initialPolylines:(NSArray<FGMPlatformPolyline *> *)initialPolylines
                  initialHeatmaps:(NSArray<FGMPlatformHeatmap *> *)initialHeatmaps
              initialTileOverlays:(NSArray<FGMPlatformTileOverlay *> *)initialTileOverlays
           initialClusterManagers:(NSArray<FGMPlatformClusterManager *> *)initialClusterManagers {
  FGMPlatformMapViewCreationParams *pigeonResult = [[FGMPlatformMapViewCreationParams alloc] init];
  pigeonResult.initialCameraPosition = initialCameraPosition;
  pigeonResult.mapConfiguration = mapConfiguration;
  pigeonResult.initialCircles = initialCircles;
  pigeonResult.initialMarkers = initialMarkers;
  pigeonResult.initialPolygons = initialPolygons;
  pigeonResult.initialPolylines = initialPolylines;
  pigeonResult.initialHeatmaps = initialHeatmaps;
  pigeonResult.initialTileOverlays = initialTileOverlays;
  pigeonResult.initialClusterManagers = initialClusterManagers;
  return pigeonResult;
}
+ (FGMPlatformMapViewCreationParams *)fromList:(NSArray<id> *)list {
  FGMPlatformMapViewCreationParams *pigeonResult = [[FGMPlatformMapViewCreationParams alloc] init];
  pigeonResult.initialCameraPosition = GetNullableObjectAtIndex(list, 0);
  pigeonResult.mapConfiguration = GetNullableObjectAtIndex(list, 1);
  pigeonResult.initialCircles = GetNullableObjectAtIndex(list, 2);
  pigeonResult.initialMarkers = GetNullableObjectAtIndex(list, 3);
  pigeonResult.initialPolygons = GetNullableObjectAtIndex(list, 4);
  pigeonResult.initialPolylines = GetNullableObjectAtIndex(list, 5);
  pigeonResult.initialHeatmaps = GetNullableObjectAtIndex(list, 6);
  pigeonResult.initialTileOverlays = GetNullableObjectAtIndex(list, 7);
  pigeonResult.initialClusterManagers = GetNullableObjectAtIndex(list, 8);
  return pigeonResult;
}
+ (nullable FGMPlatformMapViewCreationParams *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformMapViewCreationParams fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.initialCameraPosition ?: [NSNull null],
    self.mapConfiguration ?: [NSNull null],
    self.initialCircles ?: [NSNull null],
    self.initialMarkers ?: [NSNull null],
    self.initialPolygons ?: [NSNull null],
    self.initialPolylines ?: [NSNull null],
    self.initialHeatmaps ?: [NSNull null],
    self.initialTileOverlays ?: [NSNull null],
    self.initialClusterManagers ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformMapConfiguration
+ (instancetype)makeWithCompassEnabled:(nullable NSNumber *)compassEnabled
                    cameraTargetBounds:(nullable FGMPlatformCameraTargetBounds *)cameraTargetBounds
                               mapType:(nullable FGMPlatformMapTypeBox *)mapType
                  minMaxZoomPreference:(nullable FGMPlatformZoomRange *)minMaxZoomPreference
                 rotateGesturesEnabled:(nullable NSNumber *)rotateGesturesEnabled
                 scrollGesturesEnabled:(nullable NSNumber *)scrollGesturesEnabled
                   tiltGesturesEnabled:(nullable NSNumber *)tiltGesturesEnabled
                   trackCameraPosition:(nullable NSNumber *)trackCameraPosition
                   zoomGesturesEnabled:(nullable NSNumber *)zoomGesturesEnabled
                     myLocationEnabled:(nullable NSNumber *)myLocationEnabled
               myLocationButtonEnabled:(nullable NSNumber *)myLocationButtonEnabled
                               padding:(nullable FGMPlatformEdgeInsets *)padding
                     indoorViewEnabled:(nullable NSNumber *)indoorViewEnabled
                        trafficEnabled:(nullable NSNumber *)trafficEnabled
                      buildingsEnabled:(nullable NSNumber *)buildingsEnabled
                            cloudMapId:(nullable NSString *)cloudMapId
                                 style:(nullable NSString *)style {
  FGMPlatformMapConfiguration *pigeonResult = [[FGMPlatformMapConfiguration alloc] init];
  pigeonResult.compassEnabled = compassEnabled;
  pigeonResult.cameraTargetBounds = cameraTargetBounds;
  pigeonResult.mapType = mapType;
  pigeonResult.minMaxZoomPreference = minMaxZoomPreference;
  pigeonResult.rotateGesturesEnabled = rotateGesturesEnabled;
  pigeonResult.scrollGesturesEnabled = scrollGesturesEnabled;
  pigeonResult.tiltGesturesEnabled = tiltGesturesEnabled;
  pigeonResult.trackCameraPosition = trackCameraPosition;
  pigeonResult.zoomGesturesEnabled = zoomGesturesEnabled;
  pigeonResult.myLocationEnabled = myLocationEnabled;
  pigeonResult.myLocationButtonEnabled = myLocationButtonEnabled;
  pigeonResult.padding = padding;
  pigeonResult.indoorViewEnabled = indoorViewEnabled;
  pigeonResult.trafficEnabled = trafficEnabled;
  pigeonResult.buildingsEnabled = buildingsEnabled;
  pigeonResult.cloudMapId = cloudMapId;
  pigeonResult.style = style;
  return pigeonResult;
}
+ (FGMPlatformMapConfiguration *)fromList:(NSArray<id> *)list {
  FGMPlatformMapConfiguration *pigeonResult = [[FGMPlatformMapConfiguration alloc] init];
  pigeonResult.compassEnabled = GetNullableObjectAtIndex(list, 0);
  pigeonResult.cameraTargetBounds = GetNullableObjectAtIndex(list, 1);
  pigeonResult.mapType = GetNullableObjectAtIndex(list, 2);
  pigeonResult.minMaxZoomPreference = GetNullableObjectAtIndex(list, 3);
  pigeonResult.rotateGesturesEnabled = GetNullableObjectAtIndex(list, 4);
  pigeonResult.scrollGesturesEnabled = GetNullableObjectAtIndex(list, 5);
  pigeonResult.tiltGesturesEnabled = GetNullableObjectAtIndex(list, 6);
  pigeonResult.trackCameraPosition = GetNullableObjectAtIndex(list, 7);
  pigeonResult.zoomGesturesEnabled = GetNullableObjectAtIndex(list, 8);
  pigeonResult.myLocationEnabled = GetNullableObjectAtIndex(list, 9);
  pigeonResult.myLocationButtonEnabled = GetNullableObjectAtIndex(list, 10);
  pigeonResult.padding = GetNullableObjectAtIndex(list, 11);
  pigeonResult.indoorViewEnabled = GetNullableObjectAtIndex(list, 12);
  pigeonResult.trafficEnabled = GetNullableObjectAtIndex(list, 13);
  pigeonResult.buildingsEnabled = GetNullableObjectAtIndex(list, 14);
  pigeonResult.cloudMapId = GetNullableObjectAtIndex(list, 15);
  pigeonResult.style = GetNullableObjectAtIndex(list, 16);
  return pigeonResult;
}
+ (nullable FGMPlatformMapConfiguration *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformMapConfiguration fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.compassEnabled ?: [NSNull null],
    self.cameraTargetBounds ?: [NSNull null],
    self.mapType ?: [NSNull null],
    self.minMaxZoomPreference ?: [NSNull null],
    self.rotateGesturesEnabled ?: [NSNull null],
    self.scrollGesturesEnabled ?: [NSNull null],
    self.tiltGesturesEnabled ?: [NSNull null],
    self.trackCameraPosition ?: [NSNull null],
    self.zoomGesturesEnabled ?: [NSNull null],
    self.myLocationEnabled ?: [NSNull null],
    self.myLocationButtonEnabled ?: [NSNull null],
    self.padding ?: [NSNull null],
    self.indoorViewEnabled ?: [NSNull null],
    self.trafficEnabled ?: [NSNull null],
    self.buildingsEnabled ?: [NSNull null],
    self.cloudMapId ?: [NSNull null],
    self.style ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformPoint
+ (instancetype)makeWithX:(double)x y:(double)y {
  FGMPlatformPoint *pigeonResult = [[FGMPlatformPoint alloc] init];
  pigeonResult.x = x;
  pigeonResult.y = y;
  return pigeonResult;
}
+ (FGMPlatformPoint *)fromList:(NSArray<id> *)list {
  FGMPlatformPoint *pigeonResult = [[FGMPlatformPoint alloc] init];
  pigeonResult.x = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.y = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FGMPlatformPoint *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformPoint fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.x),
    @(self.y),
  ];
}
@end

@implementation FGMPlatformSize
+ (instancetype)makeWithWidth:(double)width height:(double)height {
  FGMPlatformSize *pigeonResult = [[FGMPlatformSize alloc] init];
  pigeonResult.width = width;
  pigeonResult.height = height;
  return pigeonResult;
}
+ (FGMPlatformSize *)fromList:(NSArray<id> *)list {
  FGMPlatformSize *pigeonResult = [[FGMPlatformSize alloc] init];
  pigeonResult.width = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.height = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FGMPlatformSize *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformSize fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.width),
    @(self.height),
  ];
}
@end

@implementation FGMPlatformTileLayer
+ (instancetype)makeWithVisible:(BOOL)visible
                         fadeIn:(BOOL)fadeIn
                        opacity:(double)opacity
                         zIndex:(NSInteger)zIndex {
  FGMPlatformTileLayer *pigeonResult = [[FGMPlatformTileLayer alloc] init];
  pigeonResult.visible = visible;
  pigeonResult.fadeIn = fadeIn;
  pigeonResult.opacity = opacity;
  pigeonResult.zIndex = zIndex;
  return pigeonResult;
}
+ (FGMPlatformTileLayer *)fromList:(NSArray<id> *)list {
  FGMPlatformTileLayer *pigeonResult = [[FGMPlatformTileLayer alloc] init];
  pigeonResult.visible = [GetNullableObjectAtIndex(list, 0) boolValue];
  pigeonResult.fadeIn = [GetNullableObjectAtIndex(list, 1) boolValue];
  pigeonResult.opacity = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.zIndex = [GetNullableObjectAtIndex(list, 3) integerValue];
  return pigeonResult;
}
+ (nullable FGMPlatformTileLayer *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformTileLayer fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.visible),
    @(self.fadeIn),
    @(self.opacity),
    @(self.zIndex),
  ];
}
@end

@implementation FGMPlatformZoomRange
+ (instancetype)makeWithMin:(nullable NSNumber *)min max:(nullable NSNumber *)max {
  FGMPlatformZoomRange *pigeonResult = [[FGMPlatformZoomRange alloc] init];
  pigeonResult.min = min;
  pigeonResult.max = max;
  return pigeonResult;
}
+ (FGMPlatformZoomRange *)fromList:(NSArray<id> *)list {
  FGMPlatformZoomRange *pigeonResult = [[FGMPlatformZoomRange alloc] init];
  pigeonResult.min = GetNullableObjectAtIndex(list, 0);
  pigeonResult.max = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FGMPlatformZoomRange *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformZoomRange fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.min ?: [NSNull null],
    self.max ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformBitmap
+ (instancetype)makeWithBitmap:(id)bitmap {
  FGMPlatformBitmap *pigeonResult = [[FGMPlatformBitmap alloc] init];
  pigeonResult.bitmap = bitmap;
  return pigeonResult;
}
+ (FGMPlatformBitmap *)fromList:(NSArray<id> *)list {
  FGMPlatformBitmap *pigeonResult = [[FGMPlatformBitmap alloc] init];
  pigeonResult.bitmap = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformBitmap *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformBitmap fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.bitmap ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformBitmapDefaultMarker
+ (instancetype)makeWithHue:(nullable NSNumber *)hue {
  FGMPlatformBitmapDefaultMarker *pigeonResult = [[FGMPlatformBitmapDefaultMarker alloc] init];
  pigeonResult.hue = hue;
  return pigeonResult;
}
+ (FGMPlatformBitmapDefaultMarker *)fromList:(NSArray<id> *)list {
  FGMPlatformBitmapDefaultMarker *pigeonResult = [[FGMPlatformBitmapDefaultMarker alloc] init];
  pigeonResult.hue = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformBitmapDefaultMarker *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformBitmapDefaultMarker fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.hue ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformBitmapBytes
+ (instancetype)makeWithByteData:(FlutterStandardTypedData *)byteData
                            size:(nullable FGMPlatformSize *)size {
  FGMPlatformBitmapBytes *pigeonResult = [[FGMPlatformBitmapBytes alloc] init];
  pigeonResult.byteData = byteData;
  pigeonResult.size = size;
  return pigeonResult;
}
+ (FGMPlatformBitmapBytes *)fromList:(NSArray<id> *)list {
  FGMPlatformBitmapBytes *pigeonResult = [[FGMPlatformBitmapBytes alloc] init];
  pigeonResult.byteData = GetNullableObjectAtIndex(list, 0);
  pigeonResult.size = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FGMPlatformBitmapBytes *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformBitmapBytes fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.byteData ?: [NSNull null],
    self.size ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformBitmapAsset
+ (instancetype)makeWithName:(NSString *)name pkg:(nullable NSString *)pkg {
  FGMPlatformBitmapAsset *pigeonResult = [[FGMPlatformBitmapAsset alloc] init];
  pigeonResult.name = name;
  pigeonResult.pkg = pkg;
  return pigeonResult;
}
+ (FGMPlatformBitmapAsset *)fromList:(NSArray<id> *)list {
  FGMPlatformBitmapAsset *pigeonResult = [[FGMPlatformBitmapAsset alloc] init];
  pigeonResult.name = GetNullableObjectAtIndex(list, 0);
  pigeonResult.pkg = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FGMPlatformBitmapAsset *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformBitmapAsset fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.name ?: [NSNull null],
    self.pkg ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformBitmapAssetImage
+ (instancetype)makeWithName:(NSString *)name
                       scale:(double)scale
                        size:(nullable FGMPlatformSize *)size {
  FGMPlatformBitmapAssetImage *pigeonResult = [[FGMPlatformBitmapAssetImage alloc] init];
  pigeonResult.name = name;
  pigeonResult.scale = scale;
  pigeonResult.size = size;
  return pigeonResult;
}
+ (FGMPlatformBitmapAssetImage *)fromList:(NSArray<id> *)list {
  FGMPlatformBitmapAssetImage *pigeonResult = [[FGMPlatformBitmapAssetImage alloc] init];
  pigeonResult.name = GetNullableObjectAtIndex(list, 0);
  pigeonResult.scale = [GetNullableObjectAtIndex(list, 1) doubleValue];
  pigeonResult.size = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable FGMPlatformBitmapAssetImage *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformBitmapAssetImage fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.name ?: [NSNull null],
    @(self.scale),
    self.size ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformBitmapAssetMap
+ (instancetype)makeWithAssetName:(NSString *)assetName
                    bitmapScaling:(FGMPlatformMapBitmapScaling)bitmapScaling
                  imagePixelRatio:(double)imagePixelRatio
                            width:(nullable NSNumber *)width
                           height:(nullable NSNumber *)height {
  FGMPlatformBitmapAssetMap *pigeonResult = [[FGMPlatformBitmapAssetMap alloc] init];
  pigeonResult.assetName = assetName;
  pigeonResult.bitmapScaling = bitmapScaling;
  pigeonResult.imagePixelRatio = imagePixelRatio;
  pigeonResult.width = width;
  pigeonResult.height = height;
  return pigeonResult;
}
+ (FGMPlatformBitmapAssetMap *)fromList:(NSArray<id> *)list {
  FGMPlatformBitmapAssetMap *pigeonResult = [[FGMPlatformBitmapAssetMap alloc] init];
  pigeonResult.assetName = GetNullableObjectAtIndex(list, 0);
  FGMPlatformMapBitmapScalingBox *boxedFGMPlatformMapBitmapScaling =
      GetNullableObjectAtIndex(list, 1);
  pigeonResult.bitmapScaling = boxedFGMPlatformMapBitmapScaling.value;
  pigeonResult.imagePixelRatio = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.width = GetNullableObjectAtIndex(list, 3);
  pigeonResult.height = GetNullableObjectAtIndex(list, 4);
  return pigeonResult;
}
+ (nullable FGMPlatformBitmapAssetMap *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformBitmapAssetMap fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.assetName ?: [NSNull null],
    [[FGMPlatformMapBitmapScalingBox alloc] initWithValue:self.bitmapScaling],
    @(self.imagePixelRatio),
    self.width ?: [NSNull null],
    self.height ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformBitmapBytesMap
+ (instancetype)makeWithByteData:(FlutterStandardTypedData *)byteData
                   bitmapScaling:(FGMPlatformMapBitmapScaling)bitmapScaling
                 imagePixelRatio:(double)imagePixelRatio
                           width:(nullable NSNumber *)width
                          height:(nullable NSNumber *)height {
  FGMPlatformBitmapBytesMap *pigeonResult = [[FGMPlatformBitmapBytesMap alloc] init];
  pigeonResult.byteData = byteData;
  pigeonResult.bitmapScaling = bitmapScaling;
  pigeonResult.imagePixelRatio = imagePixelRatio;
  pigeonResult.width = width;
  pigeonResult.height = height;
  return pigeonResult;
}
+ (FGMPlatformBitmapBytesMap *)fromList:(NSArray<id> *)list {
  FGMPlatformBitmapBytesMap *pigeonResult = [[FGMPlatformBitmapBytesMap alloc] init];
  pigeonResult.byteData = GetNullableObjectAtIndex(list, 0);
  FGMPlatformMapBitmapScalingBox *boxedFGMPlatformMapBitmapScaling =
      GetNullableObjectAtIndex(list, 1);
  pigeonResult.bitmapScaling = boxedFGMPlatformMapBitmapScaling.value;
  pigeonResult.imagePixelRatio = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.width = GetNullableObjectAtIndex(list, 3);
  pigeonResult.height = GetNullableObjectAtIndex(list, 4);
  return pigeonResult;
}
+ (nullable FGMPlatformBitmapBytesMap *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformBitmapBytesMap fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.byteData ?: [NSNull null],
    [[FGMPlatformMapBitmapScalingBox alloc] initWithValue:self.bitmapScaling],
    @(self.imagePixelRatio),
    self.width ?: [NSNull null],
    self.height ?: [NSNull null],
  ];
}
@end

@interface FGMMessagesPigeonCodecReader : FlutterStandardReader
@end
@implementation FGMMessagesPigeonCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 129: {
      NSNumber *enumAsNumber = [self readValue];
      return enumAsNumber == nil
                 ? nil
                 : [[FGMPlatformMapTypeBox alloc] initWithValue:[enumAsNumber integerValue]];
    }
    case 130: {
      NSNumber *enumAsNumber = [self readValue];
      return enumAsNumber == nil
                 ? nil
                 : [[FGMPlatformJointTypeBox alloc] initWithValue:[enumAsNumber integerValue]];
    }
    case 131: {
      NSNumber *enumAsNumber = [self readValue];
      return enumAsNumber == nil ? nil
                                 : [[FGMPlatformPatternItemTypeBox alloc]
                                       initWithValue:[enumAsNumber integerValue]];
    }
    case 132: {
      NSNumber *enumAsNumber = [self readValue];
      return enumAsNumber == nil ? nil
                                 : [[FGMPlatformMapBitmapScalingBox alloc]
                                       initWithValue:[enumAsNumber integerValue]];
    }
    case 133:
      return [FGMPlatformCameraPosition fromList:[self readValue]];
    case 134:
      return [FGMPlatformCameraUpdate fromList:[self readValue]];
    case 135:
      return [FGMPlatformCameraUpdateNewCameraPosition fromList:[self readValue]];
    case 136:
      return [FGMPlatformCameraUpdateNewLatLng fromList:[self readValue]];
    case 137:
      return [FGMPlatformCameraUpdateNewLatLngBounds fromList:[self readValue]];
    case 138:
      return [FGMPlatformCameraUpdateNewLatLngZoom fromList:[self readValue]];
    case 139:
      return [FGMPlatformCameraUpdateScrollBy fromList:[self readValue]];
    case 140:
      return [FGMPlatformCameraUpdateZoomBy fromList:[self readValue]];
    case 141:
      return [FGMPlatformCameraUpdateZoom fromList:[self readValue]];
    case 142:
      return [FGMPlatformCameraUpdateZoomTo fromList:[self readValue]];
    case 143:
      return [FGMPlatformCircle fromList:[self readValue]];
    case 144:
      return [FGMPlatformHeatmap fromList:[self readValue]];
    case 145:
      return [FGMPlatformInfoWindow fromList:[self readValue]];
    case 146:
      return [FGMPlatformCluster fromList:[self readValue]];
    case 147:
      return [FGMPlatformClusterManager fromList:[self readValue]];
    case 148:
      return [FGMPlatformMarker fromList:[self readValue]];
    case 149:
      return [FGMPlatformPolygon fromList:[self readValue]];
    case 150:
      return [FGMPlatformPolyline fromList:[self readValue]];
    case 151:
      return [FGMPlatformPatternItem fromList:[self readValue]];
    case 152:
      return [FGMPlatformTile fromList:[self readValue]];
    case 153:
      return [FGMPlatformTileOverlay fromList:[self readValue]];
    case 154:
      return [FGMPlatformEdgeInsets fromList:[self readValue]];
    case 155:
      return [FGMPlatformLatLng fromList:[self readValue]];
    case 156:
      return [FGMPlatformLatLngBounds fromList:[self readValue]];
    case 157:
      return [FGMPlatformCameraTargetBounds fromList:[self readValue]];
    case 158:
      return [FGMPlatformMapViewCreationParams fromList:[self readValue]];
    case 159:
      return [FGMPlatformMapConfiguration fromList:[self readValue]];
    case 160:
      return [FGMPlatformPoint fromList:[self readValue]];
    case 161:
      return [FGMPlatformSize fromList:[self readValue]];
    case 162:
      return [FGMPlatformTileLayer fromList:[self readValue]];
    case 163:
      return [FGMPlatformZoomRange fromList:[self readValue]];
    case 164:
      return [FGMPlatformBitmap fromList:[self readValue]];
    case 165:
      return [FGMPlatformBitmapDefaultMarker fromList:[self readValue]];
    case 166:
      return [FGMPlatformBitmapBytes fromList:[self readValue]];
    case 167:
      return [FGMPlatformBitmapAsset fromList:[self readValue]];
    case 168:
      return [FGMPlatformBitmapAssetImage fromList:[self readValue]];
    case 169:
      return [FGMPlatformBitmapAssetMap fromList:[self readValue]];
    case 170:
      return [FGMPlatformBitmapBytesMap fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FGMMessagesPigeonCodecWriter : FlutterStandardWriter
@end
@implementation FGMMessagesPigeonCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FGMPlatformMapTypeBox class]]) {
    FGMPlatformMapTypeBox *box = (FGMPlatformMapTypeBox *)value;
    [self writeByte:129];
    [self writeValue:(value == nil ? [NSNull null] : [NSNumber numberWithInteger:box.value])];
  } else if ([value isKindOfClass:[FGMPlatformJointTypeBox class]]) {
    FGMPlatformJointTypeBox *box = (FGMPlatformJointTypeBox *)value;
    [self writeByte:130];
    [self writeValue:(value == nil ? [NSNull null] : [NSNumber numberWithInteger:box.value])];
  } else if ([value isKindOfClass:[FGMPlatformPatternItemTypeBox class]]) {
    FGMPlatformPatternItemTypeBox *box = (FGMPlatformPatternItemTypeBox *)value;
    [self writeByte:131];
    [self writeValue:(value == nil ? [NSNull null] : [NSNumber numberWithInteger:box.value])];
  } else if ([value isKindOfClass:[FGMPlatformMapBitmapScalingBox class]]) {
    FGMPlatformMapBitmapScalingBox *box = (FGMPlatformMapBitmapScalingBox *)value;
    [self writeByte:132];
    [self writeValue:(value == nil ? [NSNull null] : [NSNumber numberWithInteger:box.value])];
  } else if ([value isKindOfClass:[FGMPlatformCameraPosition class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCameraUpdate class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCameraUpdateNewCameraPosition class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCameraUpdateNewLatLng class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCameraUpdateNewLatLngBounds class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCameraUpdateNewLatLngZoom class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCameraUpdateScrollBy class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCameraUpdateZoomBy class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCameraUpdateZoom class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCameraUpdateZoomTo class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCircle class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformHeatmap class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformInfoWindow class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCluster class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformClusterManager class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformMarker class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformPolygon class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformPolyline class]]) {
    [self writeByte:150];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformPatternItem class]]) {
    [self writeByte:151];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformTile class]]) {
    [self writeByte:152];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformTileOverlay class]]) {
    [self writeByte:153];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformEdgeInsets class]]) {
    [self writeByte:154];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformLatLng class]]) {
    [self writeByte:155];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformLatLngBounds class]]) {
    [self writeByte:156];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCameraTargetBounds class]]) {
    [self writeByte:157];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformMapViewCreationParams class]]) {
    [self writeByte:158];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformMapConfiguration class]]) {
    [self writeByte:159];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformPoint class]]) {
    [self writeByte:160];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformSize class]]) {
    [self writeByte:161];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformTileLayer class]]) {
    [self writeByte:162];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformZoomRange class]]) {
    [self writeByte:163];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformBitmap class]]) {
    [self writeByte:164];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformBitmapDefaultMarker class]]) {
    [self writeByte:165];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformBitmapBytes class]]) {
    [self writeByte:166];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformBitmapAsset class]]) {
    [self writeByte:167];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformBitmapAssetImage class]]) {
    [self writeByte:168];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformBitmapAssetMap class]]) {
    [self writeByte:169];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformBitmapBytesMap class]]) {
    [self writeByte:170];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FGMMessagesPigeonCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FGMMessagesPigeonCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FGMMessagesPigeonCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FGMMessagesPigeonCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FGMGetMessagesCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FGMMessagesPigeonCodecReaderWriter *readerWriter =
        [[FGMMessagesPigeonCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}
void SetUpFGMMapsApi(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FGMMapsApi> *api) {
  SetUpFGMMapsApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFGMMapsApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                               NSObject<FGMMapsApi> *api, NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  /// Returns once the map instance is available.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.waitForMap",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(waitForMapWithError:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(waitForMapWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api waitForMapWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the map's configuration options.
  ///
  /// Only non-null configuration values will result in updates; options with
  /// null values will remain unchanged.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.updateMapConfiguration",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(updateWithMapConfiguration:error:)],
          @"FGMMapsApi api (%@) doesn't respond to @selector(updateWithMapConfiguration:error:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        FGMPlatformMapConfiguration *arg_configuration = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api updateWithMapConfiguration:arg_configuration error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of circles on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.updateCircles",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateCirclesByAdding:changing:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updateCirclesByAdding:changing:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformCircle *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<FGMPlatformCircle *> *arg_toChange = GetNullableObjectAtIndex(args, 1);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api updateCirclesByAdding:arg_toAdd
                          changing:arg_toChange
                          removing:arg_idsToRemove
                             error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of heatmaps on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.updateHeatmaps",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateHeatmapsByAdding:changing:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updateHeatmapsByAdding:changing:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformHeatmap *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<FGMPlatformHeatmap *> *arg_toChange = GetNullableObjectAtIndex(args, 1);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api updateHeatmapsByAdding:arg_toAdd
                           changing:arg_toChange
                           removing:arg_idsToRemove
                              error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of custer managers for clusters on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.updateClusterManagers",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateClusterManagersByAdding:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updateClusterManagersByAdding:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformClusterManager *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api updateClusterManagersByAdding:arg_toAdd removing:arg_idsToRemove error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of markers on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.updateMarkers",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateMarkersByAdding:changing:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updateMarkersByAdding:changing:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformMarker *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<FGMPlatformMarker *> *arg_toChange = GetNullableObjectAtIndex(args, 1);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api updateMarkersByAdding:arg_toAdd
                          changing:arg_toChange
                          removing:arg_idsToRemove
                             error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of polygonss on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.updatePolygons",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updatePolygonsByAdding:changing:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updatePolygonsByAdding:changing:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformPolygon *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<FGMPlatformPolygon *> *arg_toChange = GetNullableObjectAtIndex(args, 1);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api updatePolygonsByAdding:arg_toAdd
                           changing:arg_toChange
                           removing:arg_idsToRemove
                              error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of polylines on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.updatePolylines",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updatePolylinesByAdding:
                                                                 changing:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updatePolylinesByAdding:changing:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformPolyline *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<FGMPlatformPolyline *> *arg_toChange = GetNullableObjectAtIndex(args, 1);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api updatePolylinesByAdding:arg_toAdd
                            changing:arg_toChange
                            removing:arg_idsToRemove
                               error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of tile overlays on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.updateTileOverlays",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateTileOverlaysByAdding:
                                                                    changing:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updateTileOverlaysByAdding:changing:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformTileOverlay *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<FGMPlatformTileOverlay *> *arg_toChange = GetNullableObjectAtIndex(args, 1);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api updateTileOverlaysByAdding:arg_toAdd
                               changing:arg_toChange
                               removing:arg_idsToRemove
                                  error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the screen coordinate for the given map location.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.getScreenCoordinate",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(screenCoordinatesForLatLng:error:)],
          @"FGMMapsApi api (%@) doesn't respond to @selector(screenCoordinatesForLatLng:error:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        FGMPlatformLatLng *arg_latLng = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FGMPlatformPoint *output = [api screenCoordinatesForLatLng:arg_latLng error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the map location for the given screen coordinate.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:
               [NSString
                   stringWithFormat:@"%@%@",
                                    @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.getLatLng",
                                    messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(latLngForScreenCoordinate:error:)],
          @"FGMMapsApi api (%@) doesn't respond to @selector(latLngForScreenCoordinate:error:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        FGMPlatformPoint *arg_screenCoordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FGMPlatformLatLng *output = [api latLngForScreenCoordinate:arg_screenCoordinate
                                                             error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the map region currently displayed on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.getVisibleRegion",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(visibleMapRegion:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(visibleMapRegion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FGMPlatformLatLngBounds *output = [api visibleMapRegion:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Moves the camera according to [cameraUpdate] immediately, with no
  /// animation.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.moveCamera",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(moveCameraWithUpdate:error:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(moveCameraWithUpdate:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        FGMPlatformCameraUpdate *arg_cameraUpdate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api moveCameraWithUpdate:arg_cameraUpdate error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Moves the camera according to [cameraUpdate], animating the update.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.animateCamera",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(animateCameraWithUpdate:error:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(animateCameraWithUpdate:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        FGMPlatformCameraUpdate *arg_cameraUpdate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api animateCameraWithUpdate:arg_cameraUpdate error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the current map zoom level.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.getZoomLevel",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(currentZoomLevel:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(currentZoomLevel:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api currentZoomLevel:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Show the info window for the marker with the given ID.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.showInfoWindow",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(showInfoWindowForMarkerWithIdentifier:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(showInfoWindowForMarkerWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_markerId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api showInfoWindowForMarkerWithIdentifier:arg_markerId error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Hide the info window for the marker with the given ID.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.hideInfoWindow",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(hideInfoWindowForMarkerWithIdentifier:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(hideInfoWindowForMarkerWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_markerId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api hideInfoWindowForMarkerWithIdentifier:arg_markerId error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns true if the marker with the given ID is currently displaying its
  /// info window.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.isInfoWindowShown",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isShowingInfoWindowForMarkerWithIdentifier:
                                                                                       error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(isShowingInfoWindowForMarkerWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_markerId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSNumber *output = [api isShowingInfoWindowForMarkerWithIdentifier:arg_markerId
                                                                     error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the style to the given map style string, where an empty string
  /// indicates that the style should be cleared.
  ///
  /// If there was an error setting the style, such as an invalid style string,
  /// returns the error message.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:
               [NSString
                   stringWithFormat:@"%@%@",
                                    @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.setStyle",
                                    messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyle:error:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(setStyle:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_style = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSString *output = [api setStyle:arg_style error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the error string from the last attempt to set the map style, if
  /// any.
  ///
  /// This allows checking asynchronously for initial style failures, as there
  /// is no way to return failures from map initialization.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.getLastStyleError",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(lastStyleError:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(lastStyleError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSString *output = [api lastStyleError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Clears the cache of tiles previously requseted from the tile provider.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.clearTileCache",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(clearTileCacheForOverlayWithIdentifier:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(clearTileCacheForOverlayWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_tileOverlayId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api clearTileCacheForOverlayWithIdentifier:arg_tileOverlayId error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Takes a snapshot of the map and returns its image data.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.takeSnapshot",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(takeSnapshotWithError:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(takeSnapshotWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FlutterStandardTypedData *output = [api takeSnapshotWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FGMMapsCallbackApi ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@property(nonatomic, strong) NSString *messageChannelSuffix;
@end

@implementation FGMMapsCallbackApi

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  return [self initWithBinaryMessenger:binaryMessenger messageChannelSuffix:@""];
}
- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger
                   messageChannelSuffix:(nullable NSString *)messageChannelSuffix {
  self = [self init];
  if (self) {
    _binaryMessenger = binaryMessenger;
    _messageChannelSuffix = [messageChannelSuffix length] == 0
                                ? @""
                                : [NSString stringWithFormat:@".%@", messageChannelSuffix];
  }
  return self;
}
- (void)didStartCameraMoveWithCompletion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:
          @"%@%@",
          @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onCameraMoveStarted",
          _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:nil
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didMoveCameraToPosition:(FGMPlatformCameraPosition *)arg_cameraPosition
                     completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onCameraMove",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_cameraPosition ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didIdleCameraWithCompletion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onCameraIdle",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:nil
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapAtPosition:(FGMPlatformLatLng *)arg_position
              completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@", @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onTap",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_position ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didLongPressAtPosition:(FGMPlatformLatLng *)arg_position
                    completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onLongPress",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_position ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapMarkerWithIdentifier:(NSString *)arg_markerId
                        completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onMarkerTap",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_markerId ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didStartDragForMarkerWithIdentifier:(NSString *)arg_markerId
                                 atPosition:(FGMPlatformLatLng *)arg_position
                                 completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:
          @"%@%@", @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onMarkerDragStart",
          _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_markerId ?: [NSNull null], arg_position ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didDragMarkerWithIdentifier:(NSString *)arg_markerId
                         atPosition:(FGMPlatformLatLng *)arg_position
                         completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onMarkerDrag",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_markerId ?: [NSNull null], arg_position ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didEndDragForMarkerWithIdentifier:(NSString *)arg_markerId
                               atPosition:(FGMPlatformLatLng *)arg_position
                               completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:
          @"%@%@", @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onMarkerDragEnd",
          _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_markerId ?: [NSNull null], arg_position ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapInfoWindowOfMarkerWithIdentifier:(NSString *)arg_markerId
                                    completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:
          @"%@%@", @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onInfoWindowTap",
          _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_markerId ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapCircleWithIdentifier:(NSString *)arg_circleId
                        completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onCircleTap",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_circleId ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapCluster:(FGMPlatformCluster *)arg_cluster
           completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onClusterTap",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_cluster ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapPolygonWithIdentifier:(NSString *)arg_polygonId
                         completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onPolygonTap",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_polygonId ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapPolylineWithIdentifier:(NSString *)arg_polylineId
                          completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onPolylineTap",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_polylineId ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)tileWithOverlayIdentifier:(NSString *)arg_tileOverlayId
                         location:(FGMPlatformPoint *)arg_location
                             zoom:(NSInteger)arg_zoom
                       completion:(void (^)(FGMPlatformTile *_Nullable,
                                            FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:
          @"%@%@", @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.getTileOverlayTile",
          _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[
    arg_tileOverlayId ?: [NSNull null], arg_location ?: [NSNull null], @(arg_zoom)
  ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion(nil, [FlutterError errorWithCode:reply[0]
                                                           message:reply[1]
                                                           details:reply[2]]);
                     } else {
                       FGMPlatformTile *output = reply[0] == [NSNull null] ? nil : reply[0];
                       completion(output, nil);
                     }
                   } else {
                     completion(nil, createConnectionError(channelName));
                   }
                 }];
}
@end

void SetUpFGMMapsPlatformViewApi(id<FlutterBinaryMessenger> binaryMessenger,
                                 NSObject<FGMMapsPlatformViewApi> *api) {
  SetUpFGMMapsPlatformViewApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFGMMapsPlatformViewApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                           NSObject<FGMMapsPlatformViewApi> *api,
                                           NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsPlatformViewApi.createView",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(createViewType:error:)],
          @"FGMMapsPlatformViewApi api (%@) doesn't respond to @selector(createViewType:error:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        FGMPlatformMapViewCreationParams *arg_type = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api createViewType:arg_type error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
void SetUpFGMMapsInspectorApi(id<FlutterBinaryMessenger> binaryMessenger,
                              NSObject<FGMMapsInspectorApi> *api) {
  SetUpFGMMapsInspectorApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFGMMapsInspectorApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                        NSObject<FGMMapsInspectorApi> *api,
                                        NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.areBuildingsEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(areBuildingsEnabledWithError:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(areBuildingsEnabledWithError:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api areBuildingsEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.areRotateGesturesEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(areRotateGesturesEnabledWithError:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(areRotateGesturesEnabledWithError:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api areRotateGesturesEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.areScrollGesturesEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(areScrollGesturesEnabledWithError:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(areScrollGesturesEnabledWithError:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api areScrollGesturesEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.areTiltGesturesEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(areTiltGesturesEnabledWithError:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(areTiltGesturesEnabledWithError:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api areTiltGesturesEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.areZoomGesturesEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(areZoomGesturesEnabledWithError:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(areZoomGesturesEnabledWithError:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api areZoomGesturesEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.isCompassEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(isCompassEnabledWithError:)],
          @"FGMMapsInspectorApi api (%@) doesn't respond to @selector(isCompassEnabledWithError:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isCompassEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.isMyLocationButtonEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isMyLocationButtonEnabledWithError:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(isMyLocationButtonEnabledWithError:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isMyLocationButtonEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.isTrafficEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(isTrafficEnabledWithError:)],
          @"FGMMapsInspectorApi api (%@) doesn't respond to @selector(isTrafficEnabledWithError:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isTrafficEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.getTileOverlayInfo",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(tileOverlayWithIdentifier:error:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(tileOverlayWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_tileOverlayId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FGMPlatformTileLayer *output = [api tileOverlayWithIdentifier:arg_tileOverlayId
                                                                error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.getHeatmapInfo",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(heatmapWithIdentifier:error:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(heatmapWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_heatmapId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FGMPlatformHeatmap *output = [api heatmapWithIdentifier:arg_heatmapId error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.getZoomRange",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(zoomRange:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to @selector(zoomRange:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FGMPlatformZoomRange *output = [api zoomRange:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.getClusters",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(clustersWithIdentifier:error:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(clustersWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_clusterManagerId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSArray<FGMPlatformCluster *> *output = [api clustersWithIdentifier:arg_clusterManagerId
                                                                      error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
