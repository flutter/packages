// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.4.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import "messages.g.h"

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSArray<id> *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}

static FlutterError *createConnectionError(NSString *channelName) {
  return [FlutterError
      errorWithCode:@"channel-error"
            message:[NSString stringWithFormat:@"%@/%@/%@",
                                               @"Unable to establish connection on channel: '",
                                               channelName, @"'."]
            details:@""];
}

static id GetNullableObjectAtIndex(NSArray<id> *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

/// Pigeon equivalent of MapType
@implementation FGMPlatformMapTypeBox
- (instancetype)initWithValue:(FGMPlatformMapType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@interface FGMPlatformCameraPosition ()
+ (FGMPlatformCameraPosition *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraPosition *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCameraUpdate ()
+ (FGMPlatformCameraUpdate *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraUpdate *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCircle ()
+ (FGMPlatformCircle *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCircle *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformHeatmap ()
+ (FGMPlatformHeatmap *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformHeatmap *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCluster ()
+ (FGMPlatformCluster *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCluster *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformClusterManager ()
+ (FGMPlatformClusterManager *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformClusterManager *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformMarker ()
+ (FGMPlatformMarker *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformMarker *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformPolygon ()
+ (FGMPlatformPolygon *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformPolygon *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformPolyline ()
+ (FGMPlatformPolyline *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformPolyline *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformTile ()
+ (FGMPlatformTile *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformTile *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformTileOverlay ()
+ (FGMPlatformTileOverlay *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformTileOverlay *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformEdgeInsets ()
+ (FGMPlatformEdgeInsets *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformEdgeInsets *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformLatLng ()
+ (FGMPlatformLatLng *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformLatLng *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformLatLngBounds ()
+ (FGMPlatformLatLngBounds *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformLatLngBounds *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformCameraTargetBounds ()
+ (FGMPlatformCameraTargetBounds *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformCameraTargetBounds *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformMapViewCreationParams ()
+ (FGMPlatformMapViewCreationParams *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformMapViewCreationParams *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformMapConfiguration ()
+ (FGMPlatformMapConfiguration *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformMapConfiguration *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformPoint ()
+ (FGMPlatformPoint *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformPoint *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformTileLayer ()
+ (FGMPlatformTileLayer *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformTileLayer *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface FGMPlatformZoomRange ()
+ (FGMPlatformZoomRange *)fromList:(NSArray<id> *)list;
+ (nullable FGMPlatformZoomRange *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@implementation FGMPlatformCameraPosition
+ (instancetype)makeWithBearing:(double)bearing
                         target:(FGMPlatformLatLng *)target
                           tilt:(double)tilt
                           zoom:(double)zoom {
  FGMPlatformCameraPosition *pigeonResult = [[FGMPlatformCameraPosition alloc] init];
  pigeonResult.bearing = bearing;
  pigeonResult.target = target;
  pigeonResult.tilt = tilt;
  pigeonResult.zoom = zoom;
  return pigeonResult;
}
+ (FGMPlatformCameraPosition *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraPosition *pigeonResult = [[FGMPlatformCameraPosition alloc] init];
  pigeonResult.bearing = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.target = GetNullableObjectAtIndex(list, 1);
  pigeonResult.tilt = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.zoom = [GetNullableObjectAtIndex(list, 3) doubleValue];
  return pigeonResult;
}
+ (nullable FGMPlatformCameraPosition *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraPosition fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.bearing),
    self.target ?: [NSNull null],
    @(self.tilt),
    @(self.zoom),
  ];
}
@end

@implementation FGMPlatformCameraUpdate
+ (instancetype)makeWithJson:(id)json {
  FGMPlatformCameraUpdate *pigeonResult = [[FGMPlatformCameraUpdate alloc] init];
  pigeonResult.json = json;
  return pigeonResult;
}
+ (FGMPlatformCameraUpdate *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraUpdate *pigeonResult = [[FGMPlatformCameraUpdate alloc] init];
  pigeonResult.json = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformCameraUpdate *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraUpdate fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.json ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformCircle
+ (instancetype)makeWithJson:(id)json {
  FGMPlatformCircle *pigeonResult = [[FGMPlatformCircle alloc] init];
  pigeonResult.json = json;
  return pigeonResult;
}
+ (FGMPlatformCircle *)fromList:(NSArray<id> *)list {
  FGMPlatformCircle *pigeonResult = [[FGMPlatformCircle alloc] init];
  pigeonResult.json = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformCircle *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCircle fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.json ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformHeatmap
+ (instancetype)makeWithJson:(id)json {
  FGMPlatformHeatmap *pigeonResult = [[FGMPlatformHeatmap alloc] init];
  pigeonResult.json = json;
  return pigeonResult;
}
+ (FGMPlatformHeatmap *)fromList:(NSArray<id> *)list {
  FGMPlatformHeatmap *pigeonResult = [[FGMPlatformHeatmap alloc] init];
  pigeonResult.json = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformHeatmap *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformHeatmap fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.json ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformCluster
+ (instancetype)makeWithClusterManagerId:(NSString *)clusterManagerId
                                position:(FGMPlatformLatLng *)position
                                  bounds:(FGMPlatformLatLngBounds *)bounds
                               markerIds:(NSArray<NSString *> *)markerIds {
  FGMPlatformCluster *pigeonResult = [[FGMPlatformCluster alloc] init];
  pigeonResult.clusterManagerId = clusterManagerId;
  pigeonResult.position = position;
  pigeonResult.bounds = bounds;
  pigeonResult.markerIds = markerIds;
  return pigeonResult;
}
+ (FGMPlatformCluster *)fromList:(NSArray<id> *)list {
  FGMPlatformCluster *pigeonResult = [[FGMPlatformCluster alloc] init];
  pigeonResult.clusterManagerId = GetNullableObjectAtIndex(list, 0);
  pigeonResult.position = GetNullableObjectAtIndex(list, 1);
  pigeonResult.bounds = GetNullableObjectAtIndex(list, 2);
  pigeonResult.markerIds = GetNullableObjectAtIndex(list, 3);
  return pigeonResult;
}
+ (nullable FGMPlatformCluster *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCluster fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.clusterManagerId ?: [NSNull null],
    self.position ?: [NSNull null],
    self.bounds ?: [NSNull null],
    self.markerIds ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformClusterManager
+ (instancetype)makeWithIdentifier:(NSString *)identifier {
  FGMPlatformClusterManager *pigeonResult = [[FGMPlatformClusterManager alloc] init];
  pigeonResult.identifier = identifier;
  return pigeonResult;
}
+ (FGMPlatformClusterManager *)fromList:(NSArray<id> *)list {
  FGMPlatformClusterManager *pigeonResult = [[FGMPlatformClusterManager alloc] init];
  pigeonResult.identifier = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformClusterManager *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformClusterManager fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.identifier ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformMarker
+ (instancetype)makeWithJson:(id)json {
  FGMPlatformMarker *pigeonResult = [[FGMPlatformMarker alloc] init];
  pigeonResult.json = json;
  return pigeonResult;
}
+ (FGMPlatformMarker *)fromList:(NSArray<id> *)list {
  FGMPlatformMarker *pigeonResult = [[FGMPlatformMarker alloc] init];
  pigeonResult.json = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformMarker *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformMarker fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.json ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformPolygon
+ (instancetype)makeWithJson:(id)json {
  FGMPlatformPolygon *pigeonResult = [[FGMPlatformPolygon alloc] init];
  pigeonResult.json = json;
  return pigeonResult;
}
+ (FGMPlatformPolygon *)fromList:(NSArray<id> *)list {
  FGMPlatformPolygon *pigeonResult = [[FGMPlatformPolygon alloc] init];
  pigeonResult.json = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformPolygon *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformPolygon fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.json ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformPolyline
+ (instancetype)makeWithJson:(id)json {
  FGMPlatformPolyline *pigeonResult = [[FGMPlatformPolyline alloc] init];
  pigeonResult.json = json;
  return pigeonResult;
}
+ (FGMPlatformPolyline *)fromList:(NSArray<id> *)list {
  FGMPlatformPolyline *pigeonResult = [[FGMPlatformPolyline alloc] init];
  pigeonResult.json = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformPolyline *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformPolyline fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.json ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformTile
+ (instancetype)makeWithWidth:(NSInteger)width
                       height:(NSInteger)height
                         data:(nullable FlutterStandardTypedData *)data {
  FGMPlatformTile *pigeonResult = [[FGMPlatformTile alloc] init];
  pigeonResult.width = width;
  pigeonResult.height = height;
  pigeonResult.data = data;
  return pigeonResult;
}
+ (FGMPlatformTile *)fromList:(NSArray<id> *)list {
  FGMPlatformTile *pigeonResult = [[FGMPlatformTile alloc] init];
  pigeonResult.width = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.height = [GetNullableObjectAtIndex(list, 1) integerValue];
  pigeonResult.data = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable FGMPlatformTile *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformTile fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.width),
    @(self.height),
    self.data ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformTileOverlay
+ (instancetype)makeWithJson:(id)json {
  FGMPlatformTileOverlay *pigeonResult = [[FGMPlatformTileOverlay alloc] init];
  pigeonResult.json = json;
  return pigeonResult;
}
+ (FGMPlatformTileOverlay *)fromList:(NSArray<id> *)list {
  FGMPlatformTileOverlay *pigeonResult = [[FGMPlatformTileOverlay alloc] init];
  pigeonResult.json = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformTileOverlay *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformTileOverlay fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.json ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformEdgeInsets
+ (instancetype)makeWithTop:(double)top
                     bottom:(double)bottom
                       left:(double)left
                      right:(double)right {
  FGMPlatformEdgeInsets *pigeonResult = [[FGMPlatformEdgeInsets alloc] init];
  pigeonResult.top = top;
  pigeonResult.bottom = bottom;
  pigeonResult.left = left;
  pigeonResult.right = right;
  return pigeonResult;
}
+ (FGMPlatformEdgeInsets *)fromList:(NSArray<id> *)list {
  FGMPlatformEdgeInsets *pigeonResult = [[FGMPlatformEdgeInsets alloc] init];
  pigeonResult.top = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.bottom = [GetNullableObjectAtIndex(list, 1) doubleValue];
  pigeonResult.left = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.right = [GetNullableObjectAtIndex(list, 3) doubleValue];
  return pigeonResult;
}
+ (nullable FGMPlatformEdgeInsets *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformEdgeInsets fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.top),
    @(self.bottom),
    @(self.left),
    @(self.right),
  ];
}
@end

@implementation FGMPlatformLatLng
+ (instancetype)makeWithLatitude:(double)latitude longitude:(double)longitude {
  FGMPlatformLatLng *pigeonResult = [[FGMPlatformLatLng alloc] init];
  pigeonResult.latitude = latitude;
  pigeonResult.longitude = longitude;
  return pigeonResult;
}
+ (FGMPlatformLatLng *)fromList:(NSArray<id> *)list {
  FGMPlatformLatLng *pigeonResult = [[FGMPlatformLatLng alloc] init];
  pigeonResult.latitude = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.longitude = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FGMPlatformLatLng *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformLatLng fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.latitude),
    @(self.longitude),
  ];
}
@end

@implementation FGMPlatformLatLngBounds
+ (instancetype)makeWithNortheast:(FGMPlatformLatLng *)northeast
                        southwest:(FGMPlatformLatLng *)southwest {
  FGMPlatformLatLngBounds *pigeonResult = [[FGMPlatformLatLngBounds alloc] init];
  pigeonResult.northeast = northeast;
  pigeonResult.southwest = southwest;
  return pigeonResult;
}
+ (FGMPlatformLatLngBounds *)fromList:(NSArray<id> *)list {
  FGMPlatformLatLngBounds *pigeonResult = [[FGMPlatformLatLngBounds alloc] init];
  pigeonResult.northeast = GetNullableObjectAtIndex(list, 0);
  pigeonResult.southwest = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FGMPlatformLatLngBounds *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformLatLngBounds fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.northeast ?: [NSNull null],
    self.southwest ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformCameraTargetBounds
+ (instancetype)makeWithBounds:(nullable FGMPlatformLatLngBounds *)bounds {
  FGMPlatformCameraTargetBounds *pigeonResult = [[FGMPlatformCameraTargetBounds alloc] init];
  pigeonResult.bounds = bounds;
  return pigeonResult;
}
+ (FGMPlatformCameraTargetBounds *)fromList:(NSArray<id> *)list {
  FGMPlatformCameraTargetBounds *pigeonResult = [[FGMPlatformCameraTargetBounds alloc] init];
  pigeonResult.bounds = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable FGMPlatformCameraTargetBounds *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformCameraTargetBounds fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.bounds ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformMapViewCreationParams
+ (instancetype)
    makeWithInitialCameraPosition:(FGMPlatformCameraPosition *)initialCameraPosition
                 mapConfiguration:(FGMPlatformMapConfiguration *)mapConfiguration
                   initialCircles:(NSArray<FGMPlatformCircle *> *)initialCircles
                   initialMarkers:(NSArray<FGMPlatformMarker *> *)initialMarkers
                  initialPolygons:(NSArray<FGMPlatformPolygon *> *)initialPolygons
                 initialPolylines:(NSArray<FGMPlatformPolyline *> *)initialPolylines
                  initialHeatmaps:(NSArray<FGMPlatformHeatmap *> *)initialHeatmaps
              initialTileOverlays:(NSArray<FGMPlatformTileOverlay *> *)initialTileOverlays
           initialClusterManagers:(NSArray<FGMPlatformClusterManager *> *)initialClusterManagers {
  FGMPlatformMapViewCreationParams *pigeonResult = [[FGMPlatformMapViewCreationParams alloc] init];
  pigeonResult.initialCameraPosition = initialCameraPosition;
  pigeonResult.mapConfiguration = mapConfiguration;
  pigeonResult.initialCircles = initialCircles;
  pigeonResult.initialMarkers = initialMarkers;
  pigeonResult.initialPolygons = initialPolygons;
  pigeonResult.initialPolylines = initialPolylines;
  pigeonResult.initialHeatmaps = initialHeatmaps;
  pigeonResult.initialTileOverlays = initialTileOverlays;
  pigeonResult.initialClusterManagers = initialClusterManagers;
  return pigeonResult;
}
+ (FGMPlatformMapViewCreationParams *)fromList:(NSArray<id> *)list {
  FGMPlatformMapViewCreationParams *pigeonResult = [[FGMPlatformMapViewCreationParams alloc] init];
  pigeonResult.initialCameraPosition = GetNullableObjectAtIndex(list, 0);
  pigeonResult.mapConfiguration = GetNullableObjectAtIndex(list, 1);
  pigeonResult.initialCircles = GetNullableObjectAtIndex(list, 2);
  pigeonResult.initialMarkers = GetNullableObjectAtIndex(list, 3);
  pigeonResult.initialPolygons = GetNullableObjectAtIndex(list, 4);
  pigeonResult.initialPolylines = GetNullableObjectAtIndex(list, 5);
  pigeonResult.initialHeatmaps = GetNullableObjectAtIndex(list, 6);
  pigeonResult.initialTileOverlays = GetNullableObjectAtIndex(list, 7);
  pigeonResult.initialClusterManagers = GetNullableObjectAtIndex(list, 8);
  return pigeonResult;
}
+ (nullable FGMPlatformMapViewCreationParams *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformMapViewCreationParams fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.initialCameraPosition ?: [NSNull null],
    self.mapConfiguration ?: [NSNull null],
    self.initialCircles ?: [NSNull null],
    self.initialMarkers ?: [NSNull null],
    self.initialPolygons ?: [NSNull null],
    self.initialPolylines ?: [NSNull null],
    self.initialHeatmaps ?: [NSNull null],
    self.initialTileOverlays ?: [NSNull null],
    self.initialClusterManagers ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformMapConfiguration
+ (instancetype)makeWithCompassEnabled:(nullable NSNumber *)compassEnabled
                    cameraTargetBounds:(nullable FGMPlatformCameraTargetBounds *)cameraTargetBounds
                               mapType:(nullable FGMPlatformMapTypeBox *)mapType
                  minMaxZoomPreference:(nullable FGMPlatformZoomRange *)minMaxZoomPreference
                 rotateGesturesEnabled:(nullable NSNumber *)rotateGesturesEnabled
                 scrollGesturesEnabled:(nullable NSNumber *)scrollGesturesEnabled
                   tiltGesturesEnabled:(nullable NSNumber *)tiltGesturesEnabled
                   trackCameraPosition:(nullable NSNumber *)trackCameraPosition
                   zoomGesturesEnabled:(nullable NSNumber *)zoomGesturesEnabled
                     myLocationEnabled:(nullable NSNumber *)myLocationEnabled
               myLocationButtonEnabled:(nullable NSNumber *)myLocationButtonEnabled
                               padding:(nullable FGMPlatformEdgeInsets *)padding
                     indoorViewEnabled:(nullable NSNumber *)indoorViewEnabled
                        trafficEnabled:(nullable NSNumber *)trafficEnabled
                      buildingsEnabled:(nullable NSNumber *)buildingsEnabled
                            cloudMapId:(nullable NSString *)cloudMapId
                                 style:(nullable NSString *)style {
  FGMPlatformMapConfiguration *pigeonResult = [[FGMPlatformMapConfiguration alloc] init];
  pigeonResult.compassEnabled = compassEnabled;
  pigeonResult.cameraTargetBounds = cameraTargetBounds;
  pigeonResult.mapType = mapType;
  pigeonResult.minMaxZoomPreference = minMaxZoomPreference;
  pigeonResult.rotateGesturesEnabled = rotateGesturesEnabled;
  pigeonResult.scrollGesturesEnabled = scrollGesturesEnabled;
  pigeonResult.tiltGesturesEnabled = tiltGesturesEnabled;
  pigeonResult.trackCameraPosition = trackCameraPosition;
  pigeonResult.zoomGesturesEnabled = zoomGesturesEnabled;
  pigeonResult.myLocationEnabled = myLocationEnabled;
  pigeonResult.myLocationButtonEnabled = myLocationButtonEnabled;
  pigeonResult.padding = padding;
  pigeonResult.indoorViewEnabled = indoorViewEnabled;
  pigeonResult.trafficEnabled = trafficEnabled;
  pigeonResult.buildingsEnabled = buildingsEnabled;
  pigeonResult.cloudMapId = cloudMapId;
  pigeonResult.style = style;
  return pigeonResult;
}
+ (FGMPlatformMapConfiguration *)fromList:(NSArray<id> *)list {
  FGMPlatformMapConfiguration *pigeonResult = [[FGMPlatformMapConfiguration alloc] init];
  pigeonResult.compassEnabled = GetNullableObjectAtIndex(list, 0);
  pigeonResult.cameraTargetBounds = GetNullableObjectAtIndex(list, 1);
  pigeonResult.mapType = GetNullableObjectAtIndex(list, 2);
  pigeonResult.minMaxZoomPreference = GetNullableObjectAtIndex(list, 3);
  pigeonResult.rotateGesturesEnabled = GetNullableObjectAtIndex(list, 4);
  pigeonResult.scrollGesturesEnabled = GetNullableObjectAtIndex(list, 5);
  pigeonResult.tiltGesturesEnabled = GetNullableObjectAtIndex(list, 6);
  pigeonResult.trackCameraPosition = GetNullableObjectAtIndex(list, 7);
  pigeonResult.zoomGesturesEnabled = GetNullableObjectAtIndex(list, 8);
  pigeonResult.myLocationEnabled = GetNullableObjectAtIndex(list, 9);
  pigeonResult.myLocationButtonEnabled = GetNullableObjectAtIndex(list, 10);
  pigeonResult.padding = GetNullableObjectAtIndex(list, 11);
  pigeonResult.indoorViewEnabled = GetNullableObjectAtIndex(list, 12);
  pigeonResult.trafficEnabled = GetNullableObjectAtIndex(list, 13);
  pigeonResult.buildingsEnabled = GetNullableObjectAtIndex(list, 14);
  pigeonResult.cloudMapId = GetNullableObjectAtIndex(list, 15);
  pigeonResult.style = GetNullableObjectAtIndex(list, 16);
  return pigeonResult;
}
+ (nullable FGMPlatformMapConfiguration *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformMapConfiguration fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.compassEnabled ?: [NSNull null],
    self.cameraTargetBounds ?: [NSNull null],
    self.mapType ?: [NSNull null],
    self.minMaxZoomPreference ?: [NSNull null],
    self.rotateGesturesEnabled ?: [NSNull null],
    self.scrollGesturesEnabled ?: [NSNull null],
    self.tiltGesturesEnabled ?: [NSNull null],
    self.trackCameraPosition ?: [NSNull null],
    self.zoomGesturesEnabled ?: [NSNull null],
    self.myLocationEnabled ?: [NSNull null],
    self.myLocationButtonEnabled ?: [NSNull null],
    self.padding ?: [NSNull null],
    self.indoorViewEnabled ?: [NSNull null],
    self.trafficEnabled ?: [NSNull null],
    self.buildingsEnabled ?: [NSNull null],
    self.cloudMapId ?: [NSNull null],
    self.style ?: [NSNull null],
  ];
}
@end

@implementation FGMPlatformPoint
+ (instancetype)makeWithX:(double)x y:(double)y {
  FGMPlatformPoint *pigeonResult = [[FGMPlatformPoint alloc] init];
  pigeonResult.x = x;
  pigeonResult.y = y;
  return pigeonResult;
}
+ (FGMPlatformPoint *)fromList:(NSArray<id> *)list {
  FGMPlatformPoint *pigeonResult = [[FGMPlatformPoint alloc] init];
  pigeonResult.x = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.y = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FGMPlatformPoint *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformPoint fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.x),
    @(self.y),
  ];
}
@end

@implementation FGMPlatformTileLayer
+ (instancetype)makeWithVisible:(BOOL)visible
                         fadeIn:(BOOL)fadeIn
                        opacity:(double)opacity
                         zIndex:(NSInteger)zIndex {
  FGMPlatformTileLayer *pigeonResult = [[FGMPlatformTileLayer alloc] init];
  pigeonResult.visible = visible;
  pigeonResult.fadeIn = fadeIn;
  pigeonResult.opacity = opacity;
  pigeonResult.zIndex = zIndex;
  return pigeonResult;
}
+ (FGMPlatformTileLayer *)fromList:(NSArray<id> *)list {
  FGMPlatformTileLayer *pigeonResult = [[FGMPlatformTileLayer alloc] init];
  pigeonResult.visible = [GetNullableObjectAtIndex(list, 0) boolValue];
  pigeonResult.fadeIn = [GetNullableObjectAtIndex(list, 1) boolValue];
  pigeonResult.opacity = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.zIndex = [GetNullableObjectAtIndex(list, 3) integerValue];
  return pigeonResult;
}
+ (nullable FGMPlatformTileLayer *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformTileLayer fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.visible),
    @(self.fadeIn),
    @(self.opacity),
    @(self.zIndex),
  ];
}
@end

@implementation FGMPlatformZoomRange
+ (instancetype)makeWithMin:(nullable NSNumber *)min max:(nullable NSNumber *)max {
  FGMPlatformZoomRange *pigeonResult = [[FGMPlatformZoomRange alloc] init];
  pigeonResult.min = min;
  pigeonResult.max = max;
  return pigeonResult;
}
+ (FGMPlatformZoomRange *)fromList:(NSArray<id> *)list {
  FGMPlatformZoomRange *pigeonResult = [[FGMPlatformZoomRange alloc] init];
  pigeonResult.min = GetNullableObjectAtIndex(list, 0);
  pigeonResult.max = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FGMPlatformZoomRange *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [FGMPlatformZoomRange fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.min ?: [NSNull null],
    self.max ?: [NSNull null],
  ];
}
@end

@interface FGMMessagesPigeonCodecReader : FlutterStandardReader
@end
@implementation FGMMessagesPigeonCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 129: {
      NSNumber *enumAsNumber = [self readValue];
      return enumAsNumber == nil
                 ? nil
                 : [[FGMPlatformMapTypeBox alloc] initWithValue:[enumAsNumber integerValue]];
    }
    case 130:
      return [FGMPlatformCameraPosition fromList:[self readValue]];
    case 131:
      return [FGMPlatformCameraUpdate fromList:[self readValue]];
    case 132:
      return [FGMPlatformCircle fromList:[self readValue]];
    case 133:
      return [FGMPlatformHeatmap fromList:[self readValue]];
    case 134:
      return [FGMPlatformCluster fromList:[self readValue]];
    case 135:
      return [FGMPlatformClusterManager fromList:[self readValue]];
    case 136:
      return [FGMPlatformMarker fromList:[self readValue]];
    case 137:
      return [FGMPlatformPolygon fromList:[self readValue]];
    case 138:
      return [FGMPlatformPolyline fromList:[self readValue]];
    case 139:
      return [FGMPlatformTile fromList:[self readValue]];
    case 140:
      return [FGMPlatformTileOverlay fromList:[self readValue]];
    case 141:
      return [FGMPlatformEdgeInsets fromList:[self readValue]];
    case 142:
      return [FGMPlatformLatLng fromList:[self readValue]];
    case 143:
      return [FGMPlatformLatLngBounds fromList:[self readValue]];
    case 144:
      return [FGMPlatformCameraTargetBounds fromList:[self readValue]];
    case 145:
      return [FGMPlatformMapViewCreationParams fromList:[self readValue]];
    case 146:
      return [FGMPlatformMapConfiguration fromList:[self readValue]];
    case 147:
      return [FGMPlatformPoint fromList:[self readValue]];
    case 148:
      return [FGMPlatformTileLayer fromList:[self readValue]];
    case 149:
      return [FGMPlatformZoomRange fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FGMMessagesPigeonCodecWriter : FlutterStandardWriter
@end
@implementation FGMMessagesPigeonCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FGMPlatformMapTypeBox class]]) {
    FGMPlatformMapTypeBox *box = (FGMPlatformMapTypeBox *)value;
    [self writeByte:129];
    [self writeValue:(value == nil ? [NSNull null] : [NSNumber numberWithInteger:box.value])];
  } else if ([value isKindOfClass:[FGMPlatformCameraPosition class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCameraUpdate class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCircle class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformHeatmap class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCluster class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformClusterManager class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformMarker class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformPolygon class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformPolyline class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformTile class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformTileOverlay class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformEdgeInsets class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformLatLng class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformLatLngBounds class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformCameraTargetBounds class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformMapViewCreationParams class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformMapConfiguration class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformPoint class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformTileLayer class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FGMPlatformZoomRange class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FGMMessagesPigeonCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FGMMessagesPigeonCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FGMMessagesPigeonCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FGMMessagesPigeonCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FGMGetMessagesCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FGMMessagesPigeonCodecReaderWriter *readerWriter =
        [[FGMMessagesPigeonCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}
void SetUpFGMMapsApi(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FGMMapsApi> *api) {
  SetUpFGMMapsApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFGMMapsApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                               NSObject<FGMMapsApi> *api, NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  /// Returns once the map instance is available.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.waitForMap",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(waitForMapWithError:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(waitForMapWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api waitForMapWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the map's configuration options.
  ///
  /// Only non-null configuration values will result in updates; options with
  /// null values will remain unchanged.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.updateMapConfiguration",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(updateWithMapConfiguration:error:)],
          @"FGMMapsApi api (%@) doesn't respond to @selector(updateWithMapConfiguration:error:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        FGMPlatformMapConfiguration *arg_configuration = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api updateWithMapConfiguration:arg_configuration error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of circles on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.updateCircles",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateCirclesByAdding:changing:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updateCirclesByAdding:changing:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformCircle *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<FGMPlatformCircle *> *arg_toChange = GetNullableObjectAtIndex(args, 1);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api updateCirclesByAdding:arg_toAdd
                          changing:arg_toChange
                          removing:arg_idsToRemove
                             error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of heatmaps on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.updateHeatmaps",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateHeatmapsByAdding:changing:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updateHeatmapsByAdding:changing:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformHeatmap *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<FGMPlatformHeatmap *> *arg_toChange = GetNullableObjectAtIndex(args, 1);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api updateHeatmapsByAdding:arg_toAdd
                           changing:arg_toChange
                           removing:arg_idsToRemove
                              error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of custer managers for clusters on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.updateClusterManagers",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateClusterManagersByAdding:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updateClusterManagersByAdding:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformClusterManager *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api updateClusterManagersByAdding:arg_toAdd removing:arg_idsToRemove error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of markers on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.updateMarkers",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateMarkersByAdding:changing:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updateMarkersByAdding:changing:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformMarker *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<FGMPlatformMarker *> *arg_toChange = GetNullableObjectAtIndex(args, 1);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api updateMarkersByAdding:arg_toAdd
                          changing:arg_toChange
                          removing:arg_idsToRemove
                             error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of polygonss on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.updatePolygons",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updatePolygonsByAdding:changing:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updatePolygonsByAdding:changing:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformPolygon *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<FGMPlatformPolygon *> *arg_toChange = GetNullableObjectAtIndex(args, 1);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api updatePolygonsByAdding:arg_toAdd
                           changing:arg_toChange
                           removing:arg_idsToRemove
                              error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of polylines on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.updatePolylines",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updatePolylinesByAdding:
                                                                 changing:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updatePolylinesByAdding:changing:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformPolyline *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<FGMPlatformPolyline *> *arg_toChange = GetNullableObjectAtIndex(args, 1);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api updatePolylinesByAdding:arg_toAdd
                            changing:arg_toChange
                            removing:arg_idsToRemove
                               error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the set of tile overlays on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.updateTileOverlays",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateTileOverlaysByAdding:
                                                                    changing:removing:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(updateTileOverlaysByAdding:changing:removing:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSArray<FGMPlatformTileOverlay *> *arg_toAdd = GetNullableObjectAtIndex(args, 0);
        NSArray<FGMPlatformTileOverlay *> *arg_toChange = GetNullableObjectAtIndex(args, 1);
        NSArray<NSString *> *arg_idsToRemove = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api updateTileOverlaysByAdding:arg_toAdd
                               changing:arg_toChange
                               removing:arg_idsToRemove
                                  error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the screen coordinate for the given map location.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.getScreenCoordinate",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(screenCoordinatesForLatLng:error:)],
          @"FGMMapsApi api (%@) doesn't respond to @selector(screenCoordinatesForLatLng:error:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        FGMPlatformLatLng *arg_latLng = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FGMPlatformPoint *output = [api screenCoordinatesForLatLng:arg_latLng error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the map location for the given screen coordinate.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:
               [NSString
                   stringWithFormat:@"%@%@",
                                    @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.getLatLng",
                                    messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(latLngForScreenCoordinate:error:)],
          @"FGMMapsApi api (%@) doesn't respond to @selector(latLngForScreenCoordinate:error:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        FGMPlatformPoint *arg_screenCoordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FGMPlatformLatLng *output = [api latLngForScreenCoordinate:arg_screenCoordinate
                                                             error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the map region currently displayed on the map.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.getVisibleRegion",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(visibleMapRegion:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(visibleMapRegion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FGMPlatformLatLngBounds *output = [api visibleMapRegion:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Moves the camera according to [cameraUpdate] immediately, with no
  /// animation.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.moveCamera",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(moveCameraWithUpdate:error:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(moveCameraWithUpdate:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        FGMPlatformCameraUpdate *arg_cameraUpdate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api moveCameraWithUpdate:arg_cameraUpdate error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Moves the camera according to [cameraUpdate], animating the update.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.animateCamera",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(animateCameraWithUpdate:error:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(animateCameraWithUpdate:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        FGMPlatformCameraUpdate *arg_cameraUpdate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api animateCameraWithUpdate:arg_cameraUpdate error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the current map zoom level.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.getZoomLevel",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(currentZoomLevel:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(currentZoomLevel:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api currentZoomLevel:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Show the info window for the marker with the given ID.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.showInfoWindow",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(showInfoWindowForMarkerWithIdentifier:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(showInfoWindowForMarkerWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_markerId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api showInfoWindowForMarkerWithIdentifier:arg_markerId error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Hide the info window for the marker with the given ID.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.hideInfoWindow",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(hideInfoWindowForMarkerWithIdentifier:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(hideInfoWindowForMarkerWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_markerId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api hideInfoWindowForMarkerWithIdentifier:arg_markerId error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns true if the marker with the given ID is currently displaying its
  /// info window.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.isInfoWindowShown",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isShowingInfoWindowForMarkerWithIdentifier:
                                                                                       error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(isShowingInfoWindowForMarkerWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_markerId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSNumber *output = [api isShowingInfoWindowForMarkerWithIdentifier:arg_markerId
                                                                     error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the style to the given map style string, where an empty string
  /// indicates that the style should be cleared.
  ///
  /// If there was an error setting the style, such as an invalid style string,
  /// returns the error message.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:
               [NSString
                   stringWithFormat:@"%@%@",
                                    @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.setStyle",
                                    messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyle:error:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(setStyle:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_style = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSString *output = [api setStyle:arg_style error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the error string from the last attempt to set the map style, if
  /// any.
  ///
  /// This allows checking asynchronously for initial style failures, as there
  /// is no way to return failures from map initialization.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.getLastStyleError",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(lastStyleError:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(lastStyleError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSString *output = [api lastStyleError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Clears the cache of tiles previously requseted from the tile provider.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsApi.clearTileCache",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(clearTileCacheForOverlayWithIdentifier:error:)],
                @"FGMMapsApi api (%@) doesn't respond to "
                @"@selector(clearTileCacheForOverlayWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_tileOverlayId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api clearTileCacheForOverlayWithIdentifier:arg_tileOverlayId error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Takes a snapshot of the map and returns its image data.
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString
                            stringWithFormat:
                                @"%@%@",
                                @"dev.flutter.pigeon.google_maps_flutter_ios.MapsApi.takeSnapshot",
                                messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(takeSnapshotWithError:)],
                @"FGMMapsApi api (%@) doesn't respond to @selector(takeSnapshotWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FlutterStandardTypedData *output = [api takeSnapshotWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FGMMapsCallbackApi ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@property(nonatomic, strong) NSString *messageChannelSuffix;
@end

@implementation FGMMapsCallbackApi

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  return [self initWithBinaryMessenger:binaryMessenger messageChannelSuffix:@""];
}
- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger
                   messageChannelSuffix:(nullable NSString *)messageChannelSuffix {
  self = [self init];
  if (self) {
    _binaryMessenger = binaryMessenger;
    _messageChannelSuffix = [messageChannelSuffix length] == 0
                                ? @""
                                : [NSString stringWithFormat:@".%@", messageChannelSuffix];
  }
  return self;
}
- (void)didStartCameraMoveWithCompletion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:
          @"%@%@",
          @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onCameraMoveStarted",
          _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:nil
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didMoveCameraToPosition:(FGMPlatformCameraPosition *)arg_cameraPosition
                     completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onCameraMove",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_cameraPosition ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didIdleCameraWithCompletion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onCameraIdle",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:nil
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapAtPosition:(FGMPlatformLatLng *)arg_position
              completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@", @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onTap",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_position ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didLongPressAtPosition:(FGMPlatformLatLng *)arg_position
                    completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onLongPress",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_position ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapMarkerWithIdentifier:(NSString *)arg_markerId
                        completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onMarkerTap",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_markerId ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didStartDragForMarkerWithIdentifier:(NSString *)arg_markerId
                                 atPosition:(FGMPlatformLatLng *)arg_position
                                 completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:
          @"%@%@", @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onMarkerDragStart",
          _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_markerId ?: [NSNull null], arg_position ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didDragMarkerWithIdentifier:(NSString *)arg_markerId
                         atPosition:(FGMPlatformLatLng *)arg_position
                         completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onMarkerDrag",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_markerId ?: [NSNull null], arg_position ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didEndDragForMarkerWithIdentifier:(NSString *)arg_markerId
                               atPosition:(FGMPlatformLatLng *)arg_position
                               completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:
          @"%@%@", @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onMarkerDragEnd",
          _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_markerId ?: [NSNull null], arg_position ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapInfoWindowOfMarkerWithIdentifier:(NSString *)arg_markerId
                                    completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:
          @"%@%@", @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onInfoWindowTap",
          _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_markerId ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapCircleWithIdentifier:(NSString *)arg_circleId
                        completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onCircleTap",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_circleId ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapCluster:(FGMPlatformCluster *)arg_cluster
           completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onClusterTap",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_cluster ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapPolygonWithIdentifier:(NSString *)arg_polygonId
                         completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onPolygonTap",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_polygonId ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)didTapPolylineWithIdentifier:(NSString *)arg_polylineId
                          completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:@"%@%@",
                       @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.onPolylineTap",
                       _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[ arg_polylineId ?: [NSNull null] ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion([FlutterError errorWithCode:reply[0]
                                                      message:reply[1]
                                                      details:reply[2]]);
                     } else {
                       completion(nil);
                     }
                   } else {
                     completion(createConnectionError(channelName));
                   }
                 }];
}
- (void)tileWithOverlayIdentifier:(NSString *)arg_tileOverlayId
                         location:(FGMPlatformPoint *)arg_location
                             zoom:(NSInteger)arg_zoom
                       completion:(void (^)(FGMPlatformTile *_Nullable,
                                            FlutterError *_Nullable))completion {
  NSString *channelName = [NSString
      stringWithFormat:
          @"%@%@", @"dev.flutter.pigeon.google_maps_flutter_ios.MapsCallbackApi.getTileOverlayTile",
          _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel messageChannelWithName:channelName
                                         binaryMessenger:self.binaryMessenger
                                                   codec:FGMGetMessagesCodec()];
  [channel sendMessage:@[
    arg_tileOverlayId ?: [NSNull null], arg_location ?: [NSNull null], @(arg_zoom)
  ]
                 reply:^(NSArray<id> *reply) {
                   if (reply != nil) {
                     if (reply.count > 1) {
                       completion(nil, [FlutterError errorWithCode:reply[0]
                                                           message:reply[1]
                                                           details:reply[2]]);
                     } else {
                       FGMPlatformTile *output = reply[0] == [NSNull null] ? nil : reply[0];
                       completion(output, nil);
                     }
                   } else {
                     completion(nil, createConnectionError(channelName));
                   }
                 }];
}
@end

void SetUpFGMMapsPlatformViewApi(id<FlutterBinaryMessenger> binaryMessenger,
                                 NSObject<FGMMapsPlatformViewApi> *api) {
  SetUpFGMMapsPlatformViewApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFGMMapsPlatformViewApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                           NSObject<FGMMapsPlatformViewApi> *api,
                                           NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsPlatformViewApi.createView",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(createViewType:error:)],
          @"FGMMapsPlatformViewApi api (%@) doesn't respond to @selector(createViewType:error:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        FGMPlatformMapViewCreationParams *arg_type = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api createViewType:arg_type error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
void SetUpFGMMapsInspectorApi(id<FlutterBinaryMessenger> binaryMessenger,
                              NSObject<FGMMapsInspectorApi> *api) {
  SetUpFGMMapsInspectorApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpFGMMapsInspectorApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger,
                                        NSObject<FGMMapsInspectorApi> *api,
                                        NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0
                             ? [NSString stringWithFormat:@".%@", messageChannelSuffix]
                             : @"";
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.areBuildingsEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(areBuildingsEnabledWithError:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(areBuildingsEnabledWithError:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api areBuildingsEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.areRotateGesturesEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(areRotateGesturesEnabledWithError:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(areRotateGesturesEnabledWithError:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api areRotateGesturesEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.areScrollGesturesEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(areScrollGesturesEnabledWithError:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(areScrollGesturesEnabledWithError:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api areScrollGesturesEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.areTiltGesturesEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(areTiltGesturesEnabledWithError:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(areTiltGesturesEnabledWithError:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api areTiltGesturesEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.areZoomGesturesEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(areZoomGesturesEnabledWithError:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(areZoomGesturesEnabledWithError:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api areZoomGesturesEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.isCompassEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(isCompassEnabledWithError:)],
          @"FGMMapsInspectorApi api (%@) doesn't respond to @selector(isCompassEnabledWithError:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isCompassEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.isMyLocationButtonEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isMyLocationButtonEnabledWithError:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(isMyLocationButtonEnabledWithError:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isMyLocationButtonEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.isTrafficEnabled",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert(
          [api respondsToSelector:@selector(isTrafficEnabledWithError:)],
          @"FGMMapsInspectorApi api (%@) doesn't respond to @selector(isTrafficEnabledWithError:)",
          api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isTrafficEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.getTileOverlayInfo",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(tileOverlayWithIdentifier:error:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(tileOverlayWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_tileOverlayId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FGMPlatformTileLayer *output = [api tileOverlayWithIdentifier:arg_tileOverlayId
                                                                error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.getHeatmapInfo",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(heatmapWithIdentifier:error:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(heatmapWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_heatmapId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FGMPlatformHeatmap *output = [api heatmapWithIdentifier:arg_heatmapId error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.getZoomRange",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(zoomRange:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to @selector(zoomRange:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FGMPlatformZoomRange *output = [api zoomRange:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel = [[FlutterBasicMessageChannel alloc]
           initWithName:[NSString stringWithFormat:@"%@%@",
                                                   @"dev.flutter.pigeon.google_maps_flutter_ios."
                                                   @"MapsInspectorApi.getClusters",
                                                   messageChannelSuffix]
        binaryMessenger:binaryMessenger
                  codec:FGMGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(clustersWithIdentifier:error:)],
                @"FGMMapsInspectorApi api (%@) doesn't respond to "
                @"@selector(clustersWithIdentifier:error:)",
                api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_clusterManagerId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSArray<FGMPlatformCluster *> *output = [api clustersWithIdentifier:arg_clusterManagerId
                                                                      error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
